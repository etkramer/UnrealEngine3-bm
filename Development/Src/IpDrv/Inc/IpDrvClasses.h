/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_IPDRV_ENUMS
#define INCLUDED_IPDRV_ENUMS 1

enum EPartyReservationResult
{
    PRR_GeneralError        =0,
    PRR_PartyLimitReached   =1,
    PRR_IncorrectPlayerCount=2,
    PRR_RequestTimedOut     =3,
    PRR_ReservationAccepted =4,
    PRR_MAX                 =5,
};
enum EReservationPacketType
{
    RPT_UnknownPacketType   =0,
    RPT_ClientReservationRequest=1,
    RPT_ClientCancellationRequest=2,
    RPT_HostReservationResponse=3,
    RPT_HostCancellationResponse=4,
    RPT_HostReservationCountUpdate=5,
    RPT_HostTravelRequest   =6,
    RPT_HostIsReady         =7,
    RPT_HostHasCancelled    =8,
    RPT_Heartbeat           =9,
    RPT_MAX                 =10,
};
enum EPartyBeaconClientState
{
    PBCS_None               =0,
    PBCS_Connecting         =1,
    PBCS_Connected          =2,
    PBCS_ConnectionFailed   =3,
    PBCS_AwaitingResponse   =4,
    PBCS_Closed             =5,
    PBCS_MAX                =6,
};
enum EEventUploadType
{
    EUT_GenericStats        =0,
    EUT_ProfileData         =1,
    EUT_HardwareData        =2,
    EUT_MatchmakingData     =3,
    EUT_MAX                 =4,
};

#endif // !INCLUDED_IPDRV_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName IPDRV_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(DestroyBeacon)
AUTOGENERATE_NAME(GetPlayerNicknameFromIndex)
AUTOGENERATE_NAME(GetPlayerUniqueNetIdFromIndex)
AUTOGENERATE_NAME(OnArbitrationRegistrationComplete)
AUTOGENERATE_NAME(OnCancelFindOnlineGamesComplete)
AUTOGENERATE_NAME(OnCancellationRequestComplete)
AUTOGENERATE_NAME(OnClientCancellationReceived)
AUTOGENERATE_NAME(OnCreateOnlineGameComplete)
AUTOGENERATE_NAME(OnDestroyOnlineGameComplete)
AUTOGENERATE_NAME(OnEndOnlineGameComplete)
AUTOGENERATE_NAME(OnFindOnlineGamesComplete)
AUTOGENERATE_NAME(OnGameInviteAccepted)
AUTOGENERATE_NAME(OnHostHasCancelled)
AUTOGENERATE_NAME(OnHostIsReady)
AUTOGENERATE_NAME(OnJoinOnlineGameComplete)
AUTOGENERATE_NAME(OnReadNewsCompleted)
AUTOGENERATE_NAME(OnReadTitleFileComplete)
AUTOGENERATE_NAME(OnRegisterPlayerComplete)
AUTOGENERATE_NAME(OnReservationChange)
AUTOGENERATE_NAME(OnReservationCountUpdated)
AUTOGENERATE_NAME(OnReservationRequestComplete)
AUTOGENERATE_NAME(OnReservationsFull)
AUTOGENERATE_NAME(OnStartOnlineGameComplete)
AUTOGENERATE_NAME(OnTravelRequestReceived)
AUTOGENERATE_NAME(OnUnregisterPlayerComplete)
AUTOGENERATE_NAME(OnUpdateOnlineGameComplete)
AUTOGENERATE_NAME(RegisterPartyMembers)
AUTOGENERATE_NAME(UnregisterParty)
AUTOGENERATE_NAME(UnregisterPartyMembers)

#ifndef NAMES_ONLY

#ifndef INCLUDED_IPDRV_CLASSES
#define INCLUDED_IPDRV_CLASSES 1

class UMCPBase : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS MCPBase
    //## END PROPS MCPBase

    DECLARE_ABSTRACT_CLASS(UMCPBase,UObject,0,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Needs to be overridden by child classes
	 *
	 * @param ignored
	 */
	virtual void Tick(FLOAT)
	{
		check(0 && "Implement this in child classes");
	}
};

struct FPlayerReservation
{
    struct FUniqueNetId NetId;
    INT Skill;
    DOUBLE Mu;
    DOUBLE Sigma;

    /** Constructors */
    FPlayerReservation() {}
    FPlayerReservation(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerReservation));
    }
};

struct FPartyReservation
{
    INT TeamNum;
    struct FUniqueNetId PartyLeader;
    TArrayNoInit<struct FPlayerReservation> PartyMembers;

    /** Constructors */
    FPartyReservation() {}
    FPartyReservation(EEventParm)
    {
        appMemzero(this, sizeof(FPartyReservation));
    }
};

struct PartyBeacon_eventDestroyBeacon_Parms
{
    PartyBeacon_eventDestroyBeacon_Parms(EEventParm)
    {
    }
};
class UPartyBeacon : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS PartyBeacon
    INT PartyBeaconPort;
    FSocket* Socket;
    BITFIELD bIsInTick:1;
    BITFIELD bWantsDeferredDestroy:1;
    BITFIELD bShouldTick:1;
    FLOAT HeartbeatTimeout;
    FLOAT ElapsedHeartbeatTime;
    FName BeaconName;
    //## END PROPS PartyBeacon

    virtual void DestroyBeacon();
    DECLARE_FUNCTION(execDestroyBeacon)
    {
        P_FINISH;
        DestroyBeacon();
    }
    void eventDestroyBeacon()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_DestroyBeacon),NULL);
    }
    DECLARE_CLASS(UPartyBeacon,UObject,0|CLASS_Config,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Converts a host response code to a readable string
	 *
	 * @param Result the code to translate
	 *
	 * @return the string that maps to it
	 */
	inline const TCHAR* PartyReservationResultToString(EPartyReservationResult Result)
	{
		switch (Result)
		{
			case PRR_PartyLimitReached: return TEXT("PRR_PartyLimitReached");
			case PRR_IncorrectPlayerCount: return TEXT("PRR_IncorrectPlayerCount");
			case PRR_ReservationAccepted: return TEXT("PRR_ReservationAccepted");
		}
		return TEXT("PRR_GeneralError");
	}

	/**
	 * Sends a heartbeat packet to the specified socket
	 *
	 * @param Socket the socket to send the data on
	 *
	 * @return TRUE if it sent ok, FALSE if there was an error
	 */
	UBOOL SendHeartbeat(FSocket* Socket);
};

struct PartyBeaconClient_eventOnHostHasCancelled_Parms
{
    PartyBeaconClient_eventOnHostHasCancelled_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnHostIsReady_Parms
{
    PartyBeaconClient_eventOnHostIsReady_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnTravelRequestReceived_Parms
{
    FName SessionName;
    class UClass* SearchClass;
    BYTE PlatformSpecificInfo[68];
    PartyBeaconClient_eventOnTravelRequestReceived_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnReservationCountUpdated_Parms
{
    INT ReservationRemaining;
    PartyBeaconClient_eventOnReservationCountUpdated_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnCancellationRequestComplete_Parms
{
    PartyBeaconClient_eventOnCancellationRequestComplete_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnReservationRequestComplete_Parms
{
    BYTE ReservationResult;
    PartyBeaconClient_eventOnReservationRequestComplete_Parms(EEventParm)
    {
    }
};
class UPartyBeaconClient : public UPartyBeacon
{
public:
    //## BEGIN PROPS PartyBeaconClient
    struct FOnlineGameSearchResult HostPendingRequest;
    struct FPartyReservation PendingRequest;
    BYTE ClientBeaconState;
    FLOAT ReservationRequestTimeout;
    FLOAT ReservationRequestElapsedTime;
    FScriptDelegate __OnReservationRequestComplete__Delegate;
    FScriptDelegate __OnCancellationRequestComplete__Delegate;
    FScriptDelegate __OnReservationCountUpdated__Delegate;
    FScriptDelegate __OnTravelRequestReceived__Delegate;
    FScriptDelegate __OnHostIsReady__Delegate;
    FScriptDelegate __OnHostHasCancelled__Delegate;
    //## END PROPS PartyBeaconClient

    virtual UBOOL RequestReservation(const struct FOnlineGameSearchResult& DesiredHost,struct FUniqueNetId RequestingPartyLeader,const TArray<struct FPlayerReservation>& Players);
    virtual UBOOL CancelReservation(struct FUniqueNetId CancellingPartyLeader);
    virtual void DestroyBeacon();
    DECLARE_FUNCTION(execRequestReservation)
    {
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredHost);
        P_GET_STRUCT(struct FUniqueNetId,RequestingPartyLeader);
        P_GET_TARRAY_REF(struct FPlayerReservation,Players);
        P_FINISH;
        *(UBOOL*)Result=RequestReservation(DesiredHost,RequestingPartyLeader,Players);
    }
    DECLARE_FUNCTION(execCancelReservation)
    {
        P_GET_STRUCT(struct FUniqueNetId,CancellingPartyLeader);
        P_FINISH;
        *(UBOOL*)Result=CancelReservation(CancellingPartyLeader);
    }
    void delegateOnHostHasCancelled()
    {
        ProcessDelegate(IPDRV_OnHostHasCancelled,&__OnHostHasCancelled__Delegate,NULL);
    }
    void delegateOnHostIsReady()
    {
        ProcessDelegate(IPDRV_OnHostIsReady,&__OnHostIsReady__Delegate,NULL);
    }
    void delegateOnTravelRequestReceived(FName SessionName,class UClass* SearchClass,BYTE* PlatformSpecificInfo)
    {
        PartyBeaconClient_eventOnTravelRequestReceived_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.SearchClass=SearchClass;
        appMemcpy(Parms.PlatformSpecificInfo,PlatformSpecificInfo,sizeof(Parms.PlatformSpecificInfo));
        ProcessDelegate(IPDRV_OnTravelRequestReceived,&__OnTravelRequestReceived__Delegate,&Parms);
    }
    void delegateOnReservationCountUpdated(INT ReservationRemaining)
    {
        PartyBeaconClient_eventOnReservationCountUpdated_Parms Parms(EC_EventParm);
        Parms.ReservationRemaining=ReservationRemaining;
        ProcessDelegate(IPDRV_OnReservationCountUpdated,&__OnReservationCountUpdated__Delegate,&Parms);
    }
    void delegateOnCancellationRequestComplete()
    {
        ProcessDelegate(IPDRV_OnCancellationRequestComplete,&__OnCancellationRequestComplete__Delegate,NULL);
    }
    void delegateOnReservationRequestComplete(BYTE ReservationResult)
    {
        PartyBeaconClient_eventOnReservationRequestComplete_Parms Parms(EC_EventParm);
        Parms.ReservationResult=ReservationResult;
        ProcessDelegate(IPDRV_OnReservationRequestComplete,&__OnReservationRequestComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UPartyBeaconClient,UPartyBeacon,0|CLASS_Config,IpDrv)
	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Creates a beacon that will send requests to remote hosts
	 *
	 * @param Addr the address that we are connecting to (needs to be resolved)
	 *
	 * @return true if the beacon was created successfully, false otherwise
	 */
	UBOOL InitClientBeacon(const FInternetIpAddr& Addr);

	/**
	 * Once the socket has been established, it sends the pending request to the host
	 */
	void SendReservationRequest(void);

	/**
	 * Processes a packet that was received from the host indicating success or
	 * failure for our reservation
	 *
	 * @param Packet the packet that the host sent
	 * @param PacketSize the size of the packet to process
	 */
	void ProcessHostResponse(BYTE* Packet,INT PacketSize);

	/**
	 * Processes a reservation response packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessReservationResponse(FNboSerializeFromBuffer& FromBuffer);
	
	/**
	 * Processes a cancellation response packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessCancellationResponse(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a reservation count update packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessReservationCountUpdate(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a heartbeat update, sends a heartbeat back, and clears the timer
	 */
	void ProcessHeartbeat(void);

	/**
	 * Notifies the delegates that the host is ready to play
	 */
	void ProcessHostIsReady(void);

	/**
	 * Processes a travel request packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessTravelRequest(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Performs platform specific resolution of the address
	 *
	 * @param DesiredHost the host to resolve the IP address for
	 * @param Addr out param having it's address set
	 *
	 * @return true if the address could be resolved, false otherwise
	 */
	virtual UBOOL ResolveAddress(const FOnlineGameSearchResult& DesiredHost,FInternetIpAddr& Addr);

	/**
	 * Allows for per platform registration of secure keys, so that a secure connection
	 * can be opened and used for sending/receiving data.
	 *
	 * @param DesiredHost the host that is being registered
	 */
	virtual UBOOL RegisterAddress(const FOnlineGameSearchResult& DesiredHost)
	{
		return TRUE;
	}

	/**
	 * Allows for per platform unregistration of secure keys, which breaks the link between
	 * a client and server. This also releases any memory associated with the keys.
	 *
	 * @param DesiredHost the host that is being registered
	 */
	virtual UBOOL UnregisterAddress(const FOnlineGameSearchResult& DesiredHost)
	{
		return TRUE;
	}

	/** Unregisters the address and zeros the members involved to prevent multiple releases */
	void CleanupAddress(void);

	/**
	 * Handles checking for the transition from connecting to connected (socket established)
	 */
	void CheckConnectionStatus(void);

	/**
	 * Checks the socket for a response from the and processes if present
	 */
	void ReadResponse(void);

	/** Common routine for cancelling matchmaking */
	inline void ProcessHostCancelled(void)
	{
		CleanupAddress();
		delegateOnHostHasCancelled();
	}
};

struct FClientBeaconConnection
{
    struct FUniqueNetId PartyLeader;
    FLOAT ElapsedHeartbeatTime;
    FSocket* Socket;

    /** Constructors */
    FClientBeaconConnection() {}
    FClientBeaconConnection(EEventParm)
    {
        appMemzero(this, sizeof(FClientBeaconConnection));
    }
};

struct PartyBeaconHost_eventUnregisterParty_Parms
{
    struct FUniqueNetId PartyLeader;
    PartyBeaconHost_eventUnregisterParty_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventUnregisterPartyMembers_Parms
{
    PartyBeaconHost_eventUnregisterPartyMembers_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventRegisterPartyMembers_Parms
{
    PartyBeaconHost_eventRegisterPartyMembers_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventOnClientCancellationReceived_Parms
{
    struct FUniqueNetId PartyLeader;
    PartyBeaconHost_eventOnClientCancellationReceived_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventOnReservationsFull_Parms
{
    PartyBeaconHost_eventOnReservationsFull_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventOnReservationChange_Parms
{
    PartyBeaconHost_eventOnReservationChange_Parms(EEventParm)
    {
    }
};
class UPartyBeaconHost : public UPartyBeacon
{
public:
    //## BEGIN PROPS PartyBeaconHost
    TArrayNoInit<struct FClientBeaconConnection> Clients;
    INT NumTeams;
    INT NumPlayersPerTeam;
    INT NumReservations;
    INT NumConsumedReservations;
    TArrayNoInit<struct FPartyReservation> Reservations;
    FName OnlineSessionName;
    INT ConnectionBacklog;
    TArrayNoInit<INT> PotentialTeamChoices;
    INT ReservedHostTeamNum;
    FScriptDelegate __OnReservationChange__Delegate;
    FScriptDelegate __OnReservationsFull__Delegate;
    FScriptDelegate __OnClientCancellationReceived__Delegate;
    //## END PROPS PartyBeaconHost

    virtual UBOOL InitHostBeacon(INT InNumTeams,INT InNumPlayersPerTeam,INT InNumReservations,FName InSessionName);
    virtual void DestroyBeacon();
    virtual void TellClientsToTravel(FName SessionName,class UClass* SearchClass,BYTE* PlatformSpecificInfo);
    virtual void TellClientsHostIsReady();
    virtual void TellClientsHostHasCancelled();
    virtual void AppendReservationSkillsToSearch(class UOnlineGameSearch* Search);
    virtual INT GetTeamAssignment();
    DECLARE_FUNCTION(execInitHostBeacon)
    {
        P_GET_INT(InNumTeams);
        P_GET_INT(InNumPlayersPerTeam);
        P_GET_INT(InNumReservations);
        P_GET_NAME(InSessionName);
        P_FINISH;
        *(UBOOL*)Result=InitHostBeacon(InNumTeams,InNumPlayersPerTeam,InNumReservations,InSessionName);
    }
    DECLARE_FUNCTION(execTellClientsToTravel)
    {
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_ARRAY(BYTE,PlatformSpecificInfo);
        P_FINISH;
        TellClientsToTravel(SessionName,SearchClass,PlatformSpecificInfo);
    }
    DECLARE_FUNCTION(execTellClientsHostIsReady)
    {
        P_FINISH;
        TellClientsHostIsReady();
    }
    DECLARE_FUNCTION(execTellClientsHostHasCancelled)
    {
        P_FINISH;
        TellClientsHostHasCancelled();
    }
    DECLARE_FUNCTION(execAppendReservationSkillsToSearch)
    {
        P_GET_OBJECT(UOnlineGameSearch,Search);
        P_FINISH;
        AppendReservationSkillsToSearch(Search);
    }
    DECLARE_FUNCTION(execGetTeamAssignment)
    {
        P_FINISH;
        *(INT*)Result=GetTeamAssignment();
    }
    void eventUnregisterParty(struct FUniqueNetId PartyLeader)
    {
        PartyBeaconHost_eventUnregisterParty_Parms Parms(EC_EventParm);
        Parms.PartyLeader=PartyLeader;
        ProcessEvent(FindFunctionChecked(IPDRV_UnregisterParty),&Parms);
    }
    void eventUnregisterPartyMembers()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_UnregisterPartyMembers),NULL);
    }
    void eventRegisterPartyMembers()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_RegisterPartyMembers),NULL);
    }
    void delegateOnClientCancellationReceived(struct FUniqueNetId PartyLeader)
    {
        PartyBeaconHost_eventOnClientCancellationReceived_Parms Parms(EC_EventParm);
        Parms.PartyLeader=PartyLeader;
        ProcessDelegate(IPDRV_OnClientCancellationReceived,&__OnClientCancellationReceived__Delegate,&Parms);
    }
    void delegateOnReservationsFull()
    {
        ProcessDelegate(IPDRV_OnReservationsFull,&__OnReservationsFull__Delegate,NULL);
    }
    void delegateOnReservationChange()
    {
        ProcessDelegate(IPDRV_OnReservationChange,&__OnReservationChange__Delegate,NULL);
    }
    DECLARE_CLASS(UPartyBeaconHost,UPartyBeacon,0|CLASS_Config,IpDrv)
	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/** Accepts any pending connections and adds them to our queue */
	void AcceptConnections(void);

	/**
	 * Reads the socket and processes any data from it
	 *
	 * @param ClientConn the client connection that sent the packet
	 *
	 * @return TRUE if the socket is ok, FALSE if it is in error
	 */
	UBOOL ReadClientData(FClientBeaconConnection& ClientConn);

	/**
	 * Processes a packet that was received from a client
	 *
	 * @param Packet the packet that the client sent
	 * @param PacketSize the size of the packet to process
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessRequest(BYTE* Packet,INT PacketSize,FClientBeaconConnection& ClientConn);

	/**
	 * Processes a reservation packet that was received from a client
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessReservationRequest(FNboSerializeFromBuffer& FromBuffer,FClientBeaconConnection& ClientConn);

	/**
	 * Processes a cancellation packet that was received from a client
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessCancellationRequest(FNboSerializeFromBuffer& FromBuffer,FClientBeaconConnection& ClientConn);

	/**
	 * Sends a client the specified response code
	 *
	 * @param Result the result being sent to the client
	 * @param ClientSocket the client socket to send the response on
	 */
	void SendReservationResponse(EPartyReservationResult Result,FSocket* ClientSocket);

	/**
	 * Tells clients that a reservation update has occured and sends them the current
	 * number of remaining reservations so they can update their UI
	 */
	void SendReservationUpdates(void);

	/**
	 * Sends a client acknowledgement that it got the message
	 *
	 * @param ClientSocket the client socket to send the response on
	 */
	void SendCancellationResponse(FSocket* ClientSocket);

	/**
	 * Initializes the team array so that random choices can be made from it
	 * Also initializes the host's team number (random from range)
	 */
	void InitTeamArray(void);

	/** @return TRUE if there are teams available, FALSE otherwise */
	inline UBOOL AreTeamsAvailable(void)
	{
		return NumTeams == 1 || PotentialTeamChoices.Num();
	}

	/**
	 * Removes the specified party leader (and party) from the arrays and notifies
	 * any connected clients of the change in status
	 *
	 * @param PartyLeader the leader of the party to remove
	 * @param ClientConn the client connection that sent the packet
	 */
	void CancelPartyReservation(FUniqueNetId& PartyLeader,FClientBeaconConnection& ClientConn);
};

struct FEventUploadConfig
{
    BYTE UploadType;
    FStringNoInit UploadUrl;
    FLOAT TimeOut;
    BITFIELD bUseCompression:1;

    /** Constructors */
    FEventUploadConfig() {}
    FEventUploadConfig(EEventParm)
    {
        appMemzero(this, sizeof(FEventUploadConfig));
    }
};

class UOnlineEventsInterfaceMcp : public UMCPBase
{
public:
    //## BEGIN PROPS OnlineEventsInterfaceMcp
    TArrayNoInit<struct FEventUploadConfig> EventUploadConfigs;
    TArrayNoInit<class FHttpDownloadString*> HttpPostObjects;
    TArrayNoInit<BYTE> DisabledUploadTypes;
    BITFIELD bBinaryStats:1;
    //## END PROPS OnlineEventsInterfaceMcp

    virtual UBOOL UploadProfileData(struct FUniqueNetId UniqueId,const FString& PlayerNick,class UOnlineProfileSettings* ProfileSettings);
    virtual UBOOL UploadGameplayEventsData(class UOnlineGameplayEvents* Events);
    DECLARE_FUNCTION(execUploadProfileData)
    {
        P_GET_STRUCT(struct FUniqueNetId,UniqueId);
        P_GET_STR(PlayerNick);
        P_GET_OBJECT(UOnlineProfileSettings,ProfileSettings);
        P_FINISH;
        *(UBOOL*)Result=UploadProfileData(UniqueId,PlayerNick,ProfileSettings);
    }
    DECLARE_FUNCTION(execUploadGameplayEventsData)
    {
        P_GET_OBJECT(UOnlineGameplayEvents,Events);
        P_FINISH;
        *(UBOOL*)Result=UploadGameplayEventsData(Events);
    }
    DECLARE_CLASS(UOnlineEventsInterfaceMcp,UMCPBase,0|CLASS_Config,IpDrv)
// FTickableObject interface
	/**
	 * Ticks any outstanding async tasks that need processing
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

// Event upload specific methods
	/**
	 * Finds the upload config for the type
	 *
	 * @param UploadType the type of upload that is being processed
	 *
	 * @return pointer to the config item or NULL if not found
	 */
	inline FEventUploadConfig* FindUploadConfig(BYTE UploadType)
	{
		// Make sure this config wasn't disabled
		INT ItemIndex = DisabledUploadTypes.FindItemIndex(UploadType);
		if (ItemIndex == INDEX_NONE)
		{
			for (INT EventIndex = 0; EventIndex < EventUploadConfigs.Num(); EventIndex++)
			{
				if (EventUploadConfigs(EventIndex).UploadType == UploadType)
				{
					return &EventUploadConfigs(EventIndex);
				}
			}
		}
		return NULL;
	}

	/**
	 * Common method for POST-ing a payload to an URL (determined by upload type)
	 *
	 * @param UploadType the type of upload that is happening
	 * @param Payload the data to send
	 *
	 * @return TRUE if the send started successfully, FALSE otherwise
	 */
	virtual UBOOL UploadPayload(BYTE UploadType,const FString& Payload);

	/**
	 * Common method for POST-ing a payload to an URL (determined by upload type)
	 *
	 * @param UploadType the type of upload that is happening
	 * @param Payload the data to send
	 *
	 * @return TRUE if the send started successfully, FALSE otherwise
	 */
	virtual UBOOL UploadBinaryPayload(BYTE UploadType,const TArray<BYTE>& Payload);

	/**
	 * Final method for POST-ing a payload to a URL.  At this point it is assumed to be binary data
	 *
	 * @param bWasText will be true if the original post was text data
	 * @param UploadType the type of upload that is happening
	 * @param Payload the data to send
	 *
	 * @return TRUE if the send started successfully, FALSE otherwise
	 */	
	virtual UBOOL UploadFinalPayload(UBOOL bWasText, BYTE UploadType, const TArray<BYTE>& Payload );

	/**
	 * Converts the net id to a string
	 *
	 * @param Id the net id to convert
	 *
	 * @return the string form of the id
	 */
	virtual FString FormatAsString(const FUniqueNetId& Id)
	{
		return FString::Printf(TEXT("0x%016I64X"),(QWORD&)Id);
	}
};

struct FNewsCacheEntry
{
    FStringNoInit NewsUrl;
    BYTE ReadState;
    BYTE NewsType;
    FStringNoInit NewsItem;
    FLOAT TimeOut;
    class FHttpDownloadString* HttpDownloader;

    /** Constructors */
    FNewsCacheEntry() {}
    FNewsCacheEntry(EEventParm)
    {
        appMemzero(this, sizeof(FNewsCacheEntry));
    }
};

struct OnlineNewsInterfaceMcp_eventOnReadNewsCompleted_Parms
{
    UBOOL bWasSuccessful;
    BYTE NewsType;
    OnlineNewsInterfaceMcp_eventOnReadNewsCompleted_Parms(EEventParm)
    {
    }
};
class UOnlineNewsInterfaceMcp : public UMCPBase
{
public:
    //## BEGIN PROPS OnlineNewsInterfaceMcp
    TArrayNoInit<struct FNewsCacheEntry> NewsItems;
    TArrayNoInit<FScriptDelegate> ReadNewsDelegates;
    BITFIELD bNeedsTicking:1;
    FScriptDelegate __OnReadNewsCompleted__Delegate;
    //## END PROPS OnlineNewsInterfaceMcp

    virtual UBOOL ReadNews(BYTE LocalUserNum,BYTE NewsType);
    DECLARE_FUNCTION(execReadNews)
    {
        P_GET_BYTE(LocalUserNum);
        P_GET_BYTE(NewsType);
        P_FINISH;
        *(UBOOL*)Result=ReadNews(LocalUserNum,NewsType);
    }
    void delegateOnReadNewsCompleted(UBOOL bWasSuccessful,BYTE NewsType)
    {
        OnlineNewsInterfaceMcp_eventOnReadNewsCompleted_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.NewsType=NewsType;
        ProcessDelegate(IPDRV_OnReadNewsCompleted,&__OnReadNewsCompleted__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineNewsInterfaceMcp,UMCPBase,0|CLASS_Config,IpDrv)
// FTickableObject interface
	/**
	 * Ticks any outstanding news read requests
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

// News specific methods
	/**
	 * Finds the news cache entry for the specified type
	 *
	 * @param NewsType the type of news being read
	 *
	 * @return pointer to the news item or NULL if not found
	 */
	inline FNewsCacheEntry* FindNewsCacheEntry(BYTE NewsType)
	{
		for (INT NewsIndex = 0; NewsIndex < NewsItems.Num(); NewsIndex++)
		{
			if (NewsItems(NewsIndex).NewsType == NewsType)
			{
				return &NewsItems(NewsIndex);
			}
		}
		return NULL;
	}
};

struct OnlineTitleFileDownloadMcp_eventOnReadTitleFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString Filename;
    OnlineTitleFileDownloadMcp_eventOnReadTitleFileComplete_Parms(EEventParm)
    {
    }
};
class UOnlineTitleFileDownloadMcp : public UMCPBase
{
public:
    //## BEGIN PROPS OnlineTitleFileDownloadMcp
    TArrayNoInit<FScriptDelegate> ReadTitleFileCompleteDelegates;
    TArrayNoInit<struct FTitleFile> TitleFiles;
    class FHttpDownloadBinary* HttpDownloader;
    INT CurrentIndex;
    FStringNoInit BaseUrl;
    FLOAT TimeOut;
    FScriptDelegate __OnReadTitleFileComplete__Delegate;
    //## END PROPS OnlineTitleFileDownloadMcp

    virtual UBOOL ReadTitleFile(const FString& FileToRead);
    virtual UBOOL GetTitleFileContents(const FString& Filename,TArray<BYTE>& FileContents);
    virtual UBOOL ClearDownloadedFiles();
    DECLARE_FUNCTION(execReadTitleFile)
    {
        P_GET_STR(FileToRead);
        P_FINISH;
        *(UBOOL*)Result=ReadTitleFile(FileToRead);
    }
    DECLARE_FUNCTION(execGetTitleFileContents)
    {
        P_GET_STR(Filename);
        P_GET_TARRAY_REF(BYTE,FileContents);
        P_FINISH;
        *(UBOOL*)Result=GetTitleFileContents(Filename,FileContents);
    }
    DECLARE_FUNCTION(execClearDownloadedFiles)
    {
        P_FINISH;
        *(UBOOL*)Result=ClearDownloadedFiles();
    }
    void delegateOnReadTitleFileComplete(UBOOL bWasSuccessful,const FString& Filename)
    {
        OnlineTitleFileDownloadMcp_eventOnReadTitleFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnReadTitleFileComplete,&__OnReadTitleFileComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineTitleFileDownloadMcp,UMCPBase,0|CLASS_Config,IpDrv)
// FTickableObject interface
	/**
	 * Ticks any outstanding async tasks that need processing
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

// Helpers

	/**
	 * Searches the list of files for the one that matches the filename
	 *
	 * @param FileName the file to search for
	 *
	 * @return the file details
	 */
	FORCEINLINE FTitleFile* GetTitleFile(const FString& FileName)
	{
		// Search for the specified file
		for (INT Index = 0; Index < TitleFiles.Num(); Index++)
		{
			FTitleFile* TitleFile = &TitleFiles(Index);
			if (TitleFile &&
				TitleFile->Filename == FileName)
			{
				return TitleFile;
			}
		}
		return NULL;
	}

	/**
	 * Starts the next async download in the list
	 */
	void DownloadNextFile(void);

	/**
	 * Fires the delegates so the caller knows the file download is complete
	 *
	 * @param TitleFile the information for the file that was downloaded
	 */
	void TriggerDelegates(const FTitleFile* TitleFile);
};

struct OnlineGameInterfaceImpl_eventOnGameInviteAccepted_Parms
{
    class UOnlineGameSettings* GameInviteSettings;
    OnlineGameInterfaceImpl_eventOnGameInviteAccepted_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnArbitrationRegistrationComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnArbitrationRegistrationComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnEndOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnEndOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnStartOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnStartOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnUnregisterPlayerComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnUnregisterPlayerComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnRegisterPlayerComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnRegisterPlayerComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnJoinOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnJoinOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnCancelFindOnlineGamesComplete_Parms
{
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnCancelFindOnlineGamesComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnDestroyOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnDestroyOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnUpdateOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnUpdateOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnCreateOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnCreateOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnFindOnlineGamesComplete_Parms
{
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnFindOnlineGamesComplete_Parms(EEventParm)
    {
    }
};
class UOnlineGameInterfaceImpl : public UObject
{
public:
    //## BEGIN PROPS OnlineGameInterfaceImpl
    class UOnlineSubsystemCommonImpl* OwningSubsystem;
    class UOnlineGameSettings* GameSettings;
    class UOnlineGameSearch* GameSearch;
    BYTE CurrentGameState;
    BYTE LanBeaconState;
    BYTE LanNonce[8];
    TArrayNoInit<FScriptDelegate> CreateOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> UpdateOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> DestroyOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> JoinOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> StartOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> EndOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> FindOnlineGamesCompleteDelegates;
    TArrayNoInit<FScriptDelegate> CancelFindOnlineGamesCompleteDelegates;
    INT LanAnnouncePort;
    INT LanGameUniqueId;
    INT LanPacketPlatformMask;
    FLOAT LanQueryTimeLeft;
    FLOAT LanQueryTimeout;
    FLanBeacon* LanBeacon;
    FSessionInfo* SessionInfo;
    FScriptDelegate __OnFindOnlineGamesComplete__Delegate;
    FScriptDelegate __OnCreateOnlineGameComplete__Delegate;
    FScriptDelegate __OnUpdateOnlineGameComplete__Delegate;
    FScriptDelegate __OnDestroyOnlineGameComplete__Delegate;
    FScriptDelegate __OnCancelFindOnlineGamesComplete__Delegate;
    FScriptDelegate __OnJoinOnlineGameComplete__Delegate;
    FScriptDelegate __OnRegisterPlayerComplete__Delegate;
    FScriptDelegate __OnUnregisterPlayerComplete__Delegate;
    FScriptDelegate __OnStartOnlineGameComplete__Delegate;
    FScriptDelegate __OnEndOnlineGameComplete__Delegate;
    FScriptDelegate __OnArbitrationRegistrationComplete__Delegate;
    FScriptDelegate __OnGameInviteAccepted__Delegate;
    //## END PROPS OnlineGameInterfaceImpl

    virtual UBOOL CreateOnlineGame(BYTE HostingPlayerNum,FName SessionName,class UOnlineGameSettings* NewGameSettings);
    virtual UBOOL DestroyOnlineGame(FName SessionName);
    virtual UBOOL FindOnlineGames(BYTE SearchingPlayerNum,class UOnlineGameSearch* SearchSettings);
    virtual UBOOL CancelFindOnlineGames();
    virtual UBOOL FreeSearchResults(class UOnlineGameSearch* Search);
    virtual UBOOL JoinOnlineGame(BYTE PlayerNum,FName SessionName,const struct FOnlineGameSearchResult& DesiredGame);
    virtual UBOOL GetResolvedConnectString(FName SessionName,FString& ConnectInfo);
    virtual UBOOL StartOnlineGame(FName SessionName);
    virtual UBOOL EndOnlineGame(FName SessionName);
    virtual UBOOL ReadPlatformSpecificSessionInfo(const struct FOnlineGameSearchResult& DesiredGame,BYTE* PlatformSpecificInfo);
    virtual UBOOL BindPlatformSpecificSessionToSearch(BYTE SearchingPlayerNum,class UOnlineGameSearch* SearchSettings,BYTE* PlatformSpecificInfo);
    DECLARE_FUNCTION(execCreateOnlineGame)
    {
        P_GET_BYTE(HostingPlayerNum);
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UOnlineGameSettings,NewGameSettings);
        P_FINISH;
        *(UBOOL*)Result=CreateOnlineGame(HostingPlayerNum,SessionName,NewGameSettings);
    }
    DECLARE_FUNCTION(execDestroyOnlineGame)
    {
        P_GET_NAME(SessionName);
        P_FINISH;
        *(UBOOL*)Result=DestroyOnlineGame(SessionName);
    }
    DECLARE_FUNCTION(execFindOnlineGames)
    {
        P_GET_BYTE(SearchingPlayerNum);
        P_GET_OBJECT(UOnlineGameSearch,SearchSettings);
        P_FINISH;
        *(UBOOL*)Result=FindOnlineGames(SearchingPlayerNum,SearchSettings);
    }
    DECLARE_FUNCTION(execCancelFindOnlineGames)
    {
        P_FINISH;
        *(UBOOL*)Result=CancelFindOnlineGames();
    }
    DECLARE_FUNCTION(execFreeSearchResults)
    {
        P_GET_OBJECT(UOnlineGameSearch,Search);
        P_FINISH;
        *(UBOOL*)Result=FreeSearchResults(Search);
    }
    DECLARE_FUNCTION(execJoinOnlineGame)
    {
        P_GET_BYTE(PlayerNum);
        P_GET_NAME(SessionName);
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredGame);
        P_FINISH;
        *(UBOOL*)Result=JoinOnlineGame(PlayerNum,SessionName,DesiredGame);
    }
    DECLARE_FUNCTION(execGetResolvedConnectString)
    {
        P_GET_NAME(SessionName);
        P_GET_STR_REF(ConnectInfo);
        P_FINISH;
        *(UBOOL*)Result=GetResolvedConnectString(SessionName,ConnectInfo);
    }
    DECLARE_FUNCTION(execStartOnlineGame)
    {
        P_GET_NAME(SessionName);
        P_FINISH;
        *(UBOOL*)Result=StartOnlineGame(SessionName);
    }
    DECLARE_FUNCTION(execEndOnlineGame)
    {
        P_GET_NAME(SessionName);
        P_FINISH;
        *(UBOOL*)Result=EndOnlineGame(SessionName);
    }
    DECLARE_FUNCTION(execReadPlatformSpecificSessionInfo)
    {
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredGame);
        P_GET_ARRAY_REF(BYTE,PlatformSpecificInfo);
        P_FINISH;
        *(UBOOL*)Result=ReadPlatformSpecificSessionInfo(DesiredGame,PlatformSpecificInfo);
    }
    DECLARE_FUNCTION(execBindPlatformSpecificSessionToSearch)
    {
        P_GET_BYTE(SearchingPlayerNum);
        P_GET_OBJECT(UOnlineGameSearch,SearchSettings);
        P_GET_ARRAY(BYTE,PlatformSpecificInfo);
        P_FINISH;
        *(UBOOL*)Result=BindPlatformSpecificSessionToSearch(SearchingPlayerNum,SearchSettings,PlatformSpecificInfo);
    }
    void delegateOnGameInviteAccepted(class UOnlineGameSettings* GameInviteSettings)
    {
        OnlineGameInterfaceImpl_eventOnGameInviteAccepted_Parms Parms(EC_EventParm);
        Parms.GameInviteSettings=GameInviteSettings;
        ProcessDelegate(IPDRV_OnGameInviteAccepted,&__OnGameInviteAccepted__Delegate,&Parms);
    }
    void delegateOnArbitrationRegistrationComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnArbitrationRegistrationComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnArbitrationRegistrationComplete,&__OnArbitrationRegistrationComplete__Delegate,&Parms);
    }
    void delegateOnEndOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnEndOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnEndOnlineGameComplete,&__OnEndOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnStartOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnStartOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnStartOnlineGameComplete,&__OnStartOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnUnregisterPlayerComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnUnregisterPlayerComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnUnregisterPlayerComplete,&__OnUnregisterPlayerComplete__Delegate,&Parms);
    }
    void delegateOnRegisterPlayerComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnRegisterPlayerComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnRegisterPlayerComplete,&__OnRegisterPlayerComplete__Delegate,&Parms);
    }
    void delegateOnJoinOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnJoinOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnJoinOnlineGameComplete,&__OnJoinOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnCancelFindOnlineGamesComplete(UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnCancelFindOnlineGamesComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnCancelFindOnlineGamesComplete,&__OnCancelFindOnlineGamesComplete__Delegate,&Parms);
    }
    void delegateOnDestroyOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnDestroyOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnDestroyOnlineGameComplete,&__OnDestroyOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnUpdateOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnUpdateOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnUpdateOnlineGameComplete,&__OnUpdateOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnCreateOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnCreateOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnCreateOnlineGameComplete,&__OnCreateOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnFindOnlineGamesComplete(UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnFindOnlineGamesComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnFindOnlineGamesComplete,&__OnFindOnlineGamesComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineGameInterfaceImpl,UObject,0|CLASS_Config,IpDrv)
    DECLARE_WITHIN(UOnlineSubsystemCommonImpl)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    #include "UOnlineGameInterfaceImpl.h"
};

struct OnlineSubsystemCommonImpl_eventGetPlayerUniqueNetIdFromIndex_Parms
{
    INT UserIndex;
    struct FUniqueNetId ReturnValue;
    OnlineSubsystemCommonImpl_eventGetPlayerUniqueNetIdFromIndex_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystemCommonImpl_eventGetPlayerNicknameFromIndex_Parms
{
    INT UserIndex;
    FString ReturnValue;
    OnlineSubsystemCommonImpl_eventGetPlayerNicknameFromIndex_Parms(EEventParm)
    {
    }
};
class UOnlineSubsystemCommonImpl : public UOnlineSubsystem
{
public:
    //## BEGIN PROPS OnlineSubsystemCommonImpl
    class FVoiceInterface* VoiceEngine;
    INT MaxLocalTalkers;
    INT MaxRemoteTalkers;
    BITFIELD bIsUsingSpeechRecognition:1;
    class UOnlineGameInterfaceImpl* GameInterfaceImpl;
    FPointer InfocasterDownload;
    //## END PROPS OnlineSubsystemCommonImpl

    struct FUniqueNetId eventGetPlayerUniqueNetIdFromIndex(INT UserIndex)
    {
        OnlineSubsystemCommonImpl_eventGetPlayerUniqueNetIdFromIndex_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.UserIndex=UserIndex;
        ProcessEvent(FindFunctionChecked(IPDRV_GetPlayerUniqueNetIdFromIndex),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGetPlayerNicknameFromIndex(INT UserIndex)
    {
        OnlineSubsystemCommonImpl_eventGetPlayerNicknameFromIndex_Parms Parms(EC_EventParm);
        Parms.UserIndex=UserIndex;
        ProcessEvent(FindFunctionChecked(IPDRV_GetPlayerNicknameFromIndex),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UOnlineSubsystemCommonImpl,UOnlineSubsystem,0|CLASS_Config,IpDrv)
    #include "UOnlineSubsystemCommonImpl.h"
};

#endif // !INCLUDED_IPDRV_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UOnlineEventsInterfaceMcp,-1,execUploadGameplayEventsData);
AUTOGENERATE_FUNCTION(UOnlineEventsInterfaceMcp,-1,execUploadProfileData);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execBindPlatformSpecificSessionToSearch);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execReadPlatformSpecificSessionInfo);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execEndOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execStartOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execGetResolvedConnectString);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execJoinOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execFreeSearchResults);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execCancelFindOnlineGames);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execFindOnlineGames);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execDestroyOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execCreateOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineNewsInterfaceMcp,-1,execReadNews);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execClearDownloadedFiles);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execGetTitleFileContents);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execReadTitleFile);
AUTOGENERATE_FUNCTION(UPartyBeacon,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execCancelReservation);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execRequestReservation);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execGetTeamAssignment);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execAppendReservationSkillsToSearch);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execTellClientsHostHasCancelled);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execTellClientsHostIsReady);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execTellClientsToTravel);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execInitHostBeacon);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef IPDRV_NATIVE_DEFS
#define IPDRV_NATIVE_DEFS

DECLARE_NATIVE_TYPE(IpDrv,UMCPBase);
DECLARE_NATIVE_TYPE(IpDrv,UOnlineEventsInterfaceMcp);
DECLARE_NATIVE_TYPE(IpDrv,UOnlineGameInterfaceImpl);
DECLARE_NATIVE_TYPE(IpDrv,UOnlineNewsInterfaceMcp);
DECLARE_NATIVE_TYPE(IpDrv,UOnlineSubsystemCommonImpl);
DECLARE_NATIVE_TYPE(IpDrv,UOnlineTitleFileDownloadMcp);
DECLARE_NATIVE_TYPE(IpDrv,UPartyBeacon);
DECLARE_NATIVE_TYPE(IpDrv,UPartyBeaconClient);
DECLARE_NATIVE_TYPE(IpDrv,UPartyBeaconHost);

#define AUTO_INITIALIZE_REGISTRANTS_IPDRV \
	UHTTPDownload::StaticClass(); \
	UMCPBase::StaticClass(); \
	UOnlineEventsInterfaceMcp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUOnlineEventsInterfaceMcpNative; \
	UOnlineGameInterfaceImpl::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUOnlineGameInterfaceImplNative; \
	UOnlineNewsInterfaceMcp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUOnlineNewsInterfaceMcpNative; \
	UOnlineSubsystemCommonImpl::StaticClass(); \
	UOnlineTitleFileDownloadMcp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUOnlineTitleFileDownloadMcpNative; \
	UPartyBeacon::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUPartyBeaconNative; \
	UPartyBeaconClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUPartyBeaconClientNative; \
	UPartyBeaconHost::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindIpDrvUPartyBeaconHostNative; \
	UTcpipConnection::StaticClass(); \
	UTcpNetDriver::StaticClass(); \

#endif // IPDRV_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UOnlineEventsInterfaceMcp) GIpDrvUOnlineEventsInterfaceMcpNatives[] = 
{ 
	MAP_NATIVE(UOnlineEventsInterfaceMcp,execUploadGameplayEventsData)
	MAP_NATIVE(UOnlineEventsInterfaceMcp,execUploadProfileData)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UOnlineEventsInterfaceMcp);

NATIVE_INFO(UOnlineGameInterfaceImpl) GIpDrvUOnlineGameInterfaceImplNatives[] = 
{ 
	MAP_NATIVE(UOnlineGameInterfaceImpl,execBindPlatformSpecificSessionToSearch)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execReadPlatformSpecificSessionInfo)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execEndOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execStartOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execGetResolvedConnectString)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execJoinOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execFreeSearchResults)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execCancelFindOnlineGames)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execFindOnlineGames)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execDestroyOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl,execCreateOnlineGame)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UOnlineGameInterfaceImpl);

NATIVE_INFO(UOnlineNewsInterfaceMcp) GIpDrvUOnlineNewsInterfaceMcpNatives[] = 
{ 
	MAP_NATIVE(UOnlineNewsInterfaceMcp,execReadNews)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UOnlineNewsInterfaceMcp);

NATIVE_INFO(UOnlineTitleFileDownloadMcp) GIpDrvUOnlineTitleFileDownloadMcpNatives[] = 
{ 
	MAP_NATIVE(UOnlineTitleFileDownloadMcp,execClearDownloadedFiles)
	MAP_NATIVE(UOnlineTitleFileDownloadMcp,execGetTitleFileContents)
	MAP_NATIVE(UOnlineTitleFileDownloadMcp,execReadTitleFile)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UOnlineTitleFileDownloadMcp);

NATIVE_INFO(UPartyBeacon) GIpDrvUPartyBeaconNatives[] = 
{ 
	MAP_NATIVE(UPartyBeacon,execDestroyBeacon)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UPartyBeacon);

NATIVE_INFO(UPartyBeaconClient) GIpDrvUPartyBeaconClientNatives[] = 
{ 
	MAP_NATIVE(UPartyBeaconClient,execDestroyBeacon)
	MAP_NATIVE(UPartyBeaconClient,execCancelReservation)
	MAP_NATIVE(UPartyBeaconClient,execRequestReservation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UPartyBeaconClient);

NATIVE_INFO(UPartyBeaconHost) GIpDrvUPartyBeaconHostNatives[] = 
{ 
	MAP_NATIVE(UPartyBeaconHost,execGetTeamAssignment)
	MAP_NATIVE(UPartyBeaconHost,execAppendReservationSkillsToSearch)
	MAP_NATIVE(UPartyBeaconHost,execTellClientsHostHasCancelled)
	MAP_NATIVE(UPartyBeaconHost,execTellClientsHostIsReady)
	MAP_NATIVE(UPartyBeaconHost,execTellClientsToTravel)
	MAP_NATIVE(UPartyBeaconHost,execDestroyBeacon)
	MAP_NATIVE(UPartyBeaconHost,execInitHostBeacon)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(IpDrv,UPartyBeaconHost);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UMCPBase)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineEventsInterfaceMcp,EventUploadConfigs)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineEventsInterfaceMcp,DisabledUploadTypes)
VERIFY_CLASS_SIZE_NODIE(UOnlineEventsInterfaceMcp)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameInterfaceImpl,OwningSubsystem)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameInterfaceImpl,__OnGameInviteAccepted__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameInterfaceImpl)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineNewsInterfaceMcp,NewsItems)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineNewsInterfaceMcp,__OnReadNewsCompleted__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineNewsInterfaceMcp)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineSubsystemCommonImpl,VoiceEngine)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineSubsystemCommonImpl,InfocasterDownload)
VERIFY_CLASS_SIZE_NODIE(UOnlineSubsystemCommonImpl)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineTitleFileDownloadMcp,ReadTitleFileCompleteDelegates)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineTitleFileDownloadMcp,__OnReadTitleFileComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineTitleFileDownloadMcp)
VERIFY_CLASS_OFFSET_NODIE(U,PartyBeacon,PartyBeaconPort)
VERIFY_CLASS_OFFSET_NODIE(U,PartyBeacon,BeaconName)
VERIFY_CLASS_SIZE_NODIE(UPartyBeacon)
VERIFY_CLASS_OFFSET_NODIE(U,PartyBeaconClient,HostPendingRequest)
VERIFY_CLASS_OFFSET_NODIE(U,PartyBeaconClient,__OnHostHasCancelled__Delegate)
VERIFY_CLASS_SIZE_NODIE(UPartyBeaconClient)
VERIFY_CLASS_OFFSET_NODIE(U,PartyBeaconHost,Clients)
VERIFY_CLASS_OFFSET_NODIE(U,PartyBeaconHost,__OnClientCancellationReceived__Delegate)
VERIFY_CLASS_SIZE_NODIE(UPartyBeaconHost)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
