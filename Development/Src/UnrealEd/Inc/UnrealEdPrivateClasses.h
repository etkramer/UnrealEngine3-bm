/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UNREALED_PRIVATE_ENUMS
#define INCLUDED_UNREALED_PRIVATE_ENUMS 1


#endif // !INCLUDED_UNREALED_PRIVATE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UNREALED_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_UNREALED_PRIVATE_CLASSES
#define INCLUDED_UNREALED_PRIVATE_CLASSES 1

struct FPropertyItemCustomProxy
{
    FStringNoInit PropertyPathName;
    FStringNoInit PropertyItemClassName;
    BITFIELD bReplaceArrayHeaders:1;
    BITFIELD bIgnoreArrayElements:1;
    class UClass* PropertyItemClass;

    /** Constructors */
    FPropertyItemCustomProxy() {}
    FPropertyItemCustomProxy(EEventParm)
    {
        appMemzero(this, sizeof(FPropertyItemCustomProxy));
    }
};

struct FPropertyTypeCustomProxy
{
    FName PropertyName;
    FStringNoInit PropertyObjectClassPathName;
    FStringNoInit PropertyItemClassName;
    BITFIELD bReplaceArrayHeaders:1;
    BITFIELD bIgnoreArrayElements:1;
    class UClass* PropertyItemClass;

    /** Constructors */
    FPropertyTypeCustomProxy() {}
    FPropertyTypeCustomProxy(EEventParm)
    {
        appMemzero(this, sizeof(FPropertyTypeCustomProxy));
    }
};

struct FPropertyItemCustomClass
{
    FStringNoInit PropertyPathName;
    FStringNoInit PropertyItemClassName;
    BITFIELD bReplaceArrayHeaders:1;
    BITFIELD bIgnoreArrayElements:1;
    class wxClassInfo* WxPropertyItemClass;

    /** Constructors */
    FPropertyItemCustomClass() {}
    FPropertyItemCustomClass(EEventParm)
    {
        appMemzero(this, sizeof(FPropertyItemCustomClass));
    }
};

struct FPropertyTypeCustomClass
{
    FName PropertyName;
    FStringNoInit PropertyObjectClassPathName;
    FStringNoInit PropertyItemClassName;
    BITFIELD bReplaceArrayHeaders:1;
    BITFIELD bIgnoreArrayElements:1;
    class wxClassInfo* WxPropertyItemClass;

    /** Constructors */
    FPropertyTypeCustomClass() {}
    FPropertyTypeCustomClass(EEventParm)
    {
        appMemzero(this, sizeof(FPropertyTypeCustomClass));
    }
};

class UCustomPropertyItemBindings : public UObject
{
public:
    //## BEGIN PROPS CustomPropertyItemBindings
    TArrayNoInit<struct FPropertyItemCustomClass> CustomPropertyClasses;
    TArrayNoInit<struct FPropertyTypeCustomClass> CustomPropertyTypeClasses;
    TArrayNoInit<struct FPropertyItemCustomProxy> CustomPropertyDrawProxies;
    TArrayNoInit<struct FPropertyItemCustomProxy> CustomPropertyInputProxies;
    TArrayNoInit<struct FPropertyTypeCustomProxy> CustomPropertyTypeDrawProxies;
    TArrayNoInit<struct FPropertyTypeCustomProxy> CustomPropertyTypeInputProxies;
    //## END PROPS CustomPropertyItemBindings

    DECLARE_CLASS(UCustomPropertyItemBindings,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Returns the custom draw proxy class that should be used for the property associated with
	 * the WxPropertyWindow_Base specified.
	 *
	 * @param	ProxyOwnerItem	the property window item that will be using this draw proxy
	 * @param	ArrayIndex		specifies which element of an array property that this property window will represent.  Only valid
	 *							when creating property window items for individual elements of an array.
	 *
	 * @return	a pointer to a child of UPropertyDrawProxy that should be used as the draw proxy
	 *			for the specified property, or NULL if there is no custom draw proxy configured for
	 *			the property.
	 */
	class UClass* GetCustomDrawProxy( const class WxPropertyWindow_Base* ProxyOwnerItem, INT ArrayIndex=INDEX_NONE );

	/**
	 * Returns the custom input proxy class that should be used for the property associated with
	 * the WxPropertyWindow_Base specified.
	 *
	 * @param	ProxyOwnerItem	the property window item that will be using this input proxy
	 * @param	ArrayIndex		specifies which element of an array property that this property window will represent.  Only valid
	 *							when creating property window items for individual elements of an array.
	 *
	 * @return	a pointer to a child of UPropertyInputProxy that should be used as the input proxy
	 *			for the specified property, or NULL if there is no custom input proxy configured for
	 *			the property.
	 */
	class UClass* GetCustomInputProxy( const class WxPropertyWindow_Base* ProxyOwnerItem, INT ArrayIndex=INDEX_NONE );

	/**
	 * Returns an instance of a custom property item class that should be used for the property specified.
	 *
	 * @param	InProperty	the property that will use the custom property item
	 * @param	ArrayIndex	specifies which element of an array property that this property window will represent.  Only valid
	 *						when creating property window items for individual elements of an array.
	 * @param	ParentItem	specified the property window item that will contain this new property window item.  Only
	 *						valid when creating property window items for individual array elements or struct member properties
	 *
	 * @return	a pointer to a child of WxPropertyWindow_Item that should be used as the property
	 *			item for the specified property, or NULL if there is no custom property item configured
	 * 			for the property.
	 */
	class WxPropertyWindow_Item* GetCustomPropertyItem( class UProperty* InProperty, INT ArrayIndex=INDEX_NONE, class WxPropertyWindow_Item* ParentItem=NULL );
};

class USequenceOpHelper_CalloutInputProxy : public USequenceObjectHelper
{
public:
    //## BEGIN PROPS SequenceOpHelper_CalloutInputProxy
    //## END PROPS SequenceOpHelper_CalloutInputProxy

    DECLARE_CLASS(USequenceOpHelper_CalloutInputProxy,USequenceObjectHelper,0,UnrealEd)
	/**
	 * Called when the user double clicks on a sequence object, can be used to display object specific
	 * property dialogs.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 * @param InObject	Pointer to the object that was clicked on.
	 */
	virtual void OnDoubleClick( const class WxKismet* InEditor, USequenceObject* InObject ) const;

	/**
	 * Called when the user right clicks on a sequence object, should show a object specific context menu.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 */
	virtual void  ShowContextMenu( class WxKismet* InEditor ) const;
//
//	not yet implemented - not actually referenced by any of the tree controls, but could be useful
//	/**
//	 * Called when the Kismet editor wants the object to add itself to a tree control.
//	 *
//	 * @param InEditor		Pointer to the editor that initiated the callback.
//	 * @param InTreeCtrl	Pointer to the tree control we will be adding an item to.
//	 * @param ParentItem	The parent of the item that will be added.
//	 * @return				The tree item we created.
//	 */
//	virtual wxTreeItemId AddToTreeControl(  class WxKismet* InEditor, class wxTreeCtrl* InTreeCtrl, class wxTreeItemId& ParentItem ) const;
};

class UObjectEditorViewportInput : public UEditorViewportInput
{
public:
    //## BEGIN PROPS ObjectEditorViewportInput
    //## END PROPS ObjectEditorViewportInput

    DECLARE_CLASS(UObjectEditorViewportInput,UEditorViewportInput,0|CLASS_Transient|CLASS_Config,UnrealEd)
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);
};

#define UCONST_AUTOEXPAND_VALUE 0

class UUIEditorOptions : public UUIRoot
{
public:
    //## BEGIN PROPS UIEditorOptions
    WxRect WindowPosition;
    INT DataStoreBrowserSashPosition;
    INT ViewportGutterSize;
    INT VirtualSizeX;
    INT VirtualSizeY;
    BITFIELD bRenderViewportOutline:1;
    BITFIELD bRenderContainerOutline:1;
    BITFIELD bRenderSelectionOutline:1;
    BITFIELD bRenderSelectionHandles:1;
    BITFIELD bRenderPerWidgetSelectionOutline:1;
    BITFIELD bRenderTitleSafeRegionOutline:1;
    BITFIELD mViewDrawBkgnd:1;
    BITFIELD mViewDrawGrid:1;
    BITFIELD bViewShowWireframe:1;
    BITFIELD bSnapToGrid:1;
    BITFIELD bShowDockHandles:1;
    INT ToolMode;
    INT GridSize;
    FStringNoInit CurrentPreviewPlatform;
    BYTE CurrentSSPreviewMode;
    //## END PROPS UIEditorOptions

    DECLARE_CLASS(UUIEditorOptions,UUIRoot,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

	/**
	 * Retrieves the size that the UI should use as the size of the viewport when resolving positions.
	 *
	 * @param	RenderViewport	if the VirtualSize is 'Auto', the output values are filled using the size of this viewport.
	 * @param	out_SizeX		receives the horizontal size of the viewport
	 * @param	out_SizeY		receives the vertical size of the viewport
	 * @param	bIgnoreSSLayout	specify TRUE to ignore the current split-screen layout preview mode and assume fullscreen
	 * @param	bIgnoreGutter	specify TRUE to ignore any gutter value being applied.
	 *
	 * @return	TRUE if a virtual viewport size has been set, FALSE if the virtual viewport size is "Auto"
	 */
	UBOOL GetVirtualViewportSize( FViewport* RenderViewport, FLOAT& out_SizeX, FLOAT& out_SizeY, UBOOL bIgnoreSSLayout=FALSE, UBOOL bIgnoreGutter=FALSE ) const;

	/**
	 * Returns a string representation of the virtual viewport size, in the format:
	 * 640x480
	 * (assuming VirtualSizeX is 640 and VirtualSizeY is 480)
	 *
	 * @return	a string representing the configured viewport size, or an empty string to indicate that the viewport
	 *			should take up the entire window (auto-expand)
	 */
	FString	GetViewportSizeString() const;

	/**
	 * Sets the values for VirtualSizeX and VirtualSizeY from a string in the format:
	 * 640x480
	 * (assuming you wanted to set VirtualSizeX to 640 and VirtualSizeY to 480).  To indicate
	 * that the viewport should take up the entire window (auto-expand), pass in an empty string.
	 *
	 * @return	TRUE if the input string was successfully parsed into a SizeX and SizeY value.
	 */
	UBOOL SetViewportSize( const FString& ViewportSizeString );
};

struct FUILayerNode
{
private:
    BITFIELD bLocked:1;
    BITFIELD bVisible:1;
    class UObject* LayerObject;
    class UUILayer* ParentLayer;
public:

	/** Default constructor - does not initialize values for members */
	FUILayerNode() {}

	/** Event constructor - used when passing this struct to an unrealscript event; zero initializes all members */
	FUILayerNode(EEventParm)
	{
		appMemzero(this,sizeof(FUILayerNode));
	}

	/** Standard constructors */
	FUILayerNode( class UUILayer* InLayer, class UUILayer* InParentLayer );
	FUILayerNode( class UUIObject* InWidget, class UUILayer* InParentLayer );

	/** Copy constructors */
	FUILayerNode( const struct FUILayerNode& Other )
	: bLocked(Other.bLocked), bVisible(Other.bVisible), LayerObject(Other.LayerObject), ParentLayer(Other.ParentLayer)
	{}

	/** Comparison operator */
	UBOOL operator==( const struct FUILayerNode& Other ) const
	{
		return bLocked		== Other.bLocked
			&& bVisible		== Other.bVisible
			&& LayerObject	== Other.LayerObject
			&& ParentLayer	== Other.ParentLayer;
	}
	UBOOL operator!=( const struct FUILayerNode& Other ) const
	{
		return bLocked		!= Other.bLocked
			|| bVisible		!= Other.bVisible
			|| LayerObject	!= Other.LayerObject
			|| ParentLayer	!= Other.ParentLayer;
	}

	/**
	 * Changes whether this layer node is locked.
	 */
	void SetLocked( UBOOL bLockLayer )
	{
		bLocked = bLockLayer;
	}

	/**
	 * Changes whether this layer node is visible.
	 */
	void SetVisible( UBOOL bShowLayer )
	{
		bVisible = bShowLayer;
	}

	/**
	 * Changes the object associated with this layer node.
	 *
	 * @param	InObject	the object to associate with this layer node; must be of type UIObject or UILayer
	 */
	UBOOL SetLayerObject( class UObject* InObject );

	/**
	 * Changes the UILayer that contains this layer node.
	 *
	 * @param	NewParent	the UILayer that now contains this layer node
	 */
	void SetLayerParent( class UUILayer* NewParent )
	{
		ParentLayer = NewParent;
	}

	/**
	 * Returns whether this layer node should be visible.
	 */
	UBOOL IsVisible() const
	{
		return bVisible;
	}

	/**
	 * Returns whether this layer node should be locked.
	 */
	UBOOL IsLocked() const
	{
		return bLocked;
	}

	/**
	 * Returns TRUE if the object associated with this layer node is of type UILayer.
	 */
	UBOOL IsUILayer() const;

	/**
	 * Returns TRUE if the object associated with this layer node is of type UIObject.
	 */
	UBOOL IsUIObject() const;

	/**
	 * Gets the object associated with this layer node, casted to a UILayer.
	 */
	class UUILayer* GetUILayer() const;

	/**
	 * Gets the object associated with this layer node, casted to a UIObject.
	 */
	class UUIObject* GetUIObject() const;

	/**
	 * Gets the object associated with this layer node.
	 */
	class UObject* GetLayerObject() const
	{
		return LayerObject;
	}

	/**
	 * Returns the UILayer that contains this layer node.
	 */
	class UUILayer* GetParentLayer() const
	{
		return ParentLayer;
	}

};

class UUILayer : public UUILayerBase
{
public:
    //## BEGIN PROPS UILayer
    FStringNoInit LayerName;
    TArrayNoInit<struct FUILayerNode> LayerNodes;
    //## END PROPS UILayer

    UBOOL InsertNode(const struct FUILayerNode& NodeToInsert,INT InsertIndex=-1);
    UBOOL RemoveNode(const struct FUILayerNode& ExistingNode);
    INT FindNodeIndex(const class UObject* NodeObject) const;
    DECLARE_FUNCTION(execInsertNode)
    {
        P_GET_STRUCT_REF(struct FUILayerNode,NodeToInsert);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=InsertNode(NodeToInsert,InsertIndex);
    }
    DECLARE_FUNCTION(execRemoveNode)
    {
        P_GET_STRUCT_REF(struct FUILayerNode,ExistingNode);
        P_FINISH;
        *(UBOOL*)Result=RemoveNode(ExistingNode);
    }
    DECLARE_FUNCTION(execFindNodeIndex)
    {
        P_GET_OBJECT(UObject,NodeObject);
        P_FINISH;
        *(INT*)Result=FindNodeIndex(NodeObject);
    }
    DECLARE_CLASS(UUILayer,UUILayerBase,0,UnrealEd)
	/**
	 * Retrieves the list of child nodes for this UILayer.
	 *
	 * @param	out_ChildNodes	receives the list of children of this UILayerNode
	 * @param	bRecurse	if FALSE, will only add children of this UILayerNode; if TRUE, will add children of this UILayerNode,
	 *						along with the children of those nodes, recursively.
	 *
	 * @return	TRUE if this nodes were added to the out_ChildNodes array, FALSE otherwise.
	 */
	UBOOL GetChildNodes( TArray<struct FUILayerNode*>& out_ChildNodes, UBOOL bRecurse=FALSE );

	/**
	 * Returns the child layer node that contains the specified object as its layer object.
	 *
	 * @param	NodeObject	the child layer object to look for
	 * @param	bRecurse	if TRUE, searches all children of this object recursively
	 *
	 * @return	a pointer to a node contained by this object that has the specified object, or
	 *			NULL if no node with that specified object was found
	 */
	struct FUILayerNode* FindChild( class UObject* NodeObject, UBOOL bRecurse=FALSE );

	/**
	 * Find any child nodes with the specified name
	 *
	 * @param	NodeTitle	the name of the child to find
	 * @param	out_ChildNodes	receives the list of children
	 * @param	bRecurse	if TRUE, searches all children of this object recursively
	 *
	 * @return	number of children added to out_ChildNodes
	 */
	INT FindChildNodes( const FString& NodeTitle, TArray<struct FUILayerNode*>& out_ChildNodes, UBOOL bRecurse=FALSE );

	/**
	 * Returns whether this layer contains the specified child in its list of children.
	 *
	 * @param	NodeTitle	the name of the child layer to look for
	 * @param	bRecurse	if TRUE, searches all children of this object recursively
	 *
	 * @return	TRUE if the child layer is contained by this layer object
	 */
	UBOOL ContainsChild( const FString& NodeTitle, UBOOL bRecurse=FALSE );

	/* === UObject interface === */

	/**
	 * Prior to 06-28, UILayer objects used to have the RF_Standalone flag.  Clear the flag if it is still set on this UILayer.
	 */
	virtual void PostLoad();
};

class UUILayerRoot : public UUILayer
{
public:
    //## BEGIN PROPS UILayerRoot
    class UUIScene* Scene;
    //## END PROPS UILayerRoot

    DECLARE_CLASS(UUILayerRoot,UUILayer,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UUILayerRoot)
};

class UUIPreviewString : public UUIString
{
public:
    //## BEGIN PROPS UIPreviewString
private:
    class UUIState* CurrentMenuState;
public:
    FVector2D PreviewViewportSize;
    //## END PROPS UIPreviewString

    DECLARE_CLASS(UUIPreviewString,UUIString,0|CLASS_Transient,UnrealEd)
	/* === UIPreviewString interface === */
	/**
	 * Changes the current menu state for this UIPreviewString.
	 */
	void SetCurrentMenuState( class UUIState* NewMenuState );

	/* === UIString interface === */
	/**
	 * Retrieves the UIState that should be used for applying style data.
	 */
	virtual class UUIState* GetCurrentMenuState() const;

	/**
	 * Gets the size of the viewport.
	 *
	 * @param	out_ViewportSize	receives the viewport size.
	 *
	 * @return	TRUE if the viewport size was retrieved successfully.
	 */
	virtual UBOOL GetViewportSize( FVector2D& out_ViewportSize ) const;
};

#endif // !INCLUDED_UNREALED_PRIVATE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UUILayer,-1,execFindNodeIndex);
AUTOGENERATE_FUNCTION(UUILayer,-1,execRemoveNode);
AUTOGENERATE_FUNCTION(UUILayer,-1,execInsertNode);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UNREALED_PRIVATE_NATIVE_DEFS
#define UNREALED_PRIVATE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UnrealEd,UCustomPropertyItemBindings);
DECLARE_NATIVE_TYPE(UnrealEd,UObjectEditorViewportInput);
DECLARE_NATIVE_TYPE(UnrealEd,USequenceOpHelper_CalloutInputProxy);
DECLARE_NATIVE_TYPE(UnrealEd,UUIEditorOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UUILayer);
DECLARE_NATIVE_TYPE(UnrealEd,UUILayerRoot);
DECLARE_NATIVE_TYPE(UnrealEd,UUIPreviewString);

#define AUTO_INITIALIZE_REGISTRANTS_UNREALED_PRIVATE \
	UCustomPropertyItemBindings::StaticClass(); \
	UObjectEditorViewportInput::StaticClass(); \
	USequenceOpHelper_CalloutInputProxy::StaticClass(); \
	UUIEditorOptions::StaticClass(); \
	UUILayer::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUnrealEdUUILayerNative; \
	UUILayerRoot::StaticClass(); \
	UUIPreviewString::StaticClass(); \

#endif // UNREALED_PRIVATE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UUILayer) GUnrealEdUUILayerNatives[] = 
{ 
	MAP_NATIVE(UUILayer,execFindNodeIndex)
	MAP_NATIVE(UUILayer,execRemoveNode)
	MAP_NATIVE(UUILayer,execInsertNode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UnrealEd,UUILayer);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,CustomPropertyItemBindings,CustomPropertyClasses)
VERIFY_CLASS_OFFSET_NODIE(U,CustomPropertyItemBindings,CustomPropertyTypeInputProxies)
VERIFY_CLASS_SIZE_NODIE(UCustomPropertyItemBindings)
VERIFY_CLASS_SIZE_NODIE(UObjectEditorViewportInput)
VERIFY_CLASS_SIZE_NODIE(USequenceOpHelper_CalloutInputProxy)
VERIFY_CLASS_OFFSET_NODIE(U,UIEditorOptions,WindowPosition)
VERIFY_CLASS_OFFSET_NODIE(U,UIEditorOptions,CurrentSSPreviewMode)
VERIFY_CLASS_SIZE_NODIE(UUIEditorOptions)
VERIFY_CLASS_OFFSET_NODIE(U,UILayer,LayerName)
VERIFY_CLASS_OFFSET_NODIE(U,UILayer,LayerNodes)
VERIFY_CLASS_SIZE_NODIE(UUILayer)
VERIFY_CLASS_OFFSET_NODIE(U,UILayerRoot,Scene)
VERIFY_CLASS_SIZE_NODIE(UUILayerRoot)
VERIFY_CLASS_OFFSET_NODIE(U,UIPreviewString,CurrentMenuState)
VERIFY_CLASS_OFFSET_NODIE(U,UIPreviewString,PreviewViewportSize)
VERIFY_CLASS_SIZE_NODIE(UUIPreviewString)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
