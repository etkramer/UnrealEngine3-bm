/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#include "GearGameGlobalIncludes.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GEARGAME_ENUMS
#define INCLUDED_GEARGAME_ENUMS 1

enum EShakeParam
{
    ESP_OffsetRandom        =0,
    ESP_OffsetZero          =1,
    ESP_MAX                 =2,
};
enum EManageTutorialInputs
{
    eMTINPUT_AddTutorial    =0,
    eMTINPUT_RemoveTutorial =1,
    eMTINPUT_StartTutorial  =2,
    eMTINPUT_StopTutorial   =3,
    eMTINPUT_CompleteTutorial=4,
    eMTINPUT_SystemOn       =5,
    eMTINPUT_SystemOff      =6,
    eMTINPUT_AutosOn        =7,
    eMTINPUT_AutosOff       =8,
    eMTINPUT_MAX            =9,
};
enum ESpeakLineBroadcastFilter
{
    SLBFilter_None          =0,
    SLBFilter_SpeakerOnly   =1,
    SLBFilter_SpeakerTeamOnly=2,
    SLBFilter_SpeakerAndAddresseeOnly=3,
    SLBFilter_MAX           =4,
};
enum ESpeechInterruptCondition
{
    SIC_IfHigher            =0,
    SIC_Never               =1,
    SIC_IfSameOrHigher      =2,
    SIC_Always              =3,
    SIC_MAX                 =4,
};
enum ESpeechPriority
{
    Speech_None             =0,
    Speech_Effort           =1,
    Speech_GUDS             =2,
    Speech_Scripted         =3,
    Speech_Immediate        =4,
    Speech_MAX              =5,
};
enum EGearTrainingType
{
    eGEARTRAIN_Basic        =0,
    eGEARTRAIN_Execution    =1,
    eGEARTRAIN_Respawn      =2,
    eGEARTRAIN_Objective    =3,
    eGEARTRAIN_Meatflag     =4,
    eGEARTRAIN_MAX          =5,
};
enum EGearExecutionType
{
    eGET_Curbstomp          =0,
    eGET_MeatShield         =1,
    eGET_ShieldBash         =2,
    eGET_QuickGeneric       =3,
    eGET_QuickBow           =4,
    eGET_QuickShotgun       =5,
    eGET_QuickSniper        =6,
    eGET_LongGeneric        =7,
    eGET_LongBoltok         =8,
    eGET_LongBow            =9,
    eGET_LongSniper         =10,
    eGET_MAX                =11,
};
enum EGearWeaponType
{
    eGEARWEAP_FragGrenade   =0,
    eGEARWEAP_InkGrenade    =1,
    eGEARWEAP_SmokeGrenade  =2,
    eGEARWEAP_Boomshot      =3,
    eGEARWEAP_Flame         =4,
    eGEARWEAP_Sniper        =5,
    eGEARWEAP_Bow           =6,
    eGEARWEAP_Mulcher       =7,
    eGEARWEAP_Mortar        =8,
    eGEARWEAP_HOD           =9,
    eGEARWEAP_Gorgon        =10,
    eGEARWEAP_Boltok        =11,
    eGEARWEAP_Pistol        =12,
    eGEARWEAP_Lancer        =13,
    eGEARWEAP_Hammerburst   =14,
    eGEARWEAP_Shotgun       =15,
    eGEARWEAP_Shield        =16,
    eGEARWEAP_Disabled      =17,
    eGEARWEAP_GoldLancer    =18,
    eGEARWEAP_GoldHammer    =19,
    eGEARWEAP_MAX           =20,
};
enum EGearMapsShipped
{
    eGEARMAP_None           =0,
    eGEARMAP_MP1            =1,
    eGEARMAP_MP2            =2,
    eGEARMAP_MP3            =3,
    eGEARMAP_MP4            =4,
    eGEARMAP_MP5            =5,
    eGEARMAP_MP6            =6,
    eGEARMAP_MP7            =7,
    eGEARMAP_MP8            =8,
    eGEARMAP_MP9            =9,
    eGEARMAP_MP10           =10,
    eGEARMAP_MAX            =11,
};
enum EGearAchievement
{
    eGA_Invalid             =0,
    eGA_GreenAsGrass        =1,
    eGA_ItsATrap            =2,
    eGA_EscortService       =3,
    eGA_GirlAboutTown       =4,
    eGA_ThatSinkingFeeling  =5,
    eGA_Freebaird           =6,
    eGA_HeartBroken         =7,
    eGA_LongitudeAndAttitude=8,
    eGA_TanksForTheMemories =9,
    eGA_WaterSports         =10,
    eGA_SavedMaria          =11,
    eGA_WrappedInBeacon     =12,
    eGA_HaveFunStormingTheCastle=13,
    eGA_AndTheHorseYourRodeInOn=14,
    eGA_TheyJustKeepComing  =15,
    eGA_BrumakRodeo         =16,
    eGA_DoesThisLookInfectedToYou=17,
    eGA_Reservist           =18,
    eGA_NonCommissionedOfficer=19,
    eGA_CommissionedOfficer =20,
    eGA_Commander           =21,
    eGA_Tourist             =22,
    eGA_PackRat             =23,
    eGA_Completionist       =24,
    eGA_DomCurious          =25,
    eGA_Domination          =26,
    eGA_ICantQuitYouDom     =27,
    eGA_CrossedSwords       =28,
    eGA_PoundOfFlesh        =29,
    eGA_DIYTurret           =30,
    eGA_ShockAndAwe         =31,
    eGA_SaidTheSpiderToTheFly=32,
    eGA_PeekABoo            =33,
    eGA_ShakeAndBake        =34,
    eGA_ActiveReload        =35,
    eGA_TickerLicker        =36,
    eGA_VarietyIsTheSpiceOfDeath=37,
    eGA_MultitalentedExecutioner=38,
    eGA_Seriously2          =39,
    eGA_Photojournalist     =40,
    eGA_ItTakesTwo          =41,
    eGA_TheOldBallAndChain  =42,
    eGA_ItsGoodToBeTheKing  =43,
    eGA_YouGoAheadIllBeFine =44,
    eGA_BackToBasic         =45,
    eGA_Martyr              =46,
    eGA_Party1999           =47,
    eGA_AroundTheWorld      =48,
    eGA_SurvivedToTen       =49,
    eGA_SurvivedToFifty     =50,
    eGA_DLC1                =51,
    eGA_DLC2                =52,
    eGA_DLC3                =53,
    eGA_DLC4                =54,
    eGA_DLC5                =55,
    eGA_DLC6                =56,
    eGA_DLC7                =57,
    eGA_DLC8                =58,
    eGA_DLC9                =59,
    eGA_DLC10               =60,
    eGA_MAX                 =61,
};
enum EGearUnlockable
{
    eUNLOCK_InsaneDifficulty=0,
    eUNLOCK_Character_Dizzy =1,
    eUNLOCK_Character_Kantus=2,
    eUNLOCK_Character_Tai   =3,
    eUNLOCK_Character_PalaceGuard=4,
    eUNLOCK_Character_Skorge=5,
    eUNLOCK_Character_Carmine1=6,
    eUNLOCK_Character_Raam  =7,
    eUNLOCK_Character_Minh  =8,
    eUNLOCK_Character_DLC1  =9,
    eUNLOCK_Character_DLC2  =10,
    eUNLOCK_Character_DLC3  =11,
    eUNLOCK_Character_DLC4  =12,
    eUNLOCK_Character_DLC5  =13,
    eUNLOCK_Character_None  =14,
    eUNLOCK_MAX             =15,
};
enum EGearDiscoverableType
{
    eDISC_None              =0,
    eDISC_Tut_Newspaper     =1,
    eDISC_Tut_AmbulanceLog  =2,
    eDISC_Hosp_MedicalFile  =3,
    eDISC_Hosp_DrNote       =4,
    eDISC_Hosp_COGLetterhead=5,
    eDISC_Hosp_COGTag       =6,
    eDISC_Hosp_MartialLaw   =7,
    eDISC_Assault_GrindSpec =8,
    eDISC_Assault_AmmoForm  =9,
    eDISC_Landown_Newspaper =10,
    eDISC_Landown_COGTag    =11,
    eDISC_Landown_PackSlip  =12,
    eDISC_Landown_Tombstone =13,
    eDISC_Interv_GrindJournal=14,
    eDISC_Interv_KantusScroll=15,
    eDISC_Interv_LocustNeck =16,
    eDISC_Rescue_HelpAd     =17,
    eDISC_Rescue_COGTag     =18,
    eDISC_Rescue_Journal    =19,
    eDISC_Riftworm_MagCover =20,
    eDISC_Riftworm_COGTag   =21,
    eDISC_Outpost_MedFile   =22,
    eDISC_Outpost_Memo      =23,
    eDISC_Outpost_CompReadout=24,
    eDISC_Outpost_Journal   =25,
    eDISC_Outpost_CaptMarks =26,
    eDISC_Leviathan_Journal =27,
    eDISC_Maria_Jornal      =28,
    eDISC_Maria_PrisCatalog =29,
    eDISC_Highway_JailSched =30,
    eDISC_Highway_FingerNeck=31,
    eDISC_Nexis_LocCalendar =32,
    eDISC_Nexis_DefPlans    =33,
    eDISC_Palace_LocInvMap  =34,
    eDISC_Palace_LocWormStat=35,
    eDISC_Palace_Tablets    =36,
    eDISC_Jacinto_ReconRep  =37,
    eDISC_Jacinto_COGTag    =38,
    eDISC_Sinkhole_Newspaper=39,
    eDISC_Sinkhole_COGTag   =40,
    eDISC_Sinkhole_Journal  =41,
    eDISC_MAX               =42,
};
enum EProgressType
{
    ePROG_Achievement       =0,
    ePROG_Collectible       =1,
    ePROG_Unlockable        =2,
    ePROG_MAX               =3,
};
enum EChapterPoint
{
    CHAP_Tutorial_Welcome   =0,
    CHAP_Hospital_Desperation=1,
    CHAP_Assault_Thunder    =2,
    CHAP_Assault_Push       =3,
    CHAP_Landown_Roadblocks =4,
    CHAP_Landown_Digging    =5,
    CHAP_Intervention_Scattered=6,
    CHAP_Intervention_Creatures=7,
    CHAP_Intervention_Revelations=8,
    CHAP_Rescue_Feeling     =9,
    CHAP_Rescue_Captivity   =10,
    CHAP_Riftworm_Belly     =11,
    CHAP_Outpost_Secret     =12,
    CHAP_Outpost_Origins    =13,
    CHAP_Outpost_Awakening  =14,
    CHAP_MountKadar_Ascension=15,
    CHAP_Leviathan_Displacement=16,
    CHAP_Leviathan_Beast    =17,
    CHAP_Maria_Priorities   =18,
    CHAP_Maria_Answers      =19,
    CHAP_Nexis_Nest         =20,
    CHAP_Nexis_NoBack       =21,
    CHAP_Palace_Plans       =22,
    CHAP_Palace_Inquisition =23,
    CHAP_Escape_Escape      =24,
    CHAP_Jacinto_Stand      =25,
    CHAP_Sinkhole_Parking   =26,
    CHAP_Sinkhole_Footing   =27,
    CHAP_Closure_Closure    =28,
    CHAP_Gameover           =29,
    CHAP_DLC_1              =30,
    CHAP_DLC_2              =31,
    CHAP_DLC_3              =32,
    CHAP_DLC_4              =33,
    CHAP_DLC_5              =34,
    CHAP_DLC_6              =35,
    CHAP_DLC_7              =36,
    CHAP_DLC_8              =37,
    CHAP_DLC_9              =38,
    CHAP_DLC_10             =39,
    CHAP_DLC_11             =40,
    CHAP_DLC_12             =41,
    CHAP_DLC_13             =42,
    CHAP_DLC_14             =43,
    CHAP_DLC_15             =44,
    CHAP_DLC_16             =45,
    CHAP_DLC_17             =46,
    CHAP_DLC_18             =47,
    CHAP_MAX                =48,
};
enum EGearAct
{
    GEARACT_I               =0,
    GEARACT_II              =1,
    GEARACT_III             =2,
    GEARACT_IV              =3,
    GEARACT_V               =4,
    GEARACT_DLC1            =5,
    GEARACT_DLC2            =6,
    GEARACT_DLC3            =7,
    GEARACT_MAX             =8,
};
enum EGearTutorialType
{
    GEARTUT_Objectives      =0,
    GEARTUT_Cover           =1,
    GEARTUT_Fire            =2,
    GEARTUT_Target          =3,
    GEARTUT_ChangeWeapon    =4,
    GEARTUT_Reload          =5,
    GEARTUT_ActiveReload    =6,
    GEARTUT_PointOfInterest =7,
    GEARTUT_Mantle1         =8,
    GEARTUT_Mantle2         =9,
    GEARTUT_Evade           =10,
    GEARTUT_CoverSlip       =11,
    GEARTUT_SwatTurn        =12,
    GEARTUT_Use1            =13,
    GEARTUT_Use2            =14,
    GEARTUT_Grenades1       =15,
    GEARTUT_Grenades2       =16,
    GEARTUT_PlayerDamage    =17,
    GEARTUT_Revive          =18,
    GEARTUT_ChainsawMelee   =19,
    GEARTUT_Ladder          =20,
    GEARTUT_RoadieRun       =21,
    GEARTUT_BlindFire       =22,
    GEARTUT_AimFromCover    =23,
    GEARTUT_Movement        =24,
    GEARTUT_Executions      =25,
    GEARTUT_MeatShield      =26,
    GEARTUT_Crawling        =27,
    GEARTUT_WeapMortar      =28,
    GEARTUT_WeapLongshot    =29,
    GEARTUT_Shield          =30,
    GEARTUT_WeapHOD         =31,
    GEARTUT_WeapBow         =32,
    GEARTUT_Centaur         =33,
    GEARTUT_CentaurCoop     =34,
    GEARTUT_CentaurLights   =35,
    GEARTUT_Reaver          =36,
    GEARTUT_Reaver2         =37,
    GEARTUT_Brumak          =38,
    GEARTUT_WeapSmokeGrenade=39,
    GEARTUT_WeapShotgun     =40,
    GEARTUT_WeapPistol      =41,
    GEARTUT_WeapMinigun     =42,
    GEARTUT_WeapInkGrenade  =43,
    GEARTUT_WeapHammerburst =44,
    GEARTUT_WeapFragGrenade =45,
    GEARTUT_WeapFlameThrower=46,
    GEARTUT_WeapBurstPistol =47,
    GEARTUT_WeapBoomshot    =48,
    GEARTUT_WeapBoltok      =49,
    GEARTUT_WeapAssaultRifle=50,
    GEARTUT_ReloadSimple    =51,
    GEARTUT_UnlimitedAmmo   =52,
    GEARTUT_Sneak           =53,
    GEARTUT_ObjectivesReminder=54,
    GEARTUT_WeapTurret      =55,
    GEARTUT_TRAIN_WarWelcome=56,
    GEARTUT_TRAIN_SudDeath  =57,
    GEARTUT_TRAIN_Revive    =58,
    GEARTUT_TRAIN_Crawl     =59,
    GEARTUT_TRAIN_GrenCrawl =60,
    GEARTUT_TRAIN_ExeWelcome=61,
    GEARTUT_TRAIN_ExeRule   =62,
    GEARTUT_TRAIN_Exe       =63,
    GEARTUT_TRAIN_GuarWelcome=64,
    GEARTUT_TRAIN_KSpawn    =65,
    GEARTUT_TRAIN_DSpawn    =66,
    GEARTUT_TRAIN_ExeLead   =67,
    GEARTUT_TRAIN_UDed      =68,
    GEARTUT_TRAIN_LeDed     =69,
    GEARTUT_TRAIN_Assas     =70,
    GEARTUT_TRAIN_HiScor    =71,
    GEARTUT_TRAIN_AnxWelcome=72,
    GEARTUT_TRAIN_NmyCap    =73,
    GEARTUT_TRAIN_TeamCap   =74,
    GEARTUT_TRAIN_Defend    =75,
    GEARTUT_TRAIN_DrainRng  =76,
    GEARTUT_TRAIN_WinRnd    =77,
    GEARTUT_TRAIN_LoseRnd   =78,
    GEARTUT_TRAIN_MeatWelcome=79,
    GEARTUT_TRAIN_MeatPick  =80,
    GEARTUT_TRAIN_MeatRng   =81,
    GEARTUT_TRAIN_MeatNmy   =82,
    GEARTUT_TRAIN_MeatScore =83,
    GEARTUT_MAX             =84,
};
enum EGearAutoInitTutorialTypes
{
    eGAIT_None              =0,
    eGAIT_SP                =1,
    eGAIT_MP                =2,
    eGAIT_Train1            =3,
    eGAIT_Train2            =4,
    eGAIT_Train3            =5,
    eGAIT_Train4            =6,
    eGAIT_Train5            =7,
    eGAIT_MAX               =8,
};
enum EGearRaceTypes
{
    eGEARRACE_COG           =0,
    eGEARRACE_Locust        =1,
    eGEARRACE_MAX           =2,
};
enum EGearCampaignLobbyMode
{
    eGCLOBBYMODE_Error      =0,
    eGCLOBBYMODE_Host       =1,
    eGCLOBBYMODE_Join       =2,
    eGCLOBBYMODE_Split      =3,
    eGCLOBBYMODE_SoloPath   =4,
    eGCLOBBYMODE_MAX        =5,
};
enum EGearMPTypes
{
    eGEARMP_Warzone         =0,
    eGEARMP_Execution       =1,
    eGEARMP_KTL             =2,
    eGEARMP_CombatTrials    =3,
    eGEARMP_Annex           =4,
    eGEARMP_Wingman         =5,
    eGEARMP_KOTH            =6,
    eGEARMP_CTM             =7,
    eGEARMP_MAX             =8,
};
enum EDifficultyLevel
{
    DL_Casual               =0,
    DL_Normal               =1,
    DL_Hardcore             =2,
    DL_Insane               =3,
    DL_MAX                  =4,
};
enum eGearKismetIconType
{
    eGEARBUTTON_A           =0,
    eGEARBUTTON_A_MASH      =1,
    eGEARBUTTON_B           =2,
    eGEARBUTTON_B_MASH      =3,
    eGEARBUTTON_X           =4,
    eGEARBUTTON_Y           =5,
    eGEARBUTTON_ChainsawMash=6,
    eGEARBUTTON_MAX         =7,
};
enum EFontType
{
    FONT_Chrom20            =0,
    FONT_Chrom24            =1,
    FONT_Euro20             =2,
    FONT_Euro24             =3,
    FONT_GameOver2          =4,
    FONT_HUD_GearHUD_font   =5,
    FONT_Xbox360_18pt       =6,
    FONT_MAX                =7,
};
enum EActionType
{
    AT_None                 =0,
    AT_KismetButton         =1,
    AT_StayingAlive         =2,
    AT_SuicideBomb          =3,
    AT_KnockedDown          =4,
    AT_DownedTeammate       =5,
    AT_ForceLook            =6,
    AT_Scripted             =7,
    AT_Player               =8,
    AT_StateAction          =9,
    AT_Vehicle              =10,
    AT_SpecialMove          =11,
    AT_Trigger              =12,
    AT_Pickup               =13,
    AT_MovableObject        =14,
    AT_VehicleControl       =15,
    AT_MAX                  =16,
};
enum EGearDecalType
{
    GDTT_Blood_GenericSplat =0,
    GDTT_Chainsaw_Ground    =1,
    GDTT_Chainsaw_Wall      =2,
    GDTT_DBNO_BodyHittingFloor=3,
    GDTT_DBNO_Smear         =4,
    GDTT_ExitWoundSplatter  =5,
    GDTT_GibExplode_Ceiling =6,
    GDTT_GibExplode_Ground  =7,
    GDTT_GibExplode_Wall    =8,
    GDTT_GibImpact          =9,
    GDTT_GibTrail           =10,
    GDTT_LimbBreak          =11,
    GDTT_MeatBag_BloodSplatter=12,
    GDTT_MeatBag_FirstGrabbing=13,
    GDTT_MeatBag_HeelScuff  =14,
    GDTT_NeckSpurt          =15,
    GDTT_Wall_SlammingIntoCover=16,
    GDTT_Wall_Smear         =17,
    GDTT_Wall_Smear_Mirrored=18,
    GDTT_GibExplode_Ground_SmallSplat=19,
    GDTT_BloodPool          =20,
    GDTT_PawnIsReallyHurtSmallSplat=21,
    GDTT_HitByBulletSmallSplat=22,
    GDTT_ExecutionLong_PunchFace=23,
    GDTT_ExecutionLong_Sniper=24,
    GDTT_ExecutionLong_TorqueBow=25,
    GDTT_ExecutionLong_PistolWhip=26,
    GDTT_FlameThrower_StartFlameBlast=27,
    GDTT_FlameThrower_FlameIsBurning=28,
    GDDT_ReaverGibExplode   =29,
    EGearDecalType_MAX      =30,
};
enum ECharacterFootStepType
{
    CFST_Generic            =0,
    CFST_COG_Dom            =1,
    CFST_COG_Marcus         =2,
    CFST_Locust_Drone       =3,
    CFST_Locust_Ticker      =4,
    CFST_Locust_Wretch      =5,
    CFST_Locust_RideableBrumak=6,
    CFST_MAX                =7,
};
enum EImpactTypeExplosion
{
    ITE_None                =0,
    ITE_BoomerFlail         =1,
    ITE_Boomshot            =2,
    ITE_BrumakMainGun       =3,
    ITE_BrumakRocket        =4,
    ITE_CentaurCannon       =5,
    ITE_GrenadeFrag         =6,
    ITE_GrenadeGas          =7,
    ITE_GrenadeInk          =8,
    ITE_GrenadeSmoke        =9,
    ITE_HOD                 =10,
    ITE_Mortar              =11,
    ITE_ReaverRocket        =12,
    ITE_RocketLauncherTurret=13,
    ITE_TorqueBowArrow      =14,
    ITE_BrumakMainGunPlayer =15,
    ITE_MAX                 =16,
};
enum EImpactTypeBallistic
{
    ITB_None                =0,
    ITB_Boltock             =1,
    ITB_BrumakSideGun       =2,
    ITB_BrumakSideGunOther  =3,
    ITB_Gnasher             =4,
    ITB_Hammerburst         =5,
    ITB_KingRavenTurret     =6,
    ITB_Lancer              =7,
    ITB_LocustBurstPistol   =8,
    ITB_Longshot            =9,
    ITB_Minigun             =10,
    ITB_Scorcher            =11,
    ITB_Snub                =12,
    ITB_TorqueBow           =13,
    ITB_Troika              =14,
    ITB_TyroTurrent         =15,
    ITB_WretchMeleeSlash    =16,
    ITB_WretchMelee         =17,
    ITB_BrumakSideGunPlayer =18,
    ITB_MAX                 =19,
};
enum EWeaponClass
{
    WC_Boltock              =0,
    WC_Boomshot             =1,
    WC_BoomerFlail          =2,
    WC_BrumakMainGun        =3,
    WC_BrumakSideGun        =4,
    WC_BrumakSideGunOther   =5,
    WC_FragGrenade          =6,
    WC_GasGrenade           =7,
    WC_Gnasher              =8,
    WC_HOD                  =9,
    WC_Hammerburst          =10,
    WC_InkGrenade           =11,
    WC_KingRavenTurret      =12,
    WC_Lancer               =13,
    WC_Longshot             =14,
    WC_Minigun              =15,
    WC_Mortar               =16,
    WC_Scorcher             =17,
    WC_SmokeGrenade         =18,
    WC_Snub                 =19,
    WC_TorqueBow            =20,
    WC_Troika               =21,
    WC_TyroTurrent          =22,
    WC_WretchMeleeSlash     =23,
    WC_FragGrenadeExplosion =24,
    WC_TorqueBowArrowExplosion=25,
    WC_MortarExplosion      =26,
    WC_BoomshotExplosion    =27,
    WC_BrumakRocketExplosion=28,
    WC_LocustBurstPistol    =29,
    WC_CentaurCannon        =30,
    WC_ReaverRocket         =31,
    WC_RocketLauncherTurret =32,
    WC_Shield               =33,
    WC_MAX                  =34,
};
enum EGameButtons
{
    GB_A                    =0,
    GB_X                    =1,
    GB_Y                    =2,
    GB_B                    =3,
    GB_Start                =4,
    GB_Back                 =5,
    GB_LeftTrigger          =6,
    GB_LeftBumper           =7,
    GB_RightTrigger         =8,
    GB_RightBumper          =9,
    GB_DPad_Up              =10,
    GB_DPad_Left            =11,
    GB_DPad_Down            =12,
    GB_DPad_Right           =13,
    GB_LeftStick_Push       =14,
    GB_RightStick_Push      =15,
    GB_LeftStick_Up         =16,
    GB_LeftStick_Down       =17,
    GB_LeftStick_Left       =18,
    GB_LeftStick_Right      =19,
    GB_RightStick_Up        =20,
    GB_RightStick_Down      =21,
    GB_RightStick_Left      =22,
    GB_RightStick_Right     =23,
    GB_Max                  =24,
};
enum EWeaponTracerType
{
    WTT_LongSkinny          =0,
    WTT_ShortBullet         =1,
    WTT_MinigunFastFiring   =2,
    WTT_Hammerburst         =3,
    WTT_Boltok              =4,
    WTT_Brumak              =5,
    WTT_Reaver              =6,
    WTT_BrumakPlayer        =7,
    WTT_MAX                 =8,
};
enum EMoveOverride
{
    EMO_None                =0,
    EMO_Fast                =1,
    EMO_MAX                 =2,
};
enum ECombatZoneType
{
    CZT_Normal              =0,
    CZT_Ambush              =1,
    CZT_MAX                 =2,
};
enum EGearLookAtNavPathType
{
    eNAVPATH_MainMenu_Training=0,
    eNAVPATH_MainMenu_WarJournal=1,
    eNAVPATH_WarJournal_Discover=2,
    eNAVPATH_WarJournal_Unlocks=3,
    eNAVPATH_WarJournal_Achieve=4,
    eNAVPATH_MAX            =5,
};
enum EGearCampaignMemorySlot
{
    eGEARCAMPMEMORYSLOT_0   =0,
    eGEARCAMPMEMORYSLOT_1   =1,
    eGEARCAMPMEMORYSLOT_2   =2,
    eGEARCAMPMEMORYSLOT_MAX =3,
};
enum EGearCheckpointUsage
{
    eGEARCHECKPOINT_UseLast =0,
    eGEARCHECKPOINT_Restart =1,
    eGEARCHECKPOINT_MAX     =2,
};
enum EGearMapSelectType
{
    eGEARMAPSELECT_VOTE     =0,
    eGEARMAPSELECT_HOSTSELECT=1,
    eGEARMAPSELECT_MAX      =2,
};
enum EGearCampMode
{
    eGCM_LivePublic         =0,
    eGCM_LivePrivate        =1,
    eGCM_SystemLink         =2,
    eGCM_MAX                =3,
};
enum EGearCoopInviteType
{
    eGCIT_InviteRequired    =0,
    eGCIT_FriendsOnly       =1,
    eGCIT_Public            =2,
    eGCIT_MAX               =3,
};
enum EGearVersusPartyType
{
    eGVPT_InviteRequired    =0,
    eGVPT_FriendsOnly       =1,
    eGVPT_Public            =2,
    eGVPT_MAX               =3,
};
enum EGearVersusMatchType
{
    eGVMT_Official          =0,
    eGVMT_Custom            =1,
    eGVMT_SystemLink        =2,
    eGVMT_Local             =3,
    eGVMT_MAX               =4,
};
enum EWeaponReplaceTypes
{
    WEAPRT_Default          =0,
    WEAPRT_Remove           =1,
    WEAPRT_MAX              =2,
};
enum ECogTag
{
    COGTAG_None             =0,
    COGTAG_MAX              =1,
};
enum ETVType
{
    TVT_Default             =0,
    TVT_Soft                =1,
    TVT_Lucent              =2,
    TVT_Vibrant             =3,
    TVT_MAX                 =4,
};
enum ELocustMPCharacter
{
    LMPC_Drone              =0,
    LMPC_DroneSniper        =1,
    LMPC_Hunter             =2,
    LMPC_HunterNoArmor      =3,
    LMPC_Theron             =4,
    LMPC_TheronHelmet       =5,
    LMPC_DroneChopper       =6,
    LMPC_BeastLord          =7,
    LMPC_Flamer             =8,
    LMPC_Kantus             =9,
    LMPC_Skorge             =10,
    LMPC_GeneralRaam        =11,
    LMPC_MAX                =12,
};
enum ECogMPCharacter
{
    CMPC_Marcus             =0,
    CMPC_Minh               =1,
    CMPC_Cole               =2,
    CMPC_Baird              =3,
    CMPC_Dom                =4,
    CMPC_Carmine            =5,
    CMPC_BenCarmine         =6,
    CMPC_Tai                =7,
    CMPC_Dizzy              =8,
    CMPC_Hoffman            =9,
    CMPC_MAX                =10,
};
enum EGearOptsOnOff
{
    WOOO_On                 =0,
    WOOO_Off                =1,
    WOOO_MAX                =2,
};
enum EGearOptsYesNo
{
    WOYN_Yes                =0,
    WOYN_No                 =1,
    WOYN_MAX                =2,
};
enum EGearTriggerConfigOpts
{
    WTCO_Default            =0,
    WTCO_SouthPaw           =1,
    WTCO_MAX                =2,
};
enum EGearStickConfigOpts
{
    WSCO_Default            =0,
    WSCO_Legacy             =1,
    WSCO_SouthPaw           =2,
    WSCO_LegacySouthpaw     =3,
    WSCO_MAX                =4,
};
enum EGearControlScheme
{
    GCS_Default             =0,
    GCS_Alternate           =1,
    GCS_MAX                 =2,
};
enum EGearDiscoverablePickupType
{
    eGDPT_Ground            =0,
    eGDPT_Wall              =1,
    eGDPT_MAX               =2,
};
enum EGearDroppedPickupType
{
    eGEARDROP_Generic       =0,
    eGEARDROP_Special       =1,
    eGEARDROP_MAX           =2,
};
enum EEncouragementType
{
    ET_WonMatch             =0,
    ET_LostMatch            =1,
    ET_WonMatchByShutout    =2,
    ET_LostMatchByShutout   =3,
    ET_MatchOrRoundDraw     =4,
    ET_WonRound             =5,
    ET_LostRound            =6,
    ET_MAX                  =7,
};
enum EVoiceChannel
{
    VC_SpectatorsDead       =0,
    VC_Team1                =1,
    VC_Team2                =2,
    VC_Team3                =3,
    VC_Team4                =4,
    VC_Team5                =5,
    VC_MAX                  =6,
};
enum EDerrickStripeColor
{
    DerrickStripe_DefaultBlue=0,
    DerrickStripe_LightBlue =1,
    DerrickStripe_White     =2,
    DerrickStripe_Yellow    =3,
    DerrickStripe_Green     =4,
    DerrickStripe_MAX       =5,
};
enum EWOPCacheTypes
{
    WOP_DEFAULT_GENERAL     =0,
    WOP_DEFAULT_IMPACT      =1,
    WOP_DEFAULT_IMPACT_AR   =2,
    WOP_DEFAULT_IMPACT_METAL=3,
    WOP_DEFAULT_IMPACT_WOOD =4,
    WOP_DEFAULT_NO_DAMAGE_SPARKS=5,
    WOP_WEAPON_TRACER_SMOKETRAIL=6,
    WOP_WEAPON_TRACER_SMOKETRAIL_AR=7,
    WOP_DEFAULT_IMPACT_LOCUST_HAMMERBURST=8,
    WOP_DEFAULT_IMPACT_LOCUST_HAMMERBURST_AR=9,
    WOP_DEFAULT_IMPACT_LOCUST_HAMMERBURST_METAL=10,
    WOP_DEFAULT_IMPACT_LOCUST_HAMMERBURST_WOOD=11,
    WOP_DEFAULT_SHOTGUN     =12,
    WOP_DEFAULT_SHOTGUN_METAL=13,
    WOP_DEFAULT_SHOTGUN_WOOD=14,
    WOP_DEFAULT_MULCHER_METAL=15,
    WOP_DEFAULT_MULCHER_STONE=16,
    WOP_DEFAULT_MULCHER_TRACER_SMOKETRAIL=17,
    WOP_DEFAULT_MULCHER_TRACER_SMOKETRAIL_AR=18,
    WOP_DEFAULT_P_TroikaCabal_Impact_Stone=19,
    WOP_COVER_HIT           =20,
    WOP_PLAYER_SLIDE        =21,
    WOP_BLOOD_MELEE_EMITTER =22,
    WOP_BLOOD_LOD           =23,
    WOP_BLOOD_METAL_LOD     =24,
    WOP_BLOOD_ARMOR_LOD     =25,
    WOP_BLOOD_DEATH_LOD     =26,
    WOP_BLOOD_GENERAL       =27,
    WOP_BLOOD_FLYING_BODY_PART=28,
    WOP_BLOOD_SPRAY_HIT_EFFECT=29,
    WOP_BLOOD_HEADSHOT      =30,
    WOP_BERSERKER_IMPACT    =31,
    WOP_NO_BLOOD            =32,
    WOP_BLOOD_MELEE         =33,
    WOP_PLAYER_ROLL         =34,
    WOP_BLOOD_GROUND_IMPACT =35,
    WOP_BLOOD_EXIT_WOUND    =36,
    WOP_FRACTURE_CONCRETE_MEDIUM=37,
    WOP_DEFAULT_IMPACT_CHEAP=38,
    WOP_PLAYER_BRUMAK_IMPACTS=39,
    WOP_MAX                 =40,
};
enum EHoleEmergeAnim
{
    EHEA_Random             =0,
    EHEA_CrawlUp            =1,
    EHEA_Jump               =2,
    EHEA_MAX                =3,
};
enum EHoleStatus
{
    HS_ReadyToOpen          =0,
    HS_Opening              =1,
    HS_Open                 =2,
    HS_Closing              =3,
    HS_Closed               =4,
    HS_MAX                  =5,
};
enum EHeadTrackPawnFilter
{
    HT_PlayersOnly          =0,
    HT_PlayerTeamOnly       =1,
    HT_AllPawns             =2,
    HT_MAX                  =3,
};
enum EGearSpecialIconType
{
    eGSIT_None              =0,
    eGSIT_Leader            =1,
    eGSIT_Flag              =2,
    eGSIT_BuddyCOG          =3,
    eGSIT_BuddyLocust       =4,
    eGSIT_MAX               =5,
};
enum EActiveReloadResultType
{
    eARResult_None          =0,
    eARResult_Success       =1,
    eARResult_SuperSuccess  =2,
    eARResult_Failed        =3,
    eARResult_MAX           =4,
};
enum EGearHUDColor
{
    eWARHUDCOLOR_WHITE      =0,
    eWARHUDCOLOR_RED        =1,
    eWARHUDCOLOR_BLACK      =2,
    eWARHUDCOLOR_WHITE_DK   =3,
    eWARHUDCOLOR_TEAMRED    =4,
    eWARHUDCOLOR_TEAMBLUE   =5,
    eWARHUDCOLOR_CHATICONRED=6,
    eWARHUDCOLOR_CHATICONBLUE=7,
    eWARHUDCOLOR_MAX        =8,
};
enum EDisplayableSquadStatus
{
    eSO_DEFENSIVE           =0,
    eSO_ATTACK              =1,
    eSO_DOWN                =2,
    eSO_REVIVE              =3,
    eSO_DEAD                =4,
    eSO_NORMAL              =5,
    eSO_MAX                 =6,
};
enum EAssessSquadStatus
{
    EASS_None               =0,
    EASS_Normal             =1,
    EASS_Attack             =2,
    EASS_Down               =3,
    EASS_Dead               =4,
    EASS_Defensive          =5,
    EASS_MAX                =6,
};
enum EAssessSquadBackgroundType
{
    EASBT_Normal            =0,
    EASBT_Dead              =1,
    EASBT_MAX               =2,
};
enum EWeatherType
{
    WeatherType_Clear       =0,
    WeatherType_Rain        =1,
    WeatherType_Hail        =2,
    WeatherType_MAX         =3,
};
enum ECountdownState
{
    eCDS_None               =0,
    eCDS_Active             =1,
    eCDS_Stopped            =2,
    eCDS_Expired            =3,
    eCDS_MAX                =4,
};
enum ETimerNotificationState
{
    TNS_NotStarted          =0,
    TNS_IsActive            =1,
    TNS_IsDone              =2,
    TNS_MAX                 =3,
};
enum ETimerNotification
{
    TN_60Secs               =0,
    TN_45Secs               =1,
    TN_30Secs               =2,
    TN_Count                =3,
    TN_MAX                  =4,
};
enum EGameStatus
{
    GS_None                 =0,
    GS_WaitingForHost       =1,
    GS_PreMatch             =2,
    GS_RoundInProgress      =3,
    GS_RoundOver            =4,
    GS_EndMatch             =5,
    GS_Loading              =6,
    GS_MAX                  =7,
};
enum EGearPlayerStatus
{
    WPS_Spectating          =0,
    WPS_Alive               =1,
    WPS_Down                =2,
    WPS_Dead                =3,
    WPS_Respawning          =4,
    WPS_MAX                 =5,
};
enum EGearTeam
{
    TEAM_COG                =0,
    TEAM_LOCUST             =1,
    TEAM_EVERYONE           =2,
    TEAM_MAX                =3,
};
enum EPOIForceLookType
{
    ePOIFORCELOOK_None      =0,
    ePOIFORCELOOK_Automatic =1,
    ePOIFORCELOOK_PlayerInduced=2,
    ePOIFORCELOOK_MAX       =3,
};
enum ECheckpointAction
{
    Checkpoint_Default      =0,
    Checkpoint_Load         =1,
    Checkpoint_Save         =2,
    Checkpoint_DeleteAll    =3,
    Checkpoint_MAX          =4,
};

#endif // !INCLUDED_GEARGAME_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName GEARGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Activate)
AUTOGENERATE_NAME(AddOccupant)
AUTOGENERATE_NAME(AddResident)
AUTOGENERATE_NAME(AIFactoryDisabled)
AUTOGENERATE_NAME(ApplySplashDamage)
AUTOGENERATE_NAME(AreStorageWritesAllowed)
AUTOGENERATE_NAME(CheckpointIsEmpty)
AUTOGENERATE_NAME(CheckpointLoadComplete)
AUTOGENERATE_NAME(DeactivateTutorial)
AUTOGENERATE_NAME(DebugDraw)
AUTOGENERATE_NAME(DrawDebug)
AUTOGENERATE_NAME(GetDriverIdealPosition)
AUTOGENERATE_NAME(GetDriverIdealRotation)
AUTOGENERATE_NAME(GetDumpString)
AUTOGENERATE_NAME(GetPhysicalFireStartLoc)
AUTOGENERATE_NAME(GetSpawnSlot)
AUTOGENERATE_NAME(GetSpawnSlotTemp)
AUTOGENERATE_NAME(GoreSystemSpawnGibEffects)
AUTOGENERATE_NAME(HandleButtonInput)
AUTOGENERATE_NAME(HandleSpawn)
AUTOGENERATE_NAME(Init)
AUTOGENERATE_NAME(Initialize)
AUTOGENERATE_NAME(InitializeButtonHandlingHandlers)
AUTOGENERATE_NAME(InternalPaused)
AUTOGENERATE_NAME(InternalPopped)
AUTOGENERATE_NAME(InternalPushed)
AUTOGENERATE_NAME(InternalResumed)
AUTOGENERATE_NAME(InternalTick)
AUTOGENERATE_NAME(IsCurrentDeviceValid)
AUTOGENERATE_NAME(IsWithinMaxEffectDistance)
AUTOGENERATE_NAME(KillPlayers)
AUTOGENERATE_NAME(LogSurveyResult)
AUTOGENERATE_NAME(NotifyLookedAt)
AUTOGENERATE_NAME(NotifyShotFired)
AUTOGENERATE_NAME(OnEnumerateScreenshotsComplete)
AUTOGENERATE_NAME(OnLoadScreenshotComplete)
AUTOGENERATE_NAME(OnPlaylistIdChanged)
AUTOGENERATE_NAME(OnSaveScreenshotComplete)
AUTOGENERATE_NAME(OnTutorialCompleted)
AUTOGENERATE_NAME(OnUploadScreenshotComplete)
AUTOGENERATE_NAME(OutputFunction)
AUTOGENERATE_NAME(PostLoadCheckpoint)
AUTOGENERATE_NAME(PostSaveCheckpoint)
AUTOGENERATE_NAME(PreLoadCheckpoint)
AUTOGENERATE_NAME(PreSaveCheckpoint)
AUTOGENERATE_NAME(Redrop)
AUTOGENERATE_NAME(RegisterFactory)
AUTOGENERATE_NAME(RemoveOccupant)
AUTOGENERATE_NAME(RemoveResident)
AUTOGENERATE_NAME(ReplicateDamageMod)
AUTOGENERATE_NAME(SetActionInfo)
AUTOGENERATE_NAME(SetCurrentWeather)
AUTOGENERATE_NAME(SetEnabled)
AUTOGENERATE_NAME(SetNextActiveTutorial)
AUTOGENERATE_NAME(SetupAudio)
AUTOGENERATE_NAME(SetWeatherEmitterHeight)
AUTOGENERATE_NAME(ShouldActivate)
AUTOGENERATE_NAME(ShutDownSubObject)
AUTOGENERATE_NAME(SlotIndexUpdated)
AUTOGENERATE_NAME(SpawnFromAIFactoryHasDied)
AUTOGENERATE_NAME(StartCountdown)
AUTOGENERATE_NAME(StopCountdown)
AUTOGENERATE_NAME(Suppress)
AUTOGENERATE_NAME(SuppressAll)
AUTOGENERATE_NAME(TemplateDelegate)
AUTOGENERATE_NAME(Tick)
AUTOGENERATE_NAME(TriggerDamageModAppliedEvent)
AUTOGENERATE_NAME(TriggerDestroyedEvent)
AUTOGENERATE_NAME(TriggerGUDEvent)
AUTOGENERATE_NAME(UnRegisterFactory)
AUTOGENERATE_NAME(UnShutDownObject)
AUTOGENERATE_NAME(UnSuppress)
AUTOGENERATE_NAME(UnSuppressAll)
AUTOGENERATE_NAME(Update)

#ifndef NAMES_ONLY

#ifndef INCLUDED_GEARGAME_CLASSES
#define INCLUDED_GEARGAME_CLASSES 1

struct FTakeHitInfo
{
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    class APawn* InstigatedBy;
    BYTE HitBoneIndex;
    class UPhysicalMaterial* PhysicalMaterial;
    FLOAT Damage;

    /** Constructors */
    FTakeHitInfo() {}
    FTakeHitInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTakeHitInfo));
    }
};

struct FDecalData
{
    BITFIELD bIsValid:1;
    class UMaterialInterface* DecalMaterial;
    BITFIELD ClipDecalsUsingFastPath:1;
    FLOAT Width;
    FLOAT Height;
    FLOAT Thickness;
    BITFIELD bRandomizeRotation:1;
    FVector2D RandomScalingRange;
    FLOAT RandomRadiusOffset;
    FLOAT LifeSpan;
    FVector2D BlendRange;

		/** Constructors */
		FDecalData() 
		{}
		FDecalData(EEventParm)
		{
			appMemzero(this, sizeof(FDecalData));
		}
		FDecalData(ENativeConstructor)
		: ClipDecalsUsingFastPath(TRUE)
		, Width(6.0f)
		, Height(6.0f)
		, Thickness(10.0f)
		, bRandomizeRotation(TRUE)
		, RandomScalingRange(1.0f,1.2f)
		, LifeSpan(15.0f)
		, BlendRange(70.f,89.5f)
		{}
	
};

struct FActionIconData
{
    TArrayNoInit<FCanvasIcon> ActionIcons;

    /** Constructors */
    FActionIconData() {}
    FActionIconData(EEventParm)
    {
        appMemzero(this, sizeof(FActionIconData));
    }
};

struct FActionInfo
{
    BYTE ActionType;
    FName ActionName;
    TArrayNoInit<struct FActionIconData> ActionIconDatas;
    FLOAT IconSpacing;
    BITFIELD bActive:1;
    FLOAT BlendPct;
    BITFIELD bCached:1;
    FLOAT SizeX;
    FLOAT SizeY;
    FStringNoInit TooltipText;
    INT FontIndex;
    FLOAT AutoDeActivateTimer;
    FLOAT ActivateTime;
    BITFIELD bMirror:1;
    FLOAT IconAnimationSpeed;

    /** Constructors */
    FActionInfo() {}
    FActionInfo(EEventParm)
    {
        appMemzero(this, sizeof(FActionInfo));
    }
};

struct FScreenShakeAnimStruct
{
    class UCameraAnim* Anim;
    BITFIELD bUseDirectionalAnimVariants:1;
    class UCameraAnim* Anim_Left;
    class UCameraAnim* Anim_Right;
    class UCameraAnim* Anim_Rear;
    FLOAT AnimPlayRate;
    FLOAT AnimScale;
    FLOAT AnimBlendInTime;
    FLOAT AnimBlendOutTime;
    BITFIELD bRandomSegment:1;
    FLOAT RandomSegmentDuration;
    BITFIELD bSingleInstance:1;

    /** Constructors */
    FScreenShakeAnimStruct() {}
    FScreenShakeAnimStruct(EEventParm)
    {
        appMemzero(this, sizeof(FScreenShakeAnimStruct));
    }
};

struct FShakeParams
{
    BYTE X;
    BYTE Y;
    BYTE Z;
    BYTE Padding;

    /** Constructors */
    FShakeParams() {}
    FShakeParams(EEventParm)
    {
        appMemzero(this, sizeof(FShakeParams));
    }
};

struct FScreenShakeStruct
{
    FLOAT TimeToGo;
    FLOAT TimeDuration;
    FVector RotAmplitude;
    FVector RotFrequency;
    FVector RotSinOffset;
    struct FShakeParams RotParam;
    FVector LocAmplitude;
    FVector LocFrequency;
    FVector LocSinOffset;
    struct FShakeParams LocParam;
    FLOAT FOVAmplitude;
    FLOAT FOVFrequency;
    FLOAT FOVSinOffset;
    BYTE FOVParam;
    FName ShakeName;
    BITFIELD bOverrideTargetingDampening:1;
    FLOAT TargetingDampening;

    /** Constructors */
    FScreenShakeStruct() {}
    FScreenShakeStruct(EEventParm)
    {
        appMemzero(this, sizeof(FScreenShakeStruct));
    }
};

struct FCheckpointTime
{
    INT SecondsSinceMidnight;
    INT Day;
    INT Month;
    INT Year;

    /** Constructors */
    FCheckpointTime() {}
    FCheckpointTime(EEventParm)
    {
        appMemzero(this, sizeof(FCheckpointTime));
    }
};

struct FDateTime
{
    INT A;
    INT B;

    /** Constructors */
    FDateTime() {}
    FDateTime(EEventParm)
    {
        appMemzero(this, sizeof(FDateTime));
    }
};

struct FScreenshotPlayerInfo
{
    FStringNoInit Nick;
    struct FUniqueNetId Xuid;
    BITFIELD IsVisible:1;
    FBox ScreenSpaceBoundingBox;
    FVector Location;

    /** Constructors */
    FScreenshotPlayerInfo() {}
    FScreenshotPlayerInfo(EEventParm)
    {
        appMemzero(this, sizeof(FScreenshotPlayerInfo));
    }
};

struct FScreenshotInfo
{
    FLOAT WorldTime;
    FStringNoInit Description;
    INT Rating;
    FStringNoInit GameType;
    FStringNoInit GameTypeFriendly;
    INT GameTypeId;
    INT MatchType;
    FStringNoInit MapName;
    FStringNoInit MapNameFriendly;
    struct FDateTime Realtime;
    FGuid MatchID;
    FVector CamLoc;
    FRotator CamRot;
    INT Width;
    INT Height;
    TArrayNoInit<struct FScreenshotPlayerInfo> Players;

    /** Constructors */
    FScreenshotInfo() {}
    FScreenshotInfo(EEventParm)
    {
        appMemzero(this, sizeof(FScreenshotInfo));
    }
};

struct FSavedScreenshotInfo
{
    FGuid Id;
    INT DeviceID;
    FStringNoInit MapName;
    FStringNoInit GameType;
    INT Rating;
    FStringNoInit Date;
    INT Year;
    BYTE Month;
    BYTE Day;

    /** Constructors */
    FSavedScreenshotInfo() {}
    FSavedScreenshotInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSavedScreenshotInfo));
    }
};

struct FPerDamageTypeMod
{
    FName DamageTypeName;
    FLOAT Multiplier;

    /** Constructors */
    FPerDamageTypeMod() {}
    FPerDamageTypeMod(EEventParm)
    {
        appMemzero(this, sizeof(FPerDamageTypeMod));
    }
};

class UGearTypes : public UObject
{
public:
    //## BEGIN PROPS GearTypes
    TArrayNoInit<class UClass*> DamageToWeaponMap;
    TArrayNoInit<class UClass*> DamageToExecutionMap;
    TArrayNoInit<class UPhysicalMaterial*> AlwaysReferencedPhysMaterials;
    TArrayNoInit<FName> ChapterLevelNames;
    //## END PROPS GearTypes

    DECLARE_ABSTRACT_CLASS(UGearTypes,UObject,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UGearTypes)
};

class AAmbientShakeVolume : public AVolume
{
public:
    //## BEGIN PROPS AmbientShakeVolume
    struct FScreenShakeStruct AmbientShake;
    BITFIELD bEnableShake:1;
    //## END PROPS AmbientShakeVolume

    DECLARE_CLASS(AAmbientShakeVolume,AVolume,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AAmbientShakeVolume)
};

class AGearPawnBlockingVolume : public ABlockingVolume
{
public:
    //## BEGIN PROPS GearPawnBlockingVolume
    BITFIELD bBlockPlayers:1 GCC_BITFIELD_MAGIC;
    BITFIELD bBlockMonsters:1;
    //## END PROPS GearPawnBlockingVolume

    DECLARE_CLASS(AGearPawnBlockingVolume,ABlockingVolume,0,GearGame)
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
};

class AGrenadeBlockingVolume : public ABlockingVolume
{
public:
    //## BEGIN PROPS GrenadeBlockingVolume
    //## END PROPS GrenadeBlockingVolume

    DECLARE_CLASS(AGrenadeBlockingVolume,ABlockingVolume,0,GearGame)
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
};

struct CombatZone_eventRemoveResident_Parms
{
    class APawn* OldResident;
    CombatZone_eventRemoveResident_Parms(EEventParm)
    {
    }
};
struct CombatZone_eventAddResident_Parms
{
    class APawn* NewResident;
    CombatZone_eventAddResident_Parms(EEventParm)
    {
    }
};
struct CombatZone_eventRemoveOccupant_Parms
{
    class APawn* OldOccupant;
    CombatZone_eventRemoveOccupant_Parms(EEventParm)
    {
    }
};
struct CombatZone_eventAddOccupant_Parms
{
    class APawn* NewOccupant;
    CombatZone_eventAddOccupant_Parms(EEventParm)
    {
    }
};
class ACombatZone : public AVolume
{
public:
    //## BEGIN PROPS CombatZone
    FStringNoInit ZoneName;
    FGuid ZoneGuid;
    BYTE MaxOccupants;
    BYTE MaxResidents;
    BYTE DelayMovesForTeam;
    BYTE ZoneType;
    BYTE MovementModeOverride;
    TArrayNoInit<class APawn*> PendingOccupants;
    TArrayNoInit<class APawn*> Occupants_COG;
    TArrayNoInit<class APawn*> Occupants_Locust;
    TArrayNoInit<class APawn*> Residents_COG;
    TArrayNoInit<class APawn*> Residents_Locust;
    FLOAT Priority_COG;
    FLOAT Priority_Locust;
    BITFIELD bEnabled:1;
    BITFIELD bDelayMovesAtMaxOccupancy:1;
    TArrayNoInit<struct FActorReference> CoverSlotRefs;
    TArrayNoInit<struct FActorReference> MyNavRefs;
    class AFauxPathNode* NetworkNode;
    FVector ZoneCenter;
    TArrayNoInit<class AActor*> AmbushTargets;
    //## END PROPS CombatZone

    UBOOL IsValidZoneFor(class AGearAI* AI,UBOOL bResidenceQuery);
    UBOOL IsOccupant(class APawn* P);
    UBOOL IsResident(class APawn* P);
    virtual UBOOL CheckForMovementDelay(class AGearAI* AI);
    DECLARE_FUNCTION(execIsValidZoneFor)
    {
        P_GET_OBJECT(AGearAI,AI);
        P_GET_UBOOL(bResidenceQuery);
        P_FINISH;
        *(UBOOL*)Result=IsValidZoneFor(AI,bResidenceQuery);
    }
    DECLARE_FUNCTION(execIsOccupant)
    {
        P_GET_OBJECT(APawn,P);
        P_FINISH;
        *(UBOOL*)Result=IsOccupant(P);
    }
    DECLARE_FUNCTION(execIsResident)
    {
        P_GET_OBJECT(APawn,P);
        P_FINISH;
        *(UBOOL*)Result=IsResident(P);
    }
    DECLARE_FUNCTION(execCheckForMovementDelay)
    {
        P_GET_OBJECT(AGearAI,AI);
        P_FINISH;
        *(UBOOL*)Result=CheckForMovementDelay(AI);
    }
    void eventRemoveResident(class APawn* OldResident)
    {
        CombatZone_eventRemoveResident_Parms Parms(EC_EventParm);
        Parms.OldResident=OldResident;
        ProcessEvent(FindFunctionChecked(GEARGAME_RemoveResident),&Parms);
    }
    void eventAddResident(class APawn* NewResident)
    {
        CombatZone_eventAddResident_Parms Parms(EC_EventParm);
        Parms.NewResident=NewResident;
        ProcessEvent(FindFunctionChecked(GEARGAME_AddResident),&Parms);
    }
    void eventRemoveOccupant(class APawn* OldOccupant)
    {
        CombatZone_eventRemoveOccupant_Parms Parms(EC_EventParm);
        Parms.OldOccupant=OldOccupant;
        ProcessEvent(FindFunctionChecked(GEARGAME_RemoveOccupant),&Parms);
    }
    void eventAddOccupant(class APawn* NewOccupant)
    {
        CombatZone_eventAddOccupant_Parms Parms(EC_EventParm);
        Parms.NewOccupant=NewOccupant;
        ProcessEvent(FindFunctionChecked(GEARGAME_AddOccupant),&Parms);
    }
    DECLARE_CLASS(ACombatZone,AVolume,0,GearGame)
	static ACombatZone* GetCombatZoneForNavPoint( ANavigationPoint* Nav );
	static UBOOL IsNavWithin( ANavigationPoint* Nav, ACombatZone* CZ );

	UBOOL IsAdjacentZone( ACombatZone* OtherZone );

	void PostEditMove(UBOOL bFinished);
	void CheckForErrors();

	virtual void GetActorReferences( TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel );
	virtual FGuid* GetGuid();
};

class AGearNavModificationVolume : public AVolume
{
public:
    //## BEGIN PROPS GearNavModificationVolume
    BITFIELD bEnabled:1 GCC_BITFIELD_MAGIC;
    BITFIELD bInvalidateAICover:1;
    INT ExtraCost;
    TArrayNoInit<class ANavigationPoint*> AffectedPoints;
    //## END PROPS GearNavModificationVolume

    void UpdateAffectedNavPoints();
    DECLARE_FUNCTION(execUpdateAffectedNavPoints)
    {
        P_FINISH;
        UpdateAffectedNavPoints();
    }
    DECLARE_CLASS(AGearNavModificationVolume,AVolume,0,GearGame)
protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
};

class AWalkVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS WalkVolume
    BITFIELD bActive:1;
    //## END PROPS WalkVolume

    DECLARE_CLASS(AWalkVolume,APhysicsVolume,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AWalkVolume)
};

class AVolume_Nemacyst : public AVolume
{
public:
    //## BEGIN PROPS Volume_Nemacyst
    TArrayNoInit<class AVolume_Nemacyst*> Neighbors;
    //## END PROPS Volume_Nemacyst

    UBOOL FormationContainsPoint(FVector& Point);
    void FindNeighbors();
    DECLARE_FUNCTION(execFormationContainsPoint)
    {
        P_GET_STRUCT_REF(FVector,Point);
        P_FINISH;
        *(UBOOL*)Result=FormationContainsPoint(Point);
    }
    DECLARE_FUNCTION(execFindNeighbors)
    {
        P_FINISH;
        FindNeighbors();
    }
    DECLARE_CLASS(AVolume_Nemacyst,AVolume,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AVolume_Nemacyst)
};

class AGearSpectatorPoint : public ACameraActor
{
public:
    //## BEGIN PROPS GearSpectatorPoint
    FStringNoInit DisplayText;
    INT OrderIndex;
    FRotator UserRotationRange;
    FLOAT MaxRotationRate;
    //## END PROPS GearSpectatorPoint

    virtual FString RetrieveDisplayString(const FString& TagName);
    DECLARE_FUNCTION(execRetrieveDisplayString)
    {
        P_GET_STR(TagName);
        P_FINISH;
        *(FString*)Result=RetrieveDisplayString(TagName);
    }
    DECLARE_CLASS(AGearSpectatorPoint,ACameraActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearSpectatorPoint)
};

struct FDerrickWheel
{
    FLOAT WheelRadius;
    FName BoneName;
    FName SkelControlName;
    class USkelControlWheel* WheelControl;
    FMatrix WheelRefPoseTM;
    FLOAT FreeSpinningFrictionDecel;
    BITFIELD bHasContact:1;
    BITFIELD bHadContact:1;
    FVector LastContactPos;
    FLOAT RollVel;
    FRotator LastRot;
    FVector Location;
    FRotator Rotation;
    FLOAT WheelRoll;
    FVector WheelRayBaseOffset;
    INT FramesSinceLastTrace;
    FLOAT WheelDispPerFrameAdjust;

    /** Constructors */
    FDerrickWheel() {}
    FDerrickWheel(EEventParm)
    {
        appMemzero(this, sizeof(FDerrickWheel));
    }
};

class ACOG_DerrickWheelsBase : public AActor
{
public:
    //## BEGIN PROPS COG_DerrickWheelsBase
    class USkeletalMeshComponent* Mesh;
    class AInterpActor_COGDerrickBase* DerrickBody;
    class USkelControlLookAt* SteeringLookatControl;
    FName SteeringLookatControlName;
    FName SteeringPivotBoneName;
    FVector LastSteeringPivotLoc;
    FRotator LastLocalSteerRot;
    FLOAT SteerInterpSpeed;
    class UAudioComponent* EngineAudio_Player_Left;
    class USoundCue* EngineAudio_Player_LeftCue;
    class UAudioComponent* EngineAudio_Player_Right;
    class USoundCue* EngineAudio_Player_RightCue;
    class UAudioComponent* SuspensionAudio_Player_FrontRight;
    class USoundCue* SuspensionAudio_Player_FrontRightCue;
    class UAudioComponent* SuspensionAudio_Player_FrontLeft;
    class USoundCue* SuspensionAudio_Player_FrontLeftCue;
    FVector2D SuspensionAudioRandomTimeRange;
    FLOAT SuspensionAudioVelocityThreshold;
    class UAudioComponent* DerrickAudio_NonPlayer;
    class USoundCue* DerrickAudio_NonPlayerCue;
    TArrayNoInit<struct FDerrickWheel> Wheels;
    INT WheelTraceInterval;
    BITFIELD bForceUpdateWheelsNextTick:1;
    BITFIELD bHatchOpen:1;
    BITFIELD bCabinDoorOpen:1;
    BITFIELD bLeftArmPrepared:1;
    BITFIELD bLeftArmDeployed:1;
    BITFIELD bRightArmPrepared:1;
    BITFIELD bRightArmDeployed:1;
    BITFIELD bResetInterpolation:1;
    FLOAT MinDistFactorForUpdate;
    class UGearAnim_BlendList* HatchAnimControl;
    class UGearAnim_BlendList* CabinDoorAnimControl;
    class UGearAnim_BlendList* LeftArmAnimControl;
    class UGearAnim_BlendList* RightArmAnimControl;
    class USkeletalMeshComponent* LeftGrindLift;
    class UGearAnim_BlendList* LeftGrindLiftAnimControl;
    class USkeletalMeshComponent* RightGrindLift;
    class UGearAnim_BlendList* RightGrindLiftAnimControl;
    class USoundCue* HatchOpenCue;
    class USoundCue* HatchCloseCue;
    class USoundCue* CabinDoorOpenCue;
    class USoundCue* CabinDoorCloseCue;
    class USoundCue* ArmPrepareCue;
    class USoundCue* ArmDeployCue;
    class UAnimNodeBlend* JiggleAnimControl;
    FVector LastVelocity;
    FLOAT AccelJiggleScalar;
    FLOAT JiggleFadeTime;
    //## END PROPS COG_DerrickWheelsBase

    void CacheWheelRefPoseTMs();
    DECLARE_FUNCTION(execCacheWheelRefPoseTMs)
    {
        P_FINISH;
        CacheWheelRefPoseTMs();
    }
    DECLARE_CLASS(ACOG_DerrickWheelsBase,AActor,0,GearGame)
private:
	/** Internal.  Updates wheel positions/orientations, etc.  */
	void UpdateWheels(FLOAT DeltaTime);
	void UpdateSteering(FLOAT DeltaTime);

public:
	virtual void TickSpecial(FLOAT DeltaTime);
	virtual UBOOL InStasis();
	void UpdateEngineAudio(FLOAT EngineSpeed);
};

struct CoverLink_Dynamic_eventSlotIndexUpdated_Parms
{
    INT NewIndex;
    INT OldIndex;
    CoverLink_Dynamic_eventSlotIndexUpdated_Parms(EEventParm)
    {
    }
};
class ACoverLink_Dynamic : public ACoverLink
{
public:
    //## BEGIN PROPS CoverLink_Dynamic
    BITFIELD bSkipPathUpdate:1 GCC_BITFIELD_MAGIC;
    BITFIELD bAddToPathNetwork:1;
    BITFIELD bClearPaths:1;
    FVector LastStableLocation;
    //## END PROPS CoverLink_Dynamic

    virtual void UpdateCoverLink();
    virtual void UpdateCoverSlot(INT SlotIndex,UBOOL bUpdateOctree=FALSE,class AScout* InScout=NULL);
    DECLARE_FUNCTION(execUpdateCoverLink)
    {
        P_FINISH;
        UpdateCoverLink();
    }
    DECLARE_FUNCTION(execUpdateCoverSlot)
    {
        P_GET_INT(SlotIndex);
        P_GET_UBOOL_OPTX(bUpdateOctree,FALSE);
        P_GET_OBJECT_OPTX(AScout,InScout,NULL);
        P_FINISH;
        UpdateCoverSlot(SlotIndex,bUpdateOctree,InScout);
    }
    void eventSlotIndexUpdated(INT NewIndex,INT OldIndex)
    {
        CoverLink_Dynamic_eventSlotIndexUpdated_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        Parms.OldIndex=OldIndex;
        ProcessEvent(FindFunctionChecked(GEARGAME_SlotIndexUpdated),&Parms);
    }
    DECLARE_CLASS(ACoverLink_Dynamic,ACoverLink,0,GearGame)
	void FindBase()
	{
		// only update the base if it's null, to prevent clobbering attachment
		if (Base == NULL)
		{
			Super::FindBase();
		}
	}

	virtual UBOOL HasFireLinkTo( INT SlotIdx, FCoverInfo &ChkCover, UBOOL bAllowFallbackLinks = FALSE );

	virtual INT AddMyMarker(AActor *S);
	virtual void PostBeginPlay();

	UBOOL ConditionalLinkSlotMarkerTo(AScout* Scout, ACoverSlotMarker* Marker, ANavigationPoint* PtToLink);
};

class ACoverSlotMarker_Dynamic : public ACoverSlotMarker
{
public:
    //## BEGIN PROPS CoverSlotMarker_Dynamic
    //## END PROPS CoverSlotMarker_Dynamic

    virtual void InitializeDynamicMantleSpec(class UClass* SpecClass=UMantleReachSpec::StaticClass());
    virtual void SetMaxPathSize(FLOAT Radius,FLOAT Height);
    virtual void RefreshOctreePosition();
    DECLARE_FUNCTION(execInitializeDynamicMantleSpec)
    {
        P_GET_OBJECT_OPTX(UClass,SpecClass,UMantleReachSpec::StaticClass());
        P_FINISH;
        InitializeDynamicMantleSpec(SpecClass);
    }
    DECLARE_FUNCTION(execSetMaxPathSize)
    {
        P_GET_FLOAT(Radius);
        P_GET_FLOAT(Height);
        P_FINISH;
        SetMaxPathSize(Radius,Height);
    }
    DECLARE_FUNCTION(execRefreshOctreePosition)
    {
        P_FINISH;
        RefreshOctreePosition();
    }
    DECLARE_CLASS(ACoverSlotMarker_Dynamic,ACoverSlotMarker,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(ACoverSlotMarker_Dynamic)
};

class AFauxPathNode : public ANavigationPoint
{
public:
    //## BEGIN PROPS FauxPathNode
    //## END PROPS FauxPathNode

    DECLARE_CLASS(AFauxPathNode,ANavigationPoint,0,GearGame)
	// Only connections made through forced paths
	virtual UBOOL CanConnectTo(ANavigationPoint* Nav, UBOOL bCheckDistance) { return FALSE; }
	// No base needed, network is not connected to physical world
	virtual UBOOL ShouldBeBased() { return FALSE; }

	virtual void CheckForErrors() {}
};

class ALadderMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS LadderMarker
    class ATrigger_LadderInteraction* LadderTrigger;
    BITFIELD bIsTopOfLadder:1;
    //## END PROPS LadderMarker

    DECLARE_CLASS(ALadderMarker,ANavigationPoint,0,GearGame)
	virtual void addReachSpecs(AScout* Scout, UBOOL bOnlyChanged);
	virtual void AddForcedSpecs( AScout *Scout );
	virtual UBOOL CanConnectTo(ANavigationPoint* Nav, UBOOL bCheckDistance);
	virtual UClass* GetReachSpecClass( ANavigationPoint* Nav, UClass* ReachSpecClass );
	virtual UBOOL CanPrunePath(INT index);
};

class AGearAirPathNode : public APathNode
{
public:
    //## BEGIN PROPS GearAirPathNode
    //## END PROPS GearAirPathNode

    DECLARE_CLASS(AGearAirPathNode,APathNode,0,GearGame)
//	virtual void AddForcedSpecs( AScout *Scout );
	virtual void FindBase() {}
	virtual UBOOL CanConnectTo(ANavigationPoint* Dest, UBOOL bCheckDistance);
};

class AGearWallPathNode : public APathNode
{
public:
    //## BEGIN PROPS GearWallPathNode
    FLOAT MaxJumpDist;
    //## END PROPS GearWallPathNode

    DECLARE_CLASS(AGearWallPathNode,APathNode,0,GearGame)
	virtual void AddForcedSpecs( AScout *Scout );
	virtual void FindBase();
	virtual UBOOL CanConnectTo(ANavigationPoint* Dest, UBOOL bCheckDistance);
	virtual UBOOL GetUpDir( FVector &V )
	{
		V = -(Rotation.Vector());
		return 1;
	}

	UBOOL IsUsableAnchorFor(APawn* P);
};

class AJumpPoint : public APathNode
{
public:
    //## BEGIN PROPS JumpPoint
    TArrayNoInit<class ANavigationPoint*> JumpDest;
    //## END PROPS JumpPoint

    DECLARE_CLASS(AJumpPoint,APathNode,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AJumpPoint)
};

class AGearPickupFactory : public APickupFactory
{
public:
    //## BEGIN PROPS GearPickupFactory
    class ULightEnvironmentComponent* MyLightEnvironment;
    struct FActionInfo PickupAction;
    FCanvasIcon NoSymbolIcon;
    BITFIELD bDrawNoSymbolIfNeeded:1;
    class UMaterialInstanceConstant* MIC_WeaponSkin;
    class AActor* ClaimedBy;
    //## END PROPS GearPickupFactory

    DECLARE_ABSTRACT_CLASS(AGearPickupFactory,APickupFactory,0|CLASS_NativeReplication,GearGame)
	virtual void PostEditChange(UProperty *PropertyThatChanged);
	virtual void PostLoad();
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

struct FCheckpointEnumerationResult
{
    BYTE bCheckpointFileExists[3];
    BYTE bCheckpointFileContainsData[3];
    BYTE bCheckpointFileCorrupted[3];
    struct FCheckpointTime CheckpointTimestamp[3];
    BYTE CheckpointDifficulty[3];
    BYTE CheckpointChapter[3];

		FCheckpointEnumerationResult()
		{
			appMemzero(this, sizeof(FCheckpointEnumerationResult));
		}
		FCheckpointEnumerationResult(EEventParm)
		{
			appMemzero(this, sizeof(FCheckpointEnumerationResult));
		}
	
};

#define UCONST_TrainTutorials3 334
#define UCONST_TrainTutorials2 333
#define UCONST_TrainTutorials1 332
#define UCONST_MPTutorials3 331
#define UCONST_SPTutorials3 330
#define UCONST_NumTickerMelees 324
#define UCONST_NumActiveReloads 323
#define UCONST_HordeWavesBeat2 322
#define UCONST_HordeWavesBeat1 321
#define UCONST_NumRoundsWon 320
#define UCONST_NumKOTHWins 319
#define UCONST_NumLeaderWins 318
#define UCONST_NumMeatflagCaps 317
#define UCONST_NumWingmanWins 316
#define UCONST_NumFlameKills 315
#define UCONST_NumKillsWithBoomShield 314
#define UCONST_NumStickyKills 313
#define UCONST_NumMortarKills 312
#define UCONST_NumMulcherKills 311
#define UCONST_NumMeatshieldsUsed 310
#define UCONST_HardwareStatsUploaded 300
#define UCONST_WeapSwap_Shield 291
#define UCONST_WeapSwap_Boltok 290
#define UCONST_WeapSwap_Gorgon 289
#define UCONST_WeapSwap_HOD 288
#define UCONST_WeapSwap_Mortar 287
#define UCONST_WeapSwap_Mulcher 286
#define UCONST_WeapSwap_Bow 285
#define UCONST_WeapSwap_Sniper 284
#define UCONST_WeapSwap_Flame 283
#define UCONST_WeapSwap_Boomshot 282
#define UCONST_WeapSwap_InkGrenade 281
#define UCONST_WeapSwap_FragGrenade 280
#define UCONST_HordeWave 267
#define UCONST_HordeEnemyDiff 266
#define UCONST_WingmanScore 247
#define UCONST_MeatflagVictimDiff 226
#define UCONST_KOTHRoundScore 206
#define UCONST_AnnexRoundScore 186
#define UCONST_UNVIEWED_ACHIEVEMENT_MASK_B 143
#define UCONST_UNVIEWED_ACHIEVEMENT_MASK_A 142
#define UCONST_COMPLETED_ACHIEVEMENT_MASK_B 141
#define UCONST_COMPLETED_ACHIEVEMENT_MASK_A 140
#define UCONST_MPNumBots 126
#define UCONST_MPBotDiff 125
#define UCONST_MPRoundsToWin 124
#define UCONST_MPWeaponSwap 123
#define UCONST_MPBleedout 122
#define UCONST_MPRoundTime 121
#define UCONST_MPFriendlyFire 120
#define UCONST_CAMP_MODE 104
#define UCONST_VERSUS_SELECTED_MAP 103
#define UCONST_VERSUS_PARTY_TYPE 102
#define UCONST_VERSUS_MATCH_MODE 101
#define UCONST_VERSUS_GAMETYPE 100
#define UCONST_WeapTutorialsOn 97
#define UCONST_UnlockedChapterAccess2 96
#define UCONST_UnlockedChapterAccess1 95
#define UCONST_MPGameTypesCompleted 94
#define UCONST_PlayerSkill 93
#define UCONST_PREFERRED_SPLIT_TYPE 92
#define UCONST_PlaylistId 91
#define UCONST_NavigationNeedsViewed 90
#define UCONST_TrainingCompleted 89
#define UCONST_TrainingNeedsViewed 88
#define UCONST_TrainingAccess 87
#define UCONST_NumMartyrKills 86
#define UCONST_NumEnemiesKilled 85
#define UCONST_ExecutionsCompleted 84
#define UCONST_WeaponsKilledWith 83
#define UCONST_MPMapsCompleted 82
#define UCONST_NumChainsawDuelWins 81
#define UCONST_CoopCompletedChapters2 80
#define UCONST_CoopCompletedChapters1 79
#define UCONST_LastCheckpointSlot 78
#define UCONST_CampCheckpointUsage 77
#define UCONST_CoopInviteType 76
#define UCONST_UnlockableNeedsViewed 75
#define UCONST_UnlockedUnlockables 74
#define UCONST_UnlockedChaptersInsane2 73
#define UCONST_UnlockedChaptersInsane1 72
#define UCONST_UnlockedChaptersHard2 71
#define UCONST_UnlockedChaptersHard1 70
#define UCONST_UnlockedChaptersNormal2 69
#define UCONST_UnlockedChaptersNormal1 68
#define UCONST_UnlockedChaptersCasual2 67
#define UCONST_UnlockedChaptersCasual1 66
#define UCONST_MAP_SELECTION_MODE 65
#define UCONST_DiscoverNeedsViewed2 64
#define UCONST_DiscoverNeedsViewed1 63
#define UCONST_DiscoverFound2 62
#define UCONST_DiscoverFound1 61
#define UCONST_ZoomSensitivity 60
#define UCONST_TargetSensitivity 59
#define UCONST_TurnInversion 58
#define UCONST_MPTutorials2 57
#define UCONST_MPTutorials1 56
#define UCONST_SPTutorials2 55
#define UCONST_SPTutorials1 54
#define UCONST_TelevisionType 53
#define UCONST_SelectedDeviceID 52
#define UCONST_GearControlScheme 51
#define UCONST_DefaultMPWeapon 50
#define UCONST_GammaSetting 49
#define UCONST_PictogramTooltips 48
#define UCONST_GameIntensity 47
#define UCONST_Gore 46
#define UCONST_LocustMPCharacter 45
#define UCONST_CogMPCharacter 44
#define UCONST_DialogueVolume 43
#define UCONST_FxVolume 42
#define UCONST_MusicVolume 41
#define UCONST_Subtitles 40
#define UCONST_GearTriggerConfig 39
#define UCONST_GearStickConfig 38
#define UCONST_MatureLang 37
#define UCONST_HudOnOff 36
#define UCONST_ProfileMode 35
#define UCONST_DISCOVERABLE_COMPLETE 41
#define UCONST_DISCOVERABLE_PACKRAT 20
#define UCONST_DISCOVERABLE_TOURIST 5
#define UCONST_NumTickerMeleeRequirement 30
#define UCONST_NumActiveReloadsRequirement 30
#define UCONST_NumChaptersCompleteFor_Domination 10
#define UCONST_NumChaptersCompleteFor_DomCurious 1
#define UCONST_NumHordeWavesCompleted_AllAchieve 50
#define UCONST_NumHordeWavesCompleted_FirstAchieve 10
#define UCONST_NumRoundsRequirement 1999
#define UCONST_KOTHWinRequirement 3
#define UCONST_LeaderWinRequirement 10
#define UCONST_MeatflagCapRequirement 10
#define UCONST_WingmanMatchesRequirement 3
#define UCONST_FlameKillRequirement 30
#define UCONST_BoomShieldKillRequirement 10
#define UCONST_GrenadePlantKillRequirement 10
#define UCONST_MortarKillRequirement 30
#define UCONST_MulcherKillRequirement 30
#define UCONST_MeatshieldRequirement 10
#define UCONST_ChainsawDuelRequirement 10
#define UCONST_MartyrKillRequirement 10
#define UCONST_Seriously2KillRequirement 100000
#define UCONST_NUM_BITS_PER_INT 32
#define UCONST_MAX_VOLUME_VALUE 10.f

class UGearProfileSettings : public UOnlineProfileSettings
{
public:
    //## BEGIN PROPS GearProfileSettings
    TArrayNoInit<BYTE> ExcludedGameTypeIds;
    //## END PROPS GearProfileSettings

    virtual UBOOL GetProfileSettingMappings(INT ProfileSettingId,TArray<struct FIdToStringMapping>& Values);
    virtual UBOOL GetProfileSettingValueMappingIndex(INT ProfileSettingId,INT& ValueIndex);
    void RemoveExcludedGameTypes();
    DECLARE_FUNCTION(execGetProfileSettingMappings)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_TARRAY_REF(struct FIdToStringMapping,Values);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingMappings(ProfileSettingId,Values);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueMappingIndex)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(ValueIndex);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValueMappingIndex(ProfileSettingId,ValueIndex);
    }
    DECLARE_FUNCTION(execRemoveExcludedGameTypes)
    {
        P_FINISH;
        RemoveExcludedGameTypes();
    }
    DECLARE_CLASS(UGearProfileSettings,UOnlineProfileSettings,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

private:
	/**
	 * Sets all of the profile settings to their default values and then does
	 * a check for your language setting and swaps the subtitle setting based
	 * off of that.
	 */
    virtual void SetToDefaults();

public:
};

class AGearCrimsonOmenPickupFactoryBase : public AGearPickupFactory
{
public:
    //## BEGIN PROPS GearCrimsonOmenPickupFactoryBase
    class USoundCue* TagPickupSound;
    BYTE TagID;
    BITFIELD bInitialTagStateSet:1 GCC_BITFIELD_MAGIC;
    BITFIELD bVisible:1;
    BITFIELD bDidInitialReplication:1;
    //## END PROPS GearCrimsonOmenPickupFactoryBase

    DECLARE_ABSTRACT_CLASS(AGearCrimsonOmenPickupFactoryBase,AGearPickupFactory,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearCrimsonOmenPickupFactoryBase)
};

struct GearDiscoverablesPickupFactoryBase_eventNotifyLookedAt_Parms
{
    GearDiscoverablesPickupFactoryBase_eventNotifyLookedAt_Parms(EEventParm)
    {
    }
};
class AGearDiscoverablesPickupFactoryBase : public AGearPickupFactory
{
public:
    //## BEGIN PROPS GearDiscoverablesPickupFactoryBase
    BYTE DISC_DiscoverableType;
    BYTE DISC_PickupType;
    class USoundCue* DISC_PickupSound;
    class UStaticMeshComponent* DISC_MeshComponent;
    class UTexture2D* DISC_BackgroundTexture;
    class AHeadTrackTargetSpawnable* HeadTrackTarget;
    FLOAT GUDSHintRadius;
    BITFIELD bDidGUDSHint:1;
    //## END PROPS GearDiscoverablesPickupFactoryBase

    void eventNotifyLookedAt()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyLookedAt),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AGearDiscoverablesPickupFactoryBase,AGearPickupFactory,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearDiscoverablesPickupFactoryBase)
};

class AGearWeaponPickupFactory : public AGearPickupFactory
{
public:
    //## BEGIN PROPS GearWeaponPickupFactory
    class UClass* WeaponPickupClass;
    class UClass* OriginalPickupClass;
    class UClass* CachedMeshActorClass;
    class UClass* PlaceholderClass;
    struct FActionInfo CantPickupAction;
    TArrayNoInit<class UClass*> MPWeaponPickupList;
    BITFIELD bMP_ExcludeAnnex:1;
    BITFIELD bMP_ExcludeKOTH:1;
    BITFIELD bMP_ExcludeMeatflag:1;
    INT ExtraAmmoCount;
    FVector MeshTranslation;
    //## END PROPS GearWeaponPickupFactory

    DECLARE_CLASS(AGearWeaponPickupFactory,AGearPickupFactory,0,GearGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class AReaverLandingPoint : public ANavigationPoint
{
public:
    //## BEGIN PROPS ReaverLandingPoint
    //## END PROPS ReaverLandingPoint

    DECLARE_CLASS(AReaverLandingPoint,ANavigationPoint,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AReaverLandingPoint)
};

struct GearDroppedPickup_eventRedrop_Parms
{
    GearDroppedPickup_eventRedrop_Parms(EEventParm)
    {
    }
};
class AGearDroppedPickup : public ADroppedPickup
{
public:
    //## BEGIN PROPS GearDroppedPickup
    class AActor* ClaimedBy;
    class ULightEnvironmentComponent* MyLightEnvironment;
    struct FActionInfo PickupAction;
    class UMaterialInstanceConstant* MIC_WeaponSkin;
    FCanvasIcon NoSymbolIcon;
    FRigidBodyState RBState;
    FLOAT AngErrorAccumulator;
    BITFIELD bCollisionSoundsEnabled:1;
    BYTE DroppedEmissiveColorTeam GCC_BITFIELD_MAGIC;
    class UMeshComponent* MyMeshComp;
    //## END PROPS GearDroppedPickup

    void eventRedrop()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_Redrop),NULL);
    }
    DECLARE_CLASS(AGearDroppedPickup,ADroppedPickup,0|CLASS_NativeReplication,GearGame)
	// AActor interface
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

struct FTeamEncouragementData
{
    TArrayNoInit<class USoundCue*> COGSounds;
    TArrayNoInit<class USoundCue*> LocustSounds;

    /** Constructors */
    FTeamEncouragementData() {}
    FTeamEncouragementData(EEventParm)
    {
        appMemzero(this, sizeof(FTeamEncouragementData));
    }
};

struct FGearGoreEffectInfo
{
    class UParticleSystem* GibEffect;
    class UParticleSystem* HoleEfect;
    FLOAT EffectScale;
    class USoundCue* LoseGibSound;

    /** Constructors */
    FGearGoreEffectInfo() {}
    FGearGoreEffectInfo(EEventParm)
    {
        appMemzero(this, sizeof(FGearGoreEffectInfo));
    }
};

#define UCONST_STATS_LEVEL1 0x01
#define UCONST_LOCUST_TEAM_INDEX 1
#define UCONST_COG_TEAM_INDEX 0

struct GearGame_eventGoreSystemSpawnGibEffects_Parms
{
    class USkeletalMeshComponent* GibComponent;
    FName GibBoneName;
    FVector GibBoneLocation;
    FVector GibVel;
    FName GibParentBoneName;
    struct FGearGoreEffectInfo EffectInfo;
    UBOOL bSpawnGibEffect;
    GearGame_eventGoreSystemSpawnGibEffects_Parms(EEventParm)
    {
    }
};
struct GearGame_eventAIFactoryDisabled_Parms
{
    INT NumUnspawnedPawns;
    class USeqAct_AIFactory* AIFactory;
    GearGame_eventAIFactoryDisabled_Parms(EEventParm)
    {
    }
};
struct GearGame_eventSpawnFromAIFactoryHasDied_Parms
{
    class APawn* KilledSpawn;
    class USeqAct_AIFactory* AIFactory;
    GearGame_eventSpawnFromAIFactoryHasDied_Parms(EEventParm)
    {
    }
};
struct GearGame_eventTriggerGUDEvent_Parms
{
    BYTE Id;
    class APawn* InstigatedBy;
    class APawn* Recipient;
    FLOAT delay;
    GearGame_eventTriggerGUDEvent_Parms(EEventParm)
    {
    }
};
class AGearGame : public AGameInfo
{
public:
    //## BEGIN PROPS GearGame
    TArrayNoInit<FString> MapPrefixes;
    INT MinPlayers;
    INT MinRankedPlayers;
    BYTE NumTeams;
    BYTE AutoTutorialType;
    TArrayNoInit<class AGearTeamInfo*> Teams;
    class AGUDManager* UnscriptedDialogueManager;
    BITFIELD bAllowFriendlyFire:1;
    BITFIELD bDBNOForeverCheat:1;
    BITFIELD bInCoopSplit:1;
    BITFIELD bInSoloSplit:1;
    BITFIELD bIsDedicatedListenServer:1;
    BITFIELD bHostTamperedWithMatch:1;
    BITFIELD bInfiniteRoundDuration:1;
    BITFIELD bAllowTutorials:1;
    BITFIELD bSkipAllMatinees:1;
    BITFIELD bDoLocScreenShotTest:1;
    BITFIELD bDoAutomatedHordeTesting:1;
    BITFIELD bForceStats:1;
    BITFIELD bURLDifficultyOverride:1;
    BITFIELD bSkipForcedTeamCallHack:1;
    class ARemoteSpeaker_COGAnya* Anya;
    class ARemoteSpeaker_Generic* GenericRemoteSpeaker;
    class ABattleStatusMonitor* BattleMonitor;
    TArrayNoInit<class AGearSpectatorPoint*> SpectatorPoints;
    struct FTeamEncouragementData EncouragementData[7];
    class USoundCue* MarcusIsDownCue;
    class USoundCue* DomIsDownCue;
    TArrayNoInit<INT> NumTeamRespawns;
    INT TotalNumTeamRespawns;
    INT RespawnTimeInterval;
    FLOAT RespawnInvincibilityTimer;
    FLOAT WeaponFadeTimeGeneric;
    FLOAT WeaponFadeTimeSpecial;
    INT ChainsawDuelingTieMargin;
    class UAIVisibilityManager* AIVisMan;
    class UGearStatsObject* StatsObject;
    TArrayNoInit<class AGearDroppedPickup_Shield*> DeployedShields;
    TArrayNoInit<class UClass*> DifficultyLevels;
    //## END PROPS GearGame

    virtual void RegisterGameWithLive();
    virtual FString GetMapFilename();
    void LoadGameTypeConfigs(const FString& GameTypeExtension);
    DECLARE_FUNCTION(execRegisterGameWithLive)
    {
        P_FINISH;
        RegisterGameWithLive();
    }
    DECLARE_FUNCTION(execGetMapFilename)
    {
        P_FINISH;
        *(FString*)Result=GetMapFilename();
    }
    DECLARE_FUNCTION(execLoadGameTypeConfigs)
    {
        P_GET_STR(GameTypeExtension);
        P_FINISH;
        LoadGameTypeConfigs(GameTypeExtension);
    }
    void eventGoreSystemSpawnGibEffects(class USkeletalMeshComponent* GibComponent,FName GibBoneName,FVector GibBoneLocation,FVector GibVel,FName GibParentBoneName,struct FGearGoreEffectInfo EffectInfo,UBOOL bSpawnGibEffect)
    {
        GearGame_eventGoreSystemSpawnGibEffects_Parms Parms(EC_EventParm);
        Parms.GibComponent=GibComponent;
        Parms.GibBoneName=GibBoneName;
        Parms.GibBoneLocation=GibBoneLocation;
        Parms.GibVel=GibVel;
        Parms.GibParentBoneName=GibParentBoneName;
        Parms.EffectInfo=EffectInfo;
        Parms.bSpawnGibEffect=bSpawnGibEffect ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_GoreSystemSpawnGibEffects),&Parms);
    }
    void eventAIFactoryDisabled(INT NumUnspawnedPawns,class USeqAct_AIFactory* AIFactory)
    {
        GearGame_eventAIFactoryDisabled_Parms Parms(EC_EventParm);
        Parms.NumUnspawnedPawns=NumUnspawnedPawns;
        Parms.AIFactory=AIFactory;
        ProcessEvent(FindFunctionChecked(GEARGAME_AIFactoryDisabled),&Parms);
    }
    void eventSpawnFromAIFactoryHasDied(class APawn* KilledSpawn,class USeqAct_AIFactory* AIFactory)
    {
        GearGame_eventSpawnFromAIFactoryHasDied_Parms Parms(EC_EventParm);
        Parms.KilledSpawn=KilledSpawn;
        Parms.AIFactory=AIFactory;
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnFromAIFactoryHasDied),&Parms);
    }
    void eventTriggerGUDEvent(BYTE Id,class APawn* InstigatedBy,class APawn* Recipient=NULL,FLOAT delay=0)
    {
        GearGame_eventTriggerGUDEvent_Parms Parms(EC_EventParm);
        Parms.Id=Id;
        Parms.InstigatedBy=InstigatedBy;
        Parms.Recipient=Recipient;
        Parms.delay=delay;
        ProcessEvent(FindFunctionChecked(GEARGAME_TriggerGUDEvent),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AGearGame,AGameInfo,0|CLASS_Config,GearGame)
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
};

struct FPawnClassData
{
    class UClass* PawnClass;
    INT Count;

    /** Constructors */
    FPawnClassData() {}
    FPawnClassData(EEventParm)
    {
        appMemzero(this, sizeof(FPawnClassData));
    }
};

struct FWeaponLookupTableData
{
    BYTE WeapSwapType;
    INT ProfileId;
    class UClass* WeapClass;

    /** Constructors */
    FWeaponLookupTableData() {}
    FWeaponLookupTableData(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponLookupTableData));
    }
};

class AGearGameMP_Base : public AGearGame
{
public:
    //## BEGIN PROPS GearGameMP_Base
    class AGearGRI* GearGRI;
    INT AutoStartDelay;
    INT HostStartDelay;
    INT RoundDuration;
    INT EndOfRoundDelay;
    INT EndOfGameDelay;
    INT InitialRevivalTime;
    BITFIELD bFirstRound:1;
    BITFIELD bAutoReviveOnBleedOut:1;
    BITFIELD bCanBeShotFromAfarAndKilledWhileDownButNotOut:1;
    BITFIELD bDeadCanTalkToLiving:1;
    BITFIELD bIsPausedDueToCheatDetection:1;
    BITFIELD bIsSystemLink:1;
    BITFIELD bUsingWeaponSwap:1;
    BITFIELD bUsingWeaponCycle:1;
    BITFIELD bLastKillerSet:1;
    BITFIELD bTourist:1;
    BITFIELD bInDevMode:1;
    BITFIELD bQuickStart:1;
    BITFIELD bExecutionRules:1;
    BITFIELD bPlayersVsBots:1;
    BITFIELD bSupportsSuddenDeath:1;
    BITFIELD bIsInSuddenDeath:1;
    BITFIELD bCanGoSuddenDeathThisRound:1;
    BITFIELD bEliminatePlantedGrenades:1;
    BITFIELD bCanSwapBotsAndPlayers:1;
    FLOAT FirstPlayerJoinTime;
    class AController* LastKiller;
    class AController* LastVictim;
    TArrayNoInit<INT> TeamPlayerStartIndex;
    INT MaxPlayerStartTeamIndex;
    class UClass* GearPlayerStartClass;
    INT MaxDownCountOverride;
    FStringNoInit AIPostfix;
    FStringNoInit AIPrefix;
    FLOAT StandbyCheatTimer;
    TArrayNoInit<struct FPawnClassData> COGClasses;
    TArrayNoInit<struct FPawnClassData> LocustClasses;
    TArrayNoInit<struct FWeaponLookupTableData> WeaponLookupTable;
    INT RequestedBots;
    FLOAT WeaponDropRadiusCheckGeneric;
    FLOAT WeaponDropRadiusCheckSpecial;
    INT BotIndex;
    FLOAT LastDownOrKillTime;
    INT SuddenDeathTime;
    INT TrainingGroundsID;
    FStringNoInit TrainingGroundsSoundPath;
    INT MaxSquadSize;
    INT GameSettingsId;
    struct FUniqueNetId MeatflagId;
    INT PreviousPreferredWeaponIdx;
    FLOAT WaitForTravelingPlayersStart;
    FLOAT MaxWaitForTravelingPlayers;
    INT InitialPlayers;
    //## END PROPS GearGameMP_Base

    struct FUniqueNetId GetMeatflagUniqueId();
    DECLARE_FUNCTION(execGetMeatflagUniqueId)
    {
        P_FINISH;
        *(struct FUniqueNetId*)Result=GetMeatflagUniqueId();
    }
    DECLARE_ABSTRACT_CLASS(AGearGameMP_Base,AGearGame,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearGameMP_Base)
};

struct FAnnexMapInfo
{
    FStringNoInit MapName;
    TArrayNoInit<FName> PickupList;
    TArrayNoInit<FName> AvoidFirstList;

    /** Constructors */
    FAnnexMapInfo() {}
    FAnnexMapInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnnexMapInfo));
    }
};

struct FKOTHPlayerPointInfo
{
    class AGearPRI* PlayerPRI;
    FLOAT PointsEarned;

    /** Constructors */
    FKOTHPlayerPointInfo() {}
    FKOTHPlayerPointInfo(EEventParm)
    {
        appMemzero(this, sizeof(FKOTHPlayerPointInfo));
    }
};

class AGearGameAnnex_Base : public AGearGameMP_Base
{
public:
    //## BEGIN PROPS GearGameAnnex_Base
    FLOAT AwardUpdateTime;
    TArrayNoInit<class AGearWeaponPickupFactory*> FactoryList;
    TArrayNoInit<class AGearWeaponPickupFactory*> AvoidFirstList;
    TArrayNoInit<class AGearWeaponPickupFactory*> UsedList;
    class AGearWeaponPickupFactory* CommandPoint;
    class ASpawnedGearEmitter* CommandPointEffect;
    class UClass* CommandPointEffectClass;
    class AGearTeamInfo* CommandTeam;
    FLOAT CommandMeter;
    FLOAT CommandMeterMax;
    FLOAT MaxPointDist;
    FLOAT MaxPointDistZ;
    class AGearTeamInfo* LeadingTeam;
    INT LastCapturedByTeamIndex;
    INT NumAwardPoints;
    INT CommandPointResources;
    INT ResourceGoal;
    class USoundCue* AnnexSound_CommandPointChanged;
    class USoundCue* AnnexSound_CommandTeamChanged[2];
    class USoundCue* AnnexSound_CommandMeterMaxed[2];
    class USoundCue* AnnexSound_CommandMeterBroken[2];
    class USoundCue* AnnexSound_TeamLeadChanged[2];
    INT PointsPerCPTick;
    INT PointsPerCap;
    INT PointsPerBreak;
    INT TeamPointsPerKOTHTick;
    TArrayNoInit<class APlayerController*> JoinInProgressList;
    TArrayNoInit<struct FAnnexMapInfo> InfoList;
    BITFIELD bKingOfTheHillMode:1;
    TArrayNoInit<struct FKOTHPlayerPointInfo> KOTHPlayerPoints;
    //## END PROPS GearGameAnnex_Base

    DECLARE_ABSTRACT_CLASS(AGearGameAnnex_Base,AGearGameMP_Base,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearGameAnnex_Base)
};

class AGearGameCTM_Base : public AGearGameMP_Base
{
public:
    //## BEGIN PROPS GearGameCTM_Base
    FLOAT TimeForRecapture;
    FLOAT TimeForUpdateDestinationUI;
    FLOAT TimeToCapture;
    TArrayNoInit<class AMeatflagSpawnPoint*> VictimSpawnList;
    TArrayNoInit<class ANavigationPoint*> VictimNavList;
    class ANavigationPoint* DestinationPoint;
    class ASpawnedGearEmitter* DestinationEffect;
    class UClass* DestinationEffectClass;
    class AGearTeamInfo* ControllingTeam;
    FLOAT MaxPointDist;
    FLOAT MaxPointDistZ;
    FLOAT OptimalMaxDestinationDist;
    class AGearAI* VictimAI;
    class AGearPawn* KidnapperPawn;
    TArrayNoInit<class UClass*> MeatflagClasses;
    class UClass* CurrMeatflagClass;
    class AGearTeamInfo* VictimTeam;
    class UClass* VictimDefaultWeaponClass;
    class AGearPawn* LastKidnapperPawn;
    INT RoundGoal;
    BITFIELD bIsSuddenDeath:1;
    class USoundCue* Sound_ControllingTeamChanged[2];
    class USoundCue* Sound_VictimDropped[2];
    class USoundCue* Sound_DestinationExpired[2];
    TArrayNoInit<class APlayerController*> JoinInProgressList;
    class AGearTeamInfo* LeadingTeam;
    INT PointsPerCap;
    //## END PROPS GearGameCTM_Base

    class APlayerStart* GetClosestStartToDestination();
    DECLARE_FUNCTION(execGetClosestStartToDestination)
    {
        P_FINISH;
        *(class APlayerStart**)Result=GetClosestStartToDestination();
    }
    DECLARE_ABSTRACT_CLASS(AGearGameCTM_Base,AGearGameMP_Base,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearGameCTM_Base)
};

class AFlockTestLocust : public ACrowdAgent
{
public:
    //## BEGIN PROPS FlockTestLocust
    class USeqAct_FlockSpawner* FlockSpawner;
    FVector FireTarget;
    FLOAT FireTime;
    BITFIELD bFirePending:1;
    //## END PROPS FlockTestLocust

    DECLARE_CLASS(AFlockTestLocust,ACrowdAgent,0,GearGame)
	virtual void SpawnActionEffect(const FVector& ActionTarget);
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual void PlayWeaponFire();
};

struct DummyWeaponFireActor_eventNotifyShotFired_Parms
{
    class AActor* InOriginActor;
    class AActor* InTargetActor;
    DummyWeaponFireActor_eventNotifyShotFired_Parms(EEventParm)
    {
    }
};
class ADummyWeaponFireActor : public AActor
{
public:
    //## BEGIN PROPS DummyWeaponFireActor
    class USeqAct_DummyWeaponFire* FireAction;
    class AActor* OriginActor;
    class AActor* TargetActor;
    INT ShotCount;
    //## END PROPS DummyWeaponFireActor

    void eventNotifyShotFired(class AActor* InOriginActor,class AActor* InTargetActor)
    {
        DummyWeaponFireActor_eventNotifyShotFired_Parms Parms(EC_EventParm);
        Parms.InOriginActor=InOriginActor;
        Parms.InTargetActor=InTargetActor;
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyShotFired),&Parms);
    }
    DECLARE_CLASS(ADummyWeaponFireActor,AActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(ADummyWeaponFireActor)
};

class AInterpActor_GearBasePlatform : public AInterpActor
{
public:
    //## BEGIN PROPS InterpActor_GearBasePlatform
    TArrayNoInit<class ANavigationPoint*> AttachedNavList;
    TArrayNoInit<class AGearPawn*> AttachedPawnList;
    BITFIELD bClampedBaseEnabled:1;
    BITFIELD bAlwaysConfineToClampedBase:1;
    BITFIELD bDoComplexCameraCollision:1;
    BITFIELD bDisallowPawnMovement:1;
    INT DamageToNonClampedPawnOnCollision;
    class UClass* DamageTypeOnCollision;
    //## END PROPS InterpActor_GearBasePlatform

    virtual void FixBasedPawn(class AGearPawn* GP);
    virtual UBOOL IsStillOnClampedBase(class AGearPawn* GP,FVector PawnExtent);
    DECLARE_FUNCTION(execFixBasedPawn)
    {
        P_GET_OBJECT(AGearPawn,GP);
        P_FINISH;
        FixBasedPawn(GP);
    }
    DECLARE_FUNCTION(execIsStillOnClampedBase)
    {
        P_GET_OBJECT(AGearPawn,GP);
        P_GET_STRUCT(FVector,PawnExtent);
        P_FINISH;
        *(UBOOL*)Result=IsStillOnClampedBase(GP,PawnExtent);
    }
    DECLARE_CLASS(AInterpActor_GearBasePlatform,AInterpActor,0,GearGame)
	virtual UBOOL InStasis();
};

struct InterpActor_COGDerrickBase_eventSetupAudio_Parms
{
    UBOOL bDoingPlayerAudio;
    UBOOL bDoingNonPlayerAudio;
    class APawn* LocallyControlledPawn;
    InterpActor_COGDerrickBase_eventSetupAudio_Parms(EEventParm)
    {
    }
};
class AInterpActor_COGDerrickBase : public AInterpActor_GearBasePlatform
{
public:
    //## BEGIN PROPS InterpActor_COGDerrickBase
    class ACOG_DerrickWheelsBase* WheelActor;
    class UClass* WheelActorClass;
    class USkeletalMeshComponent* EditorWheelsPreviewMesh;
    BITFIELD bNoAudio:1;
    BITFIELD bPlayerAudioIsPlaying:1;
    BITFIELD bNonPlayerAudioIsPlaying:1;
    BITFIELD bEngineRunning:1;
    BITFIELD bNoGlass:1;
    BITFIELD bNoJiggle:1;
    BITFIELD bAlwaysUpdateWheels:1;
    BITFIELD bHatchOpened:1;
    BITFIELD bCabinOpened:1;
    FLOAT EngineRPM;
    FLOAT LastEngineRPM;
    FLOAT EngineRPMInterpSpeed;
    FVector2D EngineRPMAccelRange;
    FVector2D EngineRPMVelRange;
    FVector LastActualVelocity;
    class UAudioComponent* PlayerEngineMainLoop;
    class USoundCue* PlayerEngineMainLoopCue;
    class USoundCue* StopEngineSound;
    class USoundCue* StartEngineSound;
    class UStaticMeshComponent* GlassMesh;
    TArrayNoInit<FLinearColor> AvailableStripeColors;
    class UMaterialInstanceConstant* MIC_Stripe;
    BYTE StripeColor;
    //## END PROPS InterpActor_COGDerrickBase

    void eventSetupAudio(UBOOL bDoingPlayerAudio,UBOOL bDoingNonPlayerAudio,class APawn* LocallyControlledPawn)
    {
        InterpActor_COGDerrickBase_eventSetupAudio_Parms Parms(EC_EventParm);
        Parms.bDoingPlayerAudio=bDoingPlayerAudio ? FIRST_BITFIELD : FALSE;
        Parms.bDoingNonPlayerAudio=bDoingNonPlayerAudio ? FIRST_BITFIELD : FALSE;
        Parms.LocallyControlledPawn=LocallyControlledPawn;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetupAudio),&Parms);
    }
    DECLARE_CLASS(AInterpActor_COGDerrickBase,AInterpActor_GearBasePlatform,0,GearGame)
	virtual void TickSpecial(FLOAT DeltaTime);
	virtual void PostNetReceive();
};

class AInterpActor_LocustBargeBase : public AInterpActor_GearBasePlatform
{
public:
    //## BEGIN PROPS InterpActor_LocustBargeBase
    FLOAT RollPos;
    FLOAT RollAngVel;
    FLOAT PitchPos;
    FLOAT PitchAngVel;
    FLOAT RollStiffness;
    FLOAT RollDamping;
    FLOAT RollMaxAngle;
    FLOAT PitchStiffness;
    FLOAT PitchDamping;
    FLOAT PitchMaxAngle;
    FLOAT RandomTorqueStrength;
    FLOAT RandomTorqueChangeInterval;
    FLOAT CurrentRandomRollTorque;
    FLOAT CurrentRandomPitchTorque;
    FLOAT NextRandomTorqueChange;
    //## END PROPS InterpActor_LocustBargeBase

    void ProcessAddRocking(class USeqAct_BargeAddRocking* Action);
    DECLARE_FUNCTION(execProcessAddRocking)
    {
        P_GET_OBJECT(USeqAct_BargeAddRocking,Action);
        P_FINISH;
        ProcessAddRocking(Action);
    }
    DECLARE_ABSTRACT_CLASS(AInterpActor_LocustBargeBase,AInterpActor_GearBasePlatform,0,GearGame)
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual void AdjustInterpTrackMove(FVector& Pos, FRotator& Rot, FLOAT DeltaTime);
};

class AInterpActor_LocustTortureBargeBase : public AInterpActor_GearBasePlatform
{
public:
    //## BEGIN PROPS InterpActor_LocustTortureBargeBase
    //## END PROPS InterpActor_LocustTortureBargeBase

    DECLARE_ABSTRACT_CLASS(AInterpActor_LocustTortureBargeBase,AInterpActor_GearBasePlatform,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AInterpActor_LocustTortureBargeBase)
};

class AInterpActor_RaftBase : public AInterpActor_GearBasePlatform
{
public:
    //## BEGIN PROPS InterpActor_RaftBase
    class UStaticMeshComponent* EntrywayCollision;
    //## END PROPS InterpActor_RaftBase

    DECLARE_CLASS(AInterpActor_RaftBase,AInterpActor_GearBasePlatform,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AInterpActor_RaftBase)
};

class AInterpActor_Pushable : public AInterpActor
{
public:
    //## BEGIN PROPS InterpActor_Pushable
    FLOAT PushForce;
    FVector PushDirection;
    class USoundCue* PushSound;
    FLOAT MaxSpeed;
    //## END PROPS InterpActor_Pushable

    DECLARE_CLASS(AInterpActor_Pushable,AInterpActor,0,GearGame)
	virtual void physRigidBody(FLOAT DeltaTime);
};

struct FWeaponColorDatum
{
    BYTE Type;
    FLinearColor EmissiveCOG;
    FLinearColor EmissiveLocust;
    FColor MuzzleFlashLightColor;
    FColor MuzzleFlashLightColor_AR;
    FLOAT Weap_SpecMult;
    FLOAT Weap_DroppedGlow;
    FLOAT Weap_DropGlowAlpha;

    /** Constructors */
    FWeaponColorDatum() {}
    FWeaponColorDatum(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponColorDatum));
    }
};

struct FRimShaderDatum
{
    FLinearColor EmisMult;
    FLinearColor TeamColor;
    FLinearColor RimColor;

    /** Constructors */
    FRimShaderDatum() {}
    FRimShaderDatum(EEventParm)
    {
        appMemzero(this, sizeof(FRimShaderDatum));
    }
};

struct FVectorParam
{
    FName Name;
    FVector Value;

    /** Constructors */
    FVectorParam() {}
    FVectorParam(EEventParm)
    {
        appMemzero(this, sizeof(FVectorParam));
    }
};

struct FFloatParam
{
    FName Name;
    FLOAT Value;

    /** Constructors */
    FFloatParam() {}
    FFloatParam(EEventParm)
    {
        appMemzero(this, sizeof(FFloatParam));
    }
};

struct FEffectParam
{
    class UClass* DamageType;
    TArrayNoInit<struct FVectorParam> VectorParams;
    TArrayNoInit<struct FFloatParam> FloatParams;

    /** Constructors */
    FEffectParam() {}
    FEffectParam(EEventParm)
    {
        appMemzero(this, sizeof(FEffectParam));
    }
};

class UGearPerMapColorConfig : public UObject
{
public:
    //## BEGIN PROPS GearPerMapColorConfig
    struct FWeaponColorDatum DefaultWeaponColor;
    TArrayNoInit<struct FWeaponColorDatum> WeaponColors;
    struct FRimShaderDatum DefaultRimShaderCOG;
    struct FRimShaderDatum DefaultRimShaderLocust;
    TArrayNoInit<struct FRimShaderDatum> RimShaders;
    TArrayNoInit<struct FEffectParam> EffectParams;
    //## END PROPS GearPerMapColorConfig

    DECLARE_CLASS(UGearPerMapColorConfig,UObject,0,GearGame)
protected:
	void RefreshTypeData();

public:
	virtual void PostLoad();
	virtual void PostEditChange( class FEditPropertyChain& PropertyThatChanged );
};

class AEmit_CameraLensEffectBase : public AEmitterCameraLensEffectBase
{
public:
    //## BEGIN PROPS Emit_CameraLensEffectBase
    FLOAT DistFromCamera;
    class AGearPlayerCamera* Cam;
    BITFIELD bAllowMultipleInstances:1;
    //## END PROPS Emit_CameraLensEffectBase

    virtual void UpdateLocation(const FVector& CamLoc,const FRotator& CamRot,FLOAT CamFOVDeg);
    DECLARE_FUNCTION(execUpdateLocation)
    {
        P_GET_STRUCT_REF(FVector,CamLoc);
        P_GET_STRUCT_REF(FRotator,CamRot);
        P_GET_FLOAT(CamFOVDeg);
        P_FINISH;
        UpdateLocation(CamLoc,CamRot,CamFOVDeg);
    }
    DECLARE_ABSTRACT_CLASS(AEmit_CameraLensEffectBase,AEmitterCameraLensEffectBase,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

    NO_DEFAULT_CONSTRUCTOR(AEmit_CameraLensEffectBase)
};

class AGearEmitter : public AEmitter
{
public:
    //## BEGIN PROPS GearEmitter
    class USoundCue* Sound;
    class UParticleSystem* ParticleSystem;
    //## END PROPS GearEmitter

    DECLARE_CLASS(AGearEmitter,AEmitter,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearEmitter)
};

class ASpawnedGearEmitter : public AGearEmitter
{
public:
    //## BEGIN PROPS SpawnedGearEmitter
    //## END PROPS SpawnedGearEmitter

    DECLARE_CLASS(ASpawnedGearEmitter,AGearEmitter,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(ASpawnedGearEmitter)
};

class AGear_GrappleHookMarker : public AActor
{
public:
    //## BEGIN PROPS Gear_GrappleHookMarker
    FVector MarkerOffset;
    //## END PROPS Gear_GrappleHookMarker

    DECLARE_CLASS(AGear_GrappleHookMarker,AActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGear_GrappleHookMarker)
};

class AGearAimAssistActor : public AActor
{
public:
    //## BEGIN PROPS GearAimAssistActor
    FLOAT Radius;
    BITFIELD bEnabled:1;
    FLOAT FrictionScale;
    FLOAT AdhesionScale;
    FLOAT BulletMagnetScale;
    class UDrawSphereComponent* SphereRenderComponent;
    //## END PROPS GearAimAssistActor

    DECLARE_CLASS(AGearAimAssistActor,AActor,0,GearGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

struct FMaterialReplaceMod
{
    class UMaterialInterface* NewMaterial;
    INT MaterialIndex;

    /** Constructors */
    FMaterialReplaceMod() {}
    FMaterialReplaceMod(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialReplaceMod));
    }
};

struct FMaterialScalarParamMod
{
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLOAT ScalarVal;

    /** Constructors */
    FMaterialScalarParamMod() {}
    FMaterialScalarParamMod(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialScalarParamMod));
    }
};

struct FMaterialTexParamMod
{
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    class UTexture* NewTexture;

    /** Constructors */
    FMaterialTexParamMod() {}
    FMaterialTexParamMod(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialTexParamMod));
    }
};

struct FMaterialVectorParamMod
{
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLinearColor VectorVal;

    /** Constructors */
    FMaterialVectorParamMod() {}
    FMaterialVectorParamMod(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialVectorParamMod));
    }
};

struct FActorSpawnParams
{
    class UActorFactory* Factory;
    FVector RelativeOffset;
    FRotator RelativeRotation;
    FLOAT LifeTimeSeconds;

    /** Constructors */
    FActorSpawnParams() {}
    FActorSpawnParams(EEventParm)
    {
        appMemzero(this, sizeof(FActorSpawnParams));
    }
};

struct FSplashDamageParams
{
    FLOAT BaseDamage;
    FLOAT DamageRadius;
    class UClass* DamageType;
    FLOAT Momentum;

    /** Constructors */
    FSplashDamageParams() {}
    FSplashDamageParams(EEventParm)
    {
        appMemzero(this, sizeof(FSplashDamageParams));
    }
};

struct FDestroyedEffectParams
{
    class UParticleSystem* ParticleEffect;
    FVector RelativeOffset;
    FRotator RelativeRotation;

    /** Constructors */
    FDestroyedEffectParams() {}
    FDestroyedEffectParams(EEventParm)
    {
        appMemzero(this, sizeof(FDestroyedEffectParams));
    }
};

struct FObjDamageModifierDependency
{
    FName DependentSubObjName;
    FLOAT MaxHealthToAllow;
    INT DependentSubObjIdx;

    /** Constructors */
    FObjDamageModifierDependency() {}
    FObjDamageModifierDependency(EEventParm)
    {
        appMemzero(this, sizeof(FObjDamageModifierDependency));
    }
};

struct FCoverModParams
{
    INT AttachedCoverIndex;
    BITFIELD bDisableCoverLink:1;
    INT SlotIndex;
    BITFIELD bDisableSlot:1;
    BYTE NewCoverType GCC_BITFIELD_MAGIC;
    BITFIELD bUpdateCanMantle:1 GCC_BITFIELD_MAGIC;
    BITFIELD bUpdateCanCoverSlip_Left:1;
    BITFIELD bUpdateCanCoverSlip_Right:1;
    BITFIELD bUpdateCanSwatTurn_Left:1;
    BITFIELD bUpdateCanSwatTurn_Right:1;
    BITFIELD bUpdateAllowPopup:1;
    BITFIELD bUpdateLeanLeft:1;
    BITFIELD bUpdateLeanRight:1;
    BITFIELD bNewCanMantle:1;
    BITFIELD bNewCanCoverSlip_Left:1;
    BITFIELD bNewCanCoverSlip_Right:1;
    BITFIELD bNewCanSwatTurn_Left:1;
    BITFIELD bNewCanSwatTurn_Right:1;
    BITFIELD bNewAllowPopup:1;
    BITFIELD bNewLeanLeft:1;
    BITFIELD bNewLeanRight:1;

    /** Constructors */
    FCoverModParams() {}
    FCoverModParams(EEventParm)
    {
        appMemzero(this, sizeof(FCoverModParams));
    }
};

struct FObjectDamageModifier
{
    FName DamageModName;
    FLOAT HealthThreshold;
    class UStaticMesh* NewMesh;
    TArrayNoInit<struct FMaterialReplaceMod> MaterialReplacements;
    TArrayNoInit<struct FMaterialScalarParamMod> MaterialScalarParams;
    TArrayNoInit<struct FMaterialTexParamMod> MaterialTexParams;
    TArrayNoInit<struct FMaterialVectorParamMod> MaterialVectorParams;
    TArrayNoInit<class USoundCue*> Sounds;
    BITFIELD bSelfDestruct:1;
    BITFIELD bStopAmbientSound:1;
    TArrayNoInit<struct FDestroyedEffectParams> DestroyedEffects;
    BITFIELD bForceDisableAttachedCover:1;
    TArrayNoInit<struct FActorSpawnParams> ActorsToSpawn;
    struct FSplashDamageParams SplashDamage;
    TArrayNoInit<struct FObjDamageModifierDependency> DependentSubObjs;
    TArrayNoInit<struct FCoverModParams> CoverMods;
    BITFIELD bApplied:1;

    /** Constructors */
    FObjectDamageModifier() {}
    FObjectDamageModifier(EEventParm)
    {
        appMemzero(this, sizeof(FObjectDamageModifier));
    }
};

struct FDestructibleSubobject
{
    FName SubObjName;
    class UStaticMeshComponent* Mesh;
    TArrayNoInit<struct FObjectDamageModifier> DamageMods;
    FLOAT DefaultHealth;
    struct FObjectDamageModifier UndoMod;

    /** Constructors */
    FDestructibleSubobject() {}
    FDestructibleSubobject(EEventParm)
    {
        appMemzero(this, sizeof(FDestructibleSubobject));
    }
};

struct FReplicatedDamageModInfo
{
    BYTE ObjIdx;
    BYTE ModIdx;
    BITFIELD bPartial:1 GCC_BITFIELD_MAGIC;

    /** Constructors */
    FReplicatedDamageModInfo() {}
    FReplicatedDamageModInfo(EEventParm)
    {
        appMemzero(this, sizeof(FReplicatedDamageModInfo));
    }
};

struct GearDestructibleObject_eventTriggerDamageModAppliedEvent_Parms
{
    struct FDestructibleSubobject SubObj;
    struct FObjectDamageModifier Mod;
    UBOOL ReturnValue;
    GearDestructibleObject_eventTriggerDamageModAppliedEvent_Parms(EEventParm)
    : SubObj(EC_EventParm)
    , Mod(EC_EventParm)
    {
    }
};
struct GearDestructibleObject_eventApplySplashDamage_Parms
{
    FVector Origin;
    struct FSplashDamageParams DamageParams;
    GearDestructibleObject_eventApplySplashDamage_Parms(EEventParm)
    {
    }
};
struct GearDestructibleObject_eventReplicateDamageMod_Parms
{
    INT ObjIdx;
    INT ModIdx;
    UBOOL bPartial;
    GearDestructibleObject_eventReplicateDamageMod_Parms(EEventParm)
    {
    }
};
struct GearDestructibleObject_eventTriggerDestroyedEvent_Parms
{
    class AController* EventInstigator;
    GearDestructibleObject_eventTriggerDestroyedEvent_Parms(EEventParm)
    {
    }
};
struct GearDestructibleObject_eventUnShutDownObject_Parms
{
    GearDestructibleObject_eventUnShutDownObject_Parms(EEventParm)
    {
    }
};
struct GearDestructibleObject_eventShutDownSubObject_Parms
{
    struct FDestructibleSubobject SubObj;
    GearDestructibleObject_eventShutDownSubObject_Parms(EEventParm)
    : SubObj(EC_EventParm)
    {
    }
};
class AGearDestructibleObject : public AActor
{
public:
    //## BEGIN PROPS GearDestructibleObject
    BITFIELD bCanSpecialMeleeAttacked:1;
    BITFIELD bComponentsSetUp:1;
    BITFIELD bLimitDamageTypes:1;
    class USoundCue* AmbientSoundCue;
    class UAudioComponent* AmbientSoundComponent;
    TArrayNoInit<class UClass*> VulnerableToDamageType;
    class ULightEnvironmentComponent* LightEnvironment;
    class UDynamicLightEnvironmentComponent* LightEnvironmentToUseForActorSpawnParams;
    FLightingChannelContainer LightingChannelsToUseForActorSpawnParams;
    TArrayNoInit<struct FDestructibleSubobject> SubObjects;
    TArrayNoInit<FLOAT> SubObjectHealths;
    TArrayNoInit<FLOAT> TempDamageCache;
    class UParticleSystem* PS_ChainsawAttack;
    class USoundCue* ChainSawRipSound;
    TArrayNoInit<class ACoverLink*> AttachedCover;
    INT ResetCount;
    struct FReplicatedDamageModInfo ReplicatedDamageMods[32];
    BYTE ProcessedMods[32];
    //## END PROPS GearDestructibleObject

    virtual void UnDestroy();
    virtual void SetupComponents();
    virtual void SetSubObjectStaticMesh(const struct FDestructibleSubobject& SubObj,class UStaticMesh* SM);
    virtual void ApplyDamageMod(INT ObjIdx,INT ModIdx,UBOOL bPartial,class AController* DamageInstigator=NULL);
    virtual void RemoveDecals();
    virtual void OneTimeInit();
    virtual void DamageSubObject(INT ObjIdx,INT Damage,class AController* EventInstigator,class UClass* DamType);
    DECLARE_FUNCTION(execUnDestroy)
    {
        P_FINISH;
        UnDestroy();
    }
    DECLARE_FUNCTION(execSetupComponents)
    {
        P_FINISH;
        SetupComponents();
    }
    DECLARE_FUNCTION(execSetSubObjectStaticMesh)
    {
        P_GET_STRUCT_INIT_REF(struct FDestructibleSubobject,SubObj);
        P_GET_OBJECT(UStaticMesh,SM);
        P_FINISH;
        SetSubObjectStaticMesh(SubObj,SM);
    }
    DECLARE_FUNCTION(execApplyDamageMod)
    {
        P_GET_INT(ObjIdx);
        P_GET_INT(ModIdx);
        P_GET_UBOOL(bPartial);
        P_GET_OBJECT_OPTX(AController,DamageInstigator,NULL);
        P_FINISH;
        ApplyDamageMod(ObjIdx,ModIdx,bPartial,DamageInstigator);
    }
    DECLARE_FUNCTION(execRemoveDecals)
    {
        P_FINISH;
        RemoveDecals();
    }
    DECLARE_FUNCTION(execOneTimeInit)
    {
        P_FINISH;
        OneTimeInit();
    }
    DECLARE_FUNCTION(execDamageSubObject)
    {
        P_GET_INT(ObjIdx);
        P_GET_INT(Damage);
        P_GET_OBJECT(AController,EventInstigator);
        P_GET_OBJECT(UClass,DamType);
        P_FINISH;
        DamageSubObject(ObjIdx,Damage,EventInstigator,DamType);
    }
    UBOOL eventTriggerDamageModAppliedEvent(const struct FDestructibleSubobject& SubObj,const struct FObjectDamageModifier& Mod)
    {
        GearDestructibleObject_eventTriggerDamageModAppliedEvent_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SubObj=SubObj;
        Parms.Mod=Mod;
        ProcessEvent(FindFunctionChecked(GEARGAME_TriggerDamageModAppliedEvent),&Parms);
        return Parms.ReturnValue;
    }
    void eventApplySplashDamage(const FVector& Origin,const struct FSplashDamageParams& DamageParams)
    {
        GearDestructibleObject_eventApplySplashDamage_Parms Parms(EC_EventParm);
        Parms.Origin=Origin;
        Parms.DamageParams=DamageParams;
        ProcessEvent(FindFunctionChecked(GEARGAME_ApplySplashDamage),&Parms);
    }
    void eventReplicateDamageMod(INT ObjIdx,INT ModIdx,UBOOL bPartial)
    {
        GearDestructibleObject_eventReplicateDamageMod_Parms Parms(EC_EventParm);
        Parms.ObjIdx=ObjIdx;
        Parms.ModIdx=ModIdx;
        Parms.bPartial=bPartial ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_ReplicateDamageMod),&Parms);
    }
    void eventTriggerDestroyedEvent(class AController* EventInstigator)
    {
        GearDestructibleObject_eventTriggerDestroyedEvent_Parms Parms(EC_EventParm);
        Parms.EventInstigator=EventInstigator;
        ProcessEvent(FindFunctionChecked(GEARGAME_TriggerDestroyedEvent),&Parms);
    }
    void eventUnShutDownObject()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_UnShutDownObject),NULL);
    }
    void eventShutDownSubObject(const struct FDestructibleSubobject& SubObj)
    {
        GearDestructibleObject_eventShutDownSubObject_Parms Parms(EC_EventParm);
        Parms.SubObj=SubObj;
        ProcessEvent(FindFunctionChecked(GEARGAME_ShutDownSubObject),&Parms);
    }
    DECLARE_CLASS(AGearDestructibleObject,AActor,0,GearGame)
private:
	void SetupHealthVars();
	void GenerateUndo();
	void GenerateSubObjUndo(FDestructibleSubobject* SubObj);
	void ApplyDamageModInternal(FDestructibleSubobject* SubObj, FObjectDamageModifier* Mod, UBOOL bPartial, class AController* DamageInstigator);
public:
	void PostLoad();
	void PostEditChange(UProperty* PropertyThatChanged);

    /* Overridden to setup collision for damage meshes that will eventually exist*/
	virtual void InitRBPhys();

	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);

	/**
	* Used by the cooker to pre cache the convex data for static meshes within a given actor.
	* Overloaded to account for the damage meshes that replace the original static mesh
	* This data is stored with the level.
	* @param Level - The level the cache is in
	* @param TriByteCount - running total of memory usage for per-tri collision cache
	* @param TriMeshCount - running count of per-tri collision cache
	* @param HullByteCount - running total of memory usage for hull cache
	* @param HullCount - running count of hull cache
	*/
	virtual void BuildPhysStaticMeshCache(ULevel* Level,
										  INT& TriByteCount, INT& TriMeshCount, INT& HullByteCount, INT& HullCount);

	/**
	* Function that gets called from within Map_Check to allow this actor to check itself
	* for any potential errors and register them with map check dialog.
	*/
	virtual void CheckForErrors();
};

struct FKActorCacheDatum
{
    INT ListIdx;
    class AKActorSpawnable* List[20];

    /** Constructors */
    FKActorCacheDatum() {}
    FKActorCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FKActorCacheDatum));
    }
};

struct FTracerCacheDatum
{
    INT Type;
    class UClass* TracerClass;
    INT ListIdx;
    class AGearProj_BulletTracer* List[20];

    /** Constructors */
    FTracerCacheDatum() {}
    FTracerCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FTracerCacheDatum));
    }
};

struct FEmitterCacheDatum
{
    INT Type;
    INT SizeOfList;
    class UParticleSystem* ParticleSystemType;
    INT ListIdx;
    class UParticleSystemComponent* PList[20];
    class AEmitter* List[20];

    /** Constructors */
    FEmitterCacheDatum() {}
    FEmitterCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FEmitterCacheDatum));
    }
};

struct FDecalDatum
{
    class UGearDecal* GD;
    FLOAT SpawnTime;
    FVector SpawnLoc;
    FLOAT CanSpawnDistance;

    /** Constructors */
    FDecalDatum() {}
    FDecalDatum(EEventParm)
    {
        appMemzero(this, sizeof(FDecalDatum));
    }
};

struct FDecalPool
{
    INT MAX_DECALS;
    INT MAX_DECALS_bDropDetail;
    INT MAX_DECALS_bAggressiveLOD;
    TArrayNoInit<struct FDecalDatum> Decals;
    INT DecalsIdx;

    /** Constructors */
    FDecalPool() {}
    FDecalPool(EEventParm)
    {
        appMemzero(this, sizeof(FDecalPool));
    }
};

struct FPathConstraintCacheDatum
{
    INT ListIdx;
    class UPathConstraint* List[3];

    /** Constructors */
    FPathConstraintCacheDatum() {}
    FPathConstraintCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FPathConstraintCacheDatum));
    }
};

#define UCONST_MAX_GOALEVALUATORS 10
#define UCONST_MAX_INSTANCES_PER_CLASS 3
#define UCONST_NUM_CONSTAINT_CLASSES 15
#define UCONST_MAX_HAILIMPACT_EMITTERS 20
#define UCONST_MAX_RAINDROP_EMITTERS 20
#define UCONST_MAX_IMPACT_PARTICLE_SYSTEMS_SMALL 10
#define UCONST_MAX_IMPACT_PARTICLE_SYSTEMS 20
#define UCONST_MAX_IMPACT_EMITTERS_SMALL 10
#define UCONST_MAX_IMPACT_EMITTERS 20
#define UCONST_MAX_TRACERS 20
#define UCONST_MAX_KACTORS 20

class AGearObjectPool : public AActor
{
public:
    //## BEGIN PROPS GearObjectPool
    struct FKActorCacheDatum KActorCache;
    TArrayNoInit<class UStaticMesh*> CachedStaticMeshes;
    struct FTracerCacheDatum TracerCache[8];
    TArrayNoInit<struct FEmitterCacheDatum> EmitterCache;
    class AEmitter* RainDropSelfEmitterList[20];
    INT RainDropSelfEmitterListIdx;
    class AEmitter* HailImpactPawnEmitterList[20];
    INT HailImpactPawnEmitterListIdx;
    class UMaterial* BulletMaterial;
    class UMaterialInstanceConstant* MIC_COG_Default;
    class UMaterialInstanceConstant* MIC_COG_ARTierOne;
    class UMaterialInstanceConstant* MIC_COG_ARTierTwo;
    class UMaterialInstanceConstant* MIC_COG_ARTierThree;
    class UMaterialInstanceConstant* MIC_LOCUST_Default;
    class UMaterialInstanceConstant* MIC_LOCUST_ARTierOne;
    class UMaterialInstanceConstant* MIC_LOCUST_ARTierTwo;
    class UMaterialInstanceConstant* MIC_LOCUST_ARTierThree;
    struct FDecalPool DecalPool_Blood;
    struct FDecalPool DecalPool_Bullet;
    struct FDecalPool DecalPool_Explosion;
    TArrayNoInit<struct FPathConstraintCacheDatum> PathConstraintCache;
    TArrayNoInit<class UPathGoalEvaluator*> PathGoalEvaluatorCache;
    //## END PROPS GearObjectPool

    UBOOL IsSafeToRecreatePools();
    class UGearDecal* GetDecal_Worker(INT& CurrIdx,const struct FDecalPool& TheDecalPool,TArray<struct FDecalDatum>& DecalList,const FVector& SpawnLocation);
    DECLARE_FUNCTION(execIsSafeToRecreatePools)
    {
        P_FINISH;
        *(UBOOL*)Result=IsSafeToRecreatePools();
    }
    DECLARE_FUNCTION(execGetDecal_Worker)
    {
        P_GET_INT_REF(CurrIdx);
        P_GET_STRUCT_INIT_REF(struct FDecalPool,TheDecalPool);
        P_GET_TARRAY_REF(struct FDecalDatum,DecalList);
        P_GET_STRUCT_REF(FVector,SpawnLocation);
        P_FINISH;
        *(class UGearDecal**)Result=GetDecal_Worker(CurrIdx,TheDecalPool,DecalList,SpawnLocation);
    }
    DECLARE_CLASS(AGearObjectPool,AActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearObjectPool)
};

struct FSpawnerSlot
{
    BITFIELD bEnabled:1;
    class AGearPawn* SpawningPawn;
    FVector LocationOffset;
    FRotator RotationOffset;
    BYTE EmergeAnim;

    /** Constructors */
    FSpawnerSlot() {}
    FSpawnerSlot(EEventParm)
    {
        appMemzero(this, sizeof(FSpawnerSlot));
    }
};

struct GearSpawner_eventUnRegisterFactory_Parms
{
    class USeqAct_AIFactory* Factory;
    GearSpawner_eventUnRegisterFactory_Parms(EEventParm)
    {
    }
};
struct GearSpawner_eventRegisterFactory_Parms
{
    class USeqAct_AIFactory* Factory;
    GearSpawner_eventRegisterFactory_Parms(EEventParm)
    {
    }
};
struct GearSpawner_eventGetSpawnSlot_Parms
{
    INT out_SpawnSlotIdx;
    FVector out_SpawnLocation;
    FRotator out_SpawnRotation;
    UBOOL ReturnValue;
    GearSpawner_eventGetSpawnSlot_Parms(EEventParm)
    {
    }
};
struct GearSpawner_eventHandleSpawn_Parms
{
    class AGearPawn* NewSpawn;
    INT SlotIdx;
    GearSpawner_eventHandleSpawn_Parms(EEventParm)
    {
    }
};
class AGearSpawner : public AActor
{
public:
    //## BEGIN PROPS GearSpawner
    BITFIELD bActive:1;
    BITFIELD bAutoDeActivate:1;
    TArrayNoInit<class USeqAct_AIFactory*> Factories;
    TArrayNoInit<struct FSpawnerSlot> SpawnSlots;
    class AActor* Killer;
    //## END PROPS GearSpawner

    void eventUnRegisterFactory(class USeqAct_AIFactory* Factory)
    {
        GearSpawner_eventUnRegisterFactory_Parms Parms(EC_EventParm);
        Parms.Factory=Factory;
        ProcessEvent(FindFunctionChecked(GEARGAME_UnRegisterFactory),&Parms);
    }
    void eventRegisterFactory(class USeqAct_AIFactory* Factory)
    {
        GearSpawner_eventRegisterFactory_Parms Parms(EC_EventParm);
        Parms.Factory=Factory;
        ProcessEvent(FindFunctionChecked(GEARGAME_RegisterFactory),&Parms);
    }
    UBOOL eventGetSpawnSlot(INT& out_SpawnSlotIdx,FVector& out_SpawnLocation,FRotator& out_SpawnRotation)
    {
        GearSpawner_eventGetSpawnSlot_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.out_SpawnSlotIdx=out_SpawnSlotIdx;
        Parms.out_SpawnLocation=out_SpawnLocation;
        Parms.out_SpawnRotation=out_SpawnRotation;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetSpawnSlot),&Parms);
        out_SpawnSlotIdx=Parms.out_SpawnSlotIdx;
        out_SpawnLocation=Parms.out_SpawnLocation;
        out_SpawnRotation=Parms.out_SpawnRotation;
        return Parms.ReturnValue;
    }
    void eventHandleSpawn(class AGearPawn* NewSpawn,INT SlotIdx)
    {
        GearSpawner_eventHandleSpawn_Parms Parms(EC_EventParm);
        Parms.NewSpawn=NewSpawn;
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(GEARGAME_HandleSpawn),&Parms);
    }
    DECLARE_CLASS(AGearSpawner,AActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearSpawner)
};

class AGearScout : public AScout
{
public:
    //## BEGIN PROPS GearScout
    //## END PROPS GearScout

    DECLARE_CLASS(AGearScout,AScout,0|CLASS_Transient|CLASS_Config,GearGame)
	virtual void InitForPathing( ANavigationPoint* Start, ANavigationPoint* End );
	virtual UClass* GetDefaultReachSpecClass();
	virtual FVector GetSize(FName desc);
	virtual FVector GetDefaultForcedPathSize(UReachSpec* Spec);
	virtual void SetPathColor(UReachSpec* ReachSpec);
	virtual void Exec( const TCHAR* Str );
	virtual void BuildCombatZones( UBOOL bFromDefinePaths = FALSE );
	virtual void AddSpecialPaths( INT NumPaths, UBOOL bOnlyChanged );
	UBOOL CreateLeapPath( ANavigationPoint* Nav, ANavigationPoint* DestNav, FCheckResult Hit, UBOOL bOnlyChanged );
	virtual INT PrunePathsForNav(ANavigationPoint* Nav);
	// called after PrunePathsForNav is called on all pathnodes 
	virtual INT SecondPassPrunePathsForNav(ANavigationPoint* Nav);

};

struct FsPointOfView
{
    FVector DirOffset;
    FLOAT Distance;
    FLOAT fZAdjust;

    /** Constructors */
    FsPointOfView() {}
    FsPointOfView(EEventParm)
    {
        appMemzero(this, sizeof(FsPointOfView));
    }
};

struct Turret_eventGetPhysicalFireStartLoc_Parms
{
    FVector FireOffset;
    FVector ReturnValue;
    Turret_eventGetPhysicalFireStartLoc_Parms(EEventParm)
    {
    }
};
struct Turret_eventGetDriverIdealRotation_Parms
{
    FRotator ReturnValue;
    Turret_eventGetDriverIdealRotation_Parms(EEventParm)
    {
    }
};
struct Turret_eventGetDriverIdealPosition_Parms
{
    FVector ReturnValue;
    Turret_eventGetDriverIdealPosition_Parms(EEventParm)
    {
    }
};
class ATurret : public AVehicle
{
public:
    //## BEGIN PROPS Turret
    class AController* Claim;
    TArrayNoInit<class UClass*> DefaultInventory;
    FRotator AimDir;
    FRotator DesiredAimDir;
    FVector2D YawLimit;
    FLOAT TurretTurnRateScale;
    FLOAT AimingTurretTurnRateScale;
    FVector CannonFireOffset;
    FName PitchBone;
    FName BaseBone;
    FVector EntryPosition;
    BITFIELD bRelativeExitPos:1;
    BITFIELD bUnableToLeave:1;
    BITFIELD bSpottedSomething:1;
    BITFIELD bDebugTurret:1;
    struct FsPointOfView POV;
    struct FActionInfo InteractAction;
    class AWeapon* MyWeapon;
    FName LeftHandBoneHandleName;
    FName RightHandBoneHandleName;
    FLOAT InitialEntryZOffset;
    //## END PROPS Turret

    virtual void UpdateDriver(FLOAT DeltaTime);
    virtual FVector GetPhysicalFireStartLoc(FVector FireOffset);
    virtual FVector GetPawnViewLocation();
    virtual FRotator GetTurretAimDir();
    DECLARE_FUNCTION(execUpdateDriver)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateDriver(DeltaTime);
    }
    DECLARE_FUNCTION(execGetPhysicalFireStartLoc)
    {
        P_GET_STRUCT(FVector,FireOffset);
        P_FINISH;
        *(FVector*)Result=GetPhysicalFireStartLoc(FireOffset);
    }
    DECLARE_FUNCTION(execGetTurretAimDir)
    {
        P_FINISH;
        *(FRotator*)Result=GetTurretAimDir();
    }
    FVector eventGetPhysicalFireStartLoc(FVector FireOffset)
    {
        Turret_eventGetPhysicalFireStartLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.FireOffset=FireOffset;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetPhysicalFireStartLoc),&Parms);
        return Parms.ReturnValue;
    }
    FRotator eventGetDriverIdealRotation()
    {
        Turret_eventGetDriverIdealRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDriverIdealRotation),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetDriverIdealPosition()
    {
        Turret_eventGetDriverIdealPosition_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDriverIdealPosition),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(ATurret,AVehicle,0|CLASS_Config,GearGame)
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
};

class AGearTurret : public ATurret
{
public:
    //## BEGIN PROPS GearTurret
    FVector CameraViewOffsetHigh;
    FVector CameraViewOffsetMid;
    FVector CameraViewOffsetLow;
    BITFIELD bAllowTargetingCamera:1;
    BITFIELD bRotationalMomentum:1;
    BITFIELD bEnforceHardAttach:1;
    BITFIELD bMovingToEnforceHardAttach:1;
    FVector CameraTargetingViewOffsetHigh;
    FVector CameraTargetingViewOffsetMid;
    FVector CameraTargetingViewOffsetLow;
    FLOAT CameraFOV;
    FLOAT CameraTargetingFOV;
    FName WorstCamLocSocketName;
    FVector ViewRotVel;
    FLOAT ViewRotInterpSpeed;
    FMatrix LastBaseTM;
    class UDynamicLightEnvironmentComponent* MyLightEnvironment;
    //## END PROPS GearTurret

    virtual void UpdateForMovingBase(class AActor* BaseActor);
    DECLARE_FUNCTION(execUpdateForMovingBase)
    {
        P_GET_OBJECT(AActor,BaseActor);
        P_FINISH;
        UpdateForMovingBase(BaseActor);
    }
    DECLARE_ABSTRACT_CLASS(AGearTurret,ATurret,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Pawn");}

	virtual void PostBeginPlay();
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
	virtual UBOOL ShouldDriverBeValidTargetFor( const APawn* Other) const
	{
		return TRUE;
	}
};

class ATurret_TroikaBase : public AGearTurret
{
public:
    //## BEGIN PROPS Turret_TroikaBase
    class AGearPawn* Spotter;
    class AGearPawn* Loader;
    FRotator TurretControlRot;
    FLOAT TrackSpeed;
    FLOAT TrackSpeedWithSpotter;
    FLOAT SearchSpeed;
    FLOAT TooCloseDist;
    FVector SpottedLoc;
    FVector DesiredSpottedLoc;
    class USkelControlLookAt* Pivot_Latitude;
    class USkelControlLookAt* Pivot_Longitude;
    FName Pivot_Latitude_BoneName;
    FName MuzzleSocketName;
    FName PlayerRefSocketName;
    class UAnimNodeSequence* SpinSeqNode;
    FLOAT EntryRadius;
    //## END PROPS Turret_TroikaBase

    virtual FVector GetPhysicalFireStartLoc(FVector FireOffset);
    virtual FRotator GetViewRotation();
    DECLARE_CLASS(ATurret_TroikaBase,AGearTurret,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(ATurret_TroikaBase)
};

struct FTimedParticleStruct
{
    FLOAT Time;
    class UParticleSystemComponent* ParticleSystem;

    /** Constructors */
    FTimedParticleStruct() {}
    FTimedParticleStruct(EEventParm)
    {
        appMemzero(this, sizeof(FTimedParticleStruct));
    }
};

struct FTimedDelegate
{
    FScriptDelegate Delegate;
    FLOAT Time;

    /** Constructors */
    FTimedDelegate() {}
    FTimedDelegate(EEventParm)
    {
        appMemzero(this, sizeof(FTimedDelegate));
    }
};

#define UCONST_OpenReminderFrequencySec 15.f

struct GearSpawner_EmergenceHoleBase_eventTemplateDelegate_Parms
{
    GearSpawner_EmergenceHoleBase_eventTemplateDelegate_Parms(EEventParm)
    {
    }
};
class AGearSpawner_EmergenceHoleBase : public AGearSpawner
{
public:
    //## BEGIN PROPS GearSpawner_EmergenceHoleBase
    class UGearExplosion* ExplosionTemplate;
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    BITFIELD bForceDirectLightMap:1;
    BITFIELD bOverrideLightMapResolution:1;
    BITFIELD bFastOpen:1;
    BITFIELD bStartOpen:1;
    BITFIELD bIgnoreDamage:1;
    BITFIELD bDisableImulsionLight:1;
    BITFIELD bDoReminders:1;
    BITFIELD bSpawnPOI:1;
    FLightingChannelContainer LightingChannels;
    INT OverriddenLightMapResolution;
    class UStaticMeshComponent* StaticMesh;
    class UStaticMeshComponent* FogMesh;
    class UCylinderComponent* CorkCylinder;
    class USkeletalMeshComponent* Mesh;
    FVector MeshTranslationAmount;
    FLOAT MeshTranslationStartTime;
    FLOAT MeshTranslationEndTime;
    class UStaticMeshComponent* BrokenMesh;
    class UStaticMeshComponent* CoverMesh;
    class UStaticMeshComponent* BaseMesh;
    TArrayNoInit<class UStaticMeshComponent*> RubbleMeshes;
    FName OpenAnimationName;
    struct FScreenShakeStruct FirstShake;
    struct FScreenShakeStruct SecondShake;
    TArrayNoInit<struct FSoundTrackKey> OpenSounds;
    class UMaterialInstanceConstant* MatInst;
    FInterpCurveFloat RampInterpCurve;
    FLOAT RampStartTime;
    FLOAT RampEndTime;
    class UTexture2D* SourceTexture;
    class UMaterialInterface* SourceMaterial;
    TArrayNoInit<struct FTimedParticleStruct> OpenParticles;
    TArrayNoInit<struct FTimedParticleStruct> CloseParticles;
    FLOAT CurrentFXTime;
    class UPointLightComponent* ExplosionLight;
    class UPointLightComponent* ImulsionLight;
    BYTE HoleStatus;
    BYTE LastHoleStatus;
    TArrayNoInit<struct FTimedDelegate> OpenDelegates;
    TArrayNoInit<class AGearPawn*> Spawns;
    FLOAT LastReminderTime;
    class AGearPointOfInterest_EHole* POI;
    FScriptDelegate __TemplateDelegate__Delegate;
    //## END PROPS GearSpawner_EmergenceHoleBase

    void ApplySourceMaterial();
    DECLARE_FUNCTION(execApplySourceMaterial)
    {
        P_FINISH;
        ApplySourceMaterial();
    }
    void delegateTemplateDelegate()
    {
        ProcessDelegate(GEARGAME_TemplateDelegate,&__TemplateDelegate__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(AGearSpawner_EmergenceHoleBase,AGearSpawner,0,GearGame)
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

#define UCONST_OpenReminderFrequencySec 15.f

struct GearSpawner_EHole_eventGetSpawnSlotTemp_Parms
{
    INT out_SpawnSlotIdx;
    FVector out_SpawnLocation;
    FRotator out_SpawnRotation;
    UBOOL ReturnValue;
    GearSpawner_EHole_eventGetSpawnSlotTemp_Parms(EEventParm)
    {
    }
};
struct GearSpawner_EHole_eventTemplateDelegate_Parms
{
    GearSpawner_EHole_eventTemplateDelegate_Parms(EEventParm)
    {
    }
};
class AGearSpawner_EHole : public AGearSpawner
{
public:
    //## BEGIN PROPS GearSpawner_EHole
    class APrefabInstance* EHolePrefab;
    class UGearExplosion* ExplosionTemplate;
    BYTE HoleStatus;
    BYTE LastHoleStatus;
    TArrayNoInit<struct FTimedDelegate> OpenDelegates;
    BITFIELD bFastOpen:1;
    BITFIELD bStartOpen:1;
    BITFIELD bIgnoreDamage:1;
    BITFIELD bDoReminders:1;
    BITFIELD bSpawnPOI:1;
    TArrayNoInit<class AGearPawn*> Spawns;
    FLOAT LastReminderTime;
    class AGearPointOfInterest_EHole* POI;
    FScriptDelegate __TemplateDelegate__Delegate;
    //## END PROPS GearSpawner_EHole

    virtual void OpenEHole_Visuals(const FString& TagOfEvent);
    virtual void OpenEHoleNormal_Visuals();
    virtual void OpenEHoleImmediately_Visuals();
    virtual void ClosEHole_Visuals();
    DECLARE_FUNCTION(execOpenEHole_Visuals)
    {
        P_GET_STR_REF(TagOfEvent);
        P_FINISH;
        OpenEHole_Visuals(TagOfEvent);
    }
    DECLARE_FUNCTION(execOpenEHoleNormal_Visuals)
    {
        P_FINISH;
        OpenEHoleNormal_Visuals();
    }
    DECLARE_FUNCTION(execOpenEHoleImmediately_Visuals)
    {
        P_FINISH;
        OpenEHoleImmediately_Visuals();
    }
    DECLARE_FUNCTION(execClosEHole_Visuals)
    {
        P_FINISH;
        ClosEHole_Visuals();
    }
    UBOOL eventGetSpawnSlotTemp(INT& out_SpawnSlotIdx,FVector& out_SpawnLocation,FRotator& out_SpawnRotation)
    {
        GearSpawner_EHole_eventGetSpawnSlotTemp_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.out_SpawnSlotIdx=out_SpawnSlotIdx;
        Parms.out_SpawnLocation=out_SpawnLocation;
        Parms.out_SpawnRotation=out_SpawnRotation;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetSpawnSlotTemp),&Parms);
        out_SpawnSlotIdx=Parms.out_SpawnSlotIdx;
        out_SpawnLocation=Parms.out_SpawnLocation;
        out_SpawnRotation=Parms.out_SpawnRotation;
        return Parms.ReturnValue;
    }
    void delegateTemplateDelegate()
    {
        ProcessDelegate(GEARGAME_TemplateDelegate,&__TemplateDelegate__Delegate,NULL);
    }
    DECLARE_CLASS(AGearSpawner_EHole,AGearSpawner,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearSpawner_EHole)
};

class AGearSpawner_EholeSpawnLocation : public AActor
{
public:
    //## BEGIN PROPS GearSpawner_EholeSpawnLocation
    BITFIELD bEnabled:1;
    BYTE EmergeAnim GCC_BITFIELD_MAGIC;
    //## END PROPS GearSpawner_EholeSpawnLocation

    DECLARE_CLASS(AGearSpawner_EholeSpawnLocation,AActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearSpawner_EholeSpawnLocation)
};

class AHeadTrackTarget : public AActor
{
public:
    //## BEGIN PROPS HeadTrackTarget
    FLOAT Radius;
    BITFIELD bEnabled:1;
    BITFIELD bRegistered:1;
    class AActor* AlternateLookatActor;
    FName AlternateLookAtActorBoneName;
    BYTE PawnFilter;
    class UDrawSphereComponent* SphereRenderComponent;
    //## END PROPS HeadTrackTarget

    UBOOL CanAffectPawn(class AGearPawn* WP) const;
    DECLARE_FUNCTION(execCanAffectPawn)
    {
        P_GET_OBJECT(AGearPawn,WP);
        P_FINISH;
        *(UBOOL*)Result=CanAffectPawn(WP);
    }
    DECLARE_CLASS(AHeadTrackTarget,AActor,0,GearGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

struct HOD_BeamManagerBase_eventSetEnabled_Parms
{
    UBOOL bNewEnabled;
    UBOOL bSuppressAlert;
    HOD_BeamManagerBase_eventSetEnabled_Parms(EEventParm)
    {
    }
};
class AHOD_BeamManagerBase : public AActor
{
public:
    //## BEGIN PROPS HOD_BeamManagerBase
    TArrayNoInit<class AHOD_BeamBase*> ActiveBeams;
    class APawn* LastFABPawn;
    class AHOD_BeamBase* LastFABBeam;
    BITFIELD bEnabled:1;
    BITFIELD bPlayerNotifiedOfDisabledStatus:1;
    FVector DirectionToDeathRayOriginNorm;
    class UClass* BeamClass;
    //## END PROPS HOD_BeamManagerBase

    virtual UBOOL IsAValidHODTarget(const FVector& Loc);
    DECLARE_FUNCTION(execIsAValidHODTarget)
    {
        P_GET_STRUCT_REF(FVector,Loc);
        P_FINISH;
        *(UBOOL*)Result=IsAValidHODTarget(Loc);
    }
    void eventSetEnabled(UBOOL bNewEnabled,UBOOL bSuppressAlert)
    {
        HOD_BeamManagerBase_eventSetEnabled_Parms Parms(EC_EventParm);
        Parms.bNewEnabled=bNewEnabled ? FIRST_BITFIELD : FALSE;
        Parms.bSuppressAlert=bSuppressAlert ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetEnabled),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AHOD_BeamManagerBase,AActor,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

    NO_DEFAULT_CONSTRUCTOR(AHOD_BeamManagerBase)
};

struct FAssessSquadData
{
    FLOAT NameYFromCenter;
    FLOAT OrderYFromCenter;
    FLOAT HeadYFromTopOfBackground;

    /** Constructors */
    FAssessSquadData() {}
    FAssessSquadData(EEventParm)
    {
        appMemzero(this, sizeof(FAssessSquadData));
    }
};

struct FAssessSquadCoord
{
    FLOAT XFromTopRight;
    FLOAT YFromTopRight;

    /** Constructors */
    FAssessSquadCoord() {}
    FAssessSquadCoord(EEventParm)
    {
        appMemzero(this, sizeof(FAssessSquadCoord));
    }
};

struct FAllAssessSquadCoord
{
    TArrayNoInit<struct FAssessSquadCoord> Coords;

    /** Constructors */
    FAllAssessSquadCoord() {}
    FAllAssessSquadCoord(EEventParm)
    {
        appMemzero(this, sizeof(FAllAssessSquadCoord));
    }
};

struct FSquadLocatorDatum
{
    FLOAT DirOfHit;
    class UMaterialInstanceConstant* MILocation;

    /** Constructors */
    FSquadLocatorDatum() {}
    FSquadLocatorDatum(EEventParm)
    {
        appMemzero(this, sizeof(FSquadLocatorDatum));
    }
};

struct FHitLocatorDatum
{
    FLOAT DirOfHit;
    FLOAT HitLocationFadePercent;
    class UMaterialInstanceConstant* MILocation;
    class AActor* ActorWhoShotMe;
    FVector HitLocation;
    BITFIELD bDirLocked:1;

    /** Constructors */
    FHitLocatorDatum() {}
    FHitLocatorDatum(EEventParm)
    {
        appMemzero(this, sizeof(FHitLocatorDatum));
    }
};

struct FDeathData
{
    FStringNoInit KillerName;
    FStringNoInit VictimName;
    BYTE KillerTeamIndex;
    BYTE VictimTeamIndex;
    class UClass* Damage;
    BYTE DeathType;
    FLOAT TimeRemaining;
    INT BloodIconIndex;
    BITFIELD bShowBlood:1;
    BITFIELD bUseMessageText:1;
    FStringNoInit MessageText;
    BITFIELD bUseTeamColors:1;
    BITFIELD bKillerDrawTeamColor:1;
    BITFIELD bKillerIsCOG:1;
    BITFIELD bVictimDrawTeamColor:1;
    BITFIELD bVictimIsCOG:1;
    BITFIELD bAlwaysShow:1;
    BITFIELD bShowPlayerNames:1;
    FLOAT Scale;
    INT GameSpecificID;

    /** Constructors */
    FDeathData() {}
    FDeathData(EEventParm)
    {
        appMemzero(this, sizeof(FDeathData));
    }
};

struct FWeaponSelectData
{
    INT TotalNumBlinks;
    FLOAT TotalBlinkTime;
    FLOAT StartBlinkTime;

    /** Constructors */
    FWeaponSelectData() {}
    FWeaponSelectData(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponSelectData));
    }
};

struct FActionReloadBarData
{
    FCanvasIcon BackGround;
    FCanvasIcon Flash;
    FCanvasIcon TickMark;
    FCanvasIcon SuccessRegion;
    FCanvasIcon PerfectGrade;
    FCanvasIcon GoodGrade;
    FLOAT FlashDuration;
    FLOAT FadeDuration;
    FLOAT TickMarkTime;
    BYTE ARResult;

    /** Constructors */
    FActionReloadBarData() {}
    FActionReloadBarData(EEventParm)
    {
        appMemzero(this, sizeof(FActionReloadBarData));
    }
};

struct FActionIconAnimData
{
    FLOAT LastActionAnimationSwitch;
    INT CurrentIconIndex;

    /** Constructors */
    FActionIconAnimData() {}
    FActionIconAnimData(EEventParm)
    {
        appMemzero(this, sizeof(FActionIconAnimData));
    }
};

#define UCONST_BLOOD_ICON_AMT 4
#define UCONST_MAX_HIT_LOCATORS 3

struct GearHUD_Base_eventDebugDraw_Parms
{
    class AGearHUD_Base* H;
    GearHUD_Base_eventDebugDraw_Parms(EEventParm)
    {
    }
};
struct GearHUD_Base_eventSetActionInfo_Parms
{
    BYTE NewActionType;
    struct FActionInfo NewAction;
    UBOOL bMirrorImage;
    UBOOL ReturnValue;
    GearHUD_Base_eventSetActionInfo_Parms(EEventParm)
    : NewAction(EC_EventParm)
    {
    }
};
class AGearHUD_Base : public AHUD
{
public:
    //## BEGIN PROPS GearHUD_Base
    BITFIELD bMinimalHUD:1;
    BITFIELD bInitialTaccomFadeIn:1;
    BITFIELD bInMultiplayerMode:1;
    BITFIELD bInMPCoopMode:1;
    BITFIELD bMBDisabled:1;
    BITFIELD bUnfriendlySpotted:1;
    BITFIELD bDrawSniperZoom:1;
    BITFIELD bPlayCinematic:1;
    BITFIELD bRefreshSafeZone:1;
    BITFIELD bRestrictScoreboard:1;
    BITFIELD bIsFadingCrosshairIn:1;
    BITFIELD bTrackingChat:1;
    BITFIELD bIsFadingTaccomIn:1;
    BITFIELD bIsFadingCoopPauseIn:1;
    BITFIELD bDrawWeaponIndicator:1;
    BITFIELD bIsFadingWeaponIn:1;
    BITFIELD bCoopClientWasPaused:1;
    BITFIELD bDrewCountdownLastFrame:1;
    BITFIELD bShowNamesWhenSpectating:1;
    class UMaterialEffect* TacComEffect;
    FStringNoInit OverTimeString;
    TArrayNoInit<FScriptDelegate> DebugDrawList;
    FColor FadeColor;
    FLOAT PreviousFadeAlpha;
    FLOAT DesiredFadeAlpha;
    FLOAT FadeAlpha;
    FLOAT FadeAlphaTime;
    FLOAT FadeAlphaDelay;
    FLOAT DesiredFadeAlphaTime;
    FLOAT MaxRednessOfDeathScreen;
    FLOAT LastWeaponInfoTime;
    FCanvasIcon MortarCrosshairTickIcon;
    FCanvasIcon MortarCrosshairSaveIcon;
    struct FAssessSquadData SquadDisplayData;
    TArrayNoInit<struct FAllAssessSquadCoord> AssessSquadCoords;
    TArrayNoInit<FCanvasIcon> SquadBackgrounds;
    FCanvasIcon SquadBackgroundNamePlate;
    TArrayNoInit<FCanvasIcon> SquadStatusIcons;
    TArrayNoInit<struct FSquadLocatorDatum> SquadLocator;
    INT NumSquadLocators;
    INT CurrSquadLocatorToUse;
    class UMaterial* SquadLocatorMaterial;
    class UMaterialInstanceConstant* ActiveReloadPulseMaterialConstant;
    class UMaterialInstanceConstant* SuperSweetPulseMaterialConstant;
    class UMaterial* ActiveReloadPulseMaterial;
    class UMaterial* SuperSweetReloadPulseMaterial;
    class UMaterialInstanceConstant* SniperOverlayMaterialConstant;
    class UMaterial* SniperOverlayMaterial;
    class UMaterial* HitLocatorMaterial;
    INT CurrHitLocatorDataIndex;
    struct FHitLocatorDatum HitLocatorList[3];
    struct FActionInfo ActiveAction;
    struct FActionInfo PreviousAction;
    FLOAT ActionFadeTime;
    FCanvasIcon WeaponInfoFrame;
    TArrayNoInit<FCanvasIcon> HealthIcons;
    TArrayNoInit<FLOAT> HealthIconsXOffset;
    class UMaterialInstanceConstant* AssessModeMatInst;
    FLinearColor AssessModeFadeColor;
    FLOAT AssessModeFadeTime;
    class UAudioComponent* TacComLoop;
    TArrayNoInit<FCanvasIcon> GameSpecificIcon;
    FCanvasIcon RevivedIcon;
    FLOAT DeathDataTime;
    FLOAT DeathDataFadeTime;
    TArrayNoInit<struct FDeathData> HUDMessages;
    FLOAT AmmoDataTime;
    FLOAT AmmoDataFadeTime;
    FLOAT CinematicTextDisplayStartTime;
    FCanvasIcon BloodIcons[4];
    INT CurrBloodIndex;
    FLOAT SafeZoneLeft;
    FLOAT SafeZoneRight;
    FLOAT SafeZoneTop;
    FLOAT SafeZoneBottom;
    FLOAT SafeZoneBottomFromViewport;
    FLOAT SafeZoneFriendlyCenterX;
    FLOAT SafeZoneFriendlyCenterY;
    FLOAT WeaponInfoScale;
    BYTE CurrSplitscreenType;
    FLOAT HUDMessagesScreenPercent;
    struct FPostProcessSettings BleedOutPPSettings;
    struct FPostProcessSettings TaccomPPSettings;
    struct FWeaponSelectData WeaponSelect;
    struct FActionReloadBarData ARBarData;
    struct FActionIconAnimData ActionIconAnimInfo;
    class UMaterial* DeadTaccomSplatMaterial;
    class UMaterialInstanceConstant* DeadTaccomSplatMaterialConstant;
    FCanvasIcon ReviveTaccomIcon;
    FCanvasIcon VoiceTaccomIcon;
    FLOAT VoiceTaccomIconPos[2];
    FLOAT CrosshairFadeStartTime;
    FLOAT CrosshairFadeOpacity;
    FLOAT TotalCrosshairFadeTime;
    FLOAT TaccomFadeStartTime;
    FLOAT TaccomFadeOpacity;
    FLOAT TotalTaccomFadeTime;
    FLOAT CoopPauseFadeStartTime;
    FLOAT CoopPauseFadeOpacity;
    FLOAT TotalCoopPauseFadeTime;
    FLOAT WeaponFadeStartTime;
    FLOAT WeaponFadeOpacity;
    FLOAT TotalWeaponFadeTime;
    FLOAT TotalDramaticStringDrawTime;
    FLOAT TotalDramaticStringFadeInTime;
    FLOAT TotalDramaticStringFadeOutTime;
    FLOAT DramaticStringDrawStartTime;
    FStringNoInit DramaticString1;
    FStringNoInit DramaticString2;
    FLOAT DramaticTextDrawYStart;
    FLOAT DramaticLineWaitTime;
    FLOAT DramaticLineFadeTime;
    FLOAT TotalSubtitleStringDrawTime;
    FLOAT TotalSubtitleStringFadeInTime;
    FLOAT TotalSubtitleStringFadeOutTime;
    FLOAT SubtitleStringDrawStartTime;
    FStringNoInit SubtitleString;
    FStringNoInit WeaponTakenString;
    FStringNoInit ServerMessageString;
    FStringNoInit ServerPauseString;
    class APlayerReplicationInfo* ServerPausedByPRI;
    FStringNoInit LoadingString;
    FStringNoInit CheckpointReachedString;
    FLOAT TimeOfLastCheckpoint;
    FLOAT MinTimeBeforeFadeForCheckpoint;
    FLOAT FadeTimeForCheckpoint;
    FLOAT DBNOFullOpacityDistance;
    FLOAT DBNOMaxFadeOpacityDistance;
    FLOAT DBNOMaxFadeOpacity;
    FCanvasIcon CountdownBgdIcon;
    FLOAT CountdownEndTime;
    FLOAT CountdownStartTime;
    FLOAT CountdownStopTime;
    FLOAT CountdownTotalFadeInTime;
    FLOAT CountdownTotalFadeOutTime;
    FLOAT CountdownTimeToDraw;
    FStringNoInit KismetMessageText;
    FLOAT KismetMessageEndTime;
    class UGearUIScene_Base* SpectatorUISceneReference;
    class UGearUIScene_Base* SpectatorUISceneInstance;
    class UGearUIScenePause_Campaign* PauseCampaignUISceneReference;
    class UGearUIScenePause_MP* PauseMPUISceneReference;
    class UGearUIScenePause_Base* PauseUISceneInstance;
    class UGearUIScenePause_Gameover* GameoverUISceneReference;
    class UGearUIScene_Base* GameoverUISceneInstance;
    class UGearUIScene_Discover* DiscoverUISceneReference;
    class UGearUIScene_Discover* DiscoverUISceneInstance;
    class UGearUIScene_PathChoice* PathChoiceSceneRef;
    FLOAT LastMortarTickPercent;
    FCanvasIcon LeaderIcon;
    FCanvasIcon MeatflagIcon;
    FCanvasIcon BuddyIconCOG;
    FCanvasIcon BuddyIconLocust;
    FScriptDelegate __DebugDraw__Delegate;
    //## END PROPS GearHUD_Base

    void SetSniperAspectRatio(class UMaterialInstanceConstant* SniperOverlay);
    DECLARE_FUNCTION(execSetSniperAspectRatio)
    {
        P_GET_OBJECT(UMaterialInstanceConstant,SniperOverlay);
        P_FINISH;
        SetSniperAspectRatio(SniperOverlay);
    }
    void delegateDebugDraw(class AGearHUD_Base* H)
    {
        GearHUD_Base_eventDebugDraw_Parms Parms(EC_EventParm);
        Parms.H=H;
        ProcessDelegate(GEARGAME_DebugDraw,&__DebugDraw__Delegate,&Parms);
    }
    UBOOL eventSetActionInfo(BYTE NewActionType,struct FActionInfo NewAction,UBOOL bMirrorImage=FALSE)
    {
        GearHUD_Base_eventSetActionInfo_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewActionType=NewActionType;
        Parms.NewAction=NewAction;
        Parms.bMirrorImage=bMirrorImage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetActionInfo),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AGearHUD_Base,AHUD,0|CLASS_Transient|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearHUD_Base)
};

class AGearGameTDM_Base : public AGearGameMP_Base
{
public:
    //## BEGIN PROPS GearGameTDM_Base
    //## END PROPS GearGameTDM_Base

    DECLARE_ABSTRACT_CLASS(AGearGameTDM_Base,AGearGameMP_Base,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearGameTDM_Base)
};

class AGearGameWingman_Base : public AGearGameTDM_Base
{
public:
    //## BEGIN PROPS GearGameWingman_Base
    //## END PROPS GearGameWingman_Base

    DECLARE_ABSTRACT_CLASS(AGearGameWingman_Base,AGearGameTDM_Base,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearGameWingman_Base)
};

struct FReplicatedWeatherData
{
    BYTE WeatherType;
    BITFIELD bOverrideEmitterHeight:1 GCC_BITFIELD_MAGIC;
    FLOAT EmitterHeight;

    /** Constructors */
    FReplicatedWeatherData() {}
    FReplicatedWeatherData(EEventParm)
    {
        appMemzero(this, sizeof(FReplicatedWeatherData));
    }
};

struct GearGRI_eventLogSurveyResult_Parms
{
    FString Question;
    FString QuestionId;
    FString Answer;
    INT AnswerNumber;
    FString Context;
    GearGRI_eventLogSurveyResult_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventSetWeatherEmitterHeight_Parms
{
    FLOAT Height;
    GearGRI_eventSetWeatherEmitterHeight_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventSetCurrentWeather_Parms
{
    BYTE NewWeather;
    GearGRI_eventSetCurrentWeather_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventKillPlayers_Parms
{
    TArray<class AController*> Players;
    UBOOL bShouldGib;
    GearGRI_eventKillPlayers_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventStopCountdown_Parms
{
    UBOOL bInstantClear;
    UBOOL bIsExpired;
    GearGRI_eventStopCountdown_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventStartCountdown_Parms
{
    FLOAT CountdownAmount;
    GearGRI_eventStartCountdown_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventIsWithinMaxEffectDistance_Parms
{
    const class APlayerController* PC;
    FVector EffectLocation;
    FLOAT CullDistance;
    UBOOL ReturnValue;
    GearGRI_eventIsWithinMaxEffectDistance_Parms(EEventParm)
    {
    }
};
struct GearGRI_eventOnPlaylistIdChanged_Parms
{
    GearGRI_eventOnPlaylistIdChanged_Parms(EEventParm)
    {
    }
};
class AGearGRI : public AGameReplicationInfo
{
public:
    //## BEGIN PROPS GearGRI
    BYTE GameStatus;
    BYTE ECDState;
    BYTE WavePointsAlivePct;
    BYTE EnemiesLeftThisRound;
    BYTE LastDeathAnimHighFwdIndex;
    BYTE LastDeathAnimHighBwdIndex;
    BYTE LastDeathAnimStdFwdIndex;
    BYTE LastDeathAnimStdBwdIndex;
    BYTE LastDeathAnimStdLtIndex;
    BYTE LastDeathAnimStdRtIndex;
    BYTE CurrentWeather;
    BITFIELD bOverTime:1 GCC_BITFIELD_MAGIC;
    BITFIELD bHasEnoughPlayers:1;
    BITFIELD bIsCoop:1;
    BITFIELD bIsDedicatedListenServer:1;
    BITFIELD bFinalFriendlyKill:1;
    BITFIELD bAllowFriendlyFire:1;
    BITFIELD bGameIsExecutionRules:1;
    BITFIELD bAnnexIsKOTHRules:1;
    BITFIELD bInfiniteRoundDuration:1;
    BITFIELD bAggressiveLOD_Test:1;
    BITFIELD bDropDetail_Test:1;
    BITFIELD bDebugShowDamage:1;
    INT AutoStartDelay;
    INT HostStartDelay;
    INT EndOfRoundDelay;
    INT EndOfGameDelay;
    INT RoundTime;
    INT RoundCount;
    INT RoundDuration;
    INT RoundEndTime;
    TArrayNoInit<FString> GameStatusText;
    class AGearObjectPool* GOP;
    class AHOD_BeamManagerBase* HODBeamManager;
    class AGearSpeechManager* SpeechManager;
    INT InitialRevivalTime;
    class APlayerReplicationInfo* FinalKiller;
    class APlayerReplicationInfo* FinalVictim;
    FLOAT EndTimeForCountdown;
    TArrayNoInit<class AHeadTrackTarget*> HeadTrackTargetCache;
    INT NextHeadTrackTargetToUpdate;
    TArrayNoInit<class AGearAimAssistActor*> AimAssistActorCache;
    FStringNoInit LastStandingOnTeamName[5];
    INT TeamIndexLossOrder[5];
    TArrayNoInit<BYTE> MPTimerNotifcationFlags;
    INT InvasionNumTotalWaves;
    INT InvasionCurrentWaveIndex;
    class UClass* EnemyDifficulty;
    INT ExtendedRestartCount;
    INT NumSecondsUntilNextRound;
    INT NumTeamRespawns[5];
    INT TotalNumTeamRespawns;
    FLOAT GameScore[5];
    INT CPControlTeam;
    class AGearWeaponPickupFactory* CommandPoint;
    INT CPControlPct;
    INT CPResourceLeft;
    INT RespawnTime;
    INT RespawnTimeInterval;
    INT AnnexResourceGoal;
    class AGearPRI* MeatflagKidnapper;
    class AGearPawn* MeatflagPawn;
    class AGearPRI* KillerOfCOGLeaderPRI;
    class AGearPRI* KillerOfLocustLeaderPRI;
    TArrayNoInit<class AGearFogVolume_Spawnable*> SmokeVolumes;
    INT PlaylistId;
    FGuid StatsGameplaySessionID;
    INT WingmanClassIndexes[5];
    struct FReplicatedWeatherData ReplicatedWeather;
    class USeqAct_SpectatorCameraPath* CurrentLevelSpectatorCameraPaths[2];
    FName DefaultSpectatingState;
    INT TrainingGroundsID;
    TArrayNoInit<FLOAT> InfantryIdleBreakLastPlayTime;
    FScriptDelegate __OnPlaylistIdChanged__Delegate;
    FScriptDelegate __IsWithinMaxEffectDistance__Delegate;
    //## END PROPS GearGRI

    void eventLogSurveyResult(const FString& Question,const FString& QuestionId,const FString& Answer,INT AnswerNumber,const FString& Context)
    {
        GearGRI_eventLogSurveyResult_Parms Parms(EC_EventParm);
        Parms.Question=Question;
        Parms.QuestionId=QuestionId;
        Parms.Answer=Answer;
        Parms.AnswerNumber=AnswerNumber;
        Parms.Context=Context;
        ProcessEvent(FindFunctionChecked(GEARGAME_LogSurveyResult),&Parms);
    }
    void eventSetWeatherEmitterHeight(FLOAT Height)
    {
        GearGRI_eventSetWeatherEmitterHeight_Parms Parms(EC_EventParm);
        Parms.Height=Height;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetWeatherEmitterHeight),&Parms);
    }
    void eventSetCurrentWeather(BYTE NewWeather)
    {
        GearGRI_eventSetCurrentWeather_Parms Parms(EC_EventParm);
        Parms.NewWeather=NewWeather;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetCurrentWeather),&Parms);
    }
    void eventKillPlayers(const TArray<class AController*>& Players,UBOOL bShouldGib)
    {
        GearGRI_eventKillPlayers_Parms Parms(EC_EventParm);
        Parms.Players=Players;
        Parms.bShouldGib=bShouldGib ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_KillPlayers),&Parms);
    }
    void eventStopCountdown(UBOOL bInstantClear=FALSE,UBOOL bIsExpired=FALSE)
    {
        GearGRI_eventStopCountdown_Parms Parms(EC_EventParm);
        Parms.bInstantClear=bInstantClear ? FIRST_BITFIELD : FALSE;
        Parms.bIsExpired=bIsExpired ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_StopCountdown),&Parms);
    }
    void eventStartCountdown(FLOAT CountdownAmount)
    {
        GearGRI_eventStartCountdown_Parms Parms(EC_EventParm);
        Parms.CountdownAmount=CountdownAmount;
        ProcessEvent(FindFunctionChecked(GEARGAME_StartCountdown),&Parms);
    }
    UBOOL delegateIsWithinMaxEffectDistance(const class APlayerController*& PC,const FVector& EffectLocation,const FLOAT CullDistance)
    {
        GearGRI_eventIsWithinMaxEffectDistance_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PC=PC;
        Parms.EffectLocation=EffectLocation;
        Parms.CullDistance=CullDistance;
        ProcessDelegate(GEARGAME_IsWithinMaxEffectDistance,&__IsWithinMaxEffectDistance__Delegate,&Parms);
        PC=Parms.PC;
        return Parms.ReturnValue;
    }
    void delegateOnPlaylistIdChanged()
    {
        ProcessDelegate(GEARGAME_OnPlaylistIdChanged,&__OnPlaylistIdChanged__Delegate,NULL);
    }
    DECLARE_CLASS(AGearGRI,AGameReplicationInfo,0|CLASS_Config|CLASS_NativeReplication,GearGame)
	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct FPlayerDamageInfo
{
    class AGearPRI* PRI;
    FLOAT DamageTotal;

    /** Constructors */
    FPlayerDamageInfo() {}
    FPlayerDamageInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerDamageInfo));
    }
};

struct FPersistentInventoryData
{
    class UClass* LeftShoulderWeaponClass;
    class UClass* RightShoulderWeaponClass;
    class UClass* HolsterWeaponClass;
    class UClass* BeltWeaponClass;
    class UClass* ShieldClass;

    /** Constructors */
    FPersistentInventoryData() {}
    FPersistentInventoryData(EEventParm)
    {
        appMemzero(this, sizeof(FPersistentInventoryData));
    }
};

struct FAggregatedWeaponStats
{
    BYTE WeaponID;
    INT KillsWith;
    INT KilledBy;
    INT Knockdowns;
    INT WasKnockedDown;
    INT ShotsFired;
    INT ShotsHit;
    INT ReloadSkips;
    INT ReloadFailures;
    INT ReloadSuccess;
    INT ReloadSuperSuccess;

    /** Constructors */
    FAggregatedWeaponStats() {}
    FAggregatedWeaponStats(EEventParm)
    {
        appMemzero(this, sizeof(FAggregatedWeaponStats));
    }
};

#define UCONST_STATS_LEVEL7 0x40
#define UCONST_STATS_LEVEL4 0x08
#define UCONST_STATS_LEVEL2 0x02
#define UCONST_STATS_LEVEL1 0x01

class AGearPRI : public APlayerReplicationInfo
{
public:
    //## BEGIN PROPS GearPRI
    BYTE PlayerStatus;
    BYTE EndOfRoundPlayerStatus;
    BYTE InitialWeaponType;
    BYTE TrigConfig;
    BYTE StickConfig;
    BYTE SelectedCharacterProfileId;
    BYTE ControllerSensitivityConfig;
    BYTE TargetSensitivityConfig;
    BYTE ZoomSensitivityConfig;
    BITFIELD bIsDead:1 GCC_BITFIELD_MAGIC;
    BITFIELD bIsLeader:1;
    BITFIELD bSquadLeader:1;
    BITFIELD bForceShowInTaccom:1;
    BITFIELD bHostIsReady:1;
    BITFIELD bIsMeatFlag:1;
    BITFIELD bShowGore:1;
    BITFIELD bShowHUD:1;
    BITFIELD bAlwaysDrawWeaponIndicatorInHUD:1;
    BITFIELD bShowPictograms:1;
    BITFIELD bReceivesTeamScoringBonus:1;
    BITFIELD bSkipWeaponAggregate:1;
    INT NumberOfCOGTagsCollected;
    FLOAT PointsFor_TakeDowns;
    FLOAT PointsFor_Executions;
    FLOAT PointsFor_InstantKills;
    FLOAT PointsFor_Revives;
    FLOAT PointsFor_CurbStomps;
    FLOAT PointsFor_DamagePct;
    TArrayNoInit<struct FPlayerDamageInfo> PlayerDamageList;
    FName SquadName;
    class UClass* PawnClass;
    FLOAT ChatFadeValue;
    FLOAT ChatFadeTime;
    FLOAT TaccomChatFadeStart;
    INT PreferredCOGIndex;
    INT PreferredLocustIndex;
    struct FPersistentInventoryData PersistentInventory;
    class UClass* Difficulty;
    class APlayerReplicationInfo* LastToDBNOMePRI;
    class APlayerReplicationInfo* LastToKillMePRI;
    class APlayerReplicationInfo* LastIKilledPRI;
    class UClass* DamageTypeToKillMe;
    INT Score_Kills;
    INT Score_Takedowns;
    INT Score_Revives;
    INT Score_GameSpecific1;
    INT Score_GameSpecific2;
    INT Score_GameSpecific3;
    FLOAT PointAccumulator;
    INT KOTHRingPointsToBeginRound;
    INT DLCFlag;
    TArrayNoInit<class AGearProj_Grenade*> PlantedGrenades;
    FLOAT TotalRoadieRunTime;
    FLOAT RoadieRunStartTime;
    FLOAT TotalAliveTime;
    FLOAT AliveStartTime;
    FLOAT TotalTimeInCover;
    INT KillStreak;
    INT MaxKillStreak;
    INT Score_Assists;
    INT Was_TakenDown;
    INT Was_Revived;
    INT Score_Executions;
    INT Was_Executed;
    INT NoTeamKills;
    INT NoGibs;
    INT NoWasGibbed;
    INT NoHeadShots;
    INT NoWasHeadShot;
    INT NoGrenadeTags;
    INT NoTimesGrenadeTagged;
    INT NoGrenadeMines;
    INT NoGrenadeMinesTriggered;
    INT NoGrenadeMinesTriggeredByMe;
    INT NoGrenadeMartyr;
    INT NoGrenadeMartyrDeaths;
    INT NoTimesIDiedByGrenadeMartyr;
    INT NoChainsawKills;
    INT NoChainSawDeaths;
    INT NoChainsawDuelsWon;
    INT NoChainsawDuelsLost;
    INT NoChainsawDuelsTied;
    INT NoMeleeKills;
    INT NoMeleeDeaths;
    INT NoMeleeKnockdowns;
    INT NoMeleeWasKnockedDown;
    INT NoMeleeHits;
    INT NoTimesMeleeHit;
    FLOAT TotalFlameTime;
    FLOAT TotalFlameDmgTime;
    TArrayNoInit<struct FAggregatedWeaponStats> WeaponStats;
    //## END PROPS GearPRI

    DECLARE_CLASS(AGearPRI,APlayerReplicationInfo,0|CLASS_Config|CLASS_NativeReplication,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Pawn");}

	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AGearTeamInfo : public ATeamInfo
{
public:
    //## BEGIN PROPS GearTeamInfo
    TArrayNoInit<class AController*> TeamMembers;
    TArrayNoInit<class AGearSquad*> Squads;
    FLOAT LastWretchScreamTime;
    INT TotalScore;
    //## END PROPS GearTeamInfo

    DECLARE_CLASS(AGearTeamInfo,ATeamInfo,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearTeamInfo)
};

struct GearGameSP_Base_eventCheckpointLoadComplete_Parms
{
    GearGameSP_Base_eventCheckpointLoadComplete_Parms(EEventParm)
    {
    }
};
class AGearGameSP_Base : public AGearGame
{
public:
    //## BEGIN PROPS GearGameSP_Base
    BITFIELD bHasHostAcceptedAnInvite:1;
    BITFIELD bStartupLoadCheckpoint:1;
    BITFIELD bStartupSaveCheckpoint:1;
    BITFIELD bCheckpointLoadInProgress:1;
    BITFIELD bNeedBackupLoadingMovie:1;
    BYTE CurrentChapter GCC_BITFIELD_MAGIC;
    //## END PROPS GearGameSP_Base

    void ResetActorChannel(class AActor* ChannelOwner);
    DECLARE_FUNCTION(execResetActorChannel)
    {
        P_GET_OBJECT(AActor,ChannelOwner);
        P_FINISH;
        ResetActorChannel(ChannelOwner);
    }
    void eventCheckpointLoadComplete()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_CheckpointLoadComplete),NULL);
    }
    DECLARE_CLASS(AGearGameSP_Base,AGearGame,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearGameSP_Base)
};

struct FGameTypePrefix
{
    FStringNoInit Prefix;
    FStringNoInit GameType;
    TArrayNoInit<FString> AdditionalGameTypes;

    /** Constructors */
    FGameTypePrefix() {}
    FGameTypePrefix(EEventParm)
    {
        appMemzero(this, sizeof(FGameTypePrefix));
    }
};

class AGearGameGeneric : public AGameInfo
{
public:
    //## BEGIN PROPS GearGameGeneric
    TArrayNoInit<struct FGameTypePrefix> DefaultMapPrefixes;
    TArrayNoInit<struct FGameTypePrefix> CustomMapPrefixes;
    FStringNoInit SuperDuperFallBackGameType;
    //## END PROPS GearGameGeneric

    DECLARE_CLASS(AGearGameGeneric,AGameInfo,0|CLASS_Config,GearGame)
	virtual void AddSupportedGameTypes(AWorldInfo* Info, const TCHAR* WorldFilename) const;
};

struct GearPointOfInterest_eventSetEnabled_Parms
{
    UBOOL bOn;
    GearPointOfInterest_eventSetEnabled_Parms(EEventParm)
    {
    }
};
class AGearPointOfInterest : public AKeypoint
{
public:
    //## BEGIN PROPS GearPointOfInterest
    INT POIPriority_ScriptedEvent;
    INT POIPriority_RevivableComrade;
    INT POIPriority_MoveOrder;
    INT POIPriority_TargetOrder;
    INT POIPriority_ComradeHuman;
    INT POIPriority_Comrade;
    INT POIPriority_Pickup;
    FStringNoInit DisplayName;
    BITFIELD bEnabled:1;
    BITFIELD bForceLookCheckLineOfSight:1;
    BITFIELD bDoTraceForFOV:1;
    BITFIELD bDisableOtherPOIs:1;
    BITFIELD bLeavePlayerFacingPOI:1;
    BITFIELD bIsInitialized:1;
    FLOAT IconDuration;
    BYTE ForceLookType;
    FLOAT ForceLookDuration;
    INT LookAtPriority;
    FLOAT DesiredFOV;
    INT FOVCount;
    FLOAT EnableDuration;
    FLOAT CurrIconDuration;
    class AActor* AttachedToActor;
    class USeqAct_ManagePOI* POIAction;
    //## END PROPS GearPointOfInterest

    virtual FString RetrievePOIString(const FString& TagName);
    DECLARE_FUNCTION(execRetrievePOIString)
    {
        P_GET_STR(TagName);
        P_FINISH;
        *(FString*)Result=RetrievePOIString(TagName);
    }
    void eventSetEnabled(UBOOL bOn)
    {
        GearPointOfInterest_eventSetEnabled_Parms Parms(EC_EventParm);
        Parms.bOn=bOn ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetEnabled),&Parms);
    }
    DECLARE_CLASS(AGearPointOfInterest,AKeypoint,0|CLASS_Config|CLASS_NativeReplication,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AGearPointOfInterest_Meatflag : public AGearPointOfInterest
{
public:
    //## BEGIN PROPS GearPointOfInterest_Meatflag
    INT KidnapperTeamIndex;
    //## END PROPS GearPointOfInterest_Meatflag

    DECLARE_CLASS(AGearPointOfInterest_Meatflag,AGearPointOfInterest,0|CLASS_Config|CLASS_NativeReplication,GearGame)
	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AMantlePlaceholderCylinder : public AActor
{
public:
    //## BEGIN PROPS MantlePlaceholderCylinder
    class APawn* PawnToIgnore;
    //## END PROPS MantlePlaceholderCylinder

    DECLARE_CLASS(AMantlePlaceholderCylinder,AActor,0,GearGame)
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
};

class ARockWorm_TailSegment : public AActor
{
public:
    //## BEGIN PROPS RockWorm_TailSegment
    class AGearPawn_RockWormBase* WormOwner;
    class ARockWorm_TailSegment* NextSegment;
    class ARockWorm_TailSegment* PrevSegment;
    FLOAT AttachOffset;
    class USkeletalMeshComponent* Mesh;
    FName FrontPivotBoneName;
    FName RearPivotBoneName;
    BITFIELD bThisSegmentIsTheTail:1;
    FLOAT LastZeroSpeedTime;
    FVector InitialLocation;
    FRotator InitialRotation;
    //## END PROPS RockWorm_TailSegment

    DECLARE_CLASS(ARockWorm_TailSegment,AActor,0,GearGame)
		virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
		virtual void NotifyBump(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitNormal);
};

class ATrigger_Engage : public ATrigger
{
public:
    //## BEGIN PROPS Trigger_Engage
    class AActor* ENGAGE_Actor;
    INT ENGAGE_TurnsToComplete;
    FLOAT ENGAGE_LoopDelay;
    FVector ENGAGE_OffsetFromActor;
    FLOAT ENGAGE_TurnTowardSpeed;
    FName ENGAGE_AnimName_Start;
    FName ENGAGE_AnimName_End;
    FName ENGAGE_AnimName_Loop;
    FName ENGAGE_AnimName_Idle;
    FName ENGAGE_AnimName_ForceOff;
    BITFIELD ENGAGE_bShouldHolsterWeaponFirst:1;
    BITFIELD ENGAGE_bPlayAnimationForHeavyWeapons:1;
    BITFIELD ENGAGE_bShouldAutoDropHeavyWeapon:1;
    BITFIELD bEngageEnabled:1;
    INT LoopCounter;
    FLOAT LastTurnTime;
    class ATrigger_Engage* LinkedCoopTrigger;
    FLOAT LastAttemptTurnTime;
    class AGearPawn* EngagedPawn;
    //## END PROPS Trigger_Engage

    DECLARE_CLASS(ATrigger_Engage,ATrigger,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(ATrigger_Engage)
};

class ATrigger_LadderInteraction : public ATrigger
{
public:
    //## BEGIN PROPS Trigger_LadderInteraction
    BITFIELD bIsTopOfLadder:1;
    class AStaticMeshActor* LadderSMActor;
    FVector BottomLocOffset;
    FRotator BottomRotOffset;
    FVector TopLocOffset;
    FRotator TopRotOffset;
    class ALadderMarker* TopMarker;
    class ALadderMarker* BottomMarker;
    FName ClimbDownAnim;
    FName ClimbUpAnim;
    //## END PROPS Trigger_LadderInteraction

    virtual void GetTopEntryPoint(FVector& out_Loc,FRotator& out_Rot);
    virtual void GetBottomEntryPoint(FVector& out_Loc,FRotator& out_Rot);
    DECLARE_FUNCTION(execGetTopEntryPoint)
    {
        P_GET_STRUCT_REF(FVector,out_Loc);
        P_GET_STRUCT_REF(FRotator,out_Rot);
        P_FINISH;
        GetTopEntryPoint(out_Loc,out_Rot);
    }
    DECLARE_FUNCTION(execGetBottomEntryPoint)
    {
        P_GET_STRUCT_REF(FVector,out_Loc);
        P_GET_STRUCT_REF(FRotator,out_Rot);
        P_FINISH;
        GetBottomEntryPoint(out_Loc,out_Rot);
    }
    DECLARE_CLASS(ATrigger_LadderInteraction,ATrigger,0,GearGame)
	virtual INT AddMyMarker( AActor *S );
};

struct FAttributeRatingStruct
{
    TArrayNoInit<FLOAT> Values;

    /** Constructors */
    FAttributeRatingStruct() {}
    FAttributeRatingStruct(EEventParm)
    {
        appMemzero(this, sizeof(FAttributeRatingStruct));
    }
};

class USeqAct_ModifyDifficulty : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ModifyDifficulty
    struct FAttributeRatingStruct AcurracyMultiplierValues;
    struct FAttributeRatingStruct HealthMultiplierValues;
    struct FAttributeRatingStruct AcquisitionTimeMultiplierValues;
    INT HealthRating;
    INT AccuracyRating;
    INT AcquisitionTimeRating;
    //## END PROPS SeqAct_ModifyDifficulty

    DECLARE_CLASS(USeqAct_ModifyDifficulty,USequenceAction,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	void Activated();

	void DeActivated();

	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	* This will determine how much we multiply the Accuracy values of the mobs spawned by this factory.
	* The factory will look at the rating value it has for accuracy and then look up in the
	* AcurracyMultiplierValues to get the percentage to multiply the base value by.
	* Separate from the Accuracy as we may want a different number of ratings
	**/
	FLOAT DetermineAccuracyMultiplier() const;


	/**
	* This will determine how much we multiply the Health values of the mobs spawned by this factory.
	* The factory will look at the rating value it has for accuracy and then look up in the
	* AcurracyMultiplierValues to get the percentage to multiply the base value by.
	* Separate from the Accuracy as we may want a different number of ratings
	**/
	FLOAT DetermineHealthMultiplier() const;


	FLOAT DetermineAcquisitionTimeMultiplier() const;

};

class USeqEvent_ChapterPoint : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ChapterPoint
    BYTE Chapter;
    TArrayNoInit<struct FLevelRecord> SubLevelsToLoad;
    TArrayNoInit<class UClass*> MarcusInventory;
    //## END PROPS SeqEvent_ChapterPoint

    DECLARE_CLASS(USeqEvent_ChapterPoint,USequenceEvent,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_ChapterPoint)
};

class UActorFactoryPushable : public UActorFactoryMover
{
public:
    //## BEGIN PROPS ActorFactoryPushable
    //## END PROPS ActorFactoryPushable

    DECLARE_CLASS(UActorFactoryPushable,UActorFactoryMover,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPushable)
};

struct AICommand_eventDrawDebug_Parms
{
    class AGearHUD_Base* HUD;
    FName category;
    AICommand_eventDrawDebug_Parms(EEventParm)
    {
    }
};
struct AICommand_eventGetDumpString_Parms
{
    FString ReturnValue;
    AICommand_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct AICommand_eventInternalTick_Parms
{
    FLOAT DeltaTime;
    AICommand_eventInternalTick_Parms(EEventParm)
    {
    }
};
struct AICommand_eventInternalResumed_Parms
{
    FName OldCommandName;
    AICommand_eventInternalResumed_Parms(EEventParm)
    {
    }
};
struct AICommand_eventInternalPaused_Parms
{
    class UAICommand* NewCommand;
    AICommand_eventInternalPaused_Parms(EEventParm)
    {
    }
};
struct AICommand_eventInternalPopped_Parms
{
    AICommand_eventInternalPopped_Parms(EEventParm)
    {
    }
};
struct AICommand_eventInternalPushed_Parms
{
    AICommand_eventInternalPushed_Parms(EEventParm)
    {
    }
};
class UAICommand : public UObject
{
public:
    //## BEGIN PROPS AICommand
    class UAICommand* ChildCommand;
    FName ChildStatus;
    class AGearAI* AIOwner;
    class AGearAI_Cover* CoverOwner;
    FName Status;
    BITFIELD bAllowNewSameClassInstance:1;
    BITFIELD bReplaceActiveSameClassInstance:1;
    BITFIELD bIsStationaryFiringCommand:1;
    BITFIELD bAllowedToFireWeapon:1;
    BITFIELD bAborted:1;
    BITFIELD bIgnoreNotifies:1;
    BITFIELD bPendingPop:1;
    //## END PROPS AICommand

    UBOOL ShouldIgnoreNotifies() const;
    DECLARE_FUNCTION(execShouldIgnoreNotifies)
    {
        P_FINISH;
        *(UBOOL*)Result=ShouldIgnoreNotifies();
    }
    void eventDrawDebug(class AGearHUD_Base* HUD,FName category)
    {
        AICommand_eventDrawDebug_Parms Parms(EC_EventParm);
        Parms.HUD=HUD;
        Parms.category=category;
        ProcessEvent(FindFunctionChecked(GEARGAME_DrawDebug),&Parms);
    }
    FString eventGetDumpString()
    {
        AICommand_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventInternalTick(FLOAT DeltaTime)
    {
        AICommand_eventInternalTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GEARGAME_InternalTick),&Parms);
    }
    void eventInternalResumed(FName OldCommandName)
    {
        AICommand_eventInternalResumed_Parms Parms(EC_EventParm);
        Parms.OldCommandName=OldCommandName;
        ProcessEvent(FindFunctionChecked(GEARGAME_InternalResumed),&Parms);
    }
    void eventInternalPaused(class UAICommand* NewCommand)
    {
        AICommand_eventInternalPaused_Parms Parms(EC_EventParm);
        Parms.NewCommand=NewCommand;
        ProcessEvent(FindFunctionChecked(GEARGAME_InternalPaused),&Parms);
    }
    void eventInternalPopped()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_InternalPopped),NULL);
    }
    void eventInternalPushed()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_InternalPushed),NULL);
    }
    DECLARE_CLASS(UAICommand,UObject,0,GearGame)
    DECLARE_WITHIN(AGearAI)
    static const TCHAR* StaticConfigName() {return TEXT("AI");}

    virtual void TickCommand(FLOAT DeltaTime);
    void ProcessState(FLOAT DeltaSeconds);
    virtual EGotoState GotoState( FName State, UBOOL bForceEvents = 0, UBOOL bKeepStack = 0 );
    void PopChildCommand();
};

class UAICmd_Attack_PlantGrenade : public UAICommand
{
public:
    //## BEGIN PROPS AICmd_Attack_PlantGrenade
    INT MinDistance;
    INT MaxDistance;
    TArrayNoInit<FVector> WallTraceDirs;
    //## END PROPS AICmd_Attack_PlantGrenade

    class ANavigationPoint* GetBestPlantPoint();
    DECLARE_FUNCTION(execGetBestPlantPoint)
    {
        P_FINISH;
        *(class ANavigationPoint**)Result=GetBestPlantPoint();
    }
    DECLARE_CLASS(UAICmd_Attack_PlantGrenade,UAICommand,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UAICmd_Attack_PlantGrenade)
};

#define UCONST_bUseAsyncRaycastsForSkipAhead 0

class UAICmd_MoveToGoal : public UAICommand
{
public:
    //## BEGIN PROPS AICmd_MoveToGoal
    struct FBasedPosition SkipAheadLastUpdatePos;
    FLOAT SkipAheadUpdateThreshold;
    INT SkipAheadMaxNodes;
    FLOAT SkipAheadMaxDist;
    FLOAT SkipAheadPitCheckInterval;
    FLOAT SkipAheadPitCheckHeight;
    BITFIELD bEnableSkipAheadChecks:1;
    BITFIELD bSkipAheadFail:1;
    BITFIELD bGoalChangedDueToSkipAhead:1;
    BITFIELD bFiringWeaponAtStart:1;
    BITFIELD bCachedShouldWalk:1;
    BITFIELD bValidRouteCache:1;
    BITFIELD bCanPathfind:1;
    BITFIELD bAllowPartialPath:1;
    BITFIELD bAllowedToFire:1;
    INT SkipAheadNumActiveTests;
    INT SkipAheadCurrentTestingIndex;
    TMap< ANavigationPoint*,UBOOL > NonSkippableWaypoints;
    INT NumTimesGetNextMoveGoalReturnedSameNode;
    INT LoopFailSafeCounter;
    FLOAT LastShouldWalkCacheTime;
    struct FBasedPosition LastPawnTargetPathLocation;
    class AActor* IntermediateMoveGoal;
    class AActor* TriggerGoal;
    TArrayNoInit<class ANavigationPoint*> NodesRequiringTriggers;
    //## END PROPS AICmd_MoveToGoal

    virtual void ClearNonSkippableWayPoints();
    virtual void AddNonSkippableWayPoint(class ANavigationPoint* Point);
    DECLARE_FUNCTION(execClearNonSkippableWayPoints)
    {
        P_FINISH;
        ClearNonSkippableWayPoints();
    }
    DECLARE_FUNCTION(execAddNonSkippableWayPoint)
    {
        P_GET_OBJECT(ANavigationPoint,Point);
        P_FINISH;
        AddNonSkippableWayPoint(Point);
    }
    DECLARE_CLASS(UAICmd_MoveToGoal,UAICommand,0,GearGame)

	class SkipAheadCheck: public FAsyncLineCheckResult
	{
	public:
		SkipAheadCheck(ANavigationPoint* InNav, UAICmd_MoveToGoal* InTestingCommand, UBOOL bInPitTest, FinishedCallback Callback) :
		  TestingForNav(InNav)
		 ,TestingCommand(InTestingCommand)
		 ,bPitTest(bInPitTest)
		  {
				LineCheckFinishedCallback=Callback;
		  }

		  virtual void Serialize( FArchive& Ar )
		  {
			  Ar << TestingCommand;
			  Ar << TestingForNav;
		  }

		ANavigationPoint* TestingForNav;
		UAICmd_MoveToGoal* TestingCommand;
		UBOOL			   bPitTest;
	};

	static void StaticTestFinished( FAsyncLineCheckResult* FinishedResult )
	{
		SkipAheadCheck* Check = ((SkipAheadCheck*)FinishedResult);
		Check->TestingCommand->TestFinished(Check);
	}

	void TestFinished(SkipAheadCheck* Check);
	virtual void TickCommand(FLOAT DeltaTime);
	void UpdateSubGoal(FLOAT DeltaTime);
	void SkipToSubGoal(AGearAI* GAI, INT Index);
	UBOOL AreTestsPending()
	{
		return (SkipAheadNumActiveTests > 0);
	}
	UBOOL IsClearOfAvoidanceZones(APawn* Pawn, ANavigationPoint* PotentialNodeToSkipTo);
	void QueueTests(const FVector& Start, ANavigationPoint* NodeToTest, FLOAT COllisionRadius);

};

struct AIReactCondition_Base_eventActivate_Parms
{
    class AActor* EventInstigator;
    class UAIReactChannel* OriginatingChannel;
    AIReactCondition_Base_eventActivate_Parms(EEventParm)
    {
    }
};
struct AIReactCondition_Base_eventShouldActivate_Parms
{
    class AActor* EventInstigator;
    class UAIReactChannel* OriginatingChannel;
    UBOOL ReturnValue;
    AIReactCondition_Base_eventShouldActivate_Parms(EEventParm)
    {
    }
};
struct AIReactCondition_Base_eventUnSuppress_Parms
{
    AIReactCondition_Base_eventUnSuppress_Parms(EEventParm)
    {
    }
};
struct AIReactCondition_Base_eventSuppress_Parms
{
    AIReactCondition_Base_eventSuppress_Parms(EEventParm)
    {
    }
};
struct AIReactCondition_Base_eventInitialize_Parms
{
    AIReactCondition_Base_eventInitialize_Parms(EEventParm)
    {
    }
};
class UAIReactCondition_Base : public UObject
{
public:
    //## BEGIN PROPS AIReactCondition_Base
    TArrayNoInit<FName> AutoSubscribeChannels;
    TArrayNoInit<FName> SubscribedChannels;
    BITFIELD bSuppressed:1;
    BITFIELD bAlwaysNotify:1;
    BITFIELD bActivateWhenBasedOnInterpActor:1;
    BITFIELD bActivateWhenBasedOnPawn:1;
    BITFIELD bOneTimeOnly:1;
    FLOAT TimerInterval;
    FLOAT TimerLastActivationTime;
    //## END PROPS AIReactCondition_Base

    void SubscribeToMyChannels();
    void UnsubscribeAll();
    DECLARE_FUNCTION(execSubscribeToMyChannels)
    {
        P_FINISH;
        SubscribeToMyChannels();
    }
    DECLARE_FUNCTION(execUnsubscribeAll)
    {
        P_FINISH;
        UnsubscribeAll();
    }
    void eventActivate(class AActor* EventInstigator,class UAIReactChannel* OriginatingChannel)
    {
        AIReactCondition_Base_eventActivate_Parms Parms(EC_EventParm);
        Parms.EventInstigator=EventInstigator;
        Parms.OriginatingChannel=OriginatingChannel;
        ProcessEvent(FindFunctionChecked(GEARGAME_Activate),&Parms);
    }
    UBOOL eventShouldActivate(class AActor* EventInstigator,class UAIReactChannel* OriginatingChannel)
    {
        AIReactCondition_Base_eventShouldActivate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventInstigator=EventInstigator;
        Parms.OriginatingChannel=OriginatingChannel;
        ProcessEvent(FindFunctionChecked(GEARGAME_ShouldActivate),&Parms);
        return Parms.ReturnValue;
    }
    void eventUnSuppress()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_UnSuppress),NULL);
    }
    void eventSuppress()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_Suppress),NULL);
    }
    void eventInitialize()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_Initialize),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UAIReactCondition_Base,UObject,0,GearGame)
    DECLARE_WITHIN(AGearAI)
	virtual UBOOL ShouldActivateNative( AActor* Instigator, UAIReactChannel* OriginatingChannel);

	void ConditionalCheckActivate( AActor* Instigator, UAIReactChannel* OriginatingChannel );
};

struct AIReactCond_Conduit_Base_eventOutputFunction_Parms
{
    class AActor* EventInstigator;
    class UAIReactChannel* OrigChannel;
    AIReactCond_Conduit_Base_eventOutputFunction_Parms(EEventParm)
    {
    }
};
class UAIReactCond_Conduit_Base : public UAIReactCondition_Base
{
public:
    //## BEGIN PROPS AIReactCond_Conduit_Base
    FName OutputChannelName;
    FLOAT MinTimeBetweenActivations;
    FLOAT LastActivationTime;
    FScriptDelegate __OutputFunction__Delegate;
    //## END PROPS AIReactCond_Conduit_Base

    void delegateOutputFunction(class AActor* EventInstigator,class UAIReactChannel* OrigChannel)
    {
        AIReactCond_Conduit_Base_eventOutputFunction_Parms Parms(EC_EventParm);
        Parms.EventInstigator=EventInstigator;
        Parms.OrigChannel=OrigChannel;
        ProcessDelegate(GEARGAME_OutputFunction,&__OutputFunction__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UAIReactCond_Conduit_Base,UAIReactCondition_Base,0,GearGame)
	virtual UBOOL ShouldActivateNative(AActor* Instigator, UAIReactChannel* OriginatingChannel);
};

struct FLastThreshPosPair
{
    class APawn* Enemy;
    FVector Position;

    /** Constructors */
    FLastThreshPosPair() {}
    FLastThreshPosPair(EEventParm)
    {
        appMemzero(this, sizeof(FLastThreshPosPair));
    }
};

#define UCONST_ThreshPosBufferSize 20

class UAIReactCond_EnemyMoved : public UAIReactCond_Conduit_Base
{
public:
    //## BEGIN PROPS AIReactCond_EnemyMoved
    FLOAT DistanceThreshold;
    TArrayNoInit<struct FLastThreshPosPair> EnemyThreshList;
    INT RingBufIndex;
    //## END PROPS AIReactCond_EnemyMoved

    virtual UBOOL IsEnemyInNewLocation(class APawn* TestEnemy);
    DECLARE_FUNCTION(execIsEnemyInNewLocation)
    {
        P_GET_OBJECT(APawn,TestEnemy);
        P_FINISH;
        *(UBOOL*)Result=IsEnemyInNewLocation(TestEnemy);
    }
    DECLARE_CLASS(UAIReactCond_EnemyMoved,UAIReactCond_Conduit_Base,0,GearGame)
	void AddNewRec(APawn* Pawn);
	INT FindRec(APawn* Pawn, FVector& outLoc);
};

struct AIReactChannel_eventUnSuppress_Parms
{
    AIReactChannel_eventUnSuppress_Parms(EEventParm)
    {
    }
};
struct AIReactChannel_eventSuppress_Parms
{
    AIReactChannel_eventSuppress_Parms(EEventParm)
    {
    }
};
class UAIReactChannel : public UObject
{
public:
    //## BEGIN PROPS AIReactChannel
    FName ChannelName;
    BITFIELD bNeedsPoll:1;
    BITFIELD bChannelSuppressed:1;
    TArrayNoInit<class UAIReactCondition_Base*> Reactions;
    //## END PROPS AIReactChannel

    virtual void Subscribe(class UAIReactCondition_Base* Condition);
    virtual UBOOL UnSubscribe(class UAIReactCondition_Base* Condition);
    virtual class UAIReactCondition_Base* SuppressReactionByType(class UClass* Type);
    virtual class UAIReactCondition_Base* UnSuppressReactionByType(class UClass* Type);
    class UAIReactCondition_Base* FindReactionByType(class UClass* Type);
    virtual void NudgeChannel(class AActor* Instigator);
    DECLARE_FUNCTION(execSubscribe)
    {
        P_GET_OBJECT(UAIReactCondition_Base,Condition);
        P_FINISH;
        Subscribe(Condition);
    }
    DECLARE_FUNCTION(execUnSubscribe)
    {
        P_GET_OBJECT(UAIReactCondition_Base,Condition);
        P_FINISH;
        *(UBOOL*)Result=UnSubscribe(Condition);
    }
    DECLARE_FUNCTION(execSuppressReactionByType)
    {
        P_GET_OBJECT(UClass,Type);
        P_FINISH;
        *(class UAIReactCondition_Base**)Result=SuppressReactionByType(Type);
    }
    DECLARE_FUNCTION(execUnSuppressReactionByType)
    {
        P_GET_OBJECT(UClass,Type);
        P_FINISH;
        *(class UAIReactCondition_Base**)Result=UnSuppressReactionByType(Type);
    }
    DECLARE_FUNCTION(execFindReactionByType)
    {
        P_GET_OBJECT(UClass,Type);
        P_FINISH;
        *(class UAIReactCondition_Base**)Result=FindReactionByType(Type);
    }
    DECLARE_FUNCTION(execNudgeChannel)
    {
        P_GET_OBJECT(AActor,Instigator);
        P_FINISH;
        NudgeChannel(Instigator);
    }
    void eventUnSuppress()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_UnSuppress),NULL);
    }
    void eventSuppress()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_Suppress),NULL);
    }
    DECLARE_CLASS(UAIReactChannel,UObject,0,GearGame)
	void Init(FName NewChannelname);
	virtual void Poll(FLOAT DeltaTime){};
};

class UAIReactChan_Timer : public UAIReactChannel
{
public:
    //## BEGIN PROPS AIReactChan_Timer
    //## END PROPS AIReactChan_Timer

    virtual void Subscribe(class UAIReactCondition_Base* Condition);
    DECLARE_CLASS(UAIReactChan_Timer,UAIReactChannel,0,GearGame)
	virtual void Poll(FLOAT DeltaTime);
};

struct FIntrinsicChannel
{
    FName ChannelName;
    class UClass* ChannelClass;

    /** Constructors */
    FIntrinsicChannel() {}
    FIntrinsicChannel(EEventParm)
    {
        appMemzero(this, sizeof(FIntrinsicChannel));
    }
};

struct AIReactionManager_eventUnSuppressAll_Parms
{
    AIReactionManager_eventUnSuppressAll_Parms(EEventParm)
    {
    }
};
struct AIReactionManager_eventSuppressAll_Parms
{
    AIReactionManager_eventSuppressAll_Parms(EEventParm)
    {
    }
};
class UAIReactionManager : public UObject
{
public:
    //## BEGIN PROPS AIReactionManager
    TArrayNoInit<struct FIntrinsicChannel> IntrinsicChannels;
    TMap< FName,UAIReactChannel* > ChannelMap;
    class UClass* DefaultChannelClass;
    TArrayNoInit<class UAIReactChannel*> PollChannels;
    BITFIELD bAllReactionsSuppressed:1;
    TArrayNoInit<class UAIReactChannel*> BasicPerceptionChannels;
    //## END PROPS AIReactionManager

    void Subscribe(class UAIReactCondition_Base* Condition,FName ChannelName);
    UBOOL UnSubscribe(class UAIReactCondition_Base* Condition,FName ChannelName);
    void SuppressReactionsByType(class UClass* Type,UBOOL bDeepSearch);
    void SuppressAllChannels();
    void UnSuppressAllChannels();
    void SuppressChannel(FName ChannelName);
    void UnSuppressChannel(FName ChannelName);
    void SuppressReaction(class UAIReactCondition_Base* ReactCondition);
    void UnSuppressReactionsByType(class UClass* Type,UBOOL bDeepSearch);
    void UnSuppressReaction(class UAIReactCondition_Base* ReactCondition);
    class UAIReactCondition_Base* FindReactionByType(class UClass* Type,UBOOL bDeepSearch);
    virtual void NudgePerceptionChannel(class AActor* EventInstigator,BYTE Pt);
    virtual void NudgeChannel(class AActor* EventInstigator,FName ChannelName);
    virtual void Initialize();
    virtual void Wipe();
    class UAIReactChannel* GetChannelFor(FName ChannelName);
    DECLARE_FUNCTION(execSubscribe)
    {
        P_GET_OBJECT(UAIReactCondition_Base,Condition);
        P_GET_NAME(ChannelName);
        P_FINISH;
        Subscribe(Condition,ChannelName);
    }
    DECLARE_FUNCTION(execUnSubscribe)
    {
        P_GET_OBJECT(UAIReactCondition_Base,Condition);
        P_GET_NAME(ChannelName);
        P_FINISH;
        *(UBOOL*)Result=UnSubscribe(Condition,ChannelName);
    }
    DECLARE_FUNCTION(execSuppressReactionsByType)
    {
        P_GET_OBJECT(UClass,Type);
        P_GET_UBOOL(bDeepSearch);
        P_FINISH;
        SuppressReactionsByType(Type,bDeepSearch);
    }
    DECLARE_FUNCTION(execSuppressAllChannels)
    {
        P_FINISH;
        SuppressAllChannels();
    }
    DECLARE_FUNCTION(execUnSuppressAllChannels)
    {
        P_FINISH;
        UnSuppressAllChannels();
    }
    DECLARE_FUNCTION(execSuppressChannel)
    {
        P_GET_NAME(ChannelName);
        P_FINISH;
        SuppressChannel(ChannelName);
    }
    DECLARE_FUNCTION(execUnSuppressChannel)
    {
        P_GET_NAME(ChannelName);
        P_FINISH;
        UnSuppressChannel(ChannelName);
    }
    DECLARE_FUNCTION(execSuppressReaction)
    {
        P_GET_OBJECT(UAIReactCondition_Base,ReactCondition);
        P_FINISH;
        SuppressReaction(ReactCondition);
    }
    DECLARE_FUNCTION(execUnSuppressReactionsByType)
    {
        P_GET_OBJECT(UClass,Type);
        P_GET_UBOOL(bDeepSearch);
        P_FINISH;
        UnSuppressReactionsByType(Type,bDeepSearch);
    }
    DECLARE_FUNCTION(execUnSuppressReaction)
    {
        P_GET_OBJECT(UAIReactCondition_Base,ReactCondition);
        P_FINISH;
        UnSuppressReaction(ReactCondition);
    }
    DECLARE_FUNCTION(execFindReactionByType)
    {
        P_GET_OBJECT(UClass,Type);
        P_GET_UBOOL(bDeepSearch);
        P_FINISH;
        *(class UAIReactCondition_Base**)Result=FindReactionByType(Type,bDeepSearch);
    }
    DECLARE_FUNCTION(execNudgePerceptionChannel)
    {
        P_GET_OBJECT(AActor,EventInstigator);
        P_GET_BYTE(Pt);
        P_FINISH;
        NudgePerceptionChannel(EventInstigator,Pt);
    }
    DECLARE_FUNCTION(execNudgeChannel)
    {
        P_GET_OBJECT(AActor,EventInstigator);
        P_GET_NAME(ChannelName);
        P_FINISH;
        NudgeChannel(EventInstigator,ChannelName);
    }
    DECLARE_FUNCTION(execInitialize)
    {
        P_FINISH;
        Initialize();
    }
    DECLARE_FUNCTION(execWipe)
    {
        P_FINISH;
        Wipe();
    }
    DECLARE_FUNCTION(execGetChannelFor)
    {
        P_GET_NAME(ChannelName);
        P_FINISH;
        *(class UAIReactChannel**)Result=GetChannelFor(ChannelName);
    }
    void eventUnSuppressAll()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_UnSuppressAll),NULL);
    }
    void eventSuppressAll()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SuppressAll),NULL);
    }
    DECLARE_CLASS(UAIReactionManager,UObject,0,GearGame)
    DECLARE_WITHIN(AGearAI)
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	void Serialize( FArchive& Ar );
	void InitializeChannel( FName ChannelName, UAIReactChannel* ReactChan );
	typedef void (UAIReactCondition_Base::*ForEachFunction)();
	void ForEachReactionOfType(UClass* Type, ForEachFunction CallThisFunction);
	UClass* GetClassForChannelName(FName Name);
	void Tick(FLOAT DeltaTime);
};

class UGearCameraModifier : public UCameraModifier
{
public:
    //## BEGIN PROPS GearCameraModifier
    BYTE Priority;
    BITFIELD bExclusive:1 GCC_BITFIELD_MAGIC;
    FLOAT AlphaInTime;
    FLOAT AlphaOutTime;
    FLOAT Alpha;
    FLOAT TargetAlpha;
    //## END PROPS GearCameraModifier

    virtual UBOOL ModifyCamera(class ACamera* Camera,FLOAT DeltaTime,FTPOV& OutPOV);
    virtual void UpdateAlpha(class ACamera* Camera,FLOAT DeltaTime);
    virtual FLOAT GetTargetAlpha(class ACamera* Camera);
    DECLARE_FUNCTION(execUpdateAlpha)
    {
        P_GET_OBJECT(ACamera,Camera);
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateAlpha(Camera,DeltaTime);
    }
    DECLARE_FUNCTION(execGetTargetAlpha)
    {
        P_GET_OBJECT(ACamera,Camera);
        P_FINISH;
        *(FLOAT*)Result=GetTargetAlpha(Camera);
    }
    DECLARE_CLASS(UGearCameraModifier,UCameraModifier,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Camera");}

    NO_DEFAULT_CONSTRUCTOR(UGearCameraModifier)
};

class UGearCamMod_ScreenShake : public UGearCameraModifier
{
public:
    //## BEGIN PROPS GearCamMod_ScreenShake
    TArrayNoInit<struct FScreenShakeStruct> Shakes;
    struct FScreenShakeStruct TestShake;
    FLOAT TargetingAlpha;
    //## END PROPS GearCamMod_ScreenShake

    virtual void UpdateScreenShake(FLOAT DeltaTime,struct FScreenShakeStruct& Shake,FTPOV& OutPOV);
    virtual FLOAT GetTargetAlpha(class ACamera* Camera);
    virtual UBOOL ModifyCamera(class ACamera* Camera,FLOAT DeltaTime,FTPOV& OutPOV);
    DECLARE_FUNCTION(execUpdateScreenShake)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(struct FScreenShakeStruct,Shake);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        UpdateScreenShake(DeltaTime,Shake,OutPOV);
    }
    DECLARE_CLASS(UGearCamMod_ScreenShake,UGearCameraModifier,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearCamMod_ScreenShake)
};

struct FSpawnPawnInfo
{
    FStringNoInit PawnName;
    FStringNoInit ClassName;
    class UClass* AIClass;

    /** Constructors */
    FSpawnPawnInfo() {}
    FSpawnPawnInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSpawnPawnInfo));
    }
};

class UGearCheatManager : public UCheatManager
{
public:
    //## BEGIN PROPS GearCheatManager
    BITFIELD bDebugGUDSStreaming:1;
    TArrayNoInit<struct FSpawnPawnInfo> SpawnPawnList;
    //## END PROPS GearCheatManager

    virtual void ForceLog(const FString& S);
    void MS_SendDebugMessage(const FString& Message);
    void MS_GetSoundCueInfo();
    DECLARE_FUNCTION(execForceLog)
    {
        P_GET_STR(S);
        P_FINISH;
        ForceLog(S);
    }
    DECLARE_FUNCTION(execMS_SendDebugMessage)
    {
        P_GET_STR(Message);
        P_FINISH;
        MS_SendDebugMessage(Message);
    }
    DECLARE_FUNCTION(execMS_GetSoundCueInfo)
    {
        P_FINISH;
        MS_GetSoundCueInfo();
    }
    DECLARE_CLASS(UGearCheatManager,UCheatManager,0,GearGame)
    DECLARE_WITHIN(AGearPC)
    NO_DEFAULT_CONSTRUCTOR(UGearCheatManager)
};

struct FLevelRecord
{
    FName LevelName;
    BITFIELD bShouldBeLoaded:1;
    BITFIELD bShouldBeVisible:1;

    /** Constructors */
    FLevelRecord() {}
    FLevelRecord(EEventParm)
    {
        appMemzero(this, sizeof(FLevelRecord));
    }
};

struct FActorRecord
{
    FStringNoInit actorName;
    FStringNoInit ActorClassPath;
    TArrayNoInit<BYTE> RecordData;

    /** Constructors */
    FActorRecord() {}
    FActorRecord(EEventParm)
    {
        appMemzero(this, sizeof(FActorRecord));
    }
};

struct Checkpoint_eventPostSaveCheckpoint_Parms
{
    Checkpoint_eventPostSaveCheckpoint_Parms(EEventParm)
    {
    }
};
struct Checkpoint_eventPreSaveCheckpoint_Parms
{
    Checkpoint_eventPreSaveCheckpoint_Parms(EEventParm)
    {
    }
};
struct Checkpoint_eventPostLoadCheckpoint_Parms
{
    Checkpoint_eventPostLoadCheckpoint_Parms(EEventParm)
    {
    }
};
struct Checkpoint_eventPreLoadCheckpoint_Parms
{
    Checkpoint_eventPreLoadCheckpoint_Parms(EEventParm)
    {
    }
};
struct Checkpoint_eventCheckpointIsEmpty_Parms
{
    UBOOL ReturnValue;
    Checkpoint_eventCheckpointIsEmpty_Parms(EEventParm)
    {
    }
};
class UCheckpoint : public UObject
{
public:
    //## BEGIN PROPS Checkpoint
    INT SlotIndex;
    FStringNoInit BaseLevelName;
    BYTE Chapter;
    BYTE Difficulty;
    struct FCheckpointTime SaveTime;
    FVector CheckpointLocation;
    TArrayNoInit<struct FLevelRecord> LevelRecords;
    TArrayNoInit<struct FActorRecord> ActorRecords;
    TArrayNoInit<BYTE> KismetData;
    TArrayNoInit<class UClass*> ActorClassesToRecord;
    TArrayNoInit<class UClass*> ActorClassesToDestroy;
    TArrayNoInit<class UClass*> ActorClassesNotToDestroy;
    FStringNoInit DisplayName;
    //## END PROPS Checkpoint

    void eventPostSaveCheckpoint()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_PostSaveCheckpoint),NULL);
    }
    void eventPreSaveCheckpoint()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_PreSaveCheckpoint),NULL);
    }
    void eventPostLoadCheckpoint()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_PostLoadCheckpoint),NULL);
    }
    void eventPreLoadCheckpoint()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_PreLoadCheckpoint),NULL);
    }
    UBOOL eventCheckpointIsEmpty()
    {
        Checkpoint_eventCheckpointIsEmpty_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_CheckpointIsEmpty),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UCheckpoint,UObject,0,GearGame)
	/** serializes the final data that is written to disk into the specified archive */
	void SerializeFinalData(FArchive& Ar);
	void SaveData();
	void LoadData();
};

struct GearDecal_eventTick_Parms
{
    FLOAT DeltaTime;
    GearDecal_eventTick_Parms(EEventParm)
    {
    }
};
class UGearDecal : public UDecalComponent
{
public:
    //## BEGIN PROPS GearDecal
    class APawn* Instigator;
    BITFIELD bRandomizeRotation:1;
    BITFIELD bRandomizeScaling:1;
    BITFIELD ClipDecalsUsingFastPath:1;
    FVector2D RandomScalingRange;
    FLOAT LifeSpan;
    class UMaterialInstanceTimeVarying* MITV_Decal;
    FLOAT MinExplosionThickness;
    FLOAT MinImpactThickness;
    FLOAT PercentToSpawnOnFracturedMesh;
    //## END PROPS GearDecal

    void eventTick(FLOAT DeltaTime)
    {
        GearDecal_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GEARGAME_Tick),&Parms);
        }
    }
    DECLARE_CLASS(UGearDecal,UDecalComponent,0,GearGame)
	virtual void Tick(FLOAT DeltaTime)
	{
		Super::Tick(DeltaTime);
		LifeSpan -= DeltaTime;
		if (LifeSpan <= 0.f)
		{
			DetachFromAny();
		}
		else
		{
			eventTick(DeltaTime);
		}
	}
};

class UEmergenceHoleRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS EmergenceHoleRenderingComponent
    //## END PROPS EmergenceHoleRenderingComponent

    DECLARE_CLASS(UEmergenceHoleRenderingComponent,UPrimitiveComponent,0,GearGame)
	FPrimitiveSceneProxy* CreateSceneProxy();
};

class UGearCoverMeshComponent : public UCoverMeshComponent
{
public:
    //## BEGIN PROPS GearCoverMeshComponent
    TArrayNoInit<struct FCoverMeshes> GameplayMeshRefs;
    class UStaticMesh* GameplayAutoAdjustOn;
    class UStaticMesh* GameplayAutoAdjustOff;
    class UStaticMesh* GameplayDisabled;
    //## END PROPS GearCoverMeshComponent

    DECLARE_CLASS(UGearCoverMeshComponent,UCoverMeshComponent,0,GearGame)
	void UpdateMeshes();
};

struct CoverGoalConstraint_eventGetDumpString_Parms
{
    FString ReturnValue;
    CoverGoalConstraint_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct CoverGoalConstraint_eventInit_Parms
{
    class UGoal_AtCover* GoalEvaluator;
    CoverGoalConstraint_eventInit_Parms(EEventParm)
    {
    }
};
class UCoverGoalConstraint : public UObject
{
public:
    //## BEGIN PROPS CoverGoalConstraint
    INT ConstraintEvaluationPriority;
    //## END PROPS CoverGoalConstraint

    FString eventGetDumpString()
    {
        CoverGoalConstraint_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit(class UGoal_AtCover* GoalEvaluator)
    {
        CoverGoalConstraint_eventInit_Parms Parms(EC_EventParm);
        Parms.GoalEvaluator=GoalEvaluator;
        ProcessEvent(FindFunctionChecked(GEARGAME_Init),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UCoverGoalConstraint,UObject,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating){return TRUE;};
};

class UCovGoal_AvoidanceVolumes : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_AvoidanceVolumes
    //## END PROPS CovGoal_AvoidanceVolumes

    DECLARE_CLASS(UCovGoal_AvoidanceVolumes,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

struct FValidEnemyCacheDatum
{
    class AGearPawn* EnemyPawn;
    struct FCoverInfo EnemyCover;

    /** Constructors */
    FValidEnemyCacheDatum() {}
    FValidEnemyCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FValidEnemyCacheDatum));
    }
};

class UCovGoal_Enemies : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_Enemies
    TArrayNoInit<struct FValidEnemyCacheDatum> ValidEnemyCache;
    //## END PROPS CovGoal_Enemies

    virtual void Init(class UGoal_AtCover* GoalEvaluator);
    DECLARE_FUNCTION(execInit)
    {
        P_GET_OBJECT(UGoal_AtCover,GoalEvaluator);
        P_FINISH;
        Init(GoalEvaluator);
    }
    DECLARE_CLASS(UCovGoal_Enemies,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_EnemyProximity : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_EnemyProximity
    //## END PROPS CovGoal_EnemyProximity

    DECLARE_CLASS(UCovGoal_EnemyProximity,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_GoalProximity : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_GoalProximity
    FLOAT BestGoalDist;
    FLOAT MinGoalDist;
    FLOAT MaxGoalDist;
    BITFIELD bHardLimits:1;
    //## END PROPS CovGoal_GoalProximity

    DECLARE_CLASS(UCovGoal_GoalProximity,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_MovementDistance : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_MovementDistance
    FLOAT BestCoverDist;
    FLOAT MaxCoverDist;
    FLOAT MinCoverDist;
    BITFIELD bMoveTowardGoal:1;
    FLOAT MinDistTowardGoal;
    //## END PROPS CovGoal_MovementDistance

    DECLARE_CLASS(UCovGoal_MovementDistance,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_ProtectedByLocation : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_ProtectedByLocation
    FVector ThreatLocation;
    BITFIELD bOnlySlotsWithFireLinks:1;
    BITFIELD bForceMoveTowardGoal:1;
    //## END PROPS CovGoal_ProtectedByLocation

    DECLARE_CLASS(UCovGoal_ProtectedByLocation,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker( ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating );
};

class UCovGoal_SquadLeaderProximity : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_SquadLeaderProximity
    FVector SquadLeaderLocation;
    //## END PROPS CovGoal_SquadLeaderProximity

    DECLARE_CLASS(UCovGoal_SquadLeaderProximity,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_TeammateProximity : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_TeammateProximity
    //## END PROPS CovGoal_TeammateProximity

    DECLARE_CLASS(UCovGoal_TeammateProximity,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_WithinAllowedCoverLinks : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_WithinAllowedCoverLinks
    //## END PROPS CovGoal_WithinAllowedCoverLinks

    DECLARE_CLASS(UCovGoal_WithinAllowedCoverLinks,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_WithinCombatZones : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_WithinCombatZones
    //## END PROPS CovGoal_WithinCombatZones

    DECLARE_CLASS(UCovGoal_WithinCombatZones,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UCovGoal_WithinWeaponRange : public UCoverGoalConstraint
{
public:
    //## BEGIN PROPS CovGoal_WithinWeaponRange
    BITFIELD bHardConstraint:1;
    BITFIELD bIsLeader:1;
    //## END PROPS CovGoal_WithinWeaponRange

    DECLARE_CLASS(UCovGoal_WithinWeaponRange,UCoverGoalConstraint,0,GearGame)
	virtual UBOOL EvaluateCoverMarker(ACoverSlotMarker* Marker, APawn* SeekingPawn, AGearAI_Cover* SeekingAI, AActor* Goal, FLOAT& Rating);
};

class UGearDamageType : public UDamageType
{
public:
    //## BEGIN PROPS GearDamageType
    BYTE ImpactTypeBallisticID;
    BYTE ImpactTypeExplosionID;
    BYTE KillGUDEvent;
    BYTE DamageGUDEvent;
    BYTE DamageHeavyGUDEvent;
    BYTE DeathScreamEffortID;
    BYTE WeaponID;
    FLOAT HeadShotDamageScale;
    FLOAT HelmetRemovalChance;
    BITFIELD bAllowHeadShotGib:1;
    BITFIELD bAllowHeadShotExecution:1;
    BITFIELD bIgnoreCover:1;
    BITFIELD bLethal:1;
    BITFIELD bEnvironmentalDamage:1;
    BITFIELD bHighKickDeathAnimation:1;
    BITFIELD bAlwaysDamageFriendlies:1;
    BITFIELD bShouldCauseStumbles:1;
    BITFIELD bForceRagdollDeath:1;
    BITFIELD bDoOnDamageCodeCameraShake:1;
    BITFIELD bDoOnDamageAnimCameraShake:1;
    BITFIELD bSuppressImpactFX:1;
    BITFIELD bSuppressBloodDecals:1;
    BITFIELD bSuppressPlayExplosiveRadialDamageEffects:1;
    BITFIELD bUseLocationForIndicator:1;
    BITFIELD bCompensateDamageForDifficulty:1;
    FLOAT StoppingPower;
    INT ChainsawInterruptValue;
    FLOAT StumblePercent;
    INT NearMissPretentDamageValue;
    FLOAT FullBodyHitReactionAnimChance;
    FLOAT HitReactionTimeScale;
    FLOAT DistFromHitLocToGib;
    FCanvasIcon KilledByIcon;
    FCanvasIcon HeadshotIcon;
    FLOAT IconScale;
    struct FScreenShakeStruct OnDamageCodeCameraShake;
    struct FScreenShakeAnimStruct OnDamageAnimCameraShake;
    FLOAT OnDamageCameraShakeScale;
    //## END PROPS GearDamageType

    DECLARE_ABSTRACT_CLASS(UGearDamageType,UDamageType,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

    NO_DEFAULT_CONSTRUCTOR(UGearDamageType)
};

class UDifficultySettings : public UObject
{
public:
    //## BEGIN PROPS DifficultySettings
    BITFIELD bCanDBNO:1;
    BITFIELD bAllowAICOGDeathWhenDBNO:1;
    BITFIELD bHumanCOGCanBeExecuted:1;
    BITFIELD bAllowLocustBlindFire:1;
    FLOAT PlayerHealthMod;
    FLOAT PlayerHealthRechargeDelayMod;
    FLOAT PlayerHealthRechargeSpeedMod;
    FLOAT PlayerDamageMod;
    FLOAT PlayerActiveReloadWindowMod;
    FLOAT FriendHealthMod;
    FLOAT FriendHealthRechargeDelayMod;
    FLOAT FriendHealthRechargeSpeedMod;
    FLOAT FriendDamageMod;
    FLOAT ReviveAndExecuteDelayMod;
    FLOAT MPBotAimErrorMultiplier;
    FLOAT MPBotActiveReloadMultiplier;
    FLOAT MPBotHearingMultiplier;
    FLOAT MPBotRotationRateMultiplier;
    FLOAT EnemyEvadeChanceScale;
    FLOAT HordeScoreMultiplier;
    FLOAT HordeBleedOutTime;
    BYTE DifficultyLevel;
    //## END PROPS DifficultySettings

    DECLARE_ABSTRACT_CLASS(UDifficultySettings,UObject,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UDifficultySettings)
};

class UGearGameViewportClient : public UGameViewportClient
{
public:
    //## BEGIN PROPS GearGameViewportClient
    BYTE PrevTransitionType;
    BITFIELD bMakeNextLoadTransitionBlack:1 GCC_BITFIELD_MAGIC;
    //## END PROPS GearGameViewportClient

    DECLARE_CLASS(UGearGameViewportClient,UGameViewportClient,0|CLASS_Transient,GearGame)
	virtual void Draw(FViewport* Viewport,FCanvas* Canvas);

	/**
	* Callback to allow game viewport to override the splitscreen settings
	* @param NewSettings - settings to modify
	* @param SplitScreenType - current splitscreen type being used
	*/
	virtual void OverrideSplitscreenSettings(FSystemSettingsData& SplitscreenSettings,ESplitScreenType SplitScreenType) const;
};

struct FBloodDecalDatum
{
    BYTE Type;
    TArrayNoInit<struct FDecalData> DecalData;

    /** Constructors */
    FBloodDecalDatum() {}
    FBloodDecalDatum(EEventParm)
    {
        appMemzero(this, sizeof(FBloodDecalDatum));
    }
};

class UGearBloodInfo : public UObject
{
public:
    //## BEGIN PROPS GearBloodInfo
    INT Version;
    TArrayNoInit<struct FBloodDecalDatum> BloodInfo;
    //## END PROPS GearBloodInfo

    DECLARE_CLASS(UGearBloodInfo,UObject,0,GearGame)
	virtual void PostLoad();
};

struct FGearDecalDatum
{
    BYTE Type;
    TArrayNoInit<struct FDecalData> DecalData;

    /** Constructors */
    FGearDecalDatum() {}
    FGearDecalDatum(EEventParm)
    {
        appMemzero(this, sizeof(FGearDecalDatum));
    }
};

class UGearDecalInfo : public UObject
{
public:
    //## BEGIN PROPS GearDecalInfo
    INT Version;
    TArrayNoInit<struct FGearDecalDatum> DecalInfo;
    //## END PROPS GearDecalInfo

    DECLARE_CLASS(UGearDecalInfo,UObject,0,GearGame)
	virtual void PostLoad();
};

class UGearEventsInterface : public UObject
{
public:
    //## BEGIN PROPS GearEventsInterface
    INT NumEvents;
    BITFIELD bInit:1;
    //## END PROPS GearEventsInterface

    virtual UBOOL Init(INT MaxNumEvents);
    virtual void BeginLog();
    virtual void BeginEvent(const FString& EventName);
    virtual void AddParamInt(const FString& ParamName,INT ParamValue);
    virtual void AddParamFloat(const FString& ParamName,FLOAT ParamValue);
    virtual void AddParamString(const FString& ParamName,const FString& ParamValue);
    virtual void EndEvent();
    virtual void EndLog();
    DECLARE_FUNCTION(execInit)
    {
        P_GET_INT(MaxNumEvents);
        P_FINISH;
        *(UBOOL*)Result=Init(MaxNumEvents);
    }
    DECLARE_FUNCTION(execBeginLog)
    {
        P_FINISH;
        BeginLog();
    }
    DECLARE_FUNCTION(execBeginEvent)
    {
        P_GET_STR(EventName);
        P_FINISH;
        BeginEvent(EventName);
    }
    DECLARE_FUNCTION(execAddParamInt)
    {
        P_GET_STR(ParamName);
        P_GET_INT(ParamValue);
        P_FINISH;
        AddParamInt(ParamName,ParamValue);
    }
    DECLARE_FUNCTION(execAddParamFloat)
    {
        P_GET_STR(ParamName);
        P_GET_FLOAT(ParamValue);
        P_FINISH;
        AddParamFloat(ParamName,ParamValue);
    }
    DECLARE_FUNCTION(execAddParamString)
    {
        P_GET_STR(ParamName);
        P_GET_STR(ParamValue);
        P_FINISH;
        AddParamString(ParamName,ParamValue);
    }
    DECLARE_FUNCTION(execEndEvent)
    {
        P_FINISH;
        EndEvent();
    }
    DECLARE_FUNCTION(execEndLog)
    {
        P_FINISH;
        EndLog();
    }
    DECLARE_CLASS(UGearEventsInterface,UObject,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearEventsInterface)
};

struct FSettingInfo
{
    FName WidgetName;
    FStringNoInit Desc;

    /** Constructors */
    FSettingInfo() {}
    FSettingInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSettingInfo));
    }
};

struct FSettingInfo_Bool : public FSettingInfo
{
    FStringNoInit ValuesDesc[2];
    BITFIELD bValue:1;

    /** Constructors */
    FSettingInfo_Bool() {}
    FSettingInfo_Bool(EEventParm)
    {
        appMemzero(this, sizeof(FSettingInfo_Bool));
    }
};

struct FSettingInfo_Float : public FSettingInfo
{
    FLOAT MinValue;
    FLOAT MaxValue;
    FLOAT Value;

    /** Constructors */
    FSettingInfo_Float() {}
    FSettingInfo_Float(EEventParm)
    {
        appMemzero(this, sizeof(FSettingInfo_Float));
    }
};

struct FSettingInfo_Int : public FSettingInfo
{
    TArrayNoInit<INT> PotentialValues;
    TArrayNoInit<FString> ValuesDesc;
    INT Value;

    /** Constructors */
    FSettingInfo_Int() {}
    FSettingInfo_Int(EEventParm)
    {
        appMemzero(this, sizeof(FSettingInfo_Int));
    }
};

class UGearGameSettings : public UObject
{
public:
    //## BEGIN PROPS GearGameSettings
    struct FSettingInfo_Int Gore;
    struct FSettingInfo_Bool LanguageFilter;
    struct FSettingInfo_Int DisplayDevice;
    struct FSettingInfo_Bool ClosedCaptioning;
    struct FSettingInfo_Float Brightness;
    struct FSettingInfo_Int Splitscreen;
    struct FSettingInfo_Float MusicVolume;
    struct FSettingInfo_Float EffectsVolume;
    struct FSettingInfo_Bool InvertLook;
    //## END PROPS GearGameSettings

    void SaveInvertLook(UBOOL bLook);
    DECLARE_FUNCTION(execSaveInvertLook)
    {
        P_GET_UBOOL(bLook);
        P_FINISH;
        SaveInvertLook(bLook);
    }
    DECLARE_CLASS(UGearGameSettings,UObject,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	UBOOL GetWidgetIntSetting( class UUIObject* Widget, FSettingInfo_Int** IntSetting );
	UBOOL GetWidgetBoolSetting( class UUIObject* Widget, FSettingInfo_Bool** BoolSetting );
	UBOOL GetWidgetFloatSetting( class UUIObject* Widget, FSettingInfo_Float** FloatSetting );

	void LoadSceneValues( class UUIScene* Scene );
	void SaveSceneValues( class UUIScene* Scene );

	void LoadIntValue( FSettingInfo_Int& Setting, class UUILabelButton* LabelButtonWidget );
	void SaveIntValue( FSettingInfo_Int& Setting, class UUILabelButton* LabelButtonWidget );

	void LoadFloatValue( FSettingInfo_Float& Setting, class UUISlider* SliderWidget );
	void SaveFloatValue( FSettingInfo_Float& Setting, class UUISlider* SliderWidget );

	void LoadBoolValue( FSettingInfo_Bool& Setting, class UUILabelButton* LabelButtonWidget );
	void SaveBoolValue( FSettingInfo_Bool& Setting, class UUILabelButton* LabelButtonWidget );

	void LoadWidgetValue( class UUIObject* Widget );
	UBOOL SaveWidgetValue( class UUIObject* Widget );

	void GetNextValue( class UUIObject* Widget );
	void GetPrevValue( class UUIObject* Widget );

	/** @return Whether or not the specified widget can navigate right. */
	UBOOL HasNextValue( class UUIObject* Widget );

	/** @return Whether or not the specified widget can navigate left. */
	UBOOL HasPrevValue( class UUIObject* Widget );
};

class UGearObjectiveManager : public UObject
{
public:
    //## BEGIN PROPS GearObjectiveManager
    TArrayNoInit<struct FObjectiveInfo> Objectives;
    FLOAT TotalDisplayTime;
    INT TotalObjectivesToDraw;
    FStringNoInit ObjectivesCompleteText;
    //## END PROPS GearObjectiveManager

    virtual FString RetrieveObjectiveString(const FString& TagName);
    DECLARE_FUNCTION(execRetrieveObjectiveString)
    {
        P_GET_STR(TagName);
        P_FINISH;
        *(FString*)Result=RetrieveObjectiveString(TagName);
    }
    DECLARE_CLASS(UGearObjectiveManager,UObject,0,GearGame)
    DECLARE_WITHIN(AGearPC)
    NO_DEFAULT_CONSTRUCTOR(UGearObjectiveManager)
};

struct GearScreenshotManager_eventOnUploadScreenshotComplete_Parms
{
    UBOOL bWasSuccessful;
    GearScreenshotManager_eventOnUploadScreenshotComplete_Parms(EEventParm)
    {
    }
};
struct GearScreenshotManager_eventOnLoadScreenshotComplete_Parms
{
    UBOOL bWasSuccessful;
    GearScreenshotManager_eventOnLoadScreenshotComplete_Parms(EEventParm)
    {
    }
};
struct GearScreenshotManager_eventOnEnumerateScreenshotsComplete_Parms
{
    UBOOL bWasSuccessful;
    GearScreenshotManager_eventOnEnumerateScreenshotsComplete_Parms(EEventParm)
    {
    }
};
struct GearScreenshotManager_eventOnSaveScreenshotComplete_Parms
{
    UBOOL bWasSuccessful;
    GearScreenshotManager_eventOnSaveScreenshotComplete_Parms(EEventParm)
    {
    }
};
class UGearScreenshotManager : public UObject
{
public:
    //## BEGIN PROPS GearScreenshotManager
    class FGearScreenshotIO* ScreenshotIO;
    INT ScreenshotContentType;
    INT ScreenshotBaseRecordId;
    TArrayNoInit<FScriptDelegate> SaveScreenshotCompleteDelegates;
    TArrayNoInit<FScriptDelegate> EnumerateScreenshotsCompleteDelegates;
    TArrayNoInit<FScriptDelegate> LoadScreenshotCompleteDelegates;
    TArrayNoInit<FScriptDelegate> UploadScreenshotCompleteDelegates;
    FScriptDelegate __OnSaveScreenshotComplete__Delegate;
    FScriptDelegate __OnEnumerateScreenshotsComplete__Delegate;
    FScriptDelegate __OnLoadScreenshotComplete__Delegate;
    FScriptDelegate __OnUploadScreenshotComplete__Delegate;
    //## END PROPS GearScreenshotManager

    virtual UBOOL Init();
    virtual UBOOL SaveScreenshot(const TArray<BYTE>& Image,const TArray<BYTE>& Thumbnail,const struct FScreenshotInfo& Info);
    virtual UBOOL DeleteScreenshot(FGuid Id,INT DeviceID);
    virtual UBOOL EnumerateScreenshots(TArray<struct FSavedScreenshotInfo>& Screenshots);
    virtual UBOOL LoadScreenshot(const FGuid& Id,INT DeviceID,TArray<BYTE>& Image,struct FScreenshotInfo& Info);
    class ULocalPlayer* GetPlayerOwner() const;
    INT GetPlayerControllerId() const;
    void ScreenshotToTexture(const TArray<BYTE>& Image,class UTexture2DDynamic*& Texture);
    void GuidToString(const FGuid InGuid,FString& OutString);
    virtual void StringToAnsiBlob(const FString& InString,TArray<BYTE>& OutBlob);
    virtual void XmlWriteStartTag(FString& Xml,const FString& TagName,INT Indent);
    virtual void XmlBeginStartTag(FString& Xml,const FString& TagName,INT Indent);
    virtual void XmlEndStartTag(FString& Xml,UBOOL Close);
    virtual void XmlWriteEndTag(FString& Xml,const FString& TagName,INT Indent=-1);
    virtual void XmlWriteAttributeString(FString& Xml,const FString& Attribute,const FString& Value);
    virtual void XmlWriteAttributeBool(FString& Xml,const FString& Attribute,UBOOL Value);
    virtual void XmlWriteAttributeInt(FString& Xml,const FString& Attribute,INT Value);
    virtual void XmlWriteAttributeFloat(FString& Xml,const FString& Attribute,FLOAT Value);
    virtual void XmlWriteAttributeQword(FString& Xml,const FString& Attribute,INT Value1,INT Value2);
    virtual void XmlWriteContent(FString& Xml,const FString& Content);
    DECLARE_FUNCTION(execInit)
    {
        P_FINISH;
        *(UBOOL*)Result=Init();
    }
    DECLARE_FUNCTION(execSaveScreenshot)
    {
        P_GET_TARRAY(BYTE,Image);
        P_GET_TARRAY(BYTE,Thumbnail);
        P_GET_STRUCT_INIT_REF(struct FScreenshotInfo,Info);
        P_FINISH;
        *(UBOOL*)Result=SaveScreenshot(Image,Thumbnail,Info);
    }
    DECLARE_FUNCTION(execDeleteScreenshot)
    {
        P_GET_STRUCT(FGuid,Id);
        P_GET_INT(DeviceID);
        P_FINISH;
        *(UBOOL*)Result=DeleteScreenshot(Id,DeviceID);
    }
    DECLARE_FUNCTION(execEnumerateScreenshots)
    {
        P_GET_TARRAY_REF(struct FSavedScreenshotInfo,Screenshots);
        P_FINISH;
        *(UBOOL*)Result=EnumerateScreenshots(Screenshots);
    }
    DECLARE_FUNCTION(execLoadScreenshot)
    {
        P_GET_STRUCT_REF(FGuid,Id);
        P_GET_INT(DeviceID);
        P_GET_TARRAY_REF(BYTE,Image);
        P_GET_STRUCT_INIT_REF(struct FScreenshotInfo,Info);
        P_FINISH;
        *(UBOOL*)Result=LoadScreenshot(Id,DeviceID,Image,Info);
    }
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner();
    }
    DECLARE_FUNCTION(execGetPlayerControllerId)
    {
        P_FINISH;
        *(INT*)Result=GetPlayerControllerId();
    }
    DECLARE_FUNCTION(execScreenshotToTexture)
    {
        P_GET_TARRAY_REF(BYTE,Image);
        P_GET_OBJECT_REF(UTexture2DDynamic,Texture);
        P_FINISH;
        ScreenshotToTexture(Image,Texture);
    }
    DECLARE_FUNCTION(execGuidToString)
    {
        P_GET_STRUCT(FGuid,InGuid);
        P_GET_STR_REF(OutString);
        P_FINISH;
        GuidToString(InGuid,OutString);
    }
    DECLARE_FUNCTION(execStringToAnsiBlob)
    {
        P_GET_STR_REF(InString);
        P_GET_TARRAY_REF(BYTE,OutBlob);
        P_FINISH;
        StringToAnsiBlob(InString,OutBlob);
    }
    DECLARE_FUNCTION(execXmlWriteStartTag)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(TagName);
        P_GET_INT(Indent);
        P_FINISH;
        XmlWriteStartTag(Xml,TagName,Indent);
    }
    DECLARE_FUNCTION(execXmlBeginStartTag)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(TagName);
        P_GET_INT(Indent);
        P_FINISH;
        XmlBeginStartTag(Xml,TagName,Indent);
    }
    DECLARE_FUNCTION(execXmlEndStartTag)
    {
        P_GET_STR_REF(Xml);
        P_GET_UBOOL(Close);
        P_FINISH;
        XmlEndStartTag(Xml,Close);
    }
    DECLARE_FUNCTION(execXmlWriteEndTag)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(TagName);
        P_GET_INT_OPTX(Indent,-1);
        P_FINISH;
        XmlWriteEndTag(Xml,TagName,Indent);
    }
    DECLARE_FUNCTION(execXmlWriteAttributeString)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(Attribute);
        P_GET_STR(Value);
        P_FINISH;
        XmlWriteAttributeString(Xml,Attribute,Value);
    }
    DECLARE_FUNCTION(execXmlWriteAttributeBool)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(Attribute);
        P_GET_UBOOL(Value);
        P_FINISH;
        XmlWriteAttributeBool(Xml,Attribute,Value);
    }
    DECLARE_FUNCTION(execXmlWriteAttributeInt)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(Attribute);
        P_GET_INT(Value);
        P_FINISH;
        XmlWriteAttributeInt(Xml,Attribute,Value);
    }
    DECLARE_FUNCTION(execXmlWriteAttributeFloat)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(Attribute);
        P_GET_FLOAT(Value);
        P_FINISH;
        XmlWriteAttributeFloat(Xml,Attribute,Value);
    }
    DECLARE_FUNCTION(execXmlWriteAttributeQword)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(Attribute);
        P_GET_INT(Value1);
        P_GET_INT(Value2);
        P_FINISH;
        XmlWriteAttributeQword(Xml,Attribute,Value1,Value2);
    }
    DECLARE_FUNCTION(execXmlWriteContent)
    {
        P_GET_STR_REF(Xml);
        P_GET_STR(Content);
        P_FINISH;
        XmlWriteContent(Xml,Content);
    }
    void delegateOnUploadScreenshotComplete(UBOOL bWasSuccessful)
    {
        GearScreenshotManager_eventOnUploadScreenshotComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(GEARGAME_OnUploadScreenshotComplete,&__OnUploadScreenshotComplete__Delegate,&Parms);
    }
    void delegateOnLoadScreenshotComplete(UBOOL bWasSuccessful)
    {
        GearScreenshotManager_eventOnLoadScreenshotComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(GEARGAME_OnLoadScreenshotComplete,&__OnLoadScreenshotComplete__Delegate,&Parms);
    }
    void delegateOnEnumerateScreenshotsComplete(UBOOL bWasSuccessful)
    {
        GearScreenshotManager_eventOnEnumerateScreenshotsComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(GEARGAME_OnEnumerateScreenshotsComplete,&__OnEnumerateScreenshotsComplete__Delegate,&Parms);
    }
    void delegateOnSaveScreenshotComplete(UBOOL bWasSuccessful)
    {
        GearScreenshotManager_eventOnSaveScreenshotComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(GEARGAME_OnSaveScreenshotComplete,&__OnSaveScreenshotComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UGearScreenshotManager,UObject,0|CLASS_Transient|CLASS_Config,GearGame)
    DECLARE_WITHIN(AGearPC)
    static const TCHAR* StaticConfigName() {return TEXT("Pawn");}

    NO_DEFAULT_CONSTRUCTOR(UGearScreenshotManager)
};

struct GearTutorial_Base_eventUpdate_Parms
{
    GearTutorial_Base_eventUpdate_Parms(EEventParm)
    {
    }
};
class UGearTutorial_Base : public UObject
{
public:
    //## BEGIN PROPS GearTutorial_Base
    BITFIELD bFreezeGameplay:1;
    BITFIELD bPauseGameplay:1;
    BITFIELD bWaitForFirstTimeLapse:1;
    BITFIELD bOptionControlled:1;
    BITFIELD bTutorialIsReadyForActivation:1;
    BITFIELD bSaveTutorialToProfile:1;
    BITFIELD bIsKismetTutorial:1;
    BITFIELD bTutorialIsActive:1;
    BITFIELD bTutorialIsComplete:1;
    BITFIELD bGameplayIsFrozen:1;
    BITFIELD bGameplayIsPaused:1;
    BITFIELD bTutorialHasUIScene:1;
    BITFIELD bSceneIsOpen:1;
    BITFIELD bSceneHasBeenOpened:1;
    FLOAT SceneOpenTimeAmount;
    FLOAT ElapsedTimeToRepeatScene;
    FStringNoInit LocalizedBodyText;
    FStringNoInit LocalizedTitleText;
    FStringNoInit LocalizedButtonText;
    FStringNoInit LocalizedKeyboardBodyText;
    FStringNoInit LocalizedAlternateBodyText;
    FStringNoInit LocalizedAlternateButtonText;
    FStringNoInit LocalizedCoopTitleTextHost;
    FStringNoInit LocalizedCoopTitleTextClient;
    FStringNoInit LocalizedCoopBodyTextHost;
    FStringNoInit LocalizedCoopBodyTextClient;
    BYTE TutorialType;
    class UClass* InputHandlerClass;
    class UUIScene* SceneReference;
    INT TutorialPriority;
    class UGearTutorialManager* TutorialMgr;
    class UGearPlayerInput_Base* InputHandler;
    class USeqAct_ManageTutorials* TutorialAction;
    class UAudioComponent* MusicLoopAC;
    class UUIScene* SceneInstance;
    FLOAT TimeOfSceneOpen;
    FLOAT NextTimeForSceneOpen;
    //## END PROPS GearTutorial_Base

    void eventUpdate()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_Update),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UGearTutorial_Base,UObject,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UGearTutorial_Base)
};

#define UCONST_TUTORIAL_PRIORITY_IMMEDIATE 600
#define UCONST_TUTORIAL_PRIORITY_HIGH 500
#define UCONST_TUTORIAL_PRIORITY_NORMAL 400
#define UCONST_TUTORIAL_PRIORITY_LOW 300
#define UCONST_TUTORIAL_PRIORITY_AUTOINIT_WEAPON 100
#define UCONST_TUTORIAL_PRIORITY_AUTOINIT 200

struct GearTutorialManager_eventSetNextActiveTutorial_Parms
{
    GearTutorialManager_eventSetNextActiveTutorial_Parms(EEventParm)
    {
    }
};
struct GearTutorialManager_eventDeactivateTutorial_Parms
{
    UBOOL bReadyForActivation;
    GearTutorialManager_eventDeactivateTutorial_Parms(EEventParm)
    {
    }
};
struct GearTutorialManager_eventOnTutorialCompleted_Parms
{
    class UGearTutorial_Base* CompletedTutorial;
    GearTutorialManager_eventOnTutorialCompleted_Parms(EEventParm)
    {
    }
};
class UGearTutorialManager : public UObject
{
public:
    //## BEGIN PROPS GearTutorialManager
    TArrayNoInit<class UClass*> TutorialClasses;
    TArrayNoInit<BYTE> SPAutoInitiatedTutorialTypes;
    TArrayNoInit<BYTE> MPAutoInitiatedTutorialTypes;
    TArrayNoInit<BYTE> TrainAutoInitiatedTutorialTypes_1;
    TArrayNoInit<BYTE> TrainAutoInitiatedTutorialTypes_2;
    TArrayNoInit<BYTE> TrainAutoInitiatedTutorialTypes_3;
    TArrayNoInit<BYTE> TrainAutoInitiatedTutorialTypes_4;
    TArrayNoInit<BYTE> TrainAutoInitiatedTutorialTypes_5;
    BYTE AutoInitType;
    BITFIELD bAutoTutorialsSuspended:1 GCC_BITFIELD_MAGIC;
    BITFIELD bTutorialSystemIsActive:1;
    BITFIELD bGameIsUsingAutoTutorials:1;
    TArrayNoInit<class UGearTutorial_Base*> Tutorials;
    class UGearTutorial_Base* ActiveTutorial;
    class UGearPlayerInput_Base* CurrentTutorialInputHandler;
    INT CompletedTutorialsSP1;
    INT CompletedTutorialsSP2;
    INT CompletedTutorialsSP3;
    INT CompletedTutorialsMP1;
    INT CompletedTutorialsMP2;
    INT CompletedTutorialsMP3;
    INT CompletedTutorialsTrain1;
    INT CompletedTutorialsTrain2;
    INT CompletedTutorialsTrain3;
    class UAudioComponent* TutorialSoundAC;
    //## END PROPS GearTutorialManager

    void eventSetNextActiveTutorial()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SetNextActiveTutorial),NULL);
    }
    void eventDeactivateTutorial(UBOOL bReadyForActivation=FALSE)
    {
        GearTutorialManager_eventDeactivateTutorial_Parms Parms(EC_EventParm);
        Parms.bReadyForActivation=bReadyForActivation ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_DeactivateTutorial),&Parms);
    }
    void eventOnTutorialCompleted(class UGearTutorial_Base* CompletedTutorial)
    {
        GearTutorialManager_eventOnTutorialCompleted_Parms Parms(EC_EventParm);
        Parms.CompletedTutorial=CompletedTutorial;
        ProcessEvent(FindFunctionChecked(GEARGAME_OnTutorialCompleted),&Parms);
    }
    DECLARE_CLASS(UGearTutorialManager,UObject,0|CLASS_Transient|CLASS_Config,GearGame)
    DECLARE_WITHIN(AGearPC)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Checks to see if there is an active tutorial, and if not it will
	 * look for a new tutorial to start
	 */
	void Update();
};

#define UCONST_GAMEEVENT_MATCH_END 22
#define UCONST_GAMEEVENT_MATCH_BEGIN 21
#define UCONST_GAMEEVENT_ROUND_END 20
#define UCONST_GAMEEVENT_ROUND_BEGIN 19
#define UCONST_GAMEEVENT_PLAYER_REVIVED 18
#define UCONST_GAMEEVENT_PLAYER_REVIVE 17
#define UCONST_GAMEEVENT_PLAYER_KNOCKEDDBNO 16
#define UCONST_GAMEEVENT_PLAYER_KNOCKEDDOWN 15
#define UCONST_GAMEEVENT_PLAYER_LEFTCOVER 14
#define UCONST_GAMEEVENT_PLAYER_ENTEREDCOVER 13
#define UCONST_GAMEEVENT_PLAYER_SPECIALMOVE 12
#define UCONST_GAMEEVENT_PLAYER_DEATH_GIB 11
#define UCONST_GAMEEVENT_PLAYER_DEATH_HEADSHOT 10
#define UCONST_GAMEEVENT_PLAYER_DEATH_BLEDOUT 9
#define UCONST_GAMEEVENT_PLAYER_DEATH_EXECUTION 8
#define UCONST_GAMEEVENT_PLAYER_DEATH 7
#define UCONST_GAMEEVENT_PLAYER_KILL_GIB 6
#define UCONST_GAMEEVENT_PLAYER_KILL_HEADSHOT 5
#define UCONST_GAMEEVENT_PLAYER_KILL_EXECUTION 4
#define UCONST_GAMEEVENT_PLAYER_KILL 3
#define UCONST_GAMEEVENT_PLAYER_LOGOUT 2
#define UCONST_GAMEEVENT_PLAYER_LOGIN 1

class UGearStatsObject : public UOnlineGameplayEvents
{
public:
    //## BEGIN PROPS GearStatsObject
    INT GearsStatsRunID;
    INT EstimatedStatBytes;
    INT AllowedStatsMask;
    BITFIELD bUglyHordeHackFlag:1;
    TArrayNoInit<FName> HordeIgnoreEvents;
    //## END PROPS GearStatsObject

    void BeginGameplaySession();
    void LogGameplayEvent(INT EventMask,FName EventName,class AController* Player,const FString& Desc,class AController* TargetPlayer=NULL,FVector EventLocation=FVector(EC_EventParm));
    void EndGameplaySession();
    void SendGameEventsToDB();
    void DumpGameplayStats();
    DECLARE_FUNCTION(execBeginGameplaySession)
    {
        P_FINISH;
        BeginGameplaySession();
    }
    DECLARE_FUNCTION(execLogGameplayEvent)
    {
        P_GET_INT(EventMask);
        P_GET_NAME(EventName);
        P_GET_OBJECT(AController,Player);
        P_GET_STR(Desc);
        P_GET_OBJECT_OPTX(AController,TargetPlayer,NULL);
        P_GET_STRUCT_OPTX(FVector,EventLocation,FVector(EC_EventParm));
        P_FINISH;
        LogGameplayEvent(EventMask,EventName,Player,Desc,TargetPlayer,EventLocation);
    }
    DECLARE_FUNCTION(execEndGameplaySession)
    {
        P_FINISH;
        EndGameplaySession();
    }
    DECLARE_FUNCTION(execSendGameEventsToDB)
    {
        P_FINISH;
        SendGameEventsToDB();
    }
    DECLARE_FUNCTION(execDumpGameplayStats)
    {
        P_FINISH;
        DumpGameplayStats();
    }
    DECLARE_CLASS(UGearStatsObject,UOnlineGameplayEvents,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	void SummarizeGameplayEvents(TArray<FGameplayEvent> &Events, FArchive *Ar);
	INT ResolvePlayerIndex(AController *Player);
};

class UPath_CoverSlotsOnly : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_CoverSlotsOnly
    //## END PROPS Path_CoverSlotsOnly

    DECLARE_CLASS(UPath_CoverSlotsOnly,UPathConstraint,0,GearGame)
	virtual UBOOL EvaluatePath(UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost)
	{
		return (Cast<ACoverSlotMarker>(*Spec->End) != NULL);
	}
};

class UGoal_AwayFromPosition : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_AwayFromPosition
    FVector AvoidPos;
    FVector AvoidDir;
    INT MaxDist;
    class ANavigationPoint* BestNode;
    INT BestRating;
    //## END PROPS Goal_AwayFromPosition

    DECLARE_CLASS(UGoal_AwayFromPosition,UPathGoalEvaluator,0,GearGame)
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal( ANavigationPoint*& out_GoalNav );
};

class UGoal_FarthestNavInRange : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_FarthestNavInRange
    INT OptimalMaxDist;
    TArrayNoInit<class ANavigationPoint*> GoalList;
    class ANavigationPoint* CurrentBest;
    //## END PROPS Goal_FarthestNavInRange

    DECLARE_CLASS(UGoal_FarthestNavInRange,UPathGoalEvaluator,0,GearGame)
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal(ANavigationPoint*& out_GoalNav);
};

struct FFormationEvalInfo
{
    INT PosIdx;
    class AActor* QueryActor;
    TMap< AActor*,FLOAT > ActorList;

    /** Constructors */
    FFormationEvalInfo() {}
    FFormationEvalInfo(EEventParm)
    {
        appMemzero(this, sizeof(FFormationEvalInfo));
    }
};

class UGoal_SquadFormation : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_SquadFormation
    TArrayNoInit<struct FFormationEvalInfo> PositionList;
    class AGearAI* SeekerAI;
    INT PositionIdx;
    class AGearSquadFormation* Formation;
    //## END PROPS Goal_SquadFormation

    virtual void ClearPositionList();
    DECLARE_FUNCTION(execClearPositionList)
    {
        P_FINISH;
        ClearPositionList();
    }
    DECLARE_CLASS(UGoal_SquadFormation,UPathGoalEvaluator,0,GearGame)
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal(ANavigationPoint*& out_GoalNav);

	AActor* GetBestPosition( TArray<AActor*> &UsedList, UBOOL bRetKey, INT& out_PosIdx );
	void	WeightPositionsBySquadMembers();
};

struct FImpactFXBase
{
    TArrayNoInit<struct FDecalData> DecalData;
    TArrayNoInit<struct FDecalData> DecalData_AR;
    TArrayNoInit<struct FDecalData> DecalData_NoGore;
    TArrayNoInit<struct FDecalData> DecalData_NoGore_AR;
    class USoundCue* ImpactCue;
    class UParticleSystem* ImpactPS;
    class UParticleSystem* ImpactPS_ForSlowPerf;
    class UParticleSystem* ImpactPS_AR;
    class UParticleSystem* ImpactPS_AR_ForSlowPerf;
    class UParticleSystem* ImpactPS_NoGore;
    class UParticleSystem* ImpactPS_NoGore_ForSlowPerf;
    class UParticleSystem* ImpactPS_NoGore_AR;
    class UParticleSystem* ImpactPS_NoGore_ForSlowPerf_AR;
    class UClass* CameraEffect;
    FLOAT CameraEffectRadius;

    /** Constructors */
    FImpactFXBase() {}
    FImpactFXBase(EEventParm)
    {
        appMemzero(this, sizeof(FImpactFXBase));
    }
};

struct FImpactFXBallistic : public FImpactFXBase
{
    BYTE Type;
    class UParticleSystem* ExitWoundPS;
    class UParticleSystem* ExitWoundPS_ForSlowPerf;

    /** Constructors */
    FImpactFXBallistic() {}
    FImpactFXBallistic(EEventParm)
    {
        appMemzero(this, sizeof(FImpactFXBallistic));
    }
};

struct FImpactFXExplosion : public FImpactFXBase
{
    BYTE Type;
    class UObject* FogVolumeArchetype;
    class UObject* FogVolumeArchetype_ForSlowPerf;

    /** Constructors */
    FImpactFXExplosion() {}
    FImpactFXExplosion(EEventParm)
    {
        appMemzero(this, sizeof(FImpactFXExplosion));
    }
};

struct FFootStepsDatum
{
    BYTE Type;
    class USoundCue* FootStep;
    class USoundCue* Landing;
    class USoundCue* Leaping;
    class USoundCue* Sliding;
    class UParticleSystem* FootstepEffectPS;

    /** Constructors */
    FFootStepsDatum() {}
    FFootStepsDatum(EEventParm)
    {
        appMemzero(this, sizeof(FFootStepsDatum));
    }
};

class UGearPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
    //## BEGIN PROPS GearPhysicalMaterialProperty
    INT Version;
    struct FImpactFXBallistic DefaultFXInfoBallistic;
    struct FImpactFXExplosion DefaultFXInfoExplosion;
    TArrayNoInit<struct FImpactFXBallistic> FXInfoBallistic;
    TArrayNoInit<struct FImpactFXExplosion> FXInfoExplosion;
    TArrayNoInit<struct FFootStepsDatum> FootStepInfo;
    class UParticleSystem* FootstepEffectWalk;
    class UParticleSystem* FootstepEffectRun;
    class UParticleSystem* RoadieRun;
    class UParticleSystem* EvadeEffect;
    class UClass* EvadeCameraLensEffect;
    class UParticleSystem* SlideIntoCoverEffect;
    class UParticleSystem* SlideIntoCoverNonPlayerEffect;
    class UClass* SlideIntoCoverCameraLensEffect;
    class UGearBloodInfo* BloodInfo;
    class UGearDecalInfo* DecalInfo;
    //## END PROPS GearPhysicalMaterialProperty

    DECLARE_CLASS(UGearPhysicalMaterialProperty,UPhysicalMaterialPropertyBase,0,GearGame)
protected:
	void RefreshTypeData();

private:
	/**
	* Make sure all decal struct defaults have valid values
	*
	* @param DecalDataEntries - decal data struct array of entries to fixup
	**/
	void FixupDecalDataStructDefaults( TArray<FDecalData>& DecalDataEntries );

public:
	virtual void PostLoad();
	virtual void PostEditChange( class FEditPropertyChain& PropertyThatChanged );
};

class ULeapReachSpec : public UAdvancedReachSpec
{
public:
    //## BEGIN PROPS LeapReachSpec
    FVector CachedVelocity;
    FLOAT RequiredJumpZ;
    //## END PROPS LeapReachSpec

    DECLARE_CLASS(ULeapReachSpec,UAdvancedReachSpec,0,GearGame)
	virtual INT CostFor(APawn* P);
	virtual UBOOL CanBeSkipped(APawn* P)
	{
		return FALSE;
	}
};

#define UCONST_MAX_DATASIZE_FOR_ALL_CHECKPOINTS 10000000

struct GearEngine_eventAreStorageWritesAllowed_Parms
{
    UBOOL bIgnoreDeviceStatus;
    INT RequiredSize;
    UBOOL ReturnValue;
    GearEngine_eventAreStorageWritesAllowed_Parms(EEventParm)
    {
    }
};
struct GearEngine_eventIsCurrentDeviceValid_Parms
{
    INT SizeNeeded;
    UBOOL ReturnValue;
    GearEngine_eventIsCurrentDeviceValid_Parms(EEventParm)
    {
    }
};
class UGearEngine : public UGameEngine
{
public:
    //## BEGIN PROPS GearEngine
    FVector PendingCheckpointLocation;
    BYTE PendingCheckpointAction;
    class UCheckpoint* CurrentCheckpoint;
    INT CurrentUserID;
private:
    INT CurrentDeviceID;
public:
    BITFIELD bShouldWriteCheckpointToDisk:1;
    BITFIELD bHasSelectedValidStorageDevice:1;
    INT FailureMemoryHackThreshold;
    //## END PROPS GearEngine

    void SetCurrentDeviceID(INT NewDeviceID,UBOOL bProfileSignedOut=FALSE);
    INT GetCurrentDeviceID() const;
    UBOOL HasStorageDeviceBeenRemoved() const;
    UBOOL FindCheckpointData(INT SlotIndex,struct FCheckpointEnumerationResult* EnumResult=NULL);
    void SaveCheckpoint(FVector CheckpointLocation);
    void LoadCheckpoint();
    UBOOL DeleteCheckpoints(INT* ResultCode=NULL);
    UBOOL NeedMemoryHack();
    DECLARE_FUNCTION(execSetCurrentDeviceID)
    {
        P_GET_INT(NewDeviceID);
        P_GET_UBOOL_OPTX(bProfileSignedOut,FALSE);
        P_FINISH;
        SetCurrentDeviceID(NewDeviceID,bProfileSignedOut);
    }
    DECLARE_FUNCTION(execGetCurrentDeviceID)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentDeviceID();
    }
    DECLARE_FUNCTION(execHasStorageDeviceBeenRemoved)
    {
        P_FINISH;
        *(UBOOL*)Result=HasStorageDeviceBeenRemoved();
    }
    DECLARE_FUNCTION(execFindCheckpointData)
    {
        P_GET_INT(SlotIndex);
        P_GET_STRUCT_OPTX_REF(struct FCheckpointEnumerationResult,EnumResult,FCheckpointEnumerationResult(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=FindCheckpointData(SlotIndex,pEnumResult ? &EnumResult : NULL);
    }
    DECLARE_FUNCTION(execSaveCheckpoint)
    {
        P_GET_STRUCT(FVector,CheckpointLocation);
        P_FINISH;
        SaveCheckpoint(CheckpointLocation);
    }
    DECLARE_FUNCTION(execLoadCheckpoint)
    {
        P_FINISH;
        LoadCheckpoint();
    }
    DECLARE_FUNCTION(execDeleteCheckpoints)
    {
        P_GET_INT_OPTX_REF(ResultCode,0);
        P_FINISH;
        *(UBOOL*)Result=DeleteCheckpoints(pResultCode ? &ResultCode : NULL);
    }
    DECLARE_FUNCTION(execNeedMemoryHack)
    {
        P_FINISH;
        *(UBOOL*)Result=NeedMemoryHack();
    }
    UBOOL eventAreStorageWritesAllowed(UBOOL bIgnoreDeviceStatus=FALSE,INT RequiredSize=10000000)
    {
        GearEngine_eventAreStorageWritesAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.bIgnoreDeviceStatus=bIgnoreDeviceStatus ? FIRST_BITFIELD : FALSE;
        Parms.RequiredSize=RequiredSize;
        ProcessEvent(FindFunctionChecked(GEARGAME_AreStorageWritesAllowed),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsCurrentDeviceValid(INT SizeNeeded=0)
    {
        GearEngine_eventIsCurrentDeviceValid_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SizeNeeded=SizeNeeded;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsCurrentDeviceValid),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UGearEngine,UGameEngine,0|CLASS_Transient|CLASS_Config,GearGame)
	virtual UBOOL LoadMap(const FURL& URL, class UPendingLevel* Pending, FString& Error);
	virtual void Tick(FLOAT DeltaSeconds);
	virtual UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Ar=*GLog );
};

struct FInputButtonData
{
    FName ButtonNameMapping;
    FScriptDelegate ButtonHandler;
    BYTE Active;
    BYTE RawActive;

    /** Constructors */
    FInputButtonData() {}
    FInputButtonData(EEventParm)
    {
        appMemzero(this, sizeof(FInputButtonData));
    }
};

struct GearPlayerInput_Base_eventInitializeButtonHandlingHandlers_Parms
{
    GearPlayerInput_Base_eventInitializeButtonHandlingHandlers_Parms(EEventParm)
    {
    }
};
struct GearPlayerInput_Base_eventHandleButtonInput_Parms
{
    UBOOL bPressed;
    UBOOL bDblClickMove;
    GearPlayerInput_Base_eventHandleButtonInput_Parms(EEventParm)
    {
    }
};
class UGearPlayerInput_Base : public UPlayerInput
{
public:
    //## BEGIN PROPS GearPlayerInput_Base
    TArrayNoInit<struct FInputButtonData> InputButtonDataList;
    BITFIELD bActivateKismetInputEvents:1;
    FScriptDelegate __HandleButtonInput__Delegate;
    //## END PROPS GearPlayerInput_Base

    void eventInitializeButtonHandlingHandlers()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_InitializeButtonHandlingHandlers),NULL);
    }
    void delegateHandleButtonInput(UBOOL bPressed,UBOOL bDblClickMove=FALSE)
    {
        GearPlayerInput_Base_eventHandleButtonInput_Parms Parms(EC_EventParm);
        Parms.bPressed=bPressed ? FIRST_BITFIELD : FALSE;
        Parms.bDblClickMove=bDblClickMove ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(GEARGAME_HandleButtonInput,&__HandleButtonInput__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UGearPlayerInput_Base,UPlayerInput,0|CLASS_Transient|CLASS_Config,GearGame)
    DECLARE_WITHIN(AGearPC)
    NO_DEFAULT_CONSTRUCTOR(UGearPlayerInput_Base)
};

class UGearPlayerInput : public UGearPlayerInput_Base
{
public:
    //## BEGIN PROPS GearPlayerInput
    FLOAT TargetingModeViewScalePct;
    BITFIELD bViewAccelEnabled:1;
    BITFIELD bAutoCenterPitch:1;
    BITFIELD bPlayerInterruptedRoadieRunPitchAutoCentering:1;
    BITFIELD bAppliedFriction:1;
    BITFIELD bDebugFriction:1;
    BITFIELD bDebugAdhesion:1;
    BITFIELD bVelocityScaleTest:1;
    BITFIELD bForcePitchCentering:1;
    BITFIELD bForcePitchCenteringIsInterruptable:1;
    BITFIELD bRecording:1;
    FLOAT YawAccelMultiplier;
    FLOAT YawAccelThreshold;
    FLOAT YawAccelRampUpTime;
    FLOAT YawAccelPct;
    FLOAT PitchAutoCenterSpeed;
    FLOAT PitchAutoCenterSpeedRoadieRun;
    FLOAT PitchAutoCenterDelay;
    FLOAT PitchAutoCenterDelayCount;
    FLOAT PitchAutoCenterHorizonOffset;
    FVector2D PitchAutoCenterTargetPitchWindow;
    FLOAT RunWalkTransitionThreshold;
    FLOAT LastDistToTarget;
    FLOAT LastDistMultiplier;
    FLOAT LastDistFromAimZ;
    FLOAT LastDistFromAimY;
    FLOAT LastFrictionMultiplier;
    FLOAT LastAdhesionAmtY;
    FLOAT LastAdhesionAmtZ;
    FLOAT LastTargetWidth;
    FLOAT LastTargetHeight;
    FLOAT LastDistFromAimYa;
    FLOAT LastDistFromAimZa;
    FLOAT LastAdjustY;
    FLOAT LastAdjustZ;
    FVector LastCamLoc;
    FRotator LastDeltaRot;
    FLOAT LastTargVelDotTurnDir;
    FLOAT LastCamRotDotTargY;
    FLOAT LastInputTime;
    FLOAT ForcePitchCenteringSpeed;
    FLOAT ForcedPitchCenteringHorizonOffset;
    FLOAT LastStrafe;
    FLOAT LastForward;
    FLOAT CachedStrafe;
    FLOAT CachedForward;
    INT DemoCount;
    //## END PROPS GearPlayerInput

    virtual FString GetGearBindNameFromCommand(const FString& BindCommand);
    DECLARE_FUNCTION(execGetGearBindNameFromCommand)
    {
        P_GET_STR(BindCommand);
        P_FINISH;
        *(FString*)Result=GetGearBindNameFromCommand(BindCommand);
    }
    DECLARE_CLASS(UGearPlayerInput,UGearPlayerInput_Base,0|CLASS_Transient|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearPlayerInput)
};

#endif // !INCLUDED_GEARGAME_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UAICmd_Attack_PlantGrenade,-1,execGetBestPlantPoint);
AUTOGENERATE_FUNCTION(UAICmd_MoveToGoal,-1,execAddNonSkippableWayPoint);
AUTOGENERATE_FUNCTION(UAICmd_MoveToGoal,-1,execClearNonSkippableWayPoints);
AUTOGENERATE_FUNCTION(UAICommand,-1,execShouldIgnoreNotifies);
AUTOGENERATE_FUNCTION(UAIReactChan_Timer,-1,execSubscribe);
AUTOGENERATE_FUNCTION(UAIReactChannel,-1,execNudgeChannel);
AUTOGENERATE_FUNCTION(UAIReactChannel,-1,execFindReactionByType);
AUTOGENERATE_FUNCTION(UAIReactChannel,-1,execUnSuppressReactionByType);
AUTOGENERATE_FUNCTION(UAIReactChannel,-1,execSuppressReactionByType);
AUTOGENERATE_FUNCTION(UAIReactChannel,-1,execUnSubscribe);
AUTOGENERATE_FUNCTION(UAIReactChannel,-1,execSubscribe);
AUTOGENERATE_FUNCTION(UAIReactCond_EnemyMoved,-1,execIsEnemyInNewLocation);
AUTOGENERATE_FUNCTION(UAIReactCondition_Base,-1,execUnsubscribeAll);
AUTOGENERATE_FUNCTION(UAIReactCondition_Base,-1,execSubscribeToMyChannels);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execGetChannelFor);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execWipe);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execInitialize);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execNudgeChannel);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execNudgePerceptionChannel);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execFindReactionByType);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execUnSuppressReaction);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execUnSuppressReactionsByType);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execSuppressReaction);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execUnSuppressChannel);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execSuppressChannel);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execUnSuppressAllChannels);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execSuppressAllChannels);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execSuppressReactionsByType);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execUnSubscribe);
AUTOGENERATE_FUNCTION(UAIReactionManager,-1,execSubscribe);
AUTOGENERATE_FUNCTION(ACOG_DerrickWheelsBase,-1,execCacheWheelRefPoseTMs);
AUTOGENERATE_FUNCTION(ACombatZone,-1,execCheckForMovementDelay);
AUTOGENERATE_FUNCTION(ACombatZone,-1,execIsResident);
AUTOGENERATE_FUNCTION(ACombatZone,-1,execIsOccupant);
AUTOGENERATE_FUNCTION(ACombatZone,-1,execIsValidZoneFor);
AUTOGENERATE_FUNCTION(ACoverLink_Dynamic,-1,execUpdateCoverSlot);
AUTOGENERATE_FUNCTION(ACoverLink_Dynamic,-1,execUpdateCoverLink);
AUTOGENERATE_FUNCTION(ACoverSlotMarker_Dynamic,-1,execRefreshOctreePosition);
AUTOGENERATE_FUNCTION(ACoverSlotMarker_Dynamic,-1,execSetMaxPathSize);
AUTOGENERATE_FUNCTION(ACoverSlotMarker_Dynamic,-1,execInitializeDynamicMantleSpec);
AUTOGENERATE_FUNCTION(UCovGoal_Enemies,-1,execInit);
AUTOGENERATE_FUNCTION(AEmit_CameraLensEffectBase,-1,execUpdateLocation);
AUTOGENERATE_FUNCTION(UGearCameraModifier,-1,execGetTargetAlpha);
AUTOGENERATE_FUNCTION(UGearCameraModifier,-1,execUpdateAlpha);
AUTOGENERATE_FUNCTION(UGearCameraModifier,-1,execModifyCamera);
AUTOGENERATE_FUNCTION(UGearCamMod_ScreenShake,-1,execModifyCamera);
AUTOGENERATE_FUNCTION(UGearCamMod_ScreenShake,-1,execGetTargetAlpha);
AUTOGENERATE_FUNCTION(UGearCamMod_ScreenShake,-1,execUpdateScreenShake);
AUTOGENERATE_FUNCTION(UGearCheatManager,-1,execMS_GetSoundCueInfo);
AUTOGENERATE_FUNCTION(UGearCheatManager,-1,execMS_SendDebugMessage);
AUTOGENERATE_FUNCTION(UGearCheatManager,-1,execForceLog);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execDamageSubObject);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execOneTimeInit);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execRemoveDecals);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execApplyDamageMod);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execSetSubObjectStaticMesh);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execSetupComponents);
AUTOGENERATE_FUNCTION(AGearDestructibleObject,-1,execUnDestroy);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execNeedMemoryHack);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execDeleteCheckpoints);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execLoadCheckpoint);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execSaveCheckpoint);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execFindCheckpointData);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execHasStorageDeviceBeenRemoved);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execGetCurrentDeviceID);
AUTOGENERATE_FUNCTION(UGearEngine,-1,execSetCurrentDeviceID);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execEndLog);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execEndEvent);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execAddParamString);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execAddParamFloat);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execAddParamInt);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execBeginEvent);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execBeginLog);
AUTOGENERATE_FUNCTION(UGearEventsInterface,-1,execInit);
AUTOGENERATE_FUNCTION(AGearGame,-1,execLoadGameTypeConfigs);
AUTOGENERATE_FUNCTION(AGearGame,-1,execGetMapFilename);
AUTOGENERATE_FUNCTION(AGearGame,-1,execRegisterGameWithLive);
AUTOGENERATE_FUNCTION(AGearGameCTM_Base,-1,execGetClosestStartToDestination);
AUTOGENERATE_FUNCTION(AGearGameMP_Base,-1,execGetMeatflagUniqueId);
AUTOGENERATE_FUNCTION(UGearGameSettings,-1,execSaveInvertLook);
AUTOGENERATE_FUNCTION(AGearGameSP_Base,-1,execResetActorChannel);
AUTOGENERATE_FUNCTION(AGearHUD_Base,-1,execSetSniperAspectRatio);
AUTOGENERATE_FUNCTION(AGearNavModificationVolume,-1,execUpdateAffectedNavPoints);
AUTOGENERATE_FUNCTION(UGearObjectiveManager,-1,execRetrieveObjectiveString);
AUTOGENERATE_FUNCTION(AGearObjectPool,-1,execGetDecal_Worker);
AUTOGENERATE_FUNCTION(AGearObjectPool,-1,execIsSafeToRecreatePools);
AUTOGENERATE_FUNCTION(UGearPlayerInput,-1,execGetGearBindNameFromCommand);
AUTOGENERATE_FUNCTION(AGearPointOfInterest,-1,execRetrievePOIString);
AUTOGENERATE_FUNCTION(UGearProfileSettings,-1,execRemoveExcludedGameTypes);
AUTOGENERATE_FUNCTION(UGearProfileSettings,-1,execGetProfileSettingValueMappingIndex);
AUTOGENERATE_FUNCTION(UGearProfileSettings,-1,execGetProfileSettingMappings);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteContent);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteAttributeQword);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteAttributeFloat);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteAttributeInt);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteAttributeBool);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteAttributeString);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteEndTag);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlEndStartTag);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlBeginStartTag);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execXmlWriteStartTag);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execStringToAnsiBlob);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execGuidToString);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execScreenshotToTexture);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execGetPlayerControllerId);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execLoadScreenshot);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execEnumerateScreenshots);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execDeleteScreenshot);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execSaveScreenshot);
AUTOGENERATE_FUNCTION(UGearScreenshotManager,-1,execInit);
AUTOGENERATE_FUNCTION(AGearSpawner_EHole,-1,execClosEHole_Visuals);
AUTOGENERATE_FUNCTION(AGearSpawner_EHole,-1,execOpenEHoleImmediately_Visuals);
AUTOGENERATE_FUNCTION(AGearSpawner_EHole,-1,execOpenEHoleNormal_Visuals);
AUTOGENERATE_FUNCTION(AGearSpawner_EHole,-1,execOpenEHole_Visuals);
AUTOGENERATE_FUNCTION(AGearSpawner_EmergenceHoleBase,-1,execApplySourceMaterial);
AUTOGENERATE_FUNCTION(AGearSpectatorPoint,-1,execRetrieveDisplayString);
AUTOGENERATE_FUNCTION(UGearStatsObject,-1,execDumpGameplayStats);
AUTOGENERATE_FUNCTION(UGearStatsObject,-1,execSendGameEventsToDB);
AUTOGENERATE_FUNCTION(UGearStatsObject,-1,execEndGameplaySession);
AUTOGENERATE_FUNCTION(UGearStatsObject,-1,execLogGameplayEvent);
AUTOGENERATE_FUNCTION(UGearStatsObject,-1,execBeginGameplaySession);
AUTOGENERATE_FUNCTION(AGearTurret,-1,execUpdateForMovingBase);
AUTOGENERATE_FUNCTION(UGoal_SquadFormation,-1,execClearPositionList);
AUTOGENERATE_FUNCTION(AHeadTrackTarget,-1,execCanAffectPawn);
AUTOGENERATE_FUNCTION(AHOD_BeamManagerBase,-1,execIsAValidHODTarget);
AUTOGENERATE_FUNCTION(AInterpActor_GearBasePlatform,-1,execIsStillOnClampedBase);
AUTOGENERATE_FUNCTION(AInterpActor_GearBasePlatform,-1,execFixBasedPawn);
AUTOGENERATE_FUNCTION(AInterpActor_LocustBargeBase,-1,execProcessAddRocking);
AUTOGENERATE_FUNCTION(ATrigger_LadderInteraction,-1,execGetBottomEntryPoint);
AUTOGENERATE_FUNCTION(ATrigger_LadderInteraction,-1,execGetTopEntryPoint);
AUTOGENERATE_FUNCTION(ATurret,-1,execGetTurretAimDir);
AUTOGENERATE_FUNCTION(ATurret,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(ATurret,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(ATurret,-1,execUpdateDriver);
AUTOGENERATE_FUNCTION(ATurret_TroikaBase,-1,execGetViewRotation);
AUTOGENERATE_FUNCTION(ATurret_TroikaBase,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AVolume_Nemacyst,-1,execFindNeighbors);
AUTOGENERATE_FUNCTION(AVolume_Nemacyst,-1,execFormationContainsPoint);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GEARGAME_NATIVE_DEFS
#define GEARGAME_NATIVE_DEFS

DECLARE_NATIVE_TYPE(GearGame,UActorFactoryPushable);
DECLARE_NATIVE_TYPE(GearGame,UAICmd_Attack_PlantGrenade);
DECLARE_NATIVE_TYPE(GearGame,UAICmd_MoveToGoal);
DECLARE_NATIVE_TYPE(GearGame,UAICommand);
DECLARE_NATIVE_TYPE(GearGame,UAIReactChan_Timer);
DECLARE_NATIVE_TYPE(GearGame,UAIReactChannel);
DECLARE_NATIVE_TYPE(GearGame,UAIReactCond_Conduit_Base);
DECLARE_NATIVE_TYPE(GearGame,UAIReactCond_EnemyMoved);
DECLARE_NATIVE_TYPE(GearGame,UAIReactCondition_Base);
DECLARE_NATIVE_TYPE(GearGame,UAIReactionManager);
DECLARE_NATIVE_TYPE(GearGame,AAmbientShakeVolume);
DECLARE_NATIVE_TYPE(GearGame,UCheckpoint);
DECLARE_NATIVE_TYPE(GearGame,ACOG_DerrickWheelsBase);
DECLARE_NATIVE_TYPE(GearGame,ACombatZone);
DECLARE_NATIVE_TYPE(GearGame,UCoverGoalConstraint);
DECLARE_NATIVE_TYPE(GearGame,ACoverLink_Dynamic);
DECLARE_NATIVE_TYPE(GearGame,ACoverSlotMarker_Dynamic);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_AvoidanceVolumes);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_Enemies);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_EnemyProximity);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_GoalProximity);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_MovementDistance);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_ProtectedByLocation);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_SquadLeaderProximity);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_TeammateProximity);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_WithinAllowedCoverLinks);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_WithinCombatZones);
DECLARE_NATIVE_TYPE(GearGame,UCovGoal_WithinWeaponRange);
DECLARE_NATIVE_TYPE(GearGame,UDifficultySettings);
DECLARE_NATIVE_TYPE(GearGame,ADummyWeaponFireActor);
DECLARE_NATIVE_TYPE(GearGame,UEmergenceHoleRenderingComponent);
DECLARE_NATIVE_TYPE(GearGame,AEmit_CameraLensEffectBase);
DECLARE_NATIVE_TYPE(GearGame,AFauxPathNode);
DECLARE_NATIVE_TYPE(GearGame,AFlockTestLocust);
DECLARE_NATIVE_TYPE(GearGame,AGear_GrappleHookMarker);
DECLARE_NATIVE_TYPE(GearGame,AGearAimAssistActor);
DECLARE_NATIVE_TYPE(GearGame,AGearAirPathNode);
DECLARE_NATIVE_TYPE(GearGame,UGearBloodInfo);
DECLARE_NATIVE_TYPE(GearGame,UGearCameraModifier);
DECLARE_NATIVE_TYPE(GearGame,UGearCamMod_ScreenShake);
DECLARE_NATIVE_TYPE(GearGame,UGearCheatManager);
DECLARE_NATIVE_TYPE(GearGame,UGearCoverMeshComponent);
DECLARE_NATIVE_TYPE(GearGame,AGearCrimsonOmenPickupFactoryBase);
DECLARE_NATIVE_TYPE(GearGame,UGearDamageType);
DECLARE_NATIVE_TYPE(GearGame,UGearDecal);
DECLARE_NATIVE_TYPE(GearGame,UGearDecalInfo);
DECLARE_NATIVE_TYPE(GearGame,AGearDestructibleObject);
DECLARE_NATIVE_TYPE(GearGame,AGearDiscoverablesPickupFactoryBase);
DECLARE_NATIVE_TYPE(GearGame,AGearDroppedPickup);
DECLARE_NATIVE_TYPE(GearGame,AGearEmitter);
DECLARE_NATIVE_TYPE(GearGame,UGearEngine);
DECLARE_NATIVE_TYPE(GearGame,UGearEventsInterface);
DECLARE_NATIVE_TYPE(GearGame,AGearGame);
DECLARE_NATIVE_TYPE(GearGame,AGearGameAnnex_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearGameCTM_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearGameGeneric);
DECLARE_NATIVE_TYPE(GearGame,AGearGameMP_Base);
DECLARE_NATIVE_TYPE(GearGame,UGearGameSettings);
DECLARE_NATIVE_TYPE(GearGame,AGearGameSP_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearGameTDM_Base);
DECLARE_NATIVE_TYPE(GearGame,UGearGameViewportClient);
DECLARE_NATIVE_TYPE(GearGame,AGearGameWingman_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearGRI);
DECLARE_NATIVE_TYPE(GearGame,AGearHUD_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearNavModificationVolume);
DECLARE_NATIVE_TYPE(GearGame,UGearObjectiveManager);
DECLARE_NATIVE_TYPE(GearGame,AGearObjectPool);
DECLARE_NATIVE_TYPE(GearGame,AGearPawnBlockingVolume);
DECLARE_NATIVE_TYPE(GearGame,UGearPerMapColorConfig);
DECLARE_NATIVE_TYPE(GearGame,UGearPhysicalMaterialProperty);
DECLARE_NATIVE_TYPE(GearGame,AGearPickupFactory);
DECLARE_NATIVE_TYPE(GearGame,UGearPlayerInput);
DECLARE_NATIVE_TYPE(GearGame,UGearPlayerInput_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearPointOfInterest);
DECLARE_NATIVE_TYPE(GearGame,AGearPointOfInterest_Meatflag);
DECLARE_NATIVE_TYPE(GearGame,AGearPRI);
DECLARE_NATIVE_TYPE(GearGame,UGearProfileSettings);
DECLARE_NATIVE_TYPE(GearGame,AGearScout);
DECLARE_NATIVE_TYPE(GearGame,UGearScreenshotManager);
DECLARE_NATIVE_TYPE(GearGame,AGearSpawner);
DECLARE_NATIVE_TYPE(GearGame,AGearSpawner_EHole);
DECLARE_NATIVE_TYPE(GearGame,AGearSpawner_EholeSpawnLocation);
DECLARE_NATIVE_TYPE(GearGame,AGearSpawner_EmergenceHoleBase);
DECLARE_NATIVE_TYPE(GearGame,AGearSpectatorPoint);
DECLARE_NATIVE_TYPE(GearGame,UGearStatsObject);
DECLARE_NATIVE_TYPE(GearGame,AGearTeamInfo);
DECLARE_NATIVE_TYPE(GearGame,AGearTurret);
DECLARE_NATIVE_TYPE(GearGame,UGearTutorial_Base);
DECLARE_NATIVE_TYPE(GearGame,UGearTutorialManager);
DECLARE_NATIVE_TYPE(GearGame,UGearTypes);
DECLARE_NATIVE_TYPE(GearGame,AGearWallPathNode);
DECLARE_NATIVE_TYPE(GearGame,AGearWeaponPickupFactory);
DECLARE_NATIVE_TYPE(GearGame,UGoal_AwayFromPosition);
DECLARE_NATIVE_TYPE(GearGame,UGoal_FarthestNavInRange);
DECLARE_NATIVE_TYPE(GearGame,UGoal_SquadFormation);
DECLARE_NATIVE_TYPE(GearGame,AGrenadeBlockingVolume);
DECLARE_NATIVE_TYPE(GearGame,AHeadTrackTarget);
DECLARE_NATIVE_TYPE(GearGame,AHOD_BeamManagerBase);
DECLARE_NATIVE_TYPE(GearGame,AInterpActor_COGDerrickBase);
DECLARE_NATIVE_TYPE(GearGame,AInterpActor_GearBasePlatform);
DECLARE_NATIVE_TYPE(GearGame,AInterpActor_LocustBargeBase);
DECLARE_NATIVE_TYPE(GearGame,AInterpActor_LocustTortureBargeBase);
DECLARE_NATIVE_TYPE(GearGame,AInterpActor_Pushable);
DECLARE_NATIVE_TYPE(GearGame,AInterpActor_RaftBase);
DECLARE_NATIVE_TYPE(GearGame,AJumpPoint);
DECLARE_NATIVE_TYPE(GearGame,ALadderMarker);
DECLARE_NATIVE_TYPE(GearGame,ULeapReachSpec);
DECLARE_NATIVE_TYPE(GearGame,AMantlePlaceholderCylinder);
DECLARE_NATIVE_TYPE(GearGame,UPath_CoverSlotsOnly);
DECLARE_NATIVE_TYPE(GearGame,AReaverLandingPoint);
DECLARE_NATIVE_TYPE(GearGame,ARockWorm_TailSegment);
DECLARE_NATIVE_TYPE(GearGame,USeqAct_ModifyDifficulty);
DECLARE_NATIVE_TYPE(GearGame,USeqEvent_ChapterPoint);
DECLARE_NATIVE_TYPE(GearGame,ASpawnedGearEmitter);
DECLARE_NATIVE_TYPE(GearGame,ATrigger_Engage);
DECLARE_NATIVE_TYPE(GearGame,ATrigger_LadderInteraction);
DECLARE_NATIVE_TYPE(GearGame,ATurret);
DECLARE_NATIVE_TYPE(GearGame,ATurret_TroikaBase);
DECLARE_NATIVE_TYPE(GearGame,AVolume_Nemacyst);
DECLARE_NATIVE_TYPE(GearGame,AWalkVolume);

#define AUTO_INITIALIZE_REGISTRANTS_GEARGAME \
	UActorFactoryPushable::StaticClass(); \
	UAICmd_Attack_PlantGrenade::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAICmd_Attack_PlantGrenadeNative; \
	UAICmd_MoveToGoal::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAICmd_MoveToGoalNative; \
	UAICommand::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAICommandNative; \
	UAIReactChan_Timer::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIReactChan_TimerNative; \
	UAIReactChannel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIReactChannelNative; \
	UAIReactCond_Conduit_Base::StaticClass(); \
	UAIReactCond_EnemyMoved::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIReactCond_EnemyMovedNative; \
	UAIReactCondition_Base::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIReactCondition_BaseNative; \
	UAIReactionManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIReactionManagerNative; \
	AAmbientShakeVolume::StaticClass(); \
	UCheckpoint::StaticClass(); \
	ACOG_DerrickWheelsBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameACOG_DerrickWheelsBaseNative; \
	ACombatZone::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameACombatZoneNative; \
	UCoverGoalConstraint::StaticClass(); \
	ACoverLink_Dynamic::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameACoverLink_DynamicNative; \
	ACoverSlotMarker_Dynamic::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameACoverSlotMarker_DynamicNative; \
	UCovGoal_AvoidanceVolumes::StaticClass(); \
	UCovGoal_Enemies::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUCovGoal_EnemiesNative; \
	UCovGoal_EnemyProximity::StaticClass(); \
	UCovGoal_GoalProximity::StaticClass(); \
	UCovGoal_MovementDistance::StaticClass(); \
	UCovGoal_ProtectedByLocation::StaticClass(); \
	UCovGoal_SquadLeaderProximity::StaticClass(); \
	UCovGoal_TeammateProximity::StaticClass(); \
	UCovGoal_WithinAllowedCoverLinks::StaticClass(); \
	UCovGoal_WithinCombatZones::StaticClass(); \
	UCovGoal_WithinWeaponRange::StaticClass(); \
	UDifficultySettings::StaticClass(); \
	ADummyWeaponFireActor::StaticClass(); \
	UEmergenceHoleRenderingComponent::StaticClass(); \
	AEmit_CameraLensEffectBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAEmit_CameraLensEffectBaseNative; \
	AFauxPathNode::StaticClass(); \
	AFlockTestLocust::StaticClass(); \
	AGear_GrappleHookMarker::StaticClass(); \
	AGearAimAssistActor::StaticClass(); \
	AGearAirPathNode::StaticClass(); \
	UGearBloodInfo::StaticClass(); \
	UGearCameraModifier::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearCameraModifierNative; \
	UGearCamMod_ScreenShake::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearCamMod_ScreenShakeNative; \
	UGearCheatManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearCheatManagerNative; \
	UGearCoverMeshComponent::StaticClass(); \
	AGearCrimsonOmenPickupFactoryBase::StaticClass(); \
	UGearDamageType::StaticClass(); \
	UGearDecal::StaticClass(); \
	UGearDecalInfo::StaticClass(); \
	AGearDestructibleObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearDestructibleObjectNative; \
	AGearDiscoverablesPickupFactoryBase::StaticClass(); \
	AGearDroppedPickup::StaticClass(); \
	AGearEmitter::StaticClass(); \
	UGearEngine::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearEngineNative; \
	UGearEventsInterface::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearEventsInterfaceNative; \
	AGearGame::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearGameNative; \
	AGearGameAnnex_Base::StaticClass(); \
	AGearGameCTM_Base::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearGameCTM_BaseNative; \
	AGearGameGeneric::StaticClass(); \
	AGearGameMP_Base::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearGameMP_BaseNative; \
	UGearGameSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearGameSettingsNative; \
	AGearGameSP_Base::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearGameSP_BaseNative; \
	AGearGameTDM_Base::StaticClass(); \
	UGearGameViewportClient::StaticClass(); \
	AGearGameWingman_Base::StaticClass(); \
	AGearGRI::StaticClass(); \
	AGearHUD_Base::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearHUD_BaseNative; \
	AGearNavModificationVolume::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearNavModificationVolumeNative; \
	UGearObjectiveManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearObjectiveManagerNative; \
	AGearObjectPool::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearObjectPoolNative; \
	AGearPawnBlockingVolume::StaticClass(); \
	UGearPerMapColorConfig::StaticClass(); \
	UGearPhysicalMaterialProperty::StaticClass(); \
	AGearPickupFactory::StaticClass(); \
	UGearPlayerInput::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearPlayerInputNative; \
	UGearPlayerInput_Base::StaticClass(); \
	AGearPointOfInterest::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPointOfInterestNative; \
	AGearPointOfInterest_Meatflag::StaticClass(); \
	AGearPRI::StaticClass(); \
	UGearProfileSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearProfileSettingsNative; \
	AGearScout::StaticClass(); \
	UGearScreenshotManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearScreenshotManagerNative; \
	AGearSpawner::StaticClass(); \
	AGearSpawner_EHole::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearSpawner_EHoleNative; \
	AGearSpawner_EholeSpawnLocation::StaticClass(); \
	AGearSpawner_EmergenceHoleBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearSpawner_EmergenceHoleBaseNative; \
	AGearSpectatorPoint::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearSpectatorPointNative; \
	UGearStatsObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearStatsObjectNative; \
	AGearTeamInfo::StaticClass(); \
	AGearTurret::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearTurretNative; \
	UGearTutorial_Base::StaticClass(); \
	UGearTutorialManager::StaticClass(); \
	UGearTypes::StaticClass(); \
	AGearWallPathNode::StaticClass(); \
	AGearWeaponPickupFactory::StaticClass(); \
	UGoal_AwayFromPosition::StaticClass(); \
	UGoal_FarthestNavInRange::StaticClass(); \
	UGoal_SquadFormation::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGoal_SquadFormationNative; \
	AGrenadeBlockingVolume::StaticClass(); \
	AHeadTrackTarget::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAHeadTrackTargetNative; \
	AHOD_BeamManagerBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAHOD_BeamManagerBaseNative; \
	AInterpActor_COGDerrickBase::StaticClass(); \
	AInterpActor_GearBasePlatform::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAInterpActor_GearBasePlatformNative; \
	AInterpActor_LocustBargeBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAInterpActor_LocustBargeBaseNative; \
	AInterpActor_LocustTortureBargeBase::StaticClass(); \
	AInterpActor_Pushable::StaticClass(); \
	AInterpActor_RaftBase::StaticClass(); \
	AJumpPoint::StaticClass(); \
	ALadderMarker::StaticClass(); \
	ULeapReachSpec::StaticClass(); \
	AMantlePlaceholderCylinder::StaticClass(); \
	UPath_CoverSlotsOnly::StaticClass(); \
	AReaverLandingPoint::StaticClass(); \
	ARockWorm_TailSegment::StaticClass(); \
	USeqAct_ModifyDifficulty::StaticClass(); \
	USeqEvent_ChapterPoint::StaticClass(); \
	ASpawnedGearEmitter::StaticClass(); \
	ATrigger_Engage::StaticClass(); \
	ATrigger_LadderInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameATrigger_LadderInteractionNative; \
	ATurret::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameATurretNative; \
	ATurret_TroikaBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameATurret_TroikaBaseNative; \
	AVolume_Nemacyst::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAVolume_NemacystNative; \
	AWalkVolume::StaticClass(); \

#endif // GEARGAME_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UAICmd_Attack_PlantGrenade) GGearGameUAICmd_Attack_PlantGrenadeNatives[] = 
{ 
	MAP_NATIVE(UAICmd_Attack_PlantGrenade,execGetBestPlantPoint)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAICmd_Attack_PlantGrenade);

NATIVE_INFO(UAICmd_MoveToGoal) GGearGameUAICmd_MoveToGoalNatives[] = 
{ 
	MAP_NATIVE(UAICmd_MoveToGoal,execAddNonSkippableWayPoint)
	MAP_NATIVE(UAICmd_MoveToGoal,execClearNonSkippableWayPoints)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAICmd_MoveToGoal);

NATIVE_INFO(UAICommand) GGearGameUAICommandNatives[] = 
{ 
	MAP_NATIVE(UAICommand,execShouldIgnoreNotifies)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAICommand);

NATIVE_INFO(UAIReactChan_Timer) GGearGameUAIReactChan_TimerNatives[] = 
{ 
	MAP_NATIVE(UAIReactChan_Timer,execSubscribe)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIReactChan_Timer);

NATIVE_INFO(UAIReactChannel) GGearGameUAIReactChannelNatives[] = 
{ 
	MAP_NATIVE(UAIReactChannel,execNudgeChannel)
	MAP_NATIVE(UAIReactChannel,execFindReactionByType)
	MAP_NATIVE(UAIReactChannel,execUnSuppressReactionByType)
	MAP_NATIVE(UAIReactChannel,execSuppressReactionByType)
	MAP_NATIVE(UAIReactChannel,execUnSubscribe)
	MAP_NATIVE(UAIReactChannel,execSubscribe)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIReactChannel);

NATIVE_INFO(UAIReactCond_EnemyMoved) GGearGameUAIReactCond_EnemyMovedNatives[] = 
{ 
	MAP_NATIVE(UAIReactCond_EnemyMoved,execIsEnemyInNewLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIReactCond_EnemyMoved);

NATIVE_INFO(UAIReactCondition_Base) GGearGameUAIReactCondition_BaseNatives[] = 
{ 
	MAP_NATIVE(UAIReactCondition_Base,execUnsubscribeAll)
	MAP_NATIVE(UAIReactCondition_Base,execSubscribeToMyChannels)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIReactCondition_Base);

NATIVE_INFO(UAIReactionManager) GGearGameUAIReactionManagerNatives[] = 
{ 
	MAP_NATIVE(UAIReactionManager,execGetChannelFor)
	MAP_NATIVE(UAIReactionManager,execWipe)
	MAP_NATIVE(UAIReactionManager,execInitialize)
	MAP_NATIVE(UAIReactionManager,execNudgeChannel)
	MAP_NATIVE(UAIReactionManager,execNudgePerceptionChannel)
	MAP_NATIVE(UAIReactionManager,execFindReactionByType)
	MAP_NATIVE(UAIReactionManager,execUnSuppressReaction)
	MAP_NATIVE(UAIReactionManager,execUnSuppressReactionsByType)
	MAP_NATIVE(UAIReactionManager,execSuppressReaction)
	MAP_NATIVE(UAIReactionManager,execUnSuppressChannel)
	MAP_NATIVE(UAIReactionManager,execSuppressChannel)
	MAP_NATIVE(UAIReactionManager,execUnSuppressAllChannels)
	MAP_NATIVE(UAIReactionManager,execSuppressAllChannels)
	MAP_NATIVE(UAIReactionManager,execSuppressReactionsByType)
	MAP_NATIVE(UAIReactionManager,execUnSubscribe)
	MAP_NATIVE(UAIReactionManager,execSubscribe)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIReactionManager);

NATIVE_INFO(ACOG_DerrickWheelsBase) GGearGameACOG_DerrickWheelsBaseNatives[] = 
{ 
	MAP_NATIVE(ACOG_DerrickWheelsBase,execCacheWheelRefPoseTMs)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ACOG_DerrickWheelsBase);

NATIVE_INFO(ACombatZone) GGearGameACombatZoneNatives[] = 
{ 
	MAP_NATIVE(ACombatZone,execCheckForMovementDelay)
	MAP_NATIVE(ACombatZone,execIsResident)
	MAP_NATIVE(ACombatZone,execIsOccupant)
	MAP_NATIVE(ACombatZone,execIsValidZoneFor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ACombatZone);

NATIVE_INFO(ACoverLink_Dynamic) GGearGameACoverLink_DynamicNatives[] = 
{ 
	MAP_NATIVE(ACoverLink_Dynamic,execUpdateCoverSlot)
	MAP_NATIVE(ACoverLink_Dynamic,execUpdateCoverLink)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ACoverLink_Dynamic);

NATIVE_INFO(ACoverSlotMarker_Dynamic) GGearGameACoverSlotMarker_DynamicNatives[] = 
{ 
	MAP_NATIVE(ACoverSlotMarker_Dynamic,execRefreshOctreePosition)
	MAP_NATIVE(ACoverSlotMarker_Dynamic,execSetMaxPathSize)
	MAP_NATIVE(ACoverSlotMarker_Dynamic,execInitializeDynamicMantleSpec)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ACoverSlotMarker_Dynamic);

NATIVE_INFO(UCovGoal_Enemies) GGearGameUCovGoal_EnemiesNatives[] = 
{ 
	MAP_NATIVE(UCovGoal_Enemies,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UCovGoal_Enemies);

NATIVE_INFO(AEmit_CameraLensEffectBase) GGearGameAEmit_CameraLensEffectBaseNatives[] = 
{ 
	MAP_NATIVE(AEmit_CameraLensEffectBase,execUpdateLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AEmit_CameraLensEffectBase);

NATIVE_INFO(UGearCameraModifier) GGearGameUGearCameraModifierNatives[] = 
{ 
	MAP_NATIVE(UGearCameraModifier,execGetTargetAlpha)
	MAP_NATIVE(UGearCameraModifier,execUpdateAlpha)
	MAP_NATIVE(UGearCameraModifier,execModifyCamera)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearCameraModifier);

NATIVE_INFO(UGearCamMod_ScreenShake) GGearGameUGearCamMod_ScreenShakeNatives[] = 
{ 
	MAP_NATIVE(UGearCamMod_ScreenShake,execModifyCamera)
	MAP_NATIVE(UGearCamMod_ScreenShake,execGetTargetAlpha)
	MAP_NATIVE(UGearCamMod_ScreenShake,execUpdateScreenShake)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearCamMod_ScreenShake);

NATIVE_INFO(UGearCheatManager) GGearGameUGearCheatManagerNatives[] = 
{ 
	MAP_NATIVE(UGearCheatManager,execMS_GetSoundCueInfo)
	MAP_NATIVE(UGearCheatManager,execMS_SendDebugMessage)
	MAP_NATIVE(UGearCheatManager,execForceLog)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearCheatManager);

NATIVE_INFO(AGearDestructibleObject) GGearGameAGearDestructibleObjectNatives[] = 
{ 
	MAP_NATIVE(AGearDestructibleObject,execDamageSubObject)
	MAP_NATIVE(AGearDestructibleObject,execOneTimeInit)
	MAP_NATIVE(AGearDestructibleObject,execRemoveDecals)
	MAP_NATIVE(AGearDestructibleObject,execApplyDamageMod)
	MAP_NATIVE(AGearDestructibleObject,execSetSubObjectStaticMesh)
	MAP_NATIVE(AGearDestructibleObject,execSetupComponents)
	MAP_NATIVE(AGearDestructibleObject,execUnDestroy)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearDestructibleObject);

NATIVE_INFO(UGearEngine) GGearGameUGearEngineNatives[] = 
{ 
	MAP_NATIVE(UGearEngine,execNeedMemoryHack)
	MAP_NATIVE(UGearEngine,execDeleteCheckpoints)
	MAP_NATIVE(UGearEngine,execLoadCheckpoint)
	MAP_NATIVE(UGearEngine,execSaveCheckpoint)
	MAP_NATIVE(UGearEngine,execFindCheckpointData)
	MAP_NATIVE(UGearEngine,execHasStorageDeviceBeenRemoved)
	MAP_NATIVE(UGearEngine,execGetCurrentDeviceID)
	MAP_NATIVE(UGearEngine,execSetCurrentDeviceID)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearEngine);

NATIVE_INFO(UGearEventsInterface) GGearGameUGearEventsInterfaceNatives[] = 
{ 
	MAP_NATIVE(UGearEventsInterface,execEndLog)
	MAP_NATIVE(UGearEventsInterface,execEndEvent)
	MAP_NATIVE(UGearEventsInterface,execAddParamString)
	MAP_NATIVE(UGearEventsInterface,execAddParamFloat)
	MAP_NATIVE(UGearEventsInterface,execAddParamInt)
	MAP_NATIVE(UGearEventsInterface,execBeginEvent)
	MAP_NATIVE(UGearEventsInterface,execBeginLog)
	MAP_NATIVE(UGearEventsInterface,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearEventsInterface);

NATIVE_INFO(AGearGame) GGearGameAGearGameNatives[] = 
{ 
	MAP_NATIVE(AGearGame,execLoadGameTypeConfigs)
	MAP_NATIVE(AGearGame,execGetMapFilename)
	MAP_NATIVE(AGearGame,execRegisterGameWithLive)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearGame);

NATIVE_INFO(AGearGameCTM_Base) GGearGameAGearGameCTM_BaseNatives[] = 
{ 
	MAP_NATIVE(AGearGameCTM_Base,execGetClosestStartToDestination)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearGameCTM_Base);

NATIVE_INFO(AGearGameMP_Base) GGearGameAGearGameMP_BaseNatives[] = 
{ 
	MAP_NATIVE(AGearGameMP_Base,execGetMeatflagUniqueId)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearGameMP_Base);

NATIVE_INFO(UGearGameSettings) GGearGameUGearGameSettingsNatives[] = 
{ 
	MAP_NATIVE(UGearGameSettings,execSaveInvertLook)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearGameSettings);

NATIVE_INFO(AGearGameSP_Base) GGearGameAGearGameSP_BaseNatives[] = 
{ 
	MAP_NATIVE(AGearGameSP_Base,execResetActorChannel)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearGameSP_Base);

NATIVE_INFO(AGearHUD_Base) GGearGameAGearHUD_BaseNatives[] = 
{ 
	MAP_NATIVE(AGearHUD_Base,execSetSniperAspectRatio)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearHUD_Base);

NATIVE_INFO(AGearNavModificationVolume) GGearGameAGearNavModificationVolumeNatives[] = 
{ 
	MAP_NATIVE(AGearNavModificationVolume,execUpdateAffectedNavPoints)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearNavModificationVolume);

NATIVE_INFO(UGearObjectiveManager) GGearGameUGearObjectiveManagerNatives[] = 
{ 
	MAP_NATIVE(UGearObjectiveManager,execRetrieveObjectiveString)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearObjectiveManager);

NATIVE_INFO(AGearObjectPool) GGearGameAGearObjectPoolNatives[] = 
{ 
	MAP_NATIVE(AGearObjectPool,execGetDecal_Worker)
	MAP_NATIVE(AGearObjectPool,execIsSafeToRecreatePools)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearObjectPool);

NATIVE_INFO(UGearPlayerInput) GGearGameUGearPlayerInputNatives[] = 
{ 
	MAP_NATIVE(UGearPlayerInput,execGetGearBindNameFromCommand)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearPlayerInput);

NATIVE_INFO(AGearPointOfInterest) GGearGameAGearPointOfInterestNatives[] = 
{ 
	MAP_NATIVE(AGearPointOfInterest,execRetrievePOIString)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPointOfInterest);

NATIVE_INFO(UGearProfileSettings) GGearGameUGearProfileSettingsNatives[] = 
{ 
	MAP_NATIVE(UGearProfileSettings,execRemoveExcludedGameTypes)
	MAP_NATIVE(UGearProfileSettings,execGetProfileSettingValueMappingIndex)
	MAP_NATIVE(UGearProfileSettings,execGetProfileSettingMappings)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearProfileSettings);

NATIVE_INFO(UGearScreenshotManager) GGearGameUGearScreenshotManagerNatives[] = 
{ 
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteContent)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteAttributeQword)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteAttributeFloat)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteAttributeInt)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteAttributeBool)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteAttributeString)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteEndTag)
	MAP_NATIVE(UGearScreenshotManager,execXmlEndStartTag)
	MAP_NATIVE(UGearScreenshotManager,execXmlBeginStartTag)
	MAP_NATIVE(UGearScreenshotManager,execXmlWriteStartTag)
	MAP_NATIVE(UGearScreenshotManager,execStringToAnsiBlob)
	MAP_NATIVE(UGearScreenshotManager,execGuidToString)
	MAP_NATIVE(UGearScreenshotManager,execScreenshotToTexture)
	MAP_NATIVE(UGearScreenshotManager,execGetPlayerControllerId)
	MAP_NATIVE(UGearScreenshotManager,execGetPlayerOwner)
	MAP_NATIVE(UGearScreenshotManager,execLoadScreenshot)
	MAP_NATIVE(UGearScreenshotManager,execEnumerateScreenshots)
	MAP_NATIVE(UGearScreenshotManager,execDeleteScreenshot)
	MAP_NATIVE(UGearScreenshotManager,execSaveScreenshot)
	MAP_NATIVE(UGearScreenshotManager,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearScreenshotManager);

NATIVE_INFO(AGearSpawner_EHole) GGearGameAGearSpawner_EHoleNatives[] = 
{ 
	MAP_NATIVE(AGearSpawner_EHole,execClosEHole_Visuals)
	MAP_NATIVE(AGearSpawner_EHole,execOpenEHoleImmediately_Visuals)
	MAP_NATIVE(AGearSpawner_EHole,execOpenEHoleNormal_Visuals)
	MAP_NATIVE(AGearSpawner_EHole,execOpenEHole_Visuals)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearSpawner_EHole);

NATIVE_INFO(AGearSpawner_EmergenceHoleBase) GGearGameAGearSpawner_EmergenceHoleBaseNatives[] = 
{ 
	MAP_NATIVE(AGearSpawner_EmergenceHoleBase,execApplySourceMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearSpawner_EmergenceHoleBase);

NATIVE_INFO(AGearSpectatorPoint) GGearGameAGearSpectatorPointNatives[] = 
{ 
	MAP_NATIVE(AGearSpectatorPoint,execRetrieveDisplayString)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearSpectatorPoint);

NATIVE_INFO(UGearStatsObject) GGearGameUGearStatsObjectNatives[] = 
{ 
	MAP_NATIVE(UGearStatsObject,execDumpGameplayStats)
	MAP_NATIVE(UGearStatsObject,execSendGameEventsToDB)
	MAP_NATIVE(UGearStatsObject,execEndGameplaySession)
	MAP_NATIVE(UGearStatsObject,execLogGameplayEvent)
	MAP_NATIVE(UGearStatsObject,execBeginGameplaySession)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearStatsObject);

NATIVE_INFO(AGearTurret) GGearGameAGearTurretNatives[] = 
{ 
	MAP_NATIVE(AGearTurret,execUpdateForMovingBase)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearTurret);

NATIVE_INFO(UGoal_SquadFormation) GGearGameUGoal_SquadFormationNatives[] = 
{ 
	MAP_NATIVE(UGoal_SquadFormation,execClearPositionList)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGoal_SquadFormation);

NATIVE_INFO(AHeadTrackTarget) GGearGameAHeadTrackTargetNatives[] = 
{ 
	MAP_NATIVE(AHeadTrackTarget,execCanAffectPawn)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AHeadTrackTarget);

NATIVE_INFO(AHOD_BeamManagerBase) GGearGameAHOD_BeamManagerBaseNatives[] = 
{ 
	MAP_NATIVE(AHOD_BeamManagerBase,execIsAValidHODTarget)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AHOD_BeamManagerBase);

NATIVE_INFO(AInterpActor_GearBasePlatform) GGearGameAInterpActor_GearBasePlatformNatives[] = 
{ 
	MAP_NATIVE(AInterpActor_GearBasePlatform,execIsStillOnClampedBase)
	MAP_NATIVE(AInterpActor_GearBasePlatform,execFixBasedPawn)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AInterpActor_GearBasePlatform);

NATIVE_INFO(AInterpActor_LocustBargeBase) GGearGameAInterpActor_LocustBargeBaseNatives[] = 
{ 
	MAP_NATIVE(AInterpActor_LocustBargeBase,execProcessAddRocking)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AInterpActor_LocustBargeBase);

NATIVE_INFO(ATrigger_LadderInteraction) GGearGameATrigger_LadderInteractionNatives[] = 
{ 
	MAP_NATIVE(ATrigger_LadderInteraction,execGetBottomEntryPoint)
	MAP_NATIVE(ATrigger_LadderInteraction,execGetTopEntryPoint)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ATrigger_LadderInteraction);

NATIVE_INFO(ATurret) GGearGameATurretNatives[] = 
{ 
	MAP_NATIVE(ATurret,execGetTurretAimDir)
	MAP_NATIVE(ATurret,execGetPawnViewLocation)
	MAP_NATIVE(ATurret,execGetPhysicalFireStartLoc)
	MAP_NATIVE(ATurret,execUpdateDriver)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ATurret);

NATIVE_INFO(ATurret_TroikaBase) GGearGameATurret_TroikaBaseNatives[] = 
{ 
	MAP_NATIVE(ATurret_TroikaBase,execGetViewRotation)
	MAP_NATIVE(ATurret_TroikaBase,execGetPhysicalFireStartLoc)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,ATurret_TroikaBase);

NATIVE_INFO(AVolume_Nemacyst) GGearGameAVolume_NemacystNatives[] = 
{ 
	MAP_NATIVE(AVolume_Nemacyst,execFindNeighbors)
	MAP_NATIVE(AVolume_Nemacyst,execFormationContainsPoint)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AVolume_Nemacyst);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPushable)
VERIFY_CLASS_OFFSET_NODIE(U,AICmd_Attack_PlantGrenade,MinDistance)
VERIFY_CLASS_OFFSET_NODIE(U,AICmd_Attack_PlantGrenade,WallTraceDirs)
VERIFY_CLASS_SIZE_NODIE(UAICmd_Attack_PlantGrenade)
VERIFY_CLASS_OFFSET_NODIE(U,AICmd_MoveToGoal,SkipAheadLastUpdatePos)
VERIFY_CLASS_OFFSET_NODIE(U,AICmd_MoveToGoal,NodesRequiringTriggers)
VERIFY_CLASS_SIZE_NODIE(UAICmd_MoveToGoal)
VERIFY_CLASS_OFFSET_NODIE(U,AICommand,ChildCommand)
VERIFY_CLASS_OFFSET_NODIE(U,AICommand,Status)
VERIFY_CLASS_SIZE_NODIE(UAICommand)
VERIFY_CLASS_SIZE_NODIE(UAIReactChan_Timer)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactChannel,ChannelName)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactChannel,Reactions)
VERIFY_CLASS_SIZE_NODIE(UAIReactChannel)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_Conduit_Base,OutputChannelName)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_Conduit_Base,__OutputFunction__Delegate)
VERIFY_CLASS_SIZE_NODIE(UAIReactCond_Conduit_Base)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_EnemyMoved,DistanceThreshold)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_EnemyMoved,RingBufIndex)
VERIFY_CLASS_SIZE_NODIE(UAIReactCond_EnemyMoved)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCondition_Base,AutoSubscribeChannels)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCondition_Base,TimerLastActivationTime)
VERIFY_CLASS_SIZE_NODIE(UAIReactCondition_Base)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactionManager,IntrinsicChannels)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactionManager,BasicPerceptionChannels)
VERIFY_CLASS_SIZE_NODIE(UAIReactionManager)
VERIFY_CLASS_OFFSET_NODIE(A,AmbientShakeVolume,AmbientShake)
VERIFY_CLASS_SIZE_NODIE(AAmbientShakeVolume)
VERIFY_CLASS_OFFSET_NODIE(U,Checkpoint,SlotIndex)
VERIFY_CLASS_OFFSET_NODIE(U,Checkpoint,DisplayName)
VERIFY_CLASS_SIZE_NODIE(UCheckpoint)
VERIFY_CLASS_OFFSET_NODIE(A,COG_DerrickWheelsBase,Mesh)
VERIFY_CLASS_OFFSET_NODIE(A,COG_DerrickWheelsBase,JiggleFadeTime)
VERIFY_CLASS_SIZE_NODIE(ACOG_DerrickWheelsBase)
VERIFY_CLASS_OFFSET_NODIE(A,CombatZone,ZoneName)
VERIFY_CLASS_OFFSET_NODIE(A,CombatZone,AmbushTargets)
VERIFY_CLASS_SIZE_NODIE(ACombatZone)
VERIFY_CLASS_OFFSET_NODIE(U,CoverGoalConstraint,ConstraintEvaluationPriority)
VERIFY_CLASS_SIZE_NODIE(UCoverGoalConstraint)
VERIFY_CLASS_OFFSET_NODIE(A,CoverLink_Dynamic,LastStableLocation)
VERIFY_CLASS_SIZE_NODIE(ACoverLink_Dynamic)
VERIFY_CLASS_SIZE_NODIE(ACoverSlotMarker_Dynamic)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_AvoidanceVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_Enemies,ValidEnemyCache)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_Enemies)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_EnemyProximity)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_GoalProximity,BestGoalDist)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_GoalProximity,MaxGoalDist)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_GoalProximity)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_MovementDistance,BestCoverDist)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_MovementDistance,MinDistTowardGoal)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_MovementDistance)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_ProtectedByLocation,ThreatLocation)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_ProtectedByLocation)
VERIFY_CLASS_OFFSET_NODIE(U,CovGoal_SquadLeaderProximity,SquadLeaderLocation)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_SquadLeaderProximity)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_TeammateProximity)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_WithinAllowedCoverLinks)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_WithinCombatZones)
VERIFY_CLASS_SIZE_NODIE(UCovGoal_WithinWeaponRange)
VERIFY_CLASS_OFFSET_NODIE(U,DifficultySettings,PlayerHealthMod)
VERIFY_CLASS_OFFSET_NODIE(U,DifficultySettings,DifficultyLevel)
VERIFY_CLASS_SIZE_NODIE(UDifficultySettings)
VERIFY_CLASS_OFFSET_NODIE(A,DummyWeaponFireActor,FireAction)
VERIFY_CLASS_OFFSET_NODIE(A,DummyWeaponFireActor,ShotCount)
VERIFY_CLASS_SIZE_NODIE(ADummyWeaponFireActor)
VERIFY_CLASS_SIZE_NODIE(UEmergenceHoleRenderingComponent)
VERIFY_CLASS_OFFSET_NODIE(A,Emit_CameraLensEffectBase,DistFromCamera)
VERIFY_CLASS_OFFSET_NODIE(A,Emit_CameraLensEffectBase,Cam)
VERIFY_CLASS_SIZE_NODIE(AEmit_CameraLensEffectBase)
VERIFY_CLASS_SIZE_NODIE(AFauxPathNode)
VERIFY_CLASS_OFFSET_NODIE(A,FlockTestLocust,FlockSpawner)
VERIFY_CLASS_OFFSET_NODIE(A,FlockTestLocust,FireTime)
VERIFY_CLASS_SIZE_NODIE(AFlockTestLocust)
VERIFY_CLASS_OFFSET_NODIE(A,Gear_GrappleHookMarker,MarkerOffset)
VERIFY_CLASS_SIZE_NODIE(AGear_GrappleHookMarker)
VERIFY_CLASS_OFFSET_NODIE(A,GearAimAssistActor,Radius)
VERIFY_CLASS_OFFSET_NODIE(A,GearAimAssistActor,SphereRenderComponent)
VERIFY_CLASS_SIZE_NODIE(AGearAimAssistActor)
VERIFY_CLASS_SIZE_NODIE(AGearAirPathNode)
VERIFY_CLASS_OFFSET_NODIE(U,GearBloodInfo,Version)
VERIFY_CLASS_OFFSET_NODIE(U,GearBloodInfo,BloodInfo)
VERIFY_CLASS_SIZE_NODIE(UGearBloodInfo)
VERIFY_CLASS_OFFSET_NODIE(U,GearCameraModifier,Priority)
VERIFY_CLASS_OFFSET_NODIE(U,GearCameraModifier,TargetAlpha)
VERIFY_CLASS_SIZE_NODIE(UGearCameraModifier)
VERIFY_CLASS_OFFSET_NODIE(U,GearCamMod_ScreenShake,Shakes)
VERIFY_CLASS_OFFSET_NODIE(U,GearCamMod_ScreenShake,TargetingAlpha)
VERIFY_CLASS_SIZE_NODIE(UGearCamMod_ScreenShake)
VERIFY_CLASS_OFFSET_NODIE(U,GearCheatManager,SpawnPawnList)
VERIFY_CLASS_SIZE_NODIE(UGearCheatManager)
VERIFY_CLASS_OFFSET_NODIE(U,GearCoverMeshComponent,GameplayMeshRefs)
VERIFY_CLASS_OFFSET_NODIE(U,GearCoverMeshComponent,GameplayDisabled)
VERIFY_CLASS_SIZE_NODIE(UGearCoverMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,GearCrimsonOmenPickupFactoryBase,TagPickupSound)
VERIFY_CLASS_OFFSET_NODIE(A,GearCrimsonOmenPickupFactoryBase,TagID)
VERIFY_CLASS_SIZE_NODIE(AGearCrimsonOmenPickupFactoryBase)
VERIFY_CLASS_OFFSET_NODIE(U,GearDamageType,ImpactTypeBallisticID)
VERIFY_CLASS_OFFSET_NODIE(U,GearDamageType,OnDamageCameraShakeScale)
VERIFY_CLASS_SIZE_NODIE(UGearDamageType)
VERIFY_CLASS_OFFSET_NODIE(U,GearDecal,Instigator)
VERIFY_CLASS_OFFSET_NODIE(U,GearDecal,PercentToSpawnOnFracturedMesh)
VERIFY_CLASS_SIZE_NODIE(UGearDecal)
VERIFY_CLASS_OFFSET_NODIE(U,GearDecalInfo,Version)
VERIFY_CLASS_OFFSET_NODIE(U,GearDecalInfo,DecalInfo)
VERIFY_CLASS_SIZE_NODIE(UGearDecalInfo)
VERIFY_CLASS_OFFSET_NODIE(A,GearDestructibleObject,AmbientSoundCue)
VERIFY_CLASS_OFFSET_NODIE(A,GearDestructibleObject,ProcessedMods)
VERIFY_CLASS_SIZE_NODIE(AGearDestructibleObject)
VERIFY_CLASS_OFFSET_NODIE(A,GearDiscoverablesPickupFactoryBase,DISC_DiscoverableType)
VERIFY_CLASS_OFFSET_NODIE(A,GearDiscoverablesPickupFactoryBase,GUDSHintRadius)
VERIFY_CLASS_SIZE_NODIE(AGearDiscoverablesPickupFactoryBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearDroppedPickup,ClaimedBy)
VERIFY_CLASS_OFFSET_NODIE(A,GearDroppedPickup,MyMeshComp)
VERIFY_CLASS_SIZE_NODIE(AGearDroppedPickup)
VERIFY_CLASS_OFFSET_NODIE(A,GearEmitter,Sound)
VERIFY_CLASS_OFFSET_NODIE(A,GearEmitter,ParticleSystem)
VERIFY_CLASS_SIZE_NODIE(AGearEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,GearEngine,PendingCheckpointLocation)
VERIFY_CLASS_OFFSET_NODIE(U,GearEngine,FailureMemoryHackThreshold)
VERIFY_CLASS_SIZE_NODIE(UGearEngine)
VERIFY_CLASS_OFFSET_NODIE(U,GearEventsInterface,NumEvents)
VERIFY_CLASS_SIZE_NODIE(UGearEventsInterface)
VERIFY_CLASS_OFFSET_NODIE(A,GearGame,MapPrefixes)
VERIFY_CLASS_OFFSET_NODIE(A,GearGame,DifficultyLevels)
VERIFY_CLASS_SIZE_NODIE(AGearGame)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameAnnex_Base,AwardUpdateTime)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameAnnex_Base,KOTHPlayerPoints)
VERIFY_CLASS_SIZE_NODIE(AGearGameAnnex_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameCTM_Base,TimeForRecapture)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameCTM_Base,PointsPerCap)
VERIFY_CLASS_SIZE_NODIE(AGearGameCTM_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameGeneric,DefaultMapPrefixes)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameGeneric,SuperDuperFallBackGameType)
VERIFY_CLASS_SIZE_NODIE(AGearGameGeneric)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameMP_Base,GearGRI)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameMP_Base,InitialPlayers)
VERIFY_CLASS_SIZE_NODIE(AGearGameMP_Base)
VERIFY_CLASS_OFFSET_NODIE(U,GearGameSettings,Gore)
VERIFY_CLASS_OFFSET_NODIE(U,GearGameSettings,InvertLook)
VERIFY_CLASS_SIZE_NODIE(UGearGameSettings)
VERIFY_CLASS_OFFSET_NODIE(A,GearGameSP_Base,CurrentChapter)
VERIFY_CLASS_SIZE_NODIE(AGearGameSP_Base)
VERIFY_CLASS_SIZE_NODIE(AGearGameTDM_Base)
VERIFY_CLASS_OFFSET_NODIE(U,GearGameViewportClient,PrevTransitionType)
VERIFY_CLASS_SIZE_NODIE(UGearGameViewportClient)
VERIFY_CLASS_SIZE_NODIE(AGearGameWingman_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearGRI,GameStatus)
VERIFY_CLASS_OFFSET_NODIE(A,GearGRI,__IsWithinMaxEffectDistance__Delegate)
VERIFY_CLASS_SIZE_NODIE(AGearGRI)
VERIFY_CLASS_OFFSET_NODIE(A,GearHUD_Base,TacComEffect)
VERIFY_CLASS_OFFSET_NODIE(A,GearHUD_Base,__DebugDraw__Delegate)
VERIFY_CLASS_SIZE_NODIE(AGearHUD_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearNavModificationVolume,ExtraCost)
VERIFY_CLASS_OFFSET_NODIE(A,GearNavModificationVolume,AffectedPoints)
VERIFY_CLASS_SIZE_NODIE(AGearNavModificationVolume)
VERIFY_CLASS_OFFSET_NODIE(U,GearObjectiveManager,Objectives)
VERIFY_CLASS_OFFSET_NODIE(U,GearObjectiveManager,ObjectivesCompleteText)
VERIFY_CLASS_SIZE_NODIE(UGearObjectiveManager)
VERIFY_CLASS_OFFSET_NODIE(A,GearObjectPool,KActorCache)
VERIFY_CLASS_OFFSET_NODIE(A,GearObjectPool,PathGoalEvaluatorCache)
VERIFY_CLASS_SIZE_NODIE(AGearObjectPool)
VERIFY_CLASS_SIZE_NODIE(AGearPawnBlockingVolume)
VERIFY_CLASS_OFFSET_NODIE(U,GearPerMapColorConfig,DefaultWeaponColor)
VERIFY_CLASS_OFFSET_NODIE(U,GearPerMapColorConfig,EffectParams)
VERIFY_CLASS_SIZE_NODIE(UGearPerMapColorConfig)
VERIFY_CLASS_OFFSET_NODIE(U,GearPhysicalMaterialProperty,Version)
VERIFY_CLASS_OFFSET_NODIE(U,GearPhysicalMaterialProperty,DecalInfo)
VERIFY_CLASS_SIZE_NODIE(UGearPhysicalMaterialProperty)
VERIFY_CLASS_OFFSET_NODIE(A,GearPickupFactory,MyLightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(A,GearPickupFactory,ClaimedBy)
VERIFY_CLASS_SIZE_NODIE(AGearPickupFactory)
VERIFY_CLASS_OFFSET_NODIE(U,GearPlayerInput,TargetingModeViewScalePct)
VERIFY_CLASS_OFFSET_NODIE(U,GearPlayerInput,DemoCount)
VERIFY_CLASS_SIZE_NODIE(UGearPlayerInput)
VERIFY_CLASS_OFFSET_NODIE(U,GearPlayerInput_Base,InputButtonDataList)
VERIFY_CLASS_OFFSET_NODIE(U,GearPlayerInput_Base,__HandleButtonInput__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGearPlayerInput_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearPointOfInterest,POIPriority_ScriptedEvent)
VERIFY_CLASS_OFFSET_NODIE(A,GearPointOfInterest,POIAction)
VERIFY_CLASS_SIZE_NODIE(AGearPointOfInterest)
VERIFY_CLASS_OFFSET_NODIE(A,GearPointOfInterest_Meatflag,KidnapperTeamIndex)
VERIFY_CLASS_SIZE_NODIE(AGearPointOfInterest_Meatflag)
VERIFY_CLASS_OFFSET_NODIE(A,GearPRI,PlayerStatus)
VERIFY_CLASS_OFFSET_NODIE(A,GearPRI,WeaponStats)
VERIFY_CLASS_SIZE_NODIE(AGearPRI)
VERIFY_CLASS_OFFSET_NODIE(U,GearProfileSettings,ExcludedGameTypeIds)
VERIFY_CLASS_SIZE_NODIE(UGearProfileSettings)
VERIFY_CLASS_SIZE_NODIE(AGearScout)
VERIFY_CLASS_OFFSET_NODIE(U,GearScreenshotManager,ScreenshotIO)
VERIFY_CLASS_OFFSET_NODIE(U,GearScreenshotManager,__OnUploadScreenshotComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGearScreenshotManager)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner,Factories)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner,Killer)
VERIFY_CLASS_SIZE_NODIE(AGearSpawner)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner_EHole,EHolePrefab)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner_EHole,__TemplateDelegate__Delegate)
VERIFY_CLASS_SIZE_NODIE(AGearSpawner_EHole)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner_EholeSpawnLocation,EmergeAnim)
VERIFY_CLASS_SIZE_NODIE(AGearSpawner_EholeSpawnLocation)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner_EmergenceHoleBase,ExplosionTemplate)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpawner_EmergenceHoleBase,__TemplateDelegate__Delegate)
VERIFY_CLASS_SIZE_NODIE(AGearSpawner_EmergenceHoleBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpectatorPoint,DisplayText)
VERIFY_CLASS_OFFSET_NODIE(A,GearSpectatorPoint,MaxRotationRate)
VERIFY_CLASS_SIZE_NODIE(AGearSpectatorPoint)
VERIFY_CLASS_OFFSET_NODIE(U,GearStatsObject,GearsStatsRunID)
VERIFY_CLASS_OFFSET_NODIE(U,GearStatsObject,HordeIgnoreEvents)
VERIFY_CLASS_SIZE_NODIE(UGearStatsObject)
VERIFY_CLASS_OFFSET_NODIE(A,GearTeamInfo,TeamMembers)
VERIFY_CLASS_OFFSET_NODIE(A,GearTeamInfo,TotalScore)
VERIFY_CLASS_SIZE_NODIE(AGearTeamInfo)
VERIFY_CLASS_OFFSET_NODIE(A,GearTurret,CameraViewOffsetHigh)
VERIFY_CLASS_OFFSET_NODIE(A,GearTurret,MyLightEnvironment)
VERIFY_CLASS_SIZE_NODIE(AGearTurret)
VERIFY_CLASS_OFFSET_NODIE(U,GearTutorial_Base,SceneOpenTimeAmount)
VERIFY_CLASS_OFFSET_NODIE(U,GearTutorial_Base,NextTimeForSceneOpen)
VERIFY_CLASS_SIZE_NODIE(UGearTutorial_Base)
VERIFY_CLASS_OFFSET_NODIE(U,GearTutorialManager,TutorialClasses)
VERIFY_CLASS_OFFSET_NODIE(U,GearTutorialManager,TutorialSoundAC)
VERIFY_CLASS_SIZE_NODIE(UGearTutorialManager)
VERIFY_CLASS_OFFSET_NODIE(U,GearTypes,DamageToWeaponMap)
VERIFY_CLASS_OFFSET_NODIE(U,GearTypes,ChapterLevelNames)
VERIFY_CLASS_SIZE_NODIE(UGearTypes)
VERIFY_CLASS_OFFSET_NODIE(A,GearWallPathNode,MaxJumpDist)
VERIFY_CLASS_SIZE_NODIE(AGearWallPathNode)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeaponPickupFactory,WeaponPickupClass)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeaponPickupFactory,MeshTranslation)
VERIFY_CLASS_SIZE_NODIE(AGearWeaponPickupFactory)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_AwayFromPosition,AvoidPos)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_AwayFromPosition,BestRating)
VERIFY_CLASS_SIZE_NODIE(UGoal_AwayFromPosition)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_FarthestNavInRange,OptimalMaxDist)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_FarthestNavInRange,CurrentBest)
VERIFY_CLASS_SIZE_NODIE(UGoal_FarthestNavInRange)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_SquadFormation,PositionList)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_SquadFormation,Formation)
VERIFY_CLASS_SIZE_NODIE(UGoal_SquadFormation)
VERIFY_CLASS_SIZE_NODIE(AGrenadeBlockingVolume)
VERIFY_CLASS_OFFSET_NODIE(A,HeadTrackTarget,Radius)
VERIFY_CLASS_OFFSET_NODIE(A,HeadTrackTarget,SphereRenderComponent)
VERIFY_CLASS_SIZE_NODIE(AHeadTrackTarget)
VERIFY_CLASS_OFFSET_NODIE(A,HOD_BeamManagerBase,ActiveBeams)
VERIFY_CLASS_OFFSET_NODIE(A,HOD_BeamManagerBase,BeamClass)
VERIFY_CLASS_SIZE_NODIE(AHOD_BeamManagerBase)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_COGDerrickBase,WheelActor)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_COGDerrickBase,StripeColor)
VERIFY_CLASS_SIZE_NODIE(AInterpActor_COGDerrickBase)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_GearBasePlatform,AttachedNavList)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_GearBasePlatform,DamageTypeOnCollision)
VERIFY_CLASS_SIZE_NODIE(AInterpActor_GearBasePlatform)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_LocustBargeBase,RollPos)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_LocustBargeBase,NextRandomTorqueChange)
VERIFY_CLASS_SIZE_NODIE(AInterpActor_LocustBargeBase)
VERIFY_CLASS_SIZE_NODIE(AInterpActor_LocustTortureBargeBase)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_Pushable,PushForce)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_Pushable,MaxSpeed)
VERIFY_CLASS_SIZE_NODIE(AInterpActor_Pushable)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor_RaftBase,EntrywayCollision)
VERIFY_CLASS_SIZE_NODIE(AInterpActor_RaftBase)
VERIFY_CLASS_OFFSET_NODIE(A,JumpPoint,JumpDest)
VERIFY_CLASS_SIZE_NODIE(AJumpPoint)
VERIFY_CLASS_OFFSET_NODIE(A,LadderMarker,LadderTrigger)
VERIFY_CLASS_SIZE_NODIE(ALadderMarker)
VERIFY_CLASS_OFFSET_NODIE(U,LeapReachSpec,CachedVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,LeapReachSpec,RequiredJumpZ)
VERIFY_CLASS_SIZE_NODIE(ULeapReachSpec)
VERIFY_CLASS_OFFSET_NODIE(A,MantlePlaceholderCylinder,PawnToIgnore)
VERIFY_CLASS_SIZE_NODIE(AMantlePlaceholderCylinder)
VERIFY_CLASS_SIZE_NODIE(UPath_CoverSlotsOnly)
VERIFY_CLASS_SIZE_NODIE(AReaverLandingPoint)
VERIFY_CLASS_OFFSET_NODIE(A,RockWorm_TailSegment,WormOwner)
VERIFY_CLASS_OFFSET_NODIE(A,RockWorm_TailSegment,InitialRotation)
VERIFY_CLASS_SIZE_NODIE(ARockWorm_TailSegment)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ModifyDifficulty,AcurracyMultiplierValues)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ModifyDifficulty,AcquisitionTimeRating)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyDifficulty)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_ChapterPoint,Chapter)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_ChapterPoint,MarcusInventory)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ChapterPoint)
VERIFY_CLASS_SIZE_NODIE(ASpawnedGearEmitter)
VERIFY_CLASS_OFFSET_NODIE(A,Trigger_Engage,ENGAGE_Actor)
VERIFY_CLASS_OFFSET_NODIE(A,Trigger_Engage,EngagedPawn)
VERIFY_CLASS_SIZE_NODIE(ATrigger_Engage)
VERIFY_CLASS_OFFSET_NODIE(A,Trigger_LadderInteraction,LadderSMActor)
VERIFY_CLASS_OFFSET_NODIE(A,Trigger_LadderInteraction,ClimbUpAnim)
VERIFY_CLASS_SIZE_NODIE(ATrigger_LadderInteraction)
VERIFY_CLASS_OFFSET_NODIE(A,Turret,Claim)
VERIFY_CLASS_OFFSET_NODIE(A,Turret,InitialEntryZOffset)
VERIFY_CLASS_SIZE_NODIE(ATurret)
VERIFY_CLASS_OFFSET_NODIE(A,Turret_TroikaBase,Spotter)
VERIFY_CLASS_OFFSET_NODIE(A,Turret_TroikaBase,EntryRadius)
VERIFY_CLASS_SIZE_NODIE(ATurret_TroikaBase)
VERIFY_CLASS_OFFSET_NODIE(A,Volume_Nemacyst,Neighbors)
VERIFY_CLASS_SIZE_NODIE(AVolume_Nemacyst)
VERIFY_CLASS_SIZE_NODIE(AWalkVolume)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
