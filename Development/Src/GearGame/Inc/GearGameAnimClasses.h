/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GEARGAME_ANIM_ENUMS
#define INCLUDED_GEARGAME_ANIM_ENUMS 1

enum EAimInput
{
    AI_PawnAimOffset        =0,
    AI_BrumakLeftGun        =1,
    AI_BrumakRightGun       =2,
    AI_PawnPositionAdjust   =3,
    AI_VehicleAimOffset     =4,
    AI_MAX                  =5,
};
enum EWretchAttackState
{
    WAS_Init                =0,
    WAS_AirLoop             =1,
    WAS_Attached            =2,
    WAS_KnockOff            =3,
    WAS_MAX                 =4,
};
enum EMoveTransChannel
{
    EMTC_Idle               =0,
    EMTC_Transition         =1,
    EMTC_Walk               =2,
    EMTC_Run                =3,
    EMTC_RoadieRun          =4,
    EMTC_MAX                =5,
};
enum EOwnerType
{
    EOT_Owner               =0,
    EOT_Base                =1,
    EOT_MAX                 =2,
};
enum ESpeedType
{
    EST_Velocity            =0,
    EST_AccelAndMaxSpeed    =1,
    EST_RootMotion          =2,
    EST_MAX                 =3,
};
enum EBlendType
{
    EBT_ParentBoneSpace     =0,
    EBT_MeshSpace           =1,
    EBT_MAX                 =2,
};
enum EWeightCheck
{
    EWC_ChildIndexFullWeight=0,
    EWC_ChildIndexNotFullWeight=1,
    EWC_ChildIndexRelevant  =2,
    EWC_ChildIndexNotRelevant=3,
    EWC_MAX                 =4,
};
enum EGoreBoneState
{
    EGBS_Attached           =0,
    EGBS_Falling            =1,
    EGBS_Hidden             =2,
    EGBS_MAX                =3,
};
enum EReaverStepType
{
    ERST_FootDown           =0,
    ERST_FootUp             =1,
    ERST_MAX                =2,
};
enum EIKRecoilStart
{
    EIKRS_Zero              =0,
    EIKRS_Random            =1,
    EIKRS_MAX               =2,
};

#endif // !INCLUDED_GEARGAME_ANIM_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName GEARGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(OnTurretStatusChange)

#ifndef NAMES_ONLY

#ifndef INCLUDED_GEARGAME_ANIM_CLASSES
#define INCLUDED_GEARGAME_ANIM_CLASSES 1

class UGearAnim_AimOffset : public UAnimNodeAimOffset
{
public:
    //## BEGIN PROPS GearAnim_AimOffset
    class AGearPawn* GearPawnOwner;
    class UGearAnim_Mirror_Master* MirrorNode;
    FLOAT TurnInPlaceOffset;
    BITFIELD bIsMirrorTransition:1;
    BITFIELD bOnlyUpdateIn360Aiming:1;
    BITFIELD bUseInteractionPawnAim:1;
    BITFIELD bTurnOffWhenReloadingWeapon:1;
    BITFIELD bDoingWeaponReloadInterp:1;
    FLOAT ReloadingBlendTime;
    FLOAT ReloadingBlendTimeToGo;
    FVector2D LastAimOffset;
    FVector2D LastPostProcessedAimOffset;
    FLOAT TurnAroundTimeToGo;
    FLOAT TurnAroundBlendTime;
    BYTE AimInput;
    //## END PROPS GearAnim_AimOffset

    DECLARE_CLASS(UGearAnim_AimOffset,UAnimNodeAimOffset,0,GearGame)
	virtual void		InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	/** Pull aim information from Pawn */
	virtual FVector2D	GetAim() ;
	virtual void		PostAimProcessing(FVector2D &AimOffsetPct);
	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL		CanBlendOutFrom();
	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL		CanBlendTo();
};

class UGearAnim_AdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
    //## BEGIN PROPS GearAnim_AdditiveBlending
    class AGearPawn* GearPawnOwner;
    BITFIELD bNotForHeavyWeapons:1;
    BITFIELD bControlledByNearMisses:1;
    BITFIELD bControlledByDamage:1;
    FLOAT ControlMaxBlendAlpha;
    FLOAT ControlHoldTime;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    //## END PROPS GearAnim_AdditiveBlending

    DECLARE_CLASS(UGearAnim_AdditiveBlending,UAnimNodeAdditiveBlending,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByAngularVelocity : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS GearAnim_BlendByAngularVelocity
    BITFIELD bUseBaseVelocity:1 GCC_BITFIELD_MAGIC;
    BITFIELD bInvertWhenMovingBackwards:1;
    FLOAT AngVelAimOffsetChangeSpeed;
    FLOAT AngVelAimOffsetScale;
    FLOAT AIScale;
    INT LastYaw;
    FLOAT YawVelHistory[10];
    INT YawVelSlot;
    //## END PROPS GearAnim_BlendByAngularVelocity

    DECLARE_CLASS(UGearAnim_BlendByAngularVelocity,UAnimNodeBlend,0,GearGame)
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByRefRelative : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS GearAnim_BlendByRefRelative
    class AGearPawn* GearPawnOwner;
    TArrayNoInit<FBoneAtom> RefPoseAtoms;
    class UAnimNodeSequence* RefPoseSeqNode;
    FName RefPoseAnimName;
    BITFIELD bDisableWarningWhenAnimNotFound:1;
    BITFIELD bOnlyForRifleSet:1;
    //## END PROPS GearAnim_BlendByRefRelative

    DECLARE_CLASS(UGearAnim_BlendByRefRelative,UAnimNodeBlend,0,GearGame)
	virtual void PostAnimNodeInstance(UAnimNode* SourceNode);

	/** Update Ref Pose Data. If taken from an animation, extract the data from it, and store it in RefPoseAtoms. */
	void UpdateRefPoseData();
	void GetChildAtoms(INT ChildIndex, FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void AnimSetsUpdated();
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
	virtual void SetChildrenTotalWeightAccumulator(const INT Index);
};

class UGearAnim_BlendByWeaponFire : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS GearAnim_BlendByWeaponFire
    class AGearPawn* GearPawnOwner;
    FLOAT MaxFireBlendWeight;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    //## END PROPS GearAnim_BlendByWeaponFire

    DECLARE_CLASS(UGearAnim_BlendByWeaponFire,UAnimNodeBlend,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_Mirror_TransitionBlend : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS GearAnim_Mirror_TransitionBlend
    TArrayNoInit<class UAnimNodeSequence*> SeqNodes;
    //## END PROPS GearAnim_Mirror_TransitionBlend

    DECLARE_CLASS(UGearAnim_Mirror_TransitionBlend,UAnimNodeBlend,0,GearGame)
	// AnimNode interface
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);

	void			StartTransition(FLOAT BlendInTime);
};

struct FRotTransitionInfo
{
    FLOAT RotationOffset;
    FName TransName;

    /** Constructors */
    FRotTransitionInfo() {}
    FRotTransitionInfo(EEventParm)
    {
        appMemzero(this, sizeof(FRotTransitionInfo));
    }
};

class UGearAnim_TurnInPlace : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS GearAnim_TurnInPlace
    BITFIELD bInitialized:1 GCC_BITFIELD_MAGIC;
    BITFIELD bRootRotInitialized:1;
    BITFIELD bDelayBlendOutToPlayAnim:1;
    BITFIELD bPlayingTurnTransition:1;
    INT LastPawnYaw;
    FLOAT PawnRotationRate;
    INT LastRootBoneYaw;
    INT YawOffset;
    FLOAT RelativeOffset;
    class AGearPawn* GearPawnOwner;
    class AGearPawn* CachedBaseGearPawn;
    BYTE OwnerType;
    TArrayNoInit<class UGearAnim_AimOffset*> OffsetNodes;
    TArrayNoInit<struct FRotTransitionInfo> RotTransitions;
    FLOAT TransitionBlendInTime;
    FLOAT TransitionBlendOutTime;
    INT CurrentTransitionIndex;
    FLOAT TransitionThresholdAngle;
    TArrayNoInit<class UGearAnim_TurnInPlace_Player*> PlayerNodes;
    //## END PROPS GearAnim_TurnInPlace

    DECLARE_CLASS(UGearAnim_TurnInPlace,UAnimNodeBlend,0,GearGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
	virtual void OnBecomeRelevant();
	virtual void OnCeaseRelevant();

	/** Get an AnimNodeSequence playing a transition animation */
	UAnimNodeSequence* GetAPlayerNode();

	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom();

	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UGearAnim_BlendBySpeed : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendBySpeed
    FLOAT Speed;
    INT LastChannel;
    FLOAT BlendUpTime;
    FLOAT BlendDownTime;
    FLOAT BlendDownPerc;
    TArrayNoInit<FLOAT> Constraints;
    //## END PROPS GearAnim_BlendBySpeed

    DECLARE_CLASS(UGearAnim_BlendBySpeed,UAnimNodeBlendList,0,GearGame)
	/**
	 * Blend animations based on an Owner's velocity.
	 *
	 * @param DeltaSeconds	Time since last tick in seconds.
	 */
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
	
	// AnimNodeBlendBySpeed interface

	/** 
	 *	Function called to calculate the speed that should be used for this node. 
	 *	Allows subclasses to easily modify the speed used.
	 */
	 virtual FLOAT CalcSpeed();
};

class UGearAnim_BlendList : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendList
    TArrayNoInit<FLOAT> ChildBlendInTime;
    TArrayNoInit<UBOOL> BlockSetActiveChildWhenRelevant;
    //## END PROPS GearAnim_BlendList

    virtual void SetActiveChild(INT ChildIndex,FLOAT BlendTime);
    DECLARE_CLASS(UGearAnim_BlendList,UAnimNodeBlendList,0,GearGame)
	// AnimTree editor interface	
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
};

class UGearAnim_BaseBlendNode : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BaseBlendNode
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_BaseBlendNode

    DECLARE_CLASS(UGearAnim_BaseBlendNode,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_Wretch_BaseBlendNode : public UGearAnim_BaseBlendNode
{
public:
    //## BEGIN PROPS GearAnim_Wretch_BaseBlendNode
    //## END PROPS GearAnim_Wretch_BaseBlendNode

    DECLARE_CLASS(UGearAnim_Wretch_BaseBlendNode,UGearAnim_BaseBlendNode,0,GearGame)
	virtual void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UGearAnim_BlendByAngularVelocity3 : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByAngularVelocity3
    class AGearPawn* GearPawnOwner;
    BITFIELD bUseInteractionPawn:1;
    BITFIELD bUseBaseVelocity:1;
    BITFIELD bInvertWhenMovingBackwards:1;
    FLOAT AngularVelDeadZoneThreshold;
    FLOAT YawAngularVelSpeedScale;
    FLOAT MaxRateScale;
    FLOAT StartRelPose;
    FName ScaleBySpeedSynchGroupName;
    INT LastYaw;
    FLOAT YawVelHistory[10];
    INT YawVelSlot;
    TArrayNoInit<class UAnimNodeSequence*> AnimSeqNodesRight;
    TArrayNoInit<class UAnimNodeSequence*> AnimSeqNodesLeft;
    //## END PROPS GearAnim_BlendByAngularVelocity3

    DECLARE_CLASS(UGearAnim_BlendByAngularVelocity3,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByBlindUpStance : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByBlindUpStance
    class AGearPawn* GearPawnOwner;
    class AGearWeapon* Weapon;
    //## END PROPS GearAnim_BlendByBlindUpStance

    DECLARE_CLASS(UGearAnim_BlendByBlindUpStance,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByCoverDirection : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByCoverDirection
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_BlendByCoverDirection

    DECLARE_CLASS(UGearAnim_BlendByCoverDirection,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByCoverType : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByCoverType
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_BlendByCoverType

    DECLARE_CLASS(UGearAnim_BlendByCoverType,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByDamage : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByDamage
    class AGearPawn* MyGearPawn;
    FLOAT Duration;
    FLOAT TimeToGo;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    BITFIELD bRequiresStoppingPower:1;
    //## END PROPS GearAnim_BlendByDamage

    DECLARE_CLASS(UGearAnim_BlendByDamage,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByHeavyWeaponMount : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByHeavyWeaponMount
    class AGearPawn* MyGearPawn;
    //## END PROPS GearAnim_BlendByHeavyWeaponMount

    DECLARE_CLASS(UGearAnim_BlendByHeavyWeaponMount,UGearAnim_BlendList,0,GearGame)
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByShieldExpand : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByShieldExpand
    class AGearPawn* MyGearPawn;
    //## END PROPS GearAnim_BlendByShieldExpand

    DECLARE_CLASS(UGearAnim_BlendByShieldExpand,UGearAnim_BlendList,0,GearGame)
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendBySpecialMove : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendBySpecialMove
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_BlendBySpecialMove

    DECLARE_CLASS(UGearAnim_BlendBySpecialMove,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendBySpeedDirection : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendBySpeedDirection
    class AGearPawn* GearPawnOwner;
    INT LastChildIndex;
    //## END PROPS GearAnim_BlendBySpeedDirection

    DECLARE_CLASS(UGearAnim_BlendBySpeedDirection,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByTargetingMode : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByTargetingMode
    class AGearPawn* GearPawnOwner;
    class AGearWeapon* Weapon;
    BITFIELD bMergeAimFiringIntoIdle:1;
    BITFIELD bMergeAimIdleIntoIdleReady:1;
    BITFIELD bMergeDownSightsIntoAim:1;
    BITFIELD bMergeDownSightsFireIntoIdle:1;
    FLOAT Aim2IdleBlendOutTime;
    //## END PROPS GearAnim_BlendByTargetingMode

    DECLARE_CLASS(UGearAnim_BlendByTargetingMode,UGearAnim_BlendList,0,GearGame)
	virtual void OnCeaseRelevant();
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByTransition : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByTransition
    class AGearPawn* GearPawnOwner;
    TArrayNoInit<BYTE> PrevCoverActionBypassIntro;
    TArrayNoInit<BYTE> CoverActionBypassOutro;
    BITFIELD b360AimingBypassIntro:1;
    BITFIELD b360AimingBypassOutro:1;
    BITFIELD bPlayingIntro:1;
    BITFIELD bPlayingOutro:1;
    BITFIELD bPlayedOutro:1;
    BITFIELD bUpdatePawnActionFiringFlag:1;
    //## END PROPS GearAnim_BlendByTransition

    DECLARE_CLASS(UGearAnim_BlendByTransition,UGearAnim_BlendList,0,GearGame)
	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom();

	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL	CanBlendTo();

	/** Starts all intro nodes, and sets blend target on intro child */
	UBOOL	PlayIntro();
	UBOOL	PlayOutro();
	void	PlayMain();

	/** Stops all Intro nodes */
	void	StopIntro();
	void	StopOutro();

	/** Returns TRUE if Child is an Intro node */
	UBOOL	IsAnIntroNode(UAnimNodeSequence* Child);
	UBOOL	IsAnOutroNode(UAnimNodeSequence* Child);

	/** Get notification that this node has become relevant for the final blend. ie TotalWeight is now > 0 */
	virtual void OnBecomeRelevant();
	virtual void OnCeaseRelevant();

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);

	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_BlendByWeaponClass : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByWeaponClass
    class AGearPawn* MyGearPawn;
    class AGearWeapon* MyGearWeapon;
    TArrayNoInit<class UClass*> WeaponClassList;
    //## END PROPS GearAnim_BlendByWeaponClass

    DECLARE_CLASS(UGearAnim_BlendByWeaponClass,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	/** Track Changes, and trigger updates */
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	/** Rename Child connectors upon edit/remove */
	virtual void	RenameChildConnectors();

	// AnimNodeBlendBase interface
	virtual void	OnAddChild(INT ChildNum);
	virtual void	OnRemoveChild(INT ChildNum);
};

class UGearAnim_BlendByWeaponType : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_BlendByWeaponType
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_BlendByWeaponType

    DECLARE_CLASS(UGearAnim_BlendByWeaponType,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_CoverActionToggle : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_CoverActionToggle
    TArrayNoInit<BYTE> PrevCoverAction;
    TArrayNoInit<BYTE> CoverAction;
    class AGearPawn* GearPawnOwner;
    BYTE CachedPrevCoverAction;
    BYTE CachedCoverAction;
    //## END PROPS GearAnim_CoverActionToggle

    DECLARE_CLASS(UGearAnim_CoverActionToggle,UGearAnim_BlendList,0,GearGame)
	virtual void OnBecomeRelevant();
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL		CanBlendOutFrom();
	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL		CanBlendTo();
};

class UGearAnim_CoverBlend : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_CoverBlend
    class AGearPawn* GearPawnOwner;
    BITFIELD bUpdatePawnActionFiringFlag:1;
    BITFIELD bLockForHeavyWeapons:1;
    BITFIELD bCarryingHeavyWeapon:1;
    BYTE AnimCoverAction GCC_BITFIELD_MAGIC;
    class AWeapon* CachedWeapon;
    //## END PROPS GearAnim_CoverBlend

    DECLARE_CLASS(UGearAnim_CoverBlend,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	/** Get notification that this node is no longer relevant for the final blend. ie TotalWeight is now == 0 */
	virtual void OnCeaseRelevant();

	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue) 
	{
		check(0 == SliderIndex && 0 == ValueIndex);
		SliderPosition	= NewSliderValue;
	}
};

class UGearAnim_Skorge_BlendByStage : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_Skorge_BlendByStage
    class AGearPawn_LocustSkorgeBase* SkorgeOwner;
    //## END PROPS GearAnim_Skorge_BlendByStage

    DECLARE_CLASS(UGearAnim_Skorge_BlendByStage,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_Skorge_BlockingBullets : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_Skorge_BlockingBullets
    class AGearPawn_LocustSkorgeBase* SkorgeOwner;
    //## END PROPS GearAnim_Skorge_BlockingBullets

    DECLARE_CLASS(UGearAnim_Skorge_BlockingBullets,UGearAnim_BlendList,0,GearGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UGearAnim_Wretch_JumpAttack : public UGearAnim_BlendList
{
public:
    //## BEGIN PROPS GearAnim_Wretch_JumpAttack
    BYTE AttackState;
    //## END PROPS GearAnim_Wretch_JumpAttack

    DECLARE_CLASS(UGearAnim_Wretch_JumpAttack,UGearAnim_BlendList,0,GearGame)
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

struct FTransInfo
{
    FName TransName;
    FVector2D Range;
    FLOAT BlendTime;
    BITFIELD bAdjustAnimPos:1;
    BITFIELD bNoTransitionAnim:1;
    BITFIELD bForcePlayerToAim:1;

    /** Constructors */
    FTransInfo() {}
    FTransInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTransInfo));
    }
};

struct FMovementDef
{
    FLOAT BaseSpeed;
    TArrayNoInit<struct FTransInfo> Move2IdleTransitions;
    TArrayNoInit<class UAnimNodeSequence*> SeqNodes;

    /** Constructors */
    FMovementDef() {}
    FMovementDef(EEventParm)
    {
        appMemzero(this, sizeof(FMovementDef));
    }
};

class UGearAnim_MovementNode : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS GearAnim_MovementNode
    BYTE SpeedType;
    BYTE OwnerType;
    BITFIELD bScaleAnimationsPlayRateBySpeed:1 GCC_BITFIELD_MAGIC;
    BITFIELD bScaleConstraintsByBaseSpeed:1;
    BITFIELD bShouldHandleTransitions:1;
    BITFIELD bPlayingTransitionToIdle:1;
    class AGearPawn* GearPawnOwner;
    class AGearPawn* CachedWorkingGearPawn;
    FLOAT Speed;
    FLOAT IdleBlendOutTime;
    FLOAT BlendUpTime;
    FLOAT BlendDownTime;
    FLOAT BlendDownPerc;
    FLOAT MoveCycleFirstStepStartPosition;
    class UAnimTree* RootNode;
    FName Name_SynchGroupName;
    FLOAT TransitionBlendOutTime;
    TArrayNoInit<class UGearAnim_DirectionalMove2Idle*> TransitionNodes;
    FLOAT PrevGroupRelPos;
    FLOAT GroupRelPos;
    TArrayNoInit<struct FMovementDef> Movements;
    FTransInfo* LastTransInfo;
    FLOAT TransWeightResumeTheshold;
    //## END PROPS GearAnim_MovementNode

    DECLARE_CLASS(UGearAnim_MovementNode,UAnimNodeBlendList,0,GearGame)
	/** Perform node initialization. */
	void InitializeNode();

	/** 
	 * Returns the Pawn's current speed.
	 * Takes into account the SpeedType.
	 */
	FLOAT GetCurrentSpeed();

	/** 
	 * See if movement has reached a transition point in the given cycle, 
	 * If that's the case, the transition information is returned. Otherwise NULL is returned.
	 */
	FTransInfo*	GetTransitionInfo(TArray<FTransInfo> &CycleTransInfoList);

	/** Get WorkingPawn */
	AGearPawn*	GetWorkingPawn();
	void		StartTransition(FTransInfo* Info);
	void		ResumeTransition(FTransInfo* Info);
	UBOOL		IsTransitionFinished(FLOAT DeltaTime);
	void		StopTransition(UBOOL bAbortTransition);

	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);

	/**
	 */
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UGearAnim_Corpser_BlendClaw : public UAnimNodeBlendMultiBone
{
public:
    //## BEGIN PROPS GearAnim_Corpser_BlendClaw
    TArrayNoInit<FLOAT> TargetWeight;
    TArrayNoInit<FLOAT> BlendTimeToGo;
    TArrayNoInit<FLOAT> ChildBlendInTime;
    TArrayNoInit<FLOAT> ChildBlendOutTime;
    //## END PROPS GearAnim_Corpser_BlendClaw

    virtual class UAnimNodeSequence* PlayAttackAnim(INT LegIdx,FLOAT InTargetWeight,FName AnimSeqName=NAME_None);
    DECLARE_FUNCTION(execPlayAttackAnim)
    {
        P_GET_INT(LegIdx);
        P_GET_FLOAT(InTargetWeight);
        P_GET_NAME_OPTX(AnimSeqName,NAME_None);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=PlayAttackAnim(LegIdx,InTargetWeight,AnimSeqName);
    }
    DECLARE_CLASS(UGearAnim_Corpser_BlendClaw,UAnimNodeBlendMultiBone,0,GearGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UGearAnim_Slot : public UAnimNodeSlot
{
public:
    //## BEGIN PROPS GearAnim_Slot
    //## END PROPS GearAnim_Slot

    DECLARE_CLASS(UGearAnim_Slot,UAnimNodeSlot,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearAnim_Slot)
};

class UGearAnim_BlendByReaverLean : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_BlendByReaverLean
    FLOAT LeanYawFactor;
    FLOAT LeanStrafeFactor;
    FLOAT LeanThreshold;
    FLOAT LeanAmountHistory[10];
    INT LeanAmountSlot;
    //## END PROPS GearAnim_BlendByReaverLean

    DECLARE_CLASS(UGearAnim_BlendByReaverLean,UAnimNodeBlendBase,0,GearGame)
	virtual void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

struct FWeightNodeRule
{
    FName NodeName;
    class UAnimNodeBlendBase* CachedNode;
    BYTE WeightCheck;
    INT ChildIndex;

    /** Constructors */
    FWeightNodeRule() {}
    FWeightNodeRule(EEventParm)
    {
        appMemzero(this, sizeof(FWeightNodeRule));
    }
};

struct FWeightRule
{
    struct FWeightNodeRule FirstNode;
    struct FWeightNodeRule SecondNode;

    /** Constructors */
    FWeightRule() {}
    FWeightRule(EEventParm)
    {
        appMemzero(this, sizeof(FWeightRule));
    }
};

struct FBranchInfo
{
    FName BoneName;
    FLOAT PerBoneWeightIncrease;

    /** Constructors */
    FBranchInfo() {}
    FBranchInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBranchInfo));
    }
};

struct FPerBoneMaskInfo
{
    TArrayNoInit<struct FBranchInfo> BranchList;
    FLOAT DesiredWeight;
    FLOAT BlendTimeToGo;
    TArrayNoInit<struct FWeightRule> WeightRuleList;
    BITFIELD bWeightBasedOnNodeRules:1;
    BITFIELD bDisableForNonLocalHumanPlayers:1;
    BITFIELD bDisableIfCameraBoneMotionScaleIsZero:1;
    BITFIELD bPendingBlend:1;
    TArrayNoInit<FLOAT> PerBoneWeights;
    TArrayNoInit<FBoneAtom> MaskAtoms;
    TArrayNoInit<FMatrix> MeshSpaceTM;
    TArrayNoInit<BYTE> TransformReqBone;
    INT TransformReqBoneIndex;

    /** Constructors */
    FPerBoneMaskInfo() {}
    FPerBoneMaskInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPerBoneMaskInfo));
    }
};

class UGearAnim_BlendPerBone : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_BlendPerBone
    class AGearPawn* GearPawnOwner;
    TArrayNoInit<struct FPerBoneMaskInfo> MaskList;
    BYTE RotationBlendType;
    //## END PROPS GearAnim_BlendPerBone

    void SetMaskWeight(INT MaskIndex,FLOAT DesiredWeight,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetMaskWeight)
    {
        P_GET_INT(MaskIndex);
        P_GET_FLOAT(DesiredWeight);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        SetMaskWeight(MaskIndex,DesiredWeight,BlendTime);
    }
    DECLARE_CLASS(UGearAnim_BlendPerBone,UAnimNodeBlendBase,0,GearGame)
	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);

	/** Ticking, updates weights... */
	virtual	void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	/** 
	 * Calculates total weight of children. 
	 * Set a full weight on source, because it's potentially always feeding animations into the final blend.
	 */
	virtual void	SetChildrenTotalWeightAccumulator(const INT Index);

	/** @see UAnimNode::GetBoneAtoms. */
	virtual void	GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	// Special Optimized Paths
	FORCEINLINE void	MeshSpaceBlendMultipleMasks(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren);
	FORCEINLINE void	LocalBlendMultipleMasks(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren);
	FORCEINLINE void	MeshSpaceBlendSingleMask(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren);
	FORCEINLINE void	LocalBlendSingleMask(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren);

	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom();
	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL	CanBlendTo();

	/**
	 * Utility for creating the Mask PerBoneWeights array. 
	 * Walks down the hierarchy increasing the weight by PerBoneWeightIncrease each step.
	 */
	virtual void	CalcMaskWeight(INT MaskIndex);

	virtual	void	UpdateRules();

	/** Track Changes, and trigger updates */
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	/** Rename Child connectors upon edit/remove */
	virtual void	RenameChildConnectors();

	// AnimNodeBlendBase interface
	virtual void	OnAddChild(INT ChildNum);
	virtual void	OnRemoveChild(INT ChildNum);
};

struct FGearGoreEntry
{
    BITFIELD bEnabled:1;
    FName HitBodyName;
    FName GoreBoneName;
    INT Health;
    INT EffectInfoIndex;
    INT MaterialParamIndex;
    FVector EffectOffset;
    INT GoreBoneIndex;
    INT ChildEntryIndex;
    FVector GoreBoneLocation;
    FVector GoreBoneRotation;
    FVector GoreBoneVelocity;
    FVector GoreBoneAngVelocity;
    BYTE GoreBoneState;
    FLOAT FallingLifetime;

    /** Constructors */
    FGearGoreEntry() {}
    FGearGoreEntry(EEventParm)
    {
        appMemzero(this, sizeof(FGearGoreEntry));
    }
};

struct FGearGoreMaterialParam
{
    FName ScalarParamName;
    FLOAT IncreasePerGore;

    /** Constructors */
    FGearGoreMaterialParam() {}
    FGearGoreMaterialParam(EEventParm)
    {
        appMemzero(this, sizeof(FGearGoreMaterialParam));
    }
};

class UGearAnim_GoreSystem : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_GoreSystem
    TArrayNoInit<struct FGearGoreEntry> GoreSetup;
    FLOAT FallingLifetime;
    FLOAT GoreFallGravScale;
    FLOAT ExplosiveGoreRadius;
    FLOAT GoreInitialVel;
    FLOAT GoreInitialAngVel;
    FVector ActorSpaceAdditionalVel;
    TArrayNoInit<struct FGearGoreEffectInfo> GoreEffectInfos;
    TArrayNoInit<struct FGearGoreMaterialParam> GoreMaterialParamInfos;
    BITFIELD bTestAllGore:1;
    BITFIELD bOldTestAllGore:1;
    BITFIELD bAutoFillGoreSetup:1;
    //## END PROPS GearAnim_GoreSystem

    virtual void UpdateGoreDamage(FName ShotBoneName,FVector HitLocation,INT Damage);
    virtual void UpdateGoreDamageRadial(FVector HitLocation,INT Damage,UBOOL bForceRemoveAll);
    virtual void ForceLoseGorePiece(FName GoreBoneName);
    virtual void ResetAllGore();
    DECLARE_FUNCTION(execUpdateGoreDamage)
    {
        P_GET_NAME(ShotBoneName);
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_INT(Damage);
        P_FINISH;
        UpdateGoreDamage(ShotBoneName,HitLocation,Damage);
    }
    DECLARE_FUNCTION(execUpdateGoreDamageRadial)
    {
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_INT(Damage);
        P_GET_UBOOL(bForceRemoveAll);
        P_FINISH;
        UpdateGoreDamageRadial(HitLocation,Damage,bForceRemoveAll);
    }
    DECLARE_FUNCTION(execForceLoseGorePiece)
    {
        P_GET_NAME(GoreBoneName);
        P_FINISH;
        ForceLoseGorePiece(GoreBoneName);
    }
    DECLARE_FUNCTION(execResetAllGore)
    {
        P_FINISH;
        ResetAllGore();
    }
    DECLARE_CLASS(UGearAnim_GoreSystem,UAnimNodeBlendBase,0,GearGame)
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	void CalcGoreIndexInfo();

	/** Start the supplied gore piece falling */
	void LoseGorePiece(FGearGoreEntry& GoreEntry, const FMatrix& GoreBoneMatrix);

	void AutoFillGoreSetup(USkeletalMesh* SkelMesh);
	void SortGoreSetup();
};

class UGearAnim_Mirror_Master : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_Mirror_Master
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    FLOAT BlendOutTimeToGo;
    BITFIELD bForceMirrorTransitionAnimInCover:1;
    BITFIELD bPlayingTransition:1;
    BITFIELD bDelayUntilMasterRelevant:1;
    BITFIELD bLockBlendOut:1;
    BITFIELD bBlendingOut:1;
    BITFIELD bEditorMirrored:1;
    BITFIELD bEditorInCover:1;
    BITFIELD bPendingIsMirrored:1;
    BITFIELD bIsMirrored:1;
    BITFIELD bToggledMirrorStatus:1;
    class AGearPawn* GearPawnOwner;
    FLOAT TransitionStartedTime;
    TArrayNoInit<class UGearAnim_Mirror_TransitionBlend*> TransitionNodes;
    class UAnimTree* RootNode;
    FName GroupName;
    TArrayNoInit<class UGearAnim_Slot*> BodyStanceNodes;
    TArrayNoInit<FName> Drive_SkelControlNames;
    TArrayNoInit<class USkelControlBase*> Drive_SkelControls;
    //## END PROPS GearAnim_Mirror_Master

    void MirrorBodyStanceNode(class UGearAnim_Slot* SlotNode,UBOOL bBeginTransition,UBOOL bMirrorAnimation);
    void ForceDrivenNodesOff();
    UBOOL AreDrivenNodesTurnedOff();
    DECLARE_FUNCTION(execMirrorBodyStanceNode)
    {
        P_GET_OBJECT(UGearAnim_Slot,SlotNode);
        P_GET_UBOOL(bBeginTransition);
        P_GET_UBOOL(bMirrorAnimation);
        P_FINISH;
        MirrorBodyStanceNode(SlotNode,bBeginTransition,bMirrorAnimation);
    }
    DECLARE_FUNCTION(execForceDrivenNodesOff)
    {
        P_FINISH;
        ForceDrivenNodesOff();
    }
    DECLARE_FUNCTION(execAreDrivenNodesTurnedOff)
    {
        P_FINISH;
        *(UBOOL*)Result=AreDrivenNodesTurnedOff();
    }
    DECLARE_CLASS(UGearAnim_Mirror_Master,UAnimNodeBlendBase,0,GearGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	void	ToggleMirrorStatus();
	void	TransitionFinished();
	/** Called when mirror transition is starting */
	void	TransitionStarted();
	/** Called when mirror transition is starting to blend out */
	void	TransitionBlendingOut(FLOAT BlendOutTimeToGo);

	/** Get most relevant TransitionBlend node */
	UGearAnim_Mirror_TransitionBlend* GetMostRelevantTransitionNode();
};

class UGearAnim_RockwormTail_SynchToPrev : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_RockwormTail_SynchToPrev
    class ARockWorm_TailSegment* MyTailSeg;
    class UAnimNodeSequence* MasterNodeToSyncTo;
    class UAnimNodeSequence* MySynchNode;
    FName SynchGroupName;
    //## END PROPS GearAnim_RockwormTail_SynchToPrev

    DECLARE_CLASS(UGearAnim_RockwormTail_SynchToPrev,UAnimNodeBlendBase,0,GearGame)
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	void InitCachePtrs();
};

class UGearAnim_TurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_TurnInPlace_Rotator
    class AGearPawn* GearPawnOwner;
    class UGearAnim_TurnInPlace* TurnInPlaceNode;
    //## END PROPS GearAnim_TurnInPlace_Rotator

    DECLARE_CLASS(UGearAnim_TurnInPlace_Rotator,UAnimNodeBlendBase,0,GearGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
};

struct FBoneCopyInfo
{
    FName SrcBoneName;
    FName DstBoneName;
    FVector PositionOffset;
    INT SrcBoneIndex;
    INT DstBoneIndex;

    /** Constructors */
    FBoneCopyInfo() {}
    FBoneCopyInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBoneCopyInfo));
    }
};

class UGearAnim_UpperBodyIKHack : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS GearAnim_UpperBodyIKHack
    class UGearAnim_Mirror_Master* CachedMirrorNode;
    class AGearPawn* GearPawnOwner;
    TArrayNoInit<struct FBoneCopyInfo> BoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> BoneCopyArrayMirrored;
    BITFIELD bDisableForHeavyWeapons:1;
    BITFIELD bDisableForMeatShield:1;
    BITFIELD bNodeDisabled:1;
    BITFIELD bUpdatedWeightNodesList:1;
    TArrayNoInit<BYTE> RequiredBones;
    TArrayNoInit<BYTE> RequiredBonesMirrored;
    TArrayNoInit<FMatrix> BoneTM;
    TArrayNoInit<FName> OffsetWeightNodesNamesList;
    TArrayNoInit<class UAnimNode*> OffsetWeightNodesList;
    //## END PROPS GearAnim_UpperBodyIKHack

    DECLARE_CLASS(UGearAnim_UpperBodyIKHack,UAnimNodeBlendBase,0,GearGame)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** Update cached list of required bones, use to transform skeleton from parent space to component space. */
	void UpdateListOfRequiredBones();
	void UpdateOffsetWeightNodesList();

	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
};

class UGearAnim_BlendAnimsByAim : public UAnimNodeSequenceBlendByAim
{
public:
    //## BEGIN PROPS GearAnim_BlendAnimsByAim
    class AGearPawn* GearPawnOwner;
    BYTE AimInput;
    //## END PROPS GearAnim_BlendAnimsByAim

    DECLARE_CLASS(UGearAnim_BlendAnimsByAim,UAnimNodeSequenceBlendByAim,0,GearGame)
	/** Pull aim information from Pawn */
	virtual FVector2D GetAim();

	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
};

class UGearAnim_BlendAnimsByDirection : public UAnimNodeSequenceBlendBase
{
public:
    //## BEGIN PROPS GearAnim_BlendAnimsByDirection
    BYTE OwnerType;
    BITFIELD bAddRotationRate:1 GCC_BITFIELD_MAGIC;
    FLOAT BlendSpeed;
    FLOAT DirAngle;
    FVector MoveDir;
    INT LastYaw;
    FLOAT YawRotationRate;
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_BlendAnimsByDirection

    DECLARE_CLASS(UGearAnim_BlendAnimsByDirection,UAnimNodeSequenceBlendBase,0,GearGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	
	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

struct FDTransInfo
{
    FName TransitionName;
    FName AnimName_Fd;
    FName AnimName_Bd;
    FName AnimName_Lt;
    FName AnimName_Rt;

    /** Constructors */
    FDTransInfo() {}
    FDTransInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDTransInfo));
    }
};

class UGearAnim_DirectionalMove2Idle : public UGearAnim_BlendAnimsByDirection
{
public:
    //## BEGIN PROPS GearAnim_DirectionalMove2Idle
    TArrayNoInit<struct FDTransInfo> DTransList;
    //## END PROPS GearAnim_DirectionalMove2Idle

    DECLARE_CLASS(UGearAnim_DirectionalMove2Idle,UGearAnim_BlendAnimsByDirection,0,GearGame)
	void	SetTransition(FName TransitionName, FLOAT StartPosition);
	UBOOL	IsTransitionFinished(FLOAT DeltaTime);
	void	StopTransition();
};

struct FTIP_Transition
{
    FName TransName;
    FName AnimName;

    /** Constructors */
    FTIP_Transition() {}
    FTIP_Transition(EEventParm)
    {
        appMemzero(this, sizeof(FTIP_Transition));
    }
};

class UGearAnim_TurnInPlace_Player : public UAnimNodeSequenceBlendBase
{
public:
    //## BEGIN PROPS GearAnim_TurnInPlace_Player
    TArrayNoInit<struct FTIP_Transition> TIP_Transitions;
    FLOAT TransitionBlendTime;
    INT ActiveChildIndex;
    FLOAT BlendTimeToGo;
    //## END PROPS GearAnim_TurnInPlace_Player

    DECLARE_CLASS(UGearAnim_TurnInPlace_Player,UAnimNodeSequenceBlendBase,0,GearGame)
	/** Play a turn in place transition */
	void PlayTransition(FName TransitionName, FLOAT BlendTime);
	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	void SetActiveChild(INT ChildIndex, FLOAT BlendTime);
};

class UGearAnim_ReverseByDirection : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS GearAnim_ReverseByDirection
    BITFIELD bInvertDirection:1 GCC_BITFIELD_MAGIC;
    BITFIELD bReversed:1;
    FLOAT SliderPosition;
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearAnim_ReverseByDirection

    DECLARE_CLASS(UGearAnim_ReverseByDirection,UAnimNodeSequence,0,GearGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UGearAnimNotify_ReaverStep : public UAnimNotify
{
public:
    //## BEGIN PROPS GearAnimNotify_ReaverStep
    INT LegIndex;
    FLOAT StepTime;
    BYTE StepAction;
    //## END PROPS GearAnimNotify_ReaverStep

    DECLARE_CLASS(UGearAnimNotify_ReaverStep,UAnimNotify,0,GearGame)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};

struct FCtrlInfo
{
    FName ControlName;
    FName SeqNodeName;

    /** Constructors */
    FCtrlInfo() {}
    FCtrlInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCtrlInfo));
    }
};

class UGearAnimNotify_ToggleSkelControl : public UAnimNotify
{
public:
    //## BEGIN PROPS GearAnimNotify_ToggleSkelControl
    BITFIELD bTurnOn:1;
    FLOAT BlendTime;
    TArrayNoInit<struct FCtrlInfo> Controls;
    //## END PROPS GearAnimNotify_ToggleSkelControl

    DECLARE_CLASS(UGearAnimNotify_ToggleSkelControl,UAnimNotify,0,GearGame)
	// AnimNotify interface.
	virtual void Notify(class UAnimNodeSequence* NodeSeq);
};

struct FBoneAngleMorph
{
    FLOAT Angle;
    FLOAT TargetWeight;

    /** Constructors */
    FBoneAngleMorph() {}
    FBoneAngleMorph(EEventParm)
    {
        appMemzero(this, sizeof(FBoneAngleMorph));
    }
};

class UGearMorph_WeightByBoneAngle : public UMorphNodeWeightBase
{
public:
    //## BEGIN PROPS GearMorph_WeightByBoneAngle
    FLOAT Angle;
    FLOAT NodeWeight;
    FName BaseBoneName;
    BYTE BaseBoneAxis;
    BYTE AngleBoneAxis;
    BITFIELD bInvertBaseBoneAxis:1 GCC_BITFIELD_MAGIC;
    BITFIELD bInvertAngleBoneAxis:1;
    BITFIELD bControlMaterialParameter:1;
    FName AngleBoneName;
    INT MaterialSlotId;
    FName ScalarParameterName;
    class UMaterialInstanceConstant* MaterialInstanceConstant;
    TArrayNoInit<struct FBoneAngleMorph> WeightArray;
    //## END PROPS GearMorph_WeightByBoneAngle

    DECLARE_CLASS(UGearMorph_WeightByBoneAngle,UMorphNodeWeightBase,0,GearGame)
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	/** Render on 3d viewport when node is selected. */
	virtual void Render(const FSceneView* View, FPrimitiveDrawInterface* PDI);
	/** Draw on 3d viewport canvas when node is selected */
	virtual void Draw(FViewport* Viewport, FCanvas* Canvas, const FSceneView* View);
};

class UGearSkelCtrl_Recoil : public UGameSkelCtrl_Recoil
{
public:
    //## BEGIN PROPS GearSkelCtrl_Recoil
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearSkelCtrl_Recoil

    DECLARE_CLASS(UGearSkelCtrl_Recoil,UGameSkelCtrl_Recoil,0,GearGame)
	/** Pull aim information from Pawn */
	virtual FVector2D GetAim(USkeletalMeshComponent* InSkelComponent);
	/** Is skeleton currently mirrored */
	virtual UBOOL IsMirrored(USkeletalMeshComponent* InSkelComponent);
};

class UGearSkelCtrl_CCD_IK : public USkelControlBase
{
public:
    //## BEGIN PROPS GearSkelCtrl_CCD_IK
    FVector EffectorLocation;
    BYTE EffectorLocationSpace;
    FName EffectorSpaceBoneName;
    FVector EffectorTranslationFromBone;
    INT NumBones;
    INT MaxPerBoneIterations;
    INT IterationsCount;
    FLOAT Precision;
    BITFIELD bStartFromTail:1;
    BITFIELD bNoTurnOptimization:1;
    TArrayNoInit<FLOAT> AngleConstraint;
    FLOAT MaxAngleSteps;
    //## END PROPS GearSkelCtrl_CCD_IK

    DECLARE_CLASS(UGearSkelCtrl_CCD_IK,USkelControlBase,0,GearGame)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	

	virtual INT GetWidgetCount();
	virtual FMatrix GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
};

class UGearSkelCtrl_Flamethrower : public USkelControlBase
{
public:
    //## BEGIN PROPS GearSkelCtrl_Flamethrower
    //## END PROPS GearSkelCtrl_Flamethrower

    DECLARE_CLASS(UGearSkelCtrl_Flamethrower,USkelControlBase,0,GearGame)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

struct FFlameScaleInParams
{
    FVector2D ScaleInTimeRange;
    FVector2D ScaleRange;
    FLOAT Pow;

    /** Constructors */
    FFlameScaleInParams() {}
    FFlameScaleInParams(EEventParm)
    {
        appMemzero(this, sizeof(FFlameScaleInParams));
    }
};

struct FFlameVelocityScaleParams
{
    FVector2D VelocityRange;
    FVector2D ScaleRange;
    FLOAT Pow;

    /** Constructors */
    FFlameVelocityScaleParams() {}
    FFlameVelocityScaleParams(EEventParm)
    {
        appMemzero(this, sizeof(FFlameVelocityScaleParams));
    }
};

struct FFlameBoneScaleParams
{
    FName BoneName;
    FLOAT CachedBoneIndex;
    BITFIELD bScaleIn:1;
    struct FFlameScaleInParams ScaleInParams;
    BITFIELD bScaleWithVelocity:1;
    struct FFlameVelocityScaleParams VelocityScaleParams;

    /** Constructors */
    FFlameBoneScaleParams() {}
    FFlameBoneScaleParams(EEventParm)
    {
        appMemzero(this, sizeof(FFlameBoneScaleParams));
    }
};

class UGearSkelCtrl_FlamethrowerScaling : public USkelControlBase
{
public:
    //## BEGIN PROPS GearSkelCtrl_FlamethrowerScaling
    FLOAT CurrentAge;
    FLOAT CurrentVel;
    FLOAT LastVel;
    FLOAT VelocitySmoothingInterpSpeed;
    TArrayNoInit<struct FFlameBoneScaleParams> ScaleParams;
    //## END PROPS GearSkelCtrl_FlamethrowerScaling

    DECLARE_CLASS(UGearSkelCtrl_FlamethrowerScaling,USkelControlBase,0,GearGame)
public:
	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneScales(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FLOAT>& OutBoneScales);
};

class UGearSkelCtrl_Prune : public USkelControlBase
{
public:
    //## BEGIN PROPS GearSkelCtrl_Prune
    FName StartBoneName;
    INT CachedStartBoneIndex;
    INT NumAffectedBones;
    FLOAT PrunedBoneScale;
    //## END PROPS GearSkelCtrl_Prune

    DECLARE_CLASS(UGearSkelCtrl_Prune,USkelControlBase,0,GearGame)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneScales(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FLOAT>& OutBoneScales);
};

class UGearSkelCtrl_Spring : public USkelControlBase
{
public:
    //## BEGIN PROPS GearSkelCtrl_Spring
    BITFIELD bLimitDisplacement:1;
    BITFIELD bNoZSpring:1;
    BITFIELD bHadValidStrength:1;
    FLOAT MaxDisplacement;
    FLOAT SpringStiffness;
    FLOAT SpringDamping;
    FLOAT ErrorResetThresh;
    FLOAT ThisTimstep;
    FVector BoneLocation;
    FVector BoneVelocity;
    //## END PROPS GearSkelCtrl_Spring

    DECLARE_CLASS(UGearSkelCtrl_Spring,USkelControlBase,0,GearGame)
	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
};

class UGearSkelCtrl_Trail : public USkelControlBase
{
public:
    //## BEGIN PROPS GearSkelCtrl_Trail
    INT ChainLength;
    BYTE ChainBoneAxis;
    BITFIELD bInvertChainBoneAxis:1 GCC_BITFIELD_MAGIC;
    BITFIELD bLimitStretch:1;
    BITFIELD bHadValidStrength:1;
    FLOAT TrailRelaxation;
    FLOAT StretchLimit;
    FLOAT ThisTimstep;
    TArrayNoInit<FVector> TrailBoneLocations;
    //## END PROPS GearSkelCtrl_Trail

    DECLARE_CLASS(UGearSkelCtrl_Trail,USkelControlBase,0,GearGame)
	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
};

class UGearSkelCtrl_CorpserIK : public USkelControlLimb
{
public:
    //## BEGIN PROPS GearSkelCtrl_CorpserIK
    FLOAT ShoulderLengthStretchAllowance;
    FVector2D InterpDistRange;
    //## END PROPS GearSkelCtrl_CorpserIK

    DECLARE_CLASS(UGearSkelCtrl_CorpserIK,USkelControlLimb,0,GearGame)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
	virtual void DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

class UGearSkelCtrl_FootPlanting : public USkelControlLimb
{
public:
    //## BEGIN PROPS GearSkelCtrl_FootPlanting
    BITFIELD bDoFootLocking:1;
    BITFIELD bLockFoot:1;
    FLOAT FootLockZThreshold;
    FName FootBoneName;
    FName IKFootBoneName;
    FLOAT LockAlphaBlendTime;
    FLOAT LockAlphaBlendTimeToGo;
    FLOAT LockAlpha;
    FLOAT LockAlphaTarget;
    FLOAT LastDeltaTime;
    FVector LockFootLoc;
    FVector LockedFootWorldLoc;
    //## END PROPS GearSkelCtrl_FootPlanting

    DECLARE_CLASS(UGearSkelCtrl_FootPlanting,USkelControlLimb,0,GearGame)
	void UpdateLockAlpha(FLOAT DeltaSeconds);
	void SetLockAlphaTarget(UBOOL bUnlock);

	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual void DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

struct FIKRecoilParams
{
    BYTE X;
    BYTE Y;
    BYTE Z;
    BYTE Padding;

    /** Constructors */
    FIKRecoilParams() {}
    FIKRecoilParams(EEventParm)
    {
        appMemzero(this, sizeof(FIKRecoilParams));
    }
};

struct FIKRecoilDef
{
    FLOAT TimeToGo;
    FLOAT TimeDuration;
    FVector RotAmplitude;
    FVector RotFrequency;
    FVector RotSinOffset;
    struct FIKRecoilParams RotParams;
    FRotator RotOffset;
    FVector LocAmplitude;
    FVector LocFrequency;
    FVector LocSinOffset;
    struct FIKRecoilParams LocParams;
    FVector LocOffset;

    /** Constructors */
    FIKRecoilDef() {}
    FIKRecoilDef(EEventParm)
    {
        appMemzero(this, sizeof(FIKRecoilDef));
    }
};

class UGearSkelCtrl_IKRecoil : public USkelControlLimb
{
public:
    //## BEGIN PROPS GearSkelCtrl_IKRecoil
    struct FIKRecoilDef Recoil;
    FVector2D Aim;
    BITFIELD bPlayRecoil:1;
    BITFIELD bOldPlayRecoil:1;
    BITFIELD bApplyControl:1;
    class AGearPawn* GearPawnOwner;
    //## END PROPS GearSkelCtrl_IKRecoil

    DECLARE_CLASS(UGearSkelCtrl_IKRecoil,USkelControlLimb,0,GearGame)
	/** Pull aim information from Pawn */
	virtual FVector2D GetAim(USkeletalMeshComponent* InSkelComponent);

	/** Is skeleton currently mirrored */
	virtual UBOOL IsMirrored(USkeletalMeshComponent* InSkelComponent);

	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
};

class UGearSkelCtrl_Copy : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS GearSkelCtrl_Copy
    BITFIELD bMirror_Controlled:1;
    BITFIELD bInvertMirrorControl:1;
    BITFIELD bHeavyWeaponControlled:1;
    BITFIELD bDisableDuringWeaponSwitches:1;
    BITFIELD bHeavyWeaponStatus:1;
    class UGearAnim_Mirror_Master* CachedMirrorNode;
    class AGearWeapon* CachedGearWeapon;
    class AGearPawn* CachedGearPawn;
    //## END PROPS GearSkelCtrl_Copy

    DECLARE_CLASS(UGearSkelCtrl_Copy,USkelControlSingleBone,0,GearGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct FTurretConstraintData
{
    INT PitchConstraint;
    INT YawConstraint;
    INT RollConstraint;

    /** Constructors */
    FTurretConstraintData() {}
    FTurretConstraintData(EEventParm)
    {
        appMemzero(this, sizeof(FTurretConstraintData));
    }
};

struct FTurretStepData
{
    INT StepStartAngle;
    INT StepEndAngle;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;

    /** Constructors */
    FTurretStepData() {}
    FTurretStepData(EEventParm)
    {
        appMemzero(this, sizeof(FTurretStepData));
    }
};

struct GearSkelCtrl_TurretConstrained_eventOnTurretStatusChange_Parms
{
    UBOOL bIsMoving;
    GearSkelCtrl_TurretConstrained_eventOnTurretStatusChange_Parms(EEventParm)
    {
    }
};
class UGearSkelCtrl_TurretConstrained : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS GearSkelCtrl_TurretConstrained
    BITFIELD bConstrainPitch:1;
    BITFIELD bConstrainYaw:1;
    BITFIELD bConstrainRoll:1;
    BITFIELD bInvertPitch:1;
    BITFIELD bInvertYaw:1;
    BITFIELD bInvertRoll:1;
    BITFIELD bZeroCompletelyConstrained:1;
    BITFIELD bFixedWhenFiring:1;
    BITFIELD bResetWhenUnattended:1;
    BITFIELD bIsInMotion:1;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;
    TArrayNoInit<struct FTurretStepData> Steps;
    FLOAT LagDegreesPerSecond;
    FLOAT PitchSpeedScale;
    FRotator DesiredBoneRotation;
    INT AssociatedSeatIndex;
    FRotator ConstrainedBoneRotation;
    FScriptDelegate __OnTurretStatusChange__Delegate;
    //## END PROPS GearSkelCtrl_TurretConstrained

    void InitTurret(FRotator InitRot,class USkeletalMeshComponent* SkelComp);
    UBOOL WouldConstrainPitch(INT TestPitch,class USkeletalMeshComponent* SkelComp);
    DECLARE_FUNCTION(execInitTurret)
    {
        P_GET_STRUCT(FRotator,InitRot);
        P_GET_OBJECT(USkeletalMeshComponent,SkelComp);
        P_FINISH;
        InitTurret(InitRot,SkelComp);
    }
    DECLARE_FUNCTION(execWouldConstrainPitch)
    {
        P_GET_INT(TestPitch);
        P_GET_OBJECT(USkeletalMeshComponent,SkelComp);
        P_FINISH;
        *(UBOOL*)Result=WouldConstrainPitch(TestPitch,SkelComp);
    }
    void delegateOnTurretStatusChange(UBOOL bIsMoving)
    {
        GearSkelCtrl_TurretConstrained_eventOnTurretStatusChange_Parms Parms(EC_EventParm);
        Parms.bIsMoving=bIsMoving ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(GEARGAME_OnTurretStatusChange,&__OnTurretStatusChange__Delegate,&Parms);
    }
    DECLARE_CLASS(UGearSkelCtrl_TurretConstrained,USkelControlSingleBone,0,GearGame)
	/** handles constraining the passed in local space rotator based on the turret's parameters */
	FRotator GetClampedLocalDesiredRotation(const FRotator& UnclampedLocalDesired);
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

#endif // !INCLUDED_GEARGAME_ANIM_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGearAnim_BlendList,-1,execSetActiveChild);
AUTOGENERATE_FUNCTION(UGearAnim_BlendPerBone,-1,execSetMaskWeight);
AUTOGENERATE_FUNCTION(UGearAnim_Corpser_BlendClaw,-1,execPlayAttackAnim);
AUTOGENERATE_FUNCTION(UGearAnim_GoreSystem,-1,execResetAllGore);
AUTOGENERATE_FUNCTION(UGearAnim_GoreSystem,-1,execForceLoseGorePiece);
AUTOGENERATE_FUNCTION(UGearAnim_GoreSystem,-1,execUpdateGoreDamageRadial);
AUTOGENERATE_FUNCTION(UGearAnim_GoreSystem,-1,execUpdateGoreDamage);
AUTOGENERATE_FUNCTION(UGearAnim_Mirror_Master,-1,execAreDrivenNodesTurnedOff);
AUTOGENERATE_FUNCTION(UGearAnim_Mirror_Master,-1,execForceDrivenNodesOff);
AUTOGENERATE_FUNCTION(UGearAnim_Mirror_Master,-1,execMirrorBodyStanceNode);
AUTOGENERATE_FUNCTION(UGearSkelCtrl_TurretConstrained,-1,execWouldConstrainPitch);
AUTOGENERATE_FUNCTION(UGearSkelCtrl_TurretConstrained,-1,execInitTurret);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GEARGAME_ANIM_NATIVE_DEFS
#define GEARGAME_ANIM_NATIVE_DEFS

DECLARE_NATIVE_TYPE(GearGame,UGearAnim_AdditiveBlending);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_AimOffset);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BaseBlendNode);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendAnimsByAim);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendAnimsByDirection);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByAngularVelocity);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByAngularVelocity3);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByBlindUpStance);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByCoverDirection);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByCoverType);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByDamage);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByHeavyWeaponMount);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByReaverLean);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByRefRelative);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByShieldExpand);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendBySpecialMove);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendBySpeed);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendBySpeedDirection);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByTargetingMode);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByTransition);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByWeaponClass);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByWeaponFire);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendByWeaponType);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendList);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_BlendPerBone);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Corpser_BlendClaw);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_CoverActionToggle);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_CoverBlend);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_DirectionalMove2Idle);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_GoreSystem);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Mirror_Master);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Mirror_TransitionBlend);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_MovementNode);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_ReverseByDirection);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_RockwormTail_SynchToPrev);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Skorge_BlendByStage);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Skorge_BlockingBullets);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Slot);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_TurnInPlace);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_TurnInPlace_Player);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_TurnInPlace_Rotator);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_UpperBodyIKHack);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Wretch_BaseBlendNode);
DECLARE_NATIVE_TYPE(GearGame,UGearAnim_Wretch_JumpAttack);
DECLARE_NATIVE_TYPE(GearGame,UGearAnimNotify_ReaverStep);
DECLARE_NATIVE_TYPE(GearGame,UGearAnimNotify_ToggleSkelControl);
DECLARE_NATIVE_TYPE(GearGame,UGearMorph_WeightByBoneAngle);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_CCD_IK);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_Copy);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_CorpserIK);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_Flamethrower);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_FlamethrowerScaling);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_FootPlanting);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_IKRecoil);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_Prune);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_Recoil);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_Spring);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_Trail);
DECLARE_NATIVE_TYPE(GearGame,UGearSkelCtrl_TurretConstrained);

#define AUTO_INITIALIZE_REGISTRANTS_GEARGAME_ANIM \
	UGearAnim_AdditiveBlending::StaticClass(); \
	UGearAnim_AimOffset::StaticClass(); \
	UGearAnim_BaseBlendNode::StaticClass(); \
	UGearAnim_BlendAnimsByAim::StaticClass(); \
	UGearAnim_BlendAnimsByDirection::StaticClass(); \
	UGearAnim_BlendByAngularVelocity::StaticClass(); \
	UGearAnim_BlendByAngularVelocity3::StaticClass(); \
	UGearAnim_BlendByBlindUpStance::StaticClass(); \
	UGearAnim_BlendByCoverDirection::StaticClass(); \
	UGearAnim_BlendByCoverType::StaticClass(); \
	UGearAnim_BlendByDamage::StaticClass(); \
	UGearAnim_BlendByHeavyWeaponMount::StaticClass(); \
	UGearAnim_BlendByReaverLean::StaticClass(); \
	UGearAnim_BlendByRefRelative::StaticClass(); \
	UGearAnim_BlendByShieldExpand::StaticClass(); \
	UGearAnim_BlendBySpecialMove::StaticClass(); \
	UGearAnim_BlendBySpeed::StaticClass(); \
	UGearAnim_BlendBySpeedDirection::StaticClass(); \
	UGearAnim_BlendByTargetingMode::StaticClass(); \
	UGearAnim_BlendByTransition::StaticClass(); \
	UGearAnim_BlendByWeaponClass::StaticClass(); \
	UGearAnim_BlendByWeaponFire::StaticClass(); \
	UGearAnim_BlendByWeaponType::StaticClass(); \
	UGearAnim_BlendList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearAnim_BlendListNative; \
	UGearAnim_BlendPerBone::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearAnim_BlendPerBoneNative; \
	UGearAnim_Corpser_BlendClaw::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearAnim_Corpser_BlendClawNative; \
	UGearAnim_CoverActionToggle::StaticClass(); \
	UGearAnim_CoverBlend::StaticClass(); \
	UGearAnim_DirectionalMove2Idle::StaticClass(); \
	UGearAnim_GoreSystem::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearAnim_GoreSystemNative; \
	UGearAnim_Mirror_Master::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearAnim_Mirror_MasterNative; \
	UGearAnim_Mirror_TransitionBlend::StaticClass(); \
	UGearAnim_MovementNode::StaticClass(); \
	UGearAnim_ReverseByDirection::StaticClass(); \
	UGearAnim_RockwormTail_SynchToPrev::StaticClass(); \
	UGearAnim_Skorge_BlendByStage::StaticClass(); \
	UGearAnim_Skorge_BlockingBullets::StaticClass(); \
	UGearAnim_Slot::StaticClass(); \
	UGearAnim_TurnInPlace::StaticClass(); \
	UGearAnim_TurnInPlace_Player::StaticClass(); \
	UGearAnim_TurnInPlace_Rotator::StaticClass(); \
	UGearAnim_UpperBodyIKHack::StaticClass(); \
	UGearAnim_Wretch_BaseBlendNode::StaticClass(); \
	UGearAnim_Wretch_JumpAttack::StaticClass(); \
	UGearAnimNotify_ReaverStep::StaticClass(); \
	UGearAnimNotify_ToggleSkelControl::StaticClass(); \
	UGearMorph_WeightByBoneAngle::StaticClass(); \
	UGearSkelCtrl_CCD_IK::StaticClass(); \
	UGearSkelCtrl_Copy::StaticClass(); \
	UGearSkelCtrl_CorpserIK::StaticClass(); \
	UGearSkelCtrl_Flamethrower::StaticClass(); \
	UGearSkelCtrl_FlamethrowerScaling::StaticClass(); \
	UGearSkelCtrl_FootPlanting::StaticClass(); \
	UGearSkelCtrl_IKRecoil::StaticClass(); \
	UGearSkelCtrl_Prune::StaticClass(); \
	UGearSkelCtrl_Recoil::StaticClass(); \
	UGearSkelCtrl_Spring::StaticClass(); \
	UGearSkelCtrl_Trail::StaticClass(); \
	UGearSkelCtrl_TurretConstrained::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearSkelCtrl_TurretConstrainedNative; \

#endif // GEARGAME_ANIM_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UGearAnim_BlendList) GGearGameUGearAnim_BlendListNatives[] = 
{ 
	MAP_NATIVE(UGearAnim_BlendList,execSetActiveChild)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearAnim_BlendList);

NATIVE_INFO(UGearAnim_BlendPerBone) GGearGameUGearAnim_BlendPerBoneNatives[] = 
{ 
	MAP_NATIVE(UGearAnim_BlendPerBone,execSetMaskWeight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearAnim_BlendPerBone);

NATIVE_INFO(UGearAnim_Corpser_BlendClaw) GGearGameUGearAnim_Corpser_BlendClawNatives[] = 
{ 
	MAP_NATIVE(UGearAnim_Corpser_BlendClaw,execPlayAttackAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearAnim_Corpser_BlendClaw);

NATIVE_INFO(UGearAnim_GoreSystem) GGearGameUGearAnim_GoreSystemNatives[] = 
{ 
	MAP_NATIVE(UGearAnim_GoreSystem,execResetAllGore)
	MAP_NATIVE(UGearAnim_GoreSystem,execForceLoseGorePiece)
	MAP_NATIVE(UGearAnim_GoreSystem,execUpdateGoreDamageRadial)
	MAP_NATIVE(UGearAnim_GoreSystem,execUpdateGoreDamage)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearAnim_GoreSystem);

NATIVE_INFO(UGearAnim_Mirror_Master) GGearGameUGearAnim_Mirror_MasterNatives[] = 
{ 
	MAP_NATIVE(UGearAnim_Mirror_Master,execAreDrivenNodesTurnedOff)
	MAP_NATIVE(UGearAnim_Mirror_Master,execForceDrivenNodesOff)
	MAP_NATIVE(UGearAnim_Mirror_Master,execMirrorBodyStanceNode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearAnim_Mirror_Master);

NATIVE_INFO(UGearSkelCtrl_TurretConstrained) GGearGameUGearSkelCtrl_TurretConstrainedNatives[] = 
{ 
	MAP_NATIVE(UGearSkelCtrl_TurretConstrained,execWouldConstrainPitch)
	MAP_NATIVE(UGearSkelCtrl_TurretConstrained,execInitTurret)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearSkelCtrl_TurretConstrained);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_AdditiveBlending,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_AdditiveBlending,BlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_AdditiveBlending)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_AimOffset,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_AimOffset,AimInput)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_AimOffset)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BaseBlendNode,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BaseBlendNode)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendAnimsByAim,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendAnimsByAim,AimInput)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendAnimsByAim)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendAnimsByDirection,OwnerType)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendAnimsByDirection,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendAnimsByDirection)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByAngularVelocity,AngVelAimOffsetChangeSpeed)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByAngularVelocity,YawVelSlot)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByAngularVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByAngularVelocity3,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByAngularVelocity3,AnimSeqNodesLeft)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByAngularVelocity3)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByBlindUpStance,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByBlindUpStance,Weapon)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByBlindUpStance)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByCoverDirection,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByCoverDirection)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByCoverType,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByCoverType)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByDamage,MyGearPawn)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByDamage,BlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByDamage)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByHeavyWeaponMount,MyGearPawn)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByHeavyWeaponMount)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByReaverLean,LeanYawFactor)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByReaverLean,LeanAmountSlot)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByReaverLean)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByRefRelative,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByRefRelative,RefPoseAnimName)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByRefRelative)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByShieldExpand,MyGearPawn)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByShieldExpand)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendBySpecialMove,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendBySpecialMove)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendBySpeed,Speed)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendBySpeed,Constraints)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendBySpeed)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendBySpeedDirection,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendBySpeedDirection,LastChildIndex)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendBySpeedDirection)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByTargetingMode,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByTargetingMode,Aim2IdleBlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByTargetingMode)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByTransition,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByTransition,CoverActionBypassOutro)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByTransition)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByWeaponClass,MyGearPawn)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByWeaponClass,WeaponClassList)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByWeaponClass)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByWeaponFire,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByWeaponFire,BlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByWeaponFire)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendByWeaponType,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendByWeaponType)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendList,ChildBlendInTime)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendList,BlockSetActiveChildWhenRelevant)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendList)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendPerBone,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_BlendPerBone,RotationBlendType)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_BlendPerBone)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Corpser_BlendClaw,TargetWeight)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Corpser_BlendClaw,ChildBlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Corpser_BlendClaw)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_CoverActionToggle,PrevCoverAction)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_CoverActionToggle,CachedCoverAction)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_CoverActionToggle)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_CoverBlend,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_CoverBlend,CachedWeapon)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_CoverBlend)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_DirectionalMove2Idle,DTransList)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_DirectionalMove2Idle)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_GoreSystem,GoreSetup)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_GoreSystem,GoreMaterialParamInfos)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_GoreSystem)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Mirror_Master,BlendInTime)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Mirror_Master,Drive_SkelControls)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Mirror_Master)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Mirror_TransitionBlend,SeqNodes)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Mirror_TransitionBlend)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_MovementNode,SpeedType)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_MovementNode,TransWeightResumeTheshold)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_MovementNode)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_ReverseByDirection,SliderPosition)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_ReverseByDirection,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_ReverseByDirection)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_RockwormTail_SynchToPrev,MyTailSeg)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_RockwormTail_SynchToPrev,SynchGroupName)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_RockwormTail_SynchToPrev)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Skorge_BlendByStage,SkorgeOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Skorge_BlendByStage)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Skorge_BlockingBullets,SkorgeOwner)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Skorge_BlockingBullets)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Slot)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_TurnInPlace,LastPawnYaw)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_TurnInPlace,PlayerNodes)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_TurnInPlace)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_TurnInPlace_Player,TIP_Transitions)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_TurnInPlace_Player,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_TurnInPlace_Player)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_TurnInPlace_Rotator,GearPawnOwner)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_TurnInPlace_Rotator,TurnInPlaceNode)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_TurnInPlace_Rotator)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_UpperBodyIKHack,CachedMirrorNode)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_UpperBodyIKHack,OffsetWeightNodesList)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_UpperBodyIKHack)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Wretch_BaseBlendNode)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnim_Wretch_JumpAttack,AttackState)
VERIFY_CLASS_SIZE_NODIE(UGearAnim_Wretch_JumpAttack)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnimNotify_ReaverStep,LegIndex)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnimNotify_ReaverStep,StepAction)
VERIFY_CLASS_SIZE_NODIE(UGearAnimNotify_ReaverStep)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnimNotify_ToggleSkelControl,BlendTime)
VERIFY_CLASS_OFFSET_NODIE(U,GearAnimNotify_ToggleSkelControl,Controls)
VERIFY_CLASS_SIZE_NODIE(UGearAnimNotify_ToggleSkelControl)
VERIFY_CLASS_OFFSET_NODIE(U,GearMorph_WeightByBoneAngle,Angle)
VERIFY_CLASS_OFFSET_NODIE(U,GearMorph_WeightByBoneAngle,WeightArray)
VERIFY_CLASS_SIZE_NODIE(UGearMorph_WeightByBoneAngle)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_CCD_IK,EffectorLocation)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_CCD_IK,MaxAngleSteps)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_CCD_IK)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Copy,CachedMirrorNode)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Copy,CachedGearPawn)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_Copy)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_CorpserIK,ShoulderLengthStretchAllowance)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_CorpserIK,InterpDistRange)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_CorpserIK)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_Flamethrower)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_FlamethrowerScaling,CurrentAge)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_FlamethrowerScaling,ScaleParams)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_FlamethrowerScaling)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_FootPlanting,FootLockZThreshold)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_FootPlanting,LockedFootWorldLoc)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_FootPlanting)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_IKRecoil,Recoil)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_IKRecoil,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_IKRecoil)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Prune,StartBoneName)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Prune,PrunedBoneScale)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_Prune)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Recoil,GearPawnOwner)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_Recoil)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Spring,MaxDisplacement)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Spring,BoneVelocity)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_Spring)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Trail,ChainLength)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_Trail,TrailBoneLocations)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_Trail)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_TurretConstrained,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,GearSkelCtrl_TurretConstrained,__OnTurretStatusChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGearSkelCtrl_TurretConstrained)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
