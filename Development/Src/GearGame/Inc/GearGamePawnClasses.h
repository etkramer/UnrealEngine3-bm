/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GEARGAME_PAWN_ENUMS
#define INCLUDED_GEARGAME_PAWN_ENUMS 1

enum PawnOnFireState
{
    POF_None                =0,
    POF_Blazing             =1,
    POF_Smoldering          =2,
    POF_MAX                 =3,
};
enum EGearDeathType
{
    GDT_NORMAL              =0,
    GDT_Headshot            =1,
    GDT_MAX                 =2,
};
enum EBodyStance
{
    BS_FullBody             =0,
    BS_Std_Up               =1,
    BS_Std_Upper_Harsh      =2,
    BS_Std_Upper_NoAim      =3,
    BS_Std_idle_FullBody    =4,
    BS_Std_Idle_Lower       =5,
    BS_Std_Idle_Upper       =6,
    BS_Std_Walk_Upper       =7,
    BS_Std_Run_Upper        =8,
    BS_CovStdIdle_Up        =9,
    BS_CovStdBlind_Up       =10,
    BS_CovStdLean_Up        =11,
    BS_CovStd_360_Upper     =12,
    BS_CovMidIdle_Up        =13,
    BS_CovMidBlindSd_Up     =14,
    BS_CovMidBlindUp_Up     =15,
    BS_CovMidLean_Up        =16,
    BS_CovMid_360_Upper     =17,
    BS_Additive             =18,
    BS_Kidnapper_Upper      =19,
    BS_Hostage_Upper        =20,
    BS_Shield_Hunkered      =21,
    BS_MortarMounted        =22,
    BS_MAX                  =23,
};
enum EAttachSlot
{
    EASlot_Holster          =0,
    EASlot_Belt             =1,
    EASlot_LeftShoulder     =2,
    EASlot_RightShoulder    =3,
    EASlot_None             =4,
    EASlot_MAX              =5,
};
enum ECQCMove
{
    CQCMove_None            =0,
    CQCMove_MeatBag         =1,
    CQCMove_WeaponKill      =2,
    CQCMove_CharacterKill   =3,
    CQCMove_CurbStomp       =4,
    CQCMove_MAX             =5,
};
enum ESpecialMove
{
    SM_None                 =0,
    SM_MidLvlJumpOver       =1,
    SM_StdLvlSwatTurn       =2,
    SM_CoverRun             =3,
    SM_RoadieRun            =4,
    SM_CoverSlip            =5,
    SM_MantleUpLowCover     =6,
    SM_MantleDown           =7,
    SM_EvadeFwd             =8,
    SM_EvadeBwd             =9,
    SM_EvadeLt              =10,
    SM_EvadeRt              =11,
    SM_Run2MidCov           =12,
    SM_Run2StdCov           =13,
    SM_Run2Idle             =14,
    SM_Walk2Idle            =15,
    SM_PushOutOfCover       =16,
    SM_FlankedReaction_Left =17,
    SM_FlankedReaction_Right=18,
    SM_FlankedReaction_Back =19,
    SM_FlankedReaction_Front=20,
    SM_Reaction_InitCombat  =21,
    SM_FullBodyHitReaction  =22,
    SM_StumbleFromMelee     =23,
    SM_StumbleFromMelee2    =24,
    SM_StumbleGoDown        =25,
    SM_StumbleGoDownFromExplosion=26,
    SM_StumbleGoDownFromCloseRangeShot=27,
    SM_StumbleGetUp         =28,
    SM_CoverHead            =29,
    SM_StumbleBackOutOfCover=30,
    SM_DBNO                 =31,
    SM_RecoverFromDBNO      =32,
    SM_RoadieRunHitReactionStumble=33,
    SM_Emerge_Type1         =34,
    SM_Emerge_Type2         =35,
    SM_DeathAnim            =36,
    SM_DeathAnimFire        =37,
    SM_RecoverFromRagdoll   =38,
    SM_ChainSawHold         =39,
    SM_ChainSawAttack       =40,
    SM_ChainSawVictim       =41,
    SM_ChainsawDuel_Leader  =42,
    SM_ChainsawDuel_Follower=43,
    SM_ChainsawDuel_Draw    =44,
    SM_ChainSawAttack_Object=45,
    SM_ChainSawAttack_Object_NoCamera=46,
    SM_EvadeFromCoverCrouching=47,
    SM_EvadeFromCoverStanding=48,
    SM_CQC_Killer           =49,
    SM_CQC_Victim           =50,
    SM_CQCMove_CurbStomp    =51,
    SM_CQCMove_PunchFace    =52,
    SM_CQCMove_Shield       =53,
    SM_CQCMove_B            =54,
    SM_Execution_CurbStomp  =55,
    SM_ReviveTeammate       =56,
    SM_GrabWretch           =57,
    SM_GrabWretchFollower   =58,
    SM_Kidnapper            =59,
    SM_Hostage              =60,
    SM_Kidnapper_Execution  =61,
    SM_WeaponPickup         =62,
    SM_DoorPush             =63,
    SM_DoorKick             =64,
    SM_PushButton           =65,
    SM_Engage_Loop          =66,
    SM_Engage_Start         =67,
    SM_Engage_End           =68,
    SM_Engage_Idle          =69,
    SM_Engage_ForceOff      =70,
    SM_LadderClimbUp        =71,
    SM_LadderClimbDown      =72,
    SM_GrapplingHook_Climb  =73,
    SM_PushObject           =74,
    SM_UsingCommLink        =75,
    SM_PutOnHelmet          =76,
    SM_TargetMortar         =77,
    SM_TargetMinigun        =78,
    SM_UnMountMinigun       =79,
    SM_UnMountMortar        =80,
    SM_DeployShield         =81,
    SM_PlantShield          =82,
    SM_RaiseShieldOverHead  =83,
    SM_ShieldBash           =84,
    GSM_PounceAttack        =85,
    GSM_SwipeAttack         =86,
    GSM_Scream              =87,
    GSM_LeapToCeiling       =88,
    GSM_DropFromCeiling     =89,
    GSM_Cart_ClimbUp        =90,
    GSM_Cart_SwipeAttack    =91,
    GSM_Elevator_Climb      =92,
    SM_Wretch_GrabAttack    =93,
    SM_Berserker_Smash      =94,
    SM_Berserker_Charge     =95,
    SM_Berserker_Collide    =96,
    SM_Berserker_Stunned    =97,
    SM_Berserker_Slide      =98,
    SM_Berserker_HODHitReaction=99,
    SM_Berserker_Alert      =100,
    GSM_Brumak_Roar         =101,
    GSM_Brumak_RtGunHit     =102,
    GSM_Brumak_LtGunHit     =103,
    GSM_Brumak_CannonHit    =104,
    GSM_Brumak_CannonFire   =105,
    GSM_Brumak_MeleeAttack  =106,
    GSM_Brumak_OverlayLftArmSwing=107,
    GSM_Brumak_OverlayRtArmSwing=108,
    GSM_Brumak_OverlayBite  =109,
    GSM_Brumak_Scream       =110,
    GSM_Brumak_LtGunPain    =111,
    GSM_Brumak_RtGunPain    =112,
    GSM_Brumak_ExposeDriver =113,
    SM_BloodMountDriver_CalmMount=114,
    SM_BloodMount_HitInFace =115,
    GSM_BloodMount_Melee    =116,
    GSM_Kantus_KnockdownScream=117,
    GSM_Kantus_ReviveScream =118,
    GSM_Kantus_SummoningScream=119,
    GSM_Sire_MeleeHeadGrab  =120,
    GSM_Sire_TankFall       =121,
    ESpecialMove_MAX        =122,
};
enum ESituationMood
{
    SITMOOD_Default         =0,
    SITMOOD_Tense           =1,
    SITMOOD_MAX             =2,
};
enum ESkorgeStage
{
    SKORGE_Staff            =0,
    SKORGE_TwoStick         =1,
    SKORGE_OneStick         =2,
    SKORGE_MAX              =3,
};
enum ELeviStatus
{
    LEVISTAT_Closed         =0,
    LEVISTAT_Opening        =1,
    LEVISTAT_Open           =2,
    LEVISTAT_Closing        =3,
    LEVISTAT_MAX            =4,
};
enum ETentacleStatus
{
    TENTACLE_None           =0,
    TENTACLE_Start          =1,
    TENTACLE_Tell           =2,
    TENTACLE_Attack         =3,
    TENTACLE_Interp         =4,
    TENTACLE_Pause          =5,
    TENTACLE_Retract        =6,
    TENTACLE_Damaged        =7,
    TENTACLE_Wounded        =8,
    TENTACLE_MAX            =9,
};

#endif // !INCLUDED_GEARGAME_PAWN_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName GEARGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AI_AddDefaultInventory)
AUTOGENERATE_NAME(BodyImpactBlendOutNotify)
AUTOGENERATE_NAME(BumpLevel)
AUTOGENERATE_NAME(CanDoSpecialMove)
AUTOGENERATE_NAME(ConditionalMove2IdleTransition)
AUTOGENERATE_NAME(CoverActionAnimationFinished)
AUTOGENERATE_NAME(Cringe)
AUTOGENERATE_NAME(DmgDealingLimbsCollision)
AUTOGENERATE_NAME(EvadeAnimationFinished)
AUTOGENERATE_NAME(FixWeaponAimIKPosition)
AUTOGENERATE_NAME(GetAimOffsetOrigin)
AUTOGENERATE_NAME(GetHeadLookTargetLocation)
AUTOGENERATE_NAME(IsCarryingShield)
AUTOGENERATE_NAME(IsDeployingShield)
AUTOGENERATE_NAME(IsFiringHOD)
AUTOGENERATE_NAME(IsInAimingPose)
AUTOGENERATE_NAME(IsPlayingCustomCameraAnim)
AUTOGENERATE_NAME(KnockdownFailsafe)
AUTOGENERATE_NAME(LocalEndSpecialMove)
AUTOGENERATE_NAME(Move2IdleTransitionFinished)
AUTOGENERATE_NAME(NotifyDoneRotating)
AUTOGENERATE_NAME(On360AimingChangeNotify)
AUTOGENERATE_NAME(OnMirrorBlendOutNotify)
AUTOGENERATE_NAME(OnMirroredNotify)
AUTOGENERATE_NAME(PlayGibEffect)
AUTOGENERATE_NAME(PlaySpeechGesture)
AUTOGENERATE_NAME(PostAIFactorySpawned)
AUTOGENERATE_NAME(ReachedCoverSlot)
AUTOGENERATE_NAME(RestoreAnimSetsToDefault)
AUTOGENERATE_NAME(ScriptedDeath)
AUTOGENERATE_NAME(ServerEndSpecialMove)
AUTOGENERATE_NAME(SetConversing)
AUTOGENERATE_NAME(SetHeadTrackActor)
AUTOGENERATE_NAME(SetMirroredSide)
AUTOGENERATE_NAME(SetWeaponAlert)
AUTOGENERATE_NAME(SpawnExecutionEffect_Boltok)
AUTOGENERATE_NAME(SpawnExecutionEffect_LongShot)
AUTOGENERATE_NAME(SpawnExecutionEffect_PunchLeftToRight)
AUTOGENERATE_NAME(SpawnExecutionEffect_PunchRightToLeft)
AUTOGENERATE_NAME(SpawnExecutionEffect_TorqueBow)
AUTOGENERATE_NAME(SpeakLineFinished)
AUTOGENERATE_NAME(SplashBloodOnScreen_ExecutionBoltok)
AUTOGENERATE_NAME(SplashBloodOnScreen_PunchFace)
AUTOGENERATE_NAME(SplashBloodOnScreen_SmashFace)
AUTOGENERATE_NAME(SplashBloodOnScreen_TorqueBow)
AUTOGENERATE_NAME(SplashChainsawBloodOnScreen)
AUTOGENERATE_NAME(SplashPunchFaceBloodOnScreen)
AUTOGENERATE_NAME(StopCringe)
AUTOGENERATE_NAME(UpdateAttachmentVisibility)
AUTOGENERATE_NAME(UpdateMarker)
AUTOGENERATE_NAME(UpdateShadowSettings)

#ifndef NAMES_ONLY

#ifndef INCLUDED_GEARGAME_PAWN_CLASSES
#define INCLUDED_GEARGAME_PAWN_CLASSES 1

struct FReplicatedRootPosInfo
{
    FVector Position;
    BYTE bNewData;

    /** Constructors */
    FReplicatedRootPosInfo() {}
    FReplicatedRootPosInfo(EEventParm)
    {
        appMemzero(this, sizeof(FReplicatedRootPosInfo));
    }
};

struct FSMStruct
{
    BYTE SpecialMove;
    class AGearPawn* InteractionPawn;
    INT Flags;

    /** Constructors */
    FSMStruct() {}
    FSMStruct(EEventParm)
    {
        appMemzero(this, sizeof(FSMStruct));
    }
};

struct FPhysicsImpactRBRemap
{
    FName RB_FromName;
    FName RB_ToName;

    /** Constructors */
    FPhysicsImpactRBRemap() {}
    FPhysicsImpactRBRemap(EEventParm)
    {
        appMemzero(this, sizeof(FPhysicsImpactRBRemap));
    }
};

struct FDependantBreakInfo
{
    FName ParentBone;
    TArrayNoInit<FName> DependantBones;

    /** Constructors */
    FDependantBreakInfo() {}
    FDependantBreakInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDependantBreakInfo));
    }
};

struct FDeadRagdollLimitScale
{
    FName RB_ConstraintName;
    FLOAT Swing1Scale;
    FLOAT Swing2Scale;
    FLOAT TwistScale;

    /** Constructors */
    FDeadRagdollLimitScale() {}
    FDeadRagdollLimitScale(EEventParm)
    {
        appMemzero(this, sizeof(FDeadRagdollLimitScale));
    }
};

struct FWeaponRepInfo
{
    class UClass* WeaponClass;
    BYTE BYTE_bHadAPreviousWeapon;

    /** Constructors */
    FWeaponRepInfo() {}
    FWeaponRepInfo(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponRepInfo));
    }
};

struct FSAttachSlot
{
    FName SocketName;
    BITFIELD bAttachToBone:1;
    class UClass* InvClass;
    class UStaticMeshComponent* StaticMesh;
    class USkeletalMeshComponent* SkeletalMesh;

    /** Constructors */
    FSAttachSlot() {}
    FSAttachSlot(EEventParm)
    {
        appMemzero(this, sizeof(FSAttachSlot));
    }
};

struct FCustomCameraAnimPropertiesStruct
{
    BITFIELD bSingleRayPenetrationOnly:1;
    BITFIELD bApplyFullMotion:1;

    /** Constructors */
    FCustomCameraAnimPropertiesStruct() {}
    FCustomCameraAnimPropertiesStruct(EEventParm)
    {
        appMemzero(this, sizeof(FCustomCameraAnimPropertiesStruct));
    }
};

struct FBodyStance
{
    TArrayNoInit<FName> AnimName;

    /** Constructors */
    FBodyStance() {}
    FBodyStance(EEventParm)
    {
        appMemzero(this, sizeof(FBodyStance));
    }
};

struct FCringeInfo
{
    class UClass* DamageType;
    TArrayNoInit<FLOAT> History;
    FLOAT NextCringeTime;

    /** Constructors */
    FCringeInfo() {}
    FCringeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCringeInfo));
    }
};

struct FAimAttractor
{
    FLOAT OuterRadius;
    FLOAT InnerRadius;
    FName BoneName;

    /** Constructors */
    FAimAttractor() {}
    FAimAttractor(EEventParm)
    {
        appMemzero(this, sizeof(FAimAttractor));
    }
};

struct FSpeakLineParamStruct
{
    class AGearPawn* Addressee;
    class USoundCue* Audio;
    FStringNoInit DebugText;
    BITFIELD bNoHeadTrack:1;
    BYTE BroadcastFilter GCC_BITFIELD_MAGIC;
    BITFIELD bSuppressSubtitle:1 GCC_BITFIELD_MAGIC;
    BYTE Priority GCC_BITFIELD_MAGIC;
    FLOAT DelayTime;
    FLOAT ExtraHeadTrackTime;

    /** Constructors */
    FSpeakLineParamStruct() {}
    FSpeakLineParamStruct(EEventParm)
    {
        appMemzero(this, sizeof(FSpeakLineParamStruct));
    }
};

struct FPhysicsImpulseInfo
{
    FVector LinearVelocity;
    FVector AngularVelocity;

    /** Constructors */
    FPhysicsImpulseInfo() {}
    FPhysicsImpulseInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPhysicsImpulseInfo));
    }
};

struct FStoppingPowerStruct
{
    FVector Direction;
    FLOAT StoppingPower;
    FLOAT Lifetime;

    /** Constructors */
    FStoppingPowerStruct() {}
    FStoppingPowerStruct(EEventParm)
    {
        appMemzero(this, sizeof(FStoppingPowerStruct));
    }
};

struct FWeaponStartTraceLocationCacheStruct
{
    BITFIELD bUpToDate:1;
    FVector StartLoc;
    class AWeapon* WeaponCacheIsValidFor;

    /** Constructors */
    FWeaponStartTraceLocationCacheStruct() {}
    FWeaponStartTraceLocationCacheStruct(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponStartTraceLocationCacheStruct));
    }
};

#define UCONST_STATS_LEVEL5 0x10
#define UCONST_STATS_LEVEL4 0x08
#define UCONST_STATS_LEVEL1 0x01
#define UCONST_MAX_DECALS_ATTACHED 3
#define UCONST_MaxCoverGuessDist 256.f

struct GearPawn_eventIsFiringHOD_Parms
{
    UBOOL ReturnValue;
    GearPawn_eventIsFiringHOD_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventPlaySpeechGesture_Parms
{
    FName GestureAnim;
    GearPawn_eventPlaySpeechGesture_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSpawnExecutionEffect_PunchLeftToRight_Parms
{
    GearPawn_eventSpawnExecutionEffect_PunchLeftToRight_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSpawnExecutionEffect_PunchRightToLeft_Parms
{
    GearPawn_eventSpawnExecutionEffect_PunchRightToLeft_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSpawnExecutionEffect_TorqueBow_Parms
{
    GearPawn_eventSpawnExecutionEffect_TorqueBow_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSpawnExecutionEffect_LongShot_Parms
{
    GearPawn_eventSpawnExecutionEffect_LongShot_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSpawnExecutionEffect_Boltok_Parms
{
    GearPawn_eventSpawnExecutionEffect_Boltok_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSplashBloodOnScreen_TorqueBow_Parms
{
    GearPawn_eventSplashBloodOnScreen_TorqueBow_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSplashBloodOnScreen_SmashFace_Parms
{
    GearPawn_eventSplashBloodOnScreen_SmashFace_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSplashBloodOnScreen_PunchFace_Parms
{
    GearPawn_eventSplashBloodOnScreen_PunchFace_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSplashBloodOnScreen_ExecutionBoltok_Parms
{
    GearPawn_eventSplashBloodOnScreen_ExecutionBoltok_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSplashPunchFaceBloodOnScreen_Parms
{
    GearPawn_eventSplashPunchFaceBloodOnScreen_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSplashChainsawBloodOnScreen_Parms
{
    GearPawn_eventSplashChainsawBloodOnScreen_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventIsDeployingShield_Parms
{
    UBOOL ReturnValue;
    GearPawn_eventIsDeployingShield_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventIsCarryingShield_Parms
{
    UBOOL ReturnValue;
    GearPawn_eventIsCarryingShield_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventPlayGibEffect_Parms
{
    FVector HitLoc;
    FVector HitNorm;
    FLOAT SquaredForce;
    GearPawn_eventPlayGibEffect_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventBumpLevel_Parms
{
    FVector HitLocation;
    FVector HitNormal;
    GearPawn_eventBumpLevel_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventKnockdownFailsafe_Parms
{
    GearPawn_eventKnockdownFailsafe_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSpeakLineFinished_Parms
{
    GearPawn_eventSpeakLineFinished_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSetHeadTrackActor_Parms
{
    class AActor* ActorToTrack;
    FName LookatBoneName;
    UBOOL bOverride;
    UBOOL ReturnValue;
    GearPawn_eventSetHeadTrackActor_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSetWeaponAlert_Parms
{
    FLOAT Duration;
    GearPawn_eventSetWeaponAlert_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventIsInAimingPose_Parms
{
    UBOOL ReturnValue;
    GearPawn_eventIsInAimingPose_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventStopCringe_Parms
{
    GearPawn_eventStopCringe_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventCringe_Parms
{
    FLOAT Duration;
    GearPawn_eventCringe_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventIsPlayingCustomCameraAnim_Parms
{
    FName SpecificAnimName;
    UBOOL ReturnValue;
    GearPawn_eventIsPlayingCustomCameraAnim_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSetConversing_Parms
{
    UBOOL bConv;
    UBOOL bUseCommLink;
    GearPawn_eventSetConversing_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventReachedCoverSlot_Parms
{
    INT SlotIdx;
    GearPawn_eventReachedCoverSlot_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventOnMirrorBlendOutNotify_Parms
{
    GearPawn_eventOnMirrorBlendOutNotify_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventOnMirroredNotify_Parms
{
    GearPawn_eventOnMirroredNotify_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventSetMirroredSide_Parms
{
    UBOOL bDesiredMirrored;
    GearPawn_eventSetMirroredSide_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventRestoreAnimSetsToDefault_Parms
{
    UBOOL ReturnValue;
    GearPawn_eventRestoreAnimSetsToDefault_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventUpdateAttachmentVisibility_Parms
{
    GearPawn_eventUpdateAttachmentVisibility_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventGetPhysicalFireStartLoc_Parms
{
    FVector FireOffset;
    FVector ReturnValue;
    GearPawn_eventGetPhysicalFireStartLoc_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventMove2IdleTransitionFinished_Parms
{
    GearPawn_eventMove2IdleTransitionFinished_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventConditionalMove2IdleTransition_Parms
{
    GearPawn_eventConditionalMove2IdleTransition_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventEvadeAnimationFinished_Parms
{
    GearPawn_eventEvadeAnimationFinished_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventLocalEndSpecialMove_Parms
{
    BYTE SpecialMoveToEnd;
    GearPawn_eventLocalEndSpecialMove_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventServerEndSpecialMove_Parms
{
    BYTE SpecialMoveToEnd;
    GearPawn_eventServerEndSpecialMove_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventCanDoSpecialMove_Parms
{
    BYTE AMove;
    UBOOL bForceCheck;
    UBOOL ReturnValue;
    GearPawn_eventCanDoSpecialMove_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventDoSpecialMove_Parms
{
    BYTE NewMove;
    UBOOL bForceMove;
    class AGearPawn* InInteractionPawn;
    INT InSpecialMoveFlags;
    GearPawn_eventDoSpecialMove_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventPostAIFactorySpawned_Parms
{
    class USeqAct_AIFactory* SpawningFactory;
    INT SpawnSetIdx;
    GearPawn_eventPostAIFactorySpawned_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventAI_AddDefaultInventory_Parms
{
    GearPawn_eventAI_AddDefaultInventory_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventCoverActionAnimationFinished_Parms
{
    GearPawn_eventCoverActionAnimationFinished_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventUpdateShadowSettings_Parms
{
    UBOOL bInWantShadow;
    GearPawn_eventUpdateShadowSettings_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventBodyImpactBlendOutNotify_Parms
{
    GearPawn_eventBodyImpactBlendOutNotify_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventScriptedDeath_Parms
{
    GearPawn_eventScriptedDeath_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventOn360AimingChangeNotify_Parms
{
    GearPawn_eventOn360AimingChangeNotify_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventFixWeaponAimIKPosition_Parms
{
    FLOAT DeltaTime;
    GearPawn_eventFixWeaponAimIKPosition_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventGetAimOffsetOrigin_Parms
{
    FVector ReturnValue;
    GearPawn_eventGetAimOffsetOrigin_Parms(EEventParm)
    {
    }
};
struct GearPawn_eventGetHeadLookTargetLocation_Parms
{
    FVector ReturnValue;
    GearPawn_eventGetHeadLookTargetLocation_Parms(EEventParm)
    {
    }
};
class AGearPawn : public AGamePawn
{
public:
    //## BEGIN PROPS GearPawn
    BITFIELD bIsOnTurret:1;
    BITFIELD bScriptedWalking:1;
    BITFIELD bTranslateMeshByCollisionHeight:1;
    BITFIELD bIsInCombat:1;
    BITFIELD bNeverAValidEnemy:1;
    BITFIELD bInvalidMeleeTarget:1;
    BITFIELD bLockRotation:1;
    BITFIELD bEndingSpecialMove:1;
    BITFIELD bEnableFloorRotConform:1;
    BITFIELD bDisableMeshTranslationChanges:1;
    BITFIELD bCanDoRun2Cover:1;
    BITFIELD bCoverDebug_PlayerFOV:1;
    BITFIELD bCoverDebug_CoverFOV:1;
    BITFIELD bCoverDebug_CoverVolume:1;
    BITFIELD bCoverDebug_ConsideredLinks:1;
    BITFIELD bCoverDebug_FoundCover:1;
    BITFIELD bCoverDebug_ValidatedCover:1;
    BITFIELD bWeaponDebug_Accuracy:1;
    BITFIELD bWeaponDebug_DamageRadius:1;
    BITFIELD bQuietWeaponEquipping:1;
    BITFIELD bIsMirrored:1;
    BITFIELD bWantsToBeMirrored:1;
    BITFIELD bDoingMirrorTransition:1;
    BITFIELD bDoWalk2IdleTransitions:1;
    BITFIELD bCanDo360AimingInCover:1;
    BITFIELD bDoing360Aiming:1;
    BITFIELD bWasDoing360Aiming:1;
    BITFIELD bIsCrawling:1;
    BITFIELD bEnableEncroachCheckOnRagdoll:1;
    BITFIELD bAllowDamageModification:1;
    BITFIELD PlayBurstDamageWarningSoundSemaphore:1;
    BITFIELD bCanDoStepsSmoothing:1;
    BITFIELD bAllowSpeedInterpolation:1;
    BITFIELD bHealthIsRecharging:1;
    BITFIELD bScalingToZero:1;
    BITFIELD bIsBleedingOut:1;
    BITFIELD bIsGore:1;
    BITFIELD bGoreSetupForDeath:1;
    BITFIELD bHasBrokenConstraints:1;
    BITFIELD bHasGoreExploded:1;
    BITFIELD bUsingNewSoftWeightedGoreWhichHasStretchiesFixed:1;
    BITFIELD bDisableKicksCorpseAfterRecovery:1;
    BITFIELD bChargingBow:1;
    BITFIELD bPlayDeathAnimations:1;
    BITFIELD bCanPlayHeadShotDeath:1;
    BITFIELD bHasPlayedHeadShotDeath:1;
    BITFIELD bCanPlayPhysicsHitReactions:1;
    BITFIELD bEnableHitReactionBoneSprings:1;
    BITFIELD bIsTargeting:1;
    BITFIELD bIsZoomed:1;
    BITFIELD bPendingFire:1;
    BITFIELD bPendingAltFire:1;
    BITFIELD bPendingMeleeAttack:1;
    BITFIELD bCanRoadieRun:1;
    BITFIELD bCanBeForcedToRoadieRun:1;
    BITFIELD bCanBlindFire:1;
    BITFIELD bActivateMeatShieldMorph:1;
    BITFIELD bLockIKStatus:1;
    BITFIELD bUsesBodyStances:1;
    BITFIELD bDoingCoverActionAnimTransition:1;
    BITFIELD bReloadingAimInterp:1;
    BITFIELD bDoingHeadTrackAimOffsetInterpolation:1;
    BITFIELD bDoingHeadTrackRunOffsetInterpolation:1;
    BITFIELD WasHeadTracking:1;
    BITFIELD bSwitchingWeapons:1;
    BITFIELD bEquipTransition:1;
    BITFIELD bWasInCover:1;
    BITFIELD bIsInStationaryCover:1;
    BITFIELD bInLitArea:1;
    BITFIELD bKyrllEnabled:1;
    BITFIELD bDoingMeleeAttack:1;
    BITFIELD bWantsToMelee:1;
    BITFIELD bShouldPlayWetFootSteps:1;
    BITFIELD bRaiseHandWhileCrawling:1;
    BITFIELD bCanDoTurnInPlaceAnim:1;
    BITFIELD bDebugAimAttractors:1;
    BITFIELD bSpawning:1;
    BITFIELD bMuteGUDS:1;
    BITFIELD bSpeaking:1;
    BITFIELD bDebugSpeech:1;
    BITFIELD bRotInterpCoverTransition:1;
    BITFIELD bDelayedDBNO:1;
    BITFIELD bCanDBNO:1;
    BITFIELD bCanRecoverFromDBNO:1;
    BITFIELD bRespondToExplosions:1;
    BITFIELD bCanBeRunOver:1;
    BITFIELD bAllowInventoryDrops:1;
    BITFIELD bAllowHitImpactDecalsOnSkelMesh:1;
    BITFIELD bSpawnHitEffectDecals:1;
    BITFIELD bSpawnBloodTrailDecals:1;
    BITFIELD bDisableDeathScreams:1;
    BITFIELD bUsingCommLink:1;
    BITFIELD bWantToUseCommLink:1;
    BITFIELD bInCommLinkStance:1;
    BITFIELD bIsConversing:1;
    BITFIELD bWantToConverse:1;
    BITFIELD bWasDBNO:1;
    BITFIELD bLastHitWasHeadShot:1;
    BITFIELD bShowFatalDeathBlood:1;
    BITFIELD bBledOut:1;
    BITFIELD bInMeatShieldRagDoll:1;
    BITFIELD bUseSimplePhysicalFireStartLoc:1;
    BITFIELD bActiveReloadBonusActive:1;
    BITFIELD bSuppressNoticedGUDSEvents:1;
    BITFIELD bCanPickupFactoryWeapons:1;
    BITFIELD bCoveringHead:1;
    BITFIELD bCannotRoadieRun:1;
    BITFIELD bBlockCamera:1;
    BITFIELD bIsHiddenByCamera:1;
    BITFIELD bOverrideDeathCamLookat:1;
    BITFIELD bCheckKnockdownFall:1;
    BITFIELD bPlayMotorAnimOnKnockDown:1;
    BITFIELD bOnFire:1;
    BITFIELD bDebugDamageText:1;
    BITFIELD bSkipCharFade:1;
    BITFIELD bSkipHeatFade:1;
    BITFIELD bUnlimitedHealth:1;
    BITFIELD bAllowAccelSmoothing:1;
    BITFIELD bAllowTurnSmoothing:1;
    BITFIELD bInDuelingMiniGame:1;
    BITFIELD bInTriggerMiniGame:1;
    BITFIELD bLastTriggerPressedIsRight:1;
    BITFIELD bDebugStoppingPower:1;
    BITFIELD bAllowStoppingPower:1;
    BITFIELD bAnimForceVelocityFromBase:1;
    BITFIELD bDisableShadows:1;
    BITFIELD bTargetingNodeIsInIdleChannel:1;
    BITFIELD bAllowAutoRevive:1;
    BITFIELD bNoDeathGUDSEvent:1;
    BITFIELD bBaseIsEncroaching:1;
    struct FReplicatedRootPosInfo ReplicationRootBodyPos;
    FLOAT MeatflagProtectionPct;
    class UGearPawnFX* GearPawnFX;
    class UClass* GearPawnFXClass;
    FVector MeshTranslationOffset;
    FLOAT MeshYawOffset;
    FLOAT MeshTranslationNudgeOffset;
    FLOAT SceneRatingValue;
    class AGearWeapon* MyGearWeapon;
    class AGearAI* MyGearAI;
    class UParticleSystem* GoreImpactParticle;
    FName FullBodyNodeName;
    class UGearAnim_Slot* FullBodyNode;
    FStringNoInit CharacterName;
    BYTE SitMood;
    BYTE SpecialMove;
    BYTE PreviousSpecialMove;
    BYTE SpecialMoveWhenDead;
    BYTE CoverType;
    BYTE CoverAction;
    BYTE PreviousCoverAction;
    BYTE SavedCoverAction;
    BYTE ReplicatedForcedAimTime;
    BYTE LastCoverActionAnim;
    BYTE CoverActionAnim;
    BYTE CurrentSlotDirection;
    BYTE CoverDirection;
    BYTE ReplicatedCoverDirection;
    BYTE CharacterFootStepType;
    BYTE ShotAtCount;
    BYTE CringeCount;
    BYTE HeavyMountedCoverAction;
    BYTE HeavyMountedCoverType;
    BYTE CurrentSpeechPriority;
    BYTE DBNOTimeExtensionCnt;
    BYTE bSpawnABloodPool;
    BYTE ActiveReload_CurrTier;
    BYTE NeedsRevivedGUDSEvent;
    BYTE WentDownGUDSEvent;
    BYTE NoticedGUDSEvent;
    BYTE LastTeamNum;
    BYTE OnFireState;
    BYTE ReplicatedOnFireState;
    class AActor* HeadLookAtActor;
    FName HeadLookAtBoneName;
    class AHeadTrackTarget* CurrentHeadTrackTargetActor;
    INT EffectCount;
    struct FSMStruct PendingSpecialMoveStruct;
    struct FSMStruct ReplicatedSpecialMoveStruct;
    TArrayNoInit<class UClass*> SpecialMoveClasses;
    TArrayNoInit<class UGearSpecialMove*> SpecialMoves;
    class AGearPawn* InteractionPawn;
    INT SpecialMoveFlags;
    TArrayNoInit<BYTE> PawnToPawnInteractionList;
    FVector SpecialMoveLocation;
    TArrayNoInit<BYTE> CoverActionSpecialMoves;
    TArrayNoInit<BYTE> ActionSpecialMoves;
    class AActor* BaseWhenDead;
    FLOAT MeshFloorConformTranslation;
    FLOAT MeshFloorConformTransSpeed;
    FLOAT MeshFloorConformRotSpeed;
    FLOAT LastBumpTime;
    struct FCovPosInfo AcquiredCoverInfo;
    FLOAT Run2CoverMaxDist;
    FLOAT Run2CoverPerpendicularMaxDist;
    FLOAT EndEvadeRun2CoverMaxDist;
    FLOAT RoadieRun2CoverSlideDist;
    FLOAT LastCoverTime;
    FLOAT LastCoverAcquireDistanceSq;
    FLOAT LastCoverActionTime;
    FLOAT NextCoverActionTime;
    FLOAT Last360AimingChangeTime;
    FLOAT LastTimeMoving;
    FLOAT LastHODDamageTime;
    FLOAT MovementPct;
    TArrayNoInit<FLOAT> CoverMovementPct;
    TArrayNoInit<class UClass*> DefaultInventory;
    INT DefaultHealth;
    FLOAT DefaultGroundSpeed;
    FLOAT LastMaxSpeedModifier;
    class USoundCue* HealthRechargeStartSound;
    class USoundCue* DeadBodyImpactSound;
    FLOAT DeadBodyImpactThreshold;
    FLOAT RechargingHealthAmount;
    FLOAT HealthRechargeDelay;
    FLOAT HealthRechargePercentPerSecond;
    FLOAT TimeOfDeath;
    class AGearPawn* KilledByPawn;
    FVector LocationWhenKilled;
    FRotator RotationWhenKilled;
    FLOAT GibKillDistance;
    INT MaxAllowedDeadRagDollPawns;
    FLOAT AI_MeleeDamageScale;
    TArrayNoInit<FName> HeadBoneNames;
    TArrayNoInit<FName> LegBoneNames;
    FName TorsoBoneName;
    class UStaticMeshComponent* HeadShotNeckGoreAttachment;
    TArrayNoInit<class UStaticMesh*> HeadChunks;
    TArrayNoInit<FName> DeathAnimHighFwd;
    TArrayNoInit<FName> DeathAnimHighBwd;
    TArrayNoInit<FName> DeathAnimStdFwd;
    TArrayNoInit<FName> DeathAnimStdBwd;
    TArrayNoInit<FName> DeathAnimStdLt;
    TArrayNoInit<FName> DeathAnimStdRt;
    TArrayNoInit<FName> PhysicsBodyImpactBoneList;
    FLOAT PhysicsImpactBlendTimeToGo;
    FLOAT PhysicsHitReactionImpulseScale;
    FLOAT PhysicsImpactBlendOutTime;
    FLOAT PhysicsImpactMassEffectScale;
    FVector2D PhysHRMotorStrength;
    FVector2D PhysHRSpringStrength;
    TArrayNoInit<struct FPhysicsImpactRBRemap> PhysicsImpactRBRemapTable;
    TArrayNoInit<FName> PhysicsImpactSpringList;
    TArrayNoInit<FName> GoreBreakableJoints;
    TArrayNoInit<FName> GoreBreakableJointsTest;
    TArrayNoInit<struct FDependantBreakInfo> JointsWithDependantBreaks;
    TArrayNoInit<struct FDeadRagdollLimitScale> RagdollLimitScaleTable;
    FLOAT TimeToScaleLimits;
    FLOAT ScaleLimitTimeToGo;
    class USkeletalMesh* GoreSkeletalMesh;
    class UPhysicsAsset* GorePhysicsAsset;
    TArrayNoInit<class UMorphTargetSet*> GoreMorphSets;
    FLOAT GibEffectsSpeedThreshold;
    FLOAT TimeBetweenGibEffects;
    class UParticleSystem* SimpleDeathEffect;
    class UParticleSystem* SimpleDeathEffectNonGore;
    FLOAT SimpleDeathEffectScale;
    class UGearSoundGroup* SoundGroup;
    FVector2D CoverProtectionFOV;
    FLOAT AimTimeAfterFiring;
    FLOAT ForcedAimTime;
    FName NeckBoneName;
    FName PelvisBoneName;
    FName MeleeDamageBoneName;
    FVector ViewLocationOffset;
    FName LeftFootBoneName;
    FName RightFootBoneName;
    FName LeftKneeBoneName;
    FName RightKneeBoneName;
    FName LeftHandBoneName;
    FName RightHandBoneName;
    struct FWeaponRepInfo RemoteWeaponRepInfo;
    FName RightHandSocketName;
    FName LeftHandSocketName;
    FName HeadSocketName;
    class UClass* AttachClass_Shield;
    class UClass* AttachSlotClass_Holster;
    class UClass* AttachSlotClass_Belt;
    class UClass* AttachSlotClass_LeftShoulder;
    class UClass* AttachSlotClass_RightShoulder;
    TArrayNoInit<struct FSAttachSlot> AttachSlots;
    FName SightBoneName;
    FLOAT BlindFirePct;
    INT NumFireTickets;
    TArrayNoInit<class AController*> FireTickets;
    INT HordeEnemyIndex;
    TArrayNoInit<class UAnimNodeAimOffset*> AimOffsetNodes;
    TArrayNoInit<class UGearAnim_Slot*> BodyStanceNodes;
    class UGearAnim_Slot* CustomCameraAnimNode;
    struct FCustomCameraAnimPropertiesStruct CustomCameraAnimProperties;
    TArrayNoInit<class UAnimNodeSequence*> ResumePlayNodes;
    class UGearAnim_UpperBodyIKHack* IKHackNode;
    class UGearAnim_BlendAnimsByAim* BlendByAimNode;
    class UGearAnim_BaseBlendNode* BaseBlendNode;
    class UGearAnim_BlendList* BlendByAimToggle;
    class UMorphNodeWeight* MeatShieldMorphNodeWeight;
    FLOAT MeatShieldMorphTimeToGo;
    FLOAT MeatShieldMorphBlendTime;
    FName MeatShieldMorphTargetName;
    FVector WeaponAimIKPositionFix;
    FLOAT CameraBoneMotionScale;
    struct FBodyStance KismetBodyStance;
    class UAnimSet* KismetAnimSets[2];
    struct FBodyStance SpeechGestureBodyStance;
    struct FBodyStance BS_Junker_Driving_Idle;
    struct FBodyStance BS_Junker_Passenger_A_Idle;
    struct FBodyStance BS_Junker_Passenger_B_Idle;
    TArrayNoInit<class UAnimSet*> MATAnimSets;
    INT CoverActionAnimUpdateTickTag;
    FLOAT AimOffsetInterpSpeedAI;
    FLOAT AimOffsetInterpSpeedHuman;
    FLOAT AimOffsetInterpSpeedHeadTrack;
    FLOAT ReloadingAimInterpTimeToGo;
    FRotator LastHeadTrackDeltaRot;
    FRotator LastHeadTrackRunDeltaRot;
    FLOAT HeadTrackTime;
    FLOAT HeadTrackDuration;
    FLOAT HeadTrackRunInterpTime;
    FLOAT HeadTrackRunInterpDuration;
    FLOAT HeadTrackBlendSpeed;
    FLOAT HeadTrackBlendSpeedModiferWhenSwitch;
    FLOAT HeadTrackCurrentBlendSpeed;
    FLOAT HeadTrackBlendWeightToTarget;
    FLOAT HeadTrackBlendTargetWeight;
    FVector2D AimOffsetPct;
    INT ReplicatedAimOffsetPct;
    FVector2D PositionAdjustAimOffsetPct;
    FLOAT PawnAcquireCoverFOV;
    FLOAT PawnAcquireCoverFOVRoadieRun;
    FLOAT CoverAcquireFOV;
    FLOAT RoadieRunCoverAcquireFOV;
    FLOAT CoverSnapScale;
    class ACoverLink* CurrentLink;
    struct FCoverInfo CachedCoverGuess;
    FLOAT LastCoverGuessTime;
    INT CurrentSlotIdx;
    INT ClosestSlotIdx;
    INT PreviousSlotIdx;
    class ACoverSlotMarker* TargetSlotMarker;
    INT LeftSlotIdx;
    INT RightSlotIdx;
    FLOAT CurrentSlotPct;
    FLOAT FreshCoverDirectionTime;
    FLOAT UnarmedMeleeRange;
    FLOAT LastShotAtTime;
    FLOAT LastCringeTime;
    TArrayNoInit<struct FCringeInfo> NearHitHistory;
    TArrayNoInit<FLOAT> CringeHistory;
    FLOAT LastBulletWhipTime;
    FLOAT LastTookDamageTime;
    FLOAT LastPlayedDamageSound;
    FLOAT LastWeaponStartFireTime;
    FLOAT LastWeaponEndFireTime;
    FLOAT LastWeaponBlindFireTime;
    FLOAT LastEvadeTime;
    FLOAT LastEvadeIntoWallTime;
    FLOAT MinTimeBetweenEvades;
    FLOAT BackwardMovementSpeedPercentage;
    FLOAT HeavyWeaponMovementSpeedPercentage;
    FLOAT HeavyWeaponFiringMovementSpeedPercentage;
    FLOAT ShieldMovementSpeedPercentage;
    FLOAT ShieldFiringMovementSpeedPercentage;
    FLOAT RoadieRunBoostTime;
    FLOAT CrawlSpeedModifier;
    FLOAT LastMeleeAttackTime;
    class UParticleSystem* PS_MeleeImpactEffect;
    class UParticleSystem* PS_RadialDamageEffect;
    TArrayNoInit<class UGearSkelCtrl_Recoil*> RecoilNodes;
    class USkelControlLookAt* HeadControl;
    class UGearAnim_BlendList* TroikaBlendNode;
    class UGearAnim_Mirror_Master* MirrorNode;
    class UAnimNodeBlend* DBNOGuardBlendNode;
    class UAnimNodeSequence* DBNOCrawlNode;
    class UAnimTree* AnimTreeRootNode;
    class UAnimNodeMirror* CrateMirrorNode;
    class USkelControlLimb* CrateIKRightHand;
    class USkelControlLimb* CrateIKLeftHand;
    class UGearAnim_BlendAnimsByDirection* CrateWalkNode;
    class USkelControlLimb* IKCtrl_RightHand;
    class USkelControlLimb* IKCtrl_LeftHand;
    class USkelControlLimb* IKBoneCtrl_RightHand;
    class USkelControlLimb* IKBoneCtrl_LeftHand;
    class USkelControlSingleBone* IKRotCtrl_RightHand;
    class USkelControlSingleBone* IKRotCtrl_LeftHand;
    TArrayNoInit<struct FAimAttractor> AimAttractors;
    struct FScreenShakeStruct Run2CoverCameraShake;
    FLOAT Run2CoverMinCameraShakeDistSqThreshold;
    FLOAT Run2CoverMaxCameraShakeDistSqThreshold;
    TArrayNoInit<FString> MasterGUDBankClassNames;
    INT LoadedGUDBank;
    class UGUDData* LoadedGUDSData;
    struct FSpeakLineParamStruct ReplicatedSpeakLineParams;
    struct FSpeakLineParamStruct QueuedSpeakLineParams;
    struct FSpeakLineParamStruct CurrentSpeakLineParams;
    class UAudioComponent* CurrentlySpeakingLine;
    FLOAT SpeechPitchMultiplier;
    class UAudioComponent* FacialAudioComp;
    FLOAT PawnRotationInterpolationTime;
    FLOAT PawnRotationBlendTimeToGo;
    FRotator LastCoverRotation;
    struct FTakeHitInfo LastTakeHitInfo;
    FLOAT LastTakeHitTimeout;
    FLOAT NextHitReactionAnimTime;
    FCanvasIcon HeadIcon;
    class UAudioComponent* ReviveBreathSound;
    class UAudioComponent* FlatLiningSound;
    class UAudioComponent* ReviveHeartbeatSound;
    class UAudioComponent* NearDeathBreathSound;
    INT NumConstraintEffectsSpawnedMax;
    INT NumConstraintEffectsSpawned;
    class USoundCue* AmmoPickupSound;
    FLOAT TimeOfDBNO;
    class AController* ControllerWhoPutMeDBNO;
    class UClass* DamageTypeThatPutMeDBNO;
    FLOAT TimeStampEnteredRevivingState;
    class UParticleSystem* DBNO_BloodCrawlSpurtTemplate;
    INT DBNODeathThreshold;
    INT HostageDefaultHealth;
    INT HostageDeathThresholdByHeadshot;
    INT HostageHealth;
    TArrayNoInit<FName> HostageHealthBuckets;
    FLOAT KidnapperHalfAngleOfProtection;
    TArrayNoInit<FName> MeatShieldUnfixedBoneList;
    FLOAT HostageReleaseTime;
    FName PickupFocusBoneName;
    FName PickupFocusBoneNameKickup;
    FLOAT NoticedGUDSPriority;
    class AGearPointOfInterest* POI;
    class ATrigger_Engage* EngageTrigger;
    class ATrigger_LadderInteraction* LadderTrigger;
    class UParticleSystemComponent* PSC_RoadieRun;
    class UParticleSystem* PS_RoadieRun;
    struct FTraceHitInfo LastFootStepTraceInfo;
    class UPhysicalMaterial* LastFootStepPhysMat;
    INT DownCount;
    INT MaxDownCount;
    FLOAT SuperDamageMultiplier;
    FLOAT TimeOfRevival;
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    struct FBodyStance BS_HeadCoverLoop;
    class USoundCue* LastGUDLinePlayed;
    FLOAT LastGUDLinePlayedTime;
    FLOAT GUDLineRepeatMin;
    FLOAT MinTimeBetweenAnyGUDS;
    class UMaterialInstanceConstant* MPRimShader;
    class UMaterialInstanceConstant* MPRimShaderHelmet;
    class UMaterialInstanceConstant* MIC_PawnMat;
    class UMaterialInstanceConstant* MIC_PawnHair;
    class UMaterialInstanceConstant* MIC_PawnMatHelmet;
    class UMaterialInstanceConstant* MIC_PawnMatShoulderPadLeft;
    class UMaterialInstanceConstant* MIC_PawnMatShoulderPadRight;
    INT OwnerNoSeeCount;
    FCylinder CameraNoRenderCylinder_High;
    FCylinder CameraNoRenderCylinder_Low;
    FCylinder CameraNoRenderCylinder_High_ViewTarget;
    FCylinder CameraNoRenderCylinder_Low_ViewTarget;
    FCylinder CameraNoRenderCylinder_FlickerBuffer;
    class UParticleSystem* PS_BurnEffect;
    class UParticleSystemComponent* BurnEffectPSC;
    FLOAT MPHeadRadius;
    FVector MPHeadOffset;
    TArrayNoInit<class UFaceFXAnimSet*> FAS_Efforts;
    TArrayNoInit<FString> FAS_ChatterNames;
    INT NeedsRevivedReminderCount;
    FLOAT DurationBeforeDestroyingDueToNotBeingSeen;
    FCylinder CrouchedFrictionCylinder;
    FLOAT ShootingThroughWallTraceDistance;
    class AGearPawn* DeathCamLookatPawn;
    FName DeathCamLookatBoneName;
    FVector LocationOfEholeEmergedFrom;
    FLOAT SafeDistanceFromEholeToSpawnBloodPool;
    struct FPhysicsImpulseInfo KnockdownImpulse;
    FVector KnockdownStartingPosition;
    struct FBodyStance BS_KnockDownAnim;
    FLOAT KnockDownMotorStrength;
    FLOAT KnockDownMotorDamping;
    FInterpCurveFloat KnockDownMotorScale;
    FLOAT KnockDownStartTime;
    class UAnimTree* RecoverFromRagdollAnimTree;
    FLOAT MortarElevationPct;
    FLOAT ShieldHalfAngleOfProtection;
    FLOAT DeployedShieldHalfAngleOfProtection;
    class AGearShield* EquippedShield;
    class UParticleSystem* OnFireBlazingParticleSystem;
    class UParticleSystem* OnFireSmolderParticleSystem;
    class UParticleSystemComponent* PSC_OnFire;
    class USoundCue* OnFireBlazingBurningSound;
    class USoundCue* OnFireSmolderingBurningSound;
    class UAudioComponent* OnFireAudioBurningLoop;
    class UParticleSystem* ImulsionParticleSystem;
    class UParticleSystemComponent* PSC_Imulsion;
    class USoundCue* ImulsionBurningSound;
    class UAudioComponent* ImulsionAudioBurningLoop;
    class ASpawnedGearEmitter* DamagedByFlamethrowerEmitter;
    FLOAT LastAttemptedHailDamageTime;
    class AGrappleRopeBase* AttachedGrappleRope;
    FVector LocationOfLastBloodTrail;
    INT NumDecalsAttachedCurr;
    INT CurrDecalIdx;
    FLOAT DecalsAttached[3];
    FLOAT CurrentSkinHeat;
    FLOAT CurrentSkinHeatMin;
    FLOAT SkinHeatDamagePctToFullyHeat;
    FLOAT SkinHeatFadeTime;
    FLOAT HeatDamagePerSecond;
    class AController* HeatDamageInstigator;
    FLOAT HeatDamageFraction;
    FLOAT SkinHeatFadeDelay;
    FLOAT CurrentSkinChar;
    FLOAT CurrentSkinCharMin;
    FLOAT SkinCharFadeTime;
    TArrayNoInit<class ACameraVolume*> CameraVolumes;
    class AGearDestructibleObject* TargetedGDO;
    class UClass* MutatedClass;
    class AGearPawn_CarryCrate_Base* CarriedCrate;
    TArrayNoInit<FName> BloodMountFixedBoneList;
    class AGearPawn_LocustBloodmount* BloodMountIDiedOn;
    class AActor* FinalSplineActor;
    class AActor* CurrentSplineActor;
    class AActor* PrevSplineActor;
    struct FBasedPosition FinalSplinePt;
    FLOAT TurningRadius;
    FLOAT EffectiveTurningRadius;
    FVector OldAcceleration;
    FLOAT AccelConvergeFalloffDistance;
    FLOAT SmoothTurnStartT;
    FGuid MyGuid;
    FLOAT LocustChanceToDBNO;
    class AActor* ClampedBase;
    INT DuelingMiniGameButtonPresses;
    FLOAT ChainsawDuelMiniGameDuration;
    FLOAT ChainsawDuelFacingDegreesAngle;
    FVector2D AI_ChainsawDuelButtonPresses;
    INT ChainsawInterruptThreshold;
    INT ChainsawInterruptDecayPerSecond;
    INT ChainsawInterruptAmount;
    TArrayNoInit<struct FStoppingPowerStruct> StoppingPowerList;
    FLOAT MaxStoppingPower;
    FLOAT MaxStoppingPowerDistance;
    FLOAT StoppingPowerAngle;
    FLOAT StoppingPowerHeavyScale;
    FLOAT StoppingPowerRecoverySpeed;
    FLOAT StoppingPowerRoadieRunStumbleThreshold;
    class AGear_GrappleHookMarker* CurrentGrapplingMarker;
    FLOAT ForceWalkingPct;
    FLOAT KantusSkinEffectFadeDuration;
    FLOAT DesiredKantusFadeVal;
    FLOAT CurrentKantusFadeVal;
    class UParticleSystemComponent* KantusRevivePSC;
    class AGearPawn_LocustKantusBase* KantusReviver;
    struct FWeaponStartTraceLocationCacheStruct WeaponStartTraceLocationCache;
    TArrayNoInit<struct FPerDamageTypeMod> PerDamageTypeModifiers;
    FVector LastMantleLocation;
    FLOAT LastmantleTime;
    INT TargetingNodeIsInIdleChannelTickTag;
    class UMaterialInterface* ReplicatedMaterial;
    FLOAT BloodOpacity;
    TArrayNoInit<BYTE> ProhibitedFindAnchorPhysicsModes;
    class UFaceFXAnimSet* ReplicatedFaceFXAnimSets[3];
    class UFaceFXAnimSet* PrevReplicatedFaceFXAnimSets[3];
    FVector BaseEncroachInvNormal;
    FVector BaseEncroachHitLocation;
    //## END PROPS GearPawn

    virtual class ANavigationPoint* GetBestAnchor(class AActor* TestActor,FVector TestLocation,UBOOL bStartPoint,UBOOL bOnlyCheckVisible,FLOAT& out_Dist);
    virtual UBOOL IsValidEnemyTargetFor(const class APlayerReplicationInfo* PRI,UBOOL bNoPRIisEnemy) const;
    FLOAT GetMaxSpeedModifier();
    UBOOL IsInCover();
    UBOOL GuessAtCover(struct FCoverInfo& out_Cover);
    class ACombatZone* GetCombatZoneForNav(class ANavigationPoint* Nav);
    UBOOL ClaimCover(class ACoverLink* Link,INT SlotIdx);
    UBOOL UnclaimCover(class ACoverLink* Link,INT SlotIdx,UBOOL bUnclaimAll);
    UBOOL FindCoverFromLocAndDir(FVector FromLoc,FVector Direction,FLOAT FOV,FLOAT MaxDistance,struct FCovPosInfo& OutCovPosInfo);
    UBOOL ValidatePotentialCover(FVector FromLoc,FVector Direction,FLOAT& OutMinDotFOV,FLOAT& OutMaxDistanceSquared,struct FCovPosInfo& OutCovPosInfo);
    void FillCoverPosInfo(class ACoverLink* Link,INT LtSlotIdx,INT RtSlotIdx,FVector FromLoc,FVector Direction,FLOAT MaxDistance,struct FCovPosInfo& out_CovPosInfo);
    virtual void GetCoverInfo();
    virtual void GetStreamingInfo(const FString& levelStatus);
    void UpdateAutomaticHeadTracking();
    FLOAT AimInterpTo(FLOAT Current,FLOAT Target,FLOAT DeltaTime,FLOAT InterpSpeed);
    virtual void UpdateMeshBoneControllersNative(FLOAT DeltaTime);
    void UpdateAimOffset(FVector2D NewAimOffsetPct,FLOAT DeltaTime);
    UBOOL Simulate360Aiming(UBOOL bCurrentlyDoing360Aiming,FVector2D TestAimOffsetPct,BYTE TestCoverType,BYTE& out_CoverDirection);
    UBOOL IsDoing360ToLeaningTransition();
    UBOOL IsDoingLeaningTo360Transition();
    UBOOL IsProtectedByCover(FVector ShotDirection,UBOOL bSkipPlayerCheck=FALSE);
    FLOAT GetResultingStoppingPower();
    UBOOL IsDoingDeathAnimSpecialMove() const;
    virtual void ReduceConstraintLimits();
    UBOOL IsLeaning();
    UBOOL IsPoppingUp();
    virtual FVector GetPawnViewLocation();
    UBOOL IsDoingSpecialMove(BYTE AMove) const;
    UBOOL IsDoingASpecialMove() const;
    UBOOL IsDoingMeleeHoldSpecialMove() const;
    UBOOL IsDoingSpecialMeleeAttack() const;
    UBOOL IsSpecialMeleeVictim() const;
    UBOOL FitCollision();
    UBOOL CanPerformMantleDown(FLOAT MinMantleHeight,FLOAT MaxMantleHeight,FRotator TestRotation);
    UBOOL IsEvading();
    UBOOL IsAtCoverEdge(UBOOL bMirrored,UBOOL bAllowLeanAsEdge=FALSE,FLOAT Scale=1.750000,INT* EdgeSlotIdx=NULL,INT StartSlotIdx=-1,UBOOL bIgnoreCurrentCoverAction=FALSE);
    INT PickClosestCoverSlot(UBOOL bRequireOverlap=TRUE,FLOAT RadiusScale=0.500000,UBOOL bIgnoreCurrentCoverAction=FALSE);
    UBOOL IsDoingMove2IdleTransition();
    virtual FVector GetPhysicalFireStartLoc(FVector FireOffset);
    virtual UBOOL SetCoverInfoFromSlotInfo(struct FCovPosInfo& OutCovInfo,struct FCoverInfo SlotInfo);
    FLOAT BS_Play(struct FBodyStance Stance,FLOAT Rate,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=TRUE,FName GroupName=NAME_None);
    void BS_PlayByDuration(struct FBodyStance Stance,FLOAT Duration,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=TRUE,FName GroupName=NAME_None);
    UBOOL BS_IsPlaying(struct FBodyStance Stance);
    UBOOL BS_HasAnyWeight(struct FBodyStance Stance);
    UBOOL BS_SeqNodeBelongsTo(class UAnimNodeSequence* SeqNode,struct FBodyStance Stance);
    void BS_Stop(struct FBodyStance Stance,FLOAT BlendOutTime=0);
    void BS_SetPlayingFlag(struct FBodyStance Stance,UBOOL bNewPlaying);
    void BS_StopAll(FLOAT BlendOutTime);
    void BS_Override(struct FBodyStance Stance);
    void BS_SetPosition(struct FBodyStance Stance,FLOAT Position);
    FLOAT BS_GetTimeLeft(struct FBodyStance Stance);
    FLOAT BS_GetPlayRate(struct FBodyStance Stance);
    void BS_SetPlayRate(struct FBodyStance Stance,FLOAT NewRate);
    void BS_ScalePlayRate(struct FBodyStance Stance,FLOAT RateScale);
    void BS_SetRootBoneAxisOptions(struct FBodyStance Stance,BYTE AxisX=0,BYTE AxisY=0,BYTE AxisZ=0);
    void BS_SetMirrorOptions(struct FBodyStance Stance,UBOOL bTransitionToMirrored,UBOOL bBeginTransition,UBOOL bMirrorAnimation);
    void BS_SetAnimEndNotify(struct FBodyStance Stance,UBOOL bNewStatus);
    void BS_SetEarlyAnimEndNotify(struct FBodyStance Stance,UBOOL bNewEarlyAnimEndNotify);
    UBOOL IsReloadingWeapon();
    virtual void MAT_BeginAnimControl(const TArray<class UAnimSet*>& InAnimSets);
    virtual void MAT_SetAnimPosition(FName SlotName,INT ChannelIndex,FName InAnimSeqName,FLOAT InPosition,UBOOL bFireNotifies,UBOOL bLooping);
    virtual void MAT_SetAnimWeights(const TArray<struct FAnimSlotInfo>& SlotInfos);
    virtual void MAT_FinishAnimControl();
    virtual FName GetRightHandSocketName();
    virtual void GetWeaponHandPosition(FVector& HandLoc,FRotator& HandRot);
    virtual FRotator GetViewRotation();
    UBOOL IsFacingOther(class AGearPawn* OtherPawn,FLOAT minDot=0.500000,FLOAT HeightTolerancePct=0.800000) const;
    UBOOL SpeakLine(class AGearPawn* Addressee,class USoundCue* Audio,const FString& DebugText,FLOAT DelaySec,BYTE Priority=0,BYTE IntCondition=0,UBOOL bNoHeadTrack=FALSE,INT BroadcastFilter=0,UBOOL bSuppressSubtitle=FALSE,FLOAT InExtraHeadTrackTime=0,UBOOL bClientSide=FALSE);
    UBOOL ShouldSuppressSubtitlesForQueuedSpeakLine(UBOOL bVersusMulti);
    UBOOL ShouldFilterOutSpeech(BYTE Filter,class AGearPawn* Addressee);
    void PlayQueuedSpeakLine();
    virtual void TickKnockDownMotorStrength(FLOAT DeltaSeconds);
    UBOOL IsDBNO() const;
    UBOOL IsAHostage() const;
    UBOOL IsAKidnapper() const;
    virtual UBOOL CanFireWeapon(UBOOL bTestingForTargeting=FALSE);
    void GetCameraNoRenderCylinder(FLOAT& Radius,FLOAT& Height,UBOOL bViewTarget,UBOOL bHiddenLocally);
    void SetMeshTranslationOffset(FVector NewOffset,UBOOL bForce=FALSE);
    DECLARE_FUNCTION(execGetMaxSpeedModifier)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMaxSpeedModifier();
    }
    DECLARE_FUNCTION(execIsInCover)
    {
        P_FINISH;
        *(UBOOL*)Result=IsInCover();
    }
    DECLARE_FUNCTION(execGuessAtCover)
    {
        P_GET_STRUCT_REF(struct FCoverInfo,out_Cover);
        P_FINISH;
        *(UBOOL*)Result=GuessAtCover(out_Cover);
    }
    DECLARE_FUNCTION(execGetCombatZoneForNav)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        *(class ACombatZone**)Result=GetCombatZoneForNav(Nav);
    }
    DECLARE_FUNCTION(execClaimCover)
    {
        P_GET_OBJECT(ACoverLink,Link);
        P_GET_INT(SlotIdx);
        P_FINISH;
        *(UBOOL*)Result=ClaimCover(Link,SlotIdx);
    }
    DECLARE_FUNCTION(execUnclaimCover)
    {
        P_GET_OBJECT(ACoverLink,Link);
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bUnclaimAll);
        P_FINISH;
        *(UBOOL*)Result=UnclaimCover(Link,SlotIdx,bUnclaimAll);
    }
    DECLARE_FUNCTION(execFindCoverFromLocAndDir)
    {
        P_GET_STRUCT(FVector,FromLoc);
        P_GET_STRUCT(FVector,Direction);
        P_GET_FLOAT(FOV);
        P_GET_FLOAT(MaxDistance);
        P_GET_STRUCT_REF(struct FCovPosInfo,OutCovPosInfo);
        P_FINISH;
        *(UBOOL*)Result=FindCoverFromLocAndDir(FromLoc,Direction,FOV,MaxDistance,OutCovPosInfo);
    }
    DECLARE_FUNCTION(execValidatePotentialCover)
    {
        P_GET_STRUCT(FVector,FromLoc);
        P_GET_STRUCT(FVector,Direction);
        P_GET_FLOAT_REF(OutMinDotFOV);
        P_GET_FLOAT_REF(OutMaxDistanceSquared);
        P_GET_STRUCT_REF(struct FCovPosInfo,OutCovPosInfo);
        P_FINISH;
        *(UBOOL*)Result=ValidatePotentialCover(FromLoc,Direction,OutMinDotFOV,OutMaxDistanceSquared,OutCovPosInfo);
    }
    DECLARE_FUNCTION(execFillCoverPosInfo)
    {
        P_GET_OBJECT(ACoverLink,Link);
        P_GET_INT(LtSlotIdx);
        P_GET_INT(RtSlotIdx);
        P_GET_STRUCT(FVector,FromLoc);
        P_GET_STRUCT(FVector,Direction);
        P_GET_FLOAT(MaxDistance);
        P_GET_STRUCT_REF(struct FCovPosInfo,out_CovPosInfo);
        P_FINISH;
        FillCoverPosInfo(Link,LtSlotIdx,RtSlotIdx,FromLoc,Direction,MaxDistance,out_CovPosInfo);
    }
    DECLARE_FUNCTION(execGetCoverInfo)
    {
        P_FINISH;
        GetCoverInfo();
    }
    DECLARE_FUNCTION(execGetStreamingInfo)
    {
        P_GET_STR(levelStatus);
        P_FINISH;
        GetStreamingInfo(levelStatus);
    }
    DECLARE_FUNCTION(execUpdateAutomaticHeadTracking)
    {
        P_FINISH;
        UpdateAutomaticHeadTracking();
    }
    DECLARE_FUNCTION(execAimInterpTo)
    {
        P_GET_FLOAT(Current);
        P_GET_FLOAT(Target);
        P_GET_FLOAT(DeltaTime);
        P_GET_FLOAT(InterpSpeed);
        P_FINISH;
        *(FLOAT*)Result=AimInterpTo(Current,Target,DeltaTime,InterpSpeed);
    }
    DECLARE_FUNCTION(execUpdateMeshBoneControllersNative)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateMeshBoneControllersNative(DeltaTime);
    }
    DECLARE_FUNCTION(execUpdateAimOffset)
    {
        P_GET_STRUCT(FVector2D,NewAimOffsetPct);
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateAimOffset(NewAimOffsetPct,DeltaTime);
    }
    DECLARE_FUNCTION(execSimulate360Aiming)
    {
        P_GET_UBOOL(bCurrentlyDoing360Aiming);
        P_GET_STRUCT(FVector2D,TestAimOffsetPct);
        P_GET_BYTE(TestCoverType);
        P_GET_BYTE_REF(out_CoverDirection);
        P_FINISH;
        *(UBOOL*)Result=Simulate360Aiming(bCurrentlyDoing360Aiming,TestAimOffsetPct,TestCoverType,out_CoverDirection);
    }
    DECLARE_FUNCTION(execIsDoing360ToLeaningTransition)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoing360ToLeaningTransition();
    }
    DECLARE_FUNCTION(execIsDoingLeaningTo360Transition)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoingLeaningTo360Transition();
    }
    DECLARE_FUNCTION(execIsProtectedByCover)
    {
        P_GET_STRUCT(FVector,ShotDirection);
        P_GET_UBOOL_OPTX(bSkipPlayerCheck,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsProtectedByCover(ShotDirection,bSkipPlayerCheck);
    }
    DECLARE_FUNCTION(execGetResultingStoppingPower)
    {
        P_FINISH;
        *(FLOAT*)Result=GetResultingStoppingPower();
    }
    DECLARE_FUNCTION(execIsDoingDeathAnimSpecialMove)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoingDeathAnimSpecialMove();
    }
    DECLARE_FUNCTION(execReduceConstraintLimits)
    {
        P_FINISH;
        ReduceConstraintLimits();
    }
    DECLARE_FUNCTION(execIsLeaning)
    {
        P_FINISH;
        *(UBOOL*)Result=IsLeaning();
    }
    DECLARE_FUNCTION(execIsPoppingUp)
    {
        P_FINISH;
        *(UBOOL*)Result=IsPoppingUp();
    }
    DECLARE_FUNCTION(execIsDoingSpecialMove)
    {
        P_GET_BYTE(AMove);
        P_FINISH;
        *(UBOOL*)Result=IsDoingSpecialMove(AMove);
    }
    DECLARE_FUNCTION(execIsDoingASpecialMove)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoingASpecialMove();
    }
    DECLARE_FUNCTION(execIsDoingMeleeHoldSpecialMove)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoingMeleeHoldSpecialMove();
    }
    DECLARE_FUNCTION(execIsDoingSpecialMeleeAttack)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoingSpecialMeleeAttack();
    }
    DECLARE_FUNCTION(execIsSpecialMeleeVictim)
    {
        P_FINISH;
        *(UBOOL*)Result=IsSpecialMeleeVictim();
    }
    DECLARE_FUNCTION(execFitCollision)
    {
        P_FINISH;
        *(UBOOL*)Result=FitCollision();
    }
    DECLARE_FUNCTION(execCanPerformMantleDown)
    {
        P_GET_FLOAT(MinMantleHeight);
        P_GET_FLOAT(MaxMantleHeight);
        P_GET_STRUCT(FRotator,TestRotation);
        P_FINISH;
        *(UBOOL*)Result=CanPerformMantleDown(MinMantleHeight,MaxMantleHeight,TestRotation);
    }
    DECLARE_FUNCTION(execIsEvading)
    {
        P_FINISH;
        *(UBOOL*)Result=IsEvading();
    }
    DECLARE_FUNCTION(execIsAtCoverEdge)
    {
        P_GET_UBOOL(bMirrored);
        P_GET_UBOOL_OPTX(bAllowLeanAsEdge,FALSE);
        P_GET_FLOAT_OPTX(Scale,1.750000);
        P_GET_INT_OPTX_REF(EdgeSlotIdx,0);
        P_GET_INT_OPTX(StartSlotIdx,-1);
        P_GET_UBOOL_OPTX(bIgnoreCurrentCoverAction,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsAtCoverEdge(bMirrored,bAllowLeanAsEdge,Scale,pEdgeSlotIdx ? &EdgeSlotIdx : NULL,StartSlotIdx,bIgnoreCurrentCoverAction);
    }
    DECLARE_FUNCTION(execPickClosestCoverSlot)
    {
        P_GET_UBOOL_OPTX(bRequireOverlap,TRUE);
        P_GET_FLOAT_OPTX(RadiusScale,0.500000);
        P_GET_UBOOL_OPTX(bIgnoreCurrentCoverAction,FALSE);
        P_FINISH;
        *(INT*)Result=PickClosestCoverSlot(bRequireOverlap,RadiusScale,bIgnoreCurrentCoverAction);
    }
    DECLARE_FUNCTION(execIsDoingMove2IdleTransition)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDoingMove2IdleTransition();
    }
    DECLARE_FUNCTION(execGetPhysicalFireStartLoc)
    {
        P_GET_STRUCT(FVector,FireOffset);
        P_FINISH;
        *(FVector*)Result=GetPhysicalFireStartLoc(FireOffset);
    }
    DECLARE_FUNCTION(execSetCoverInfoFromSlotInfo)
    {
        P_GET_STRUCT_REF(struct FCovPosInfo,OutCovInfo);
        P_GET_STRUCT(struct FCoverInfo,SlotInfo);
        P_FINISH;
        *(UBOOL*)Result=SetCoverInfoFromSlotInfo(OutCovInfo,SlotInfo);
    }
    DECLARE_FUNCTION(execBS_Play)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_FLOAT(Rate);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,TRUE);
        P_GET_NAME_OPTX(GroupName,NAME_None);
        P_FINISH;
        *(FLOAT*)Result=BS_Play(Stance,Rate,BlendInTime,BlendOutTime,bLooping,bOverride,GroupName);
    }
    DECLARE_FUNCTION(execBS_PlayByDuration)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_FLOAT(Duration);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,TRUE);
        P_GET_NAME_OPTX(GroupName,NAME_None);
        P_FINISH;
        BS_PlayByDuration(Stance,Duration,BlendInTime,BlendOutTime,bLooping,bOverride,GroupName);
    }
    DECLARE_FUNCTION(execBS_IsPlaying)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_FINISH;
        *(UBOOL*)Result=BS_IsPlaying(Stance);
    }
    DECLARE_FUNCTION(execBS_HasAnyWeight)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_FINISH;
        *(UBOOL*)Result=BS_HasAnyWeight(Stance);
    }
    DECLARE_FUNCTION(execBS_SeqNodeBelongsTo)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_FINISH;
        *(UBOOL*)Result=BS_SeqNodeBelongsTo(SeqNode,Stance);
    }
    DECLARE_FUNCTION(execBS_Stop)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_FINISH;
        BS_Stop(Stance,BlendOutTime);
    }
    DECLARE_FUNCTION(execBS_SetPlayingFlag)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_UBOOL(bNewPlaying);
        P_FINISH;
        BS_SetPlayingFlag(Stance,bNewPlaying);
    }
    DECLARE_FUNCTION(execBS_StopAll)
    {
        P_GET_FLOAT(BlendOutTime);
        P_FINISH;
        BS_StopAll(BlendOutTime);
    }
    DECLARE_FUNCTION(execBS_Override)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_FINISH;
        BS_Override(Stance);
    }
    DECLARE_FUNCTION(execBS_SetPosition)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_FLOAT(Position);
        P_FINISH;
        BS_SetPosition(Stance,Position);
    }
    DECLARE_FUNCTION(execBS_GetTimeLeft)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_FINISH;
        *(FLOAT*)Result=BS_GetTimeLeft(Stance);
    }
    DECLARE_FUNCTION(execBS_GetPlayRate)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_FINISH;
        *(FLOAT*)Result=BS_GetPlayRate(Stance);
    }
    DECLARE_FUNCTION(execBS_SetPlayRate)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_FLOAT(NewRate);
        P_FINISH;
        BS_SetPlayRate(Stance,NewRate);
    }
    DECLARE_FUNCTION(execBS_ScalePlayRate)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_FLOAT(RateScale);
        P_FINISH;
        BS_ScalePlayRate(Stance,RateScale);
    }
    DECLARE_FUNCTION(execBS_SetRootBoneAxisOptions)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_BYTE_OPTX(AxisX,0);
        P_GET_BYTE_OPTX(AxisY,0);
        P_GET_BYTE_OPTX(AxisZ,0);
        P_FINISH;
        BS_SetRootBoneAxisOptions(Stance,AxisX,AxisY,AxisZ);
    }
    DECLARE_FUNCTION(execBS_SetMirrorOptions)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_UBOOL(bTransitionToMirrored);
        P_GET_UBOOL(bBeginTransition);
        P_GET_UBOOL(bMirrorAnimation);
        P_FINISH;
        BS_SetMirrorOptions(Stance,bTransitionToMirrored,bBeginTransition,bMirrorAnimation);
    }
    DECLARE_FUNCTION(execBS_SetAnimEndNotify)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_UBOOL(bNewStatus);
        P_FINISH;
        BS_SetAnimEndNotify(Stance,bNewStatus);
    }
    DECLARE_FUNCTION(execBS_SetEarlyAnimEndNotify)
    {
        P_GET_STRUCT_INIT(struct FBodyStance,Stance);
        P_GET_UBOOL(bNewEarlyAnimEndNotify);
        P_FINISH;
        BS_SetEarlyAnimEndNotify(Stance,bNewEarlyAnimEndNotify);
    }
    DECLARE_FUNCTION(execIsReloadingWeapon)
    {
        P_FINISH;
        *(UBOOL*)Result=IsReloadingWeapon();
    }
    DECLARE_FUNCTION(execMAT_BeginAnimControl)
    {
        P_GET_TARRAY(class UAnimSet*,InAnimSets);
        P_FINISH;
        MAT_BeginAnimControl(InAnimSets);
    }
    DECLARE_FUNCTION(execMAT_SetAnimPosition)
    {
        P_GET_NAME(SlotName);
        P_GET_INT(ChannelIndex);
        P_GET_NAME(InAnimSeqName);
        P_GET_FLOAT(InPosition);
        P_GET_UBOOL(bFireNotifies);
        P_GET_UBOOL(bLooping);
        P_FINISH;
        MAT_SetAnimPosition(SlotName,ChannelIndex,InAnimSeqName,InPosition,bFireNotifies,bLooping);
    }
    DECLARE_FUNCTION(execMAT_SetAnimWeights)
    {
        P_GET_TARRAY(struct FAnimSlotInfo,SlotInfos);
        P_FINISH;
        MAT_SetAnimWeights(SlotInfos);
    }
    DECLARE_FUNCTION(execMAT_FinishAnimControl)
    {
        P_FINISH;
        MAT_FinishAnimControl();
    }
    DECLARE_FUNCTION(execGetRightHandSocketName)
    {
        P_FINISH;
        *(FName*)Result=GetRightHandSocketName();
    }
    DECLARE_FUNCTION(execGetWeaponHandPosition)
    {
        P_GET_STRUCT_REF(FVector,HandLoc);
        P_GET_STRUCT_REF(FRotator,HandRot);
        P_FINISH;
        GetWeaponHandPosition(HandLoc,HandRot);
    }
    DECLARE_FUNCTION(execIsFacingOther)
    {
        P_GET_OBJECT(AGearPawn,OtherPawn);
        P_GET_FLOAT_OPTX(minDot,0.500000);
        P_GET_FLOAT_OPTX(HeightTolerancePct,0.800000);
        P_FINISH;
        *(UBOOL*)Result=IsFacingOther(OtherPawn,minDot,HeightTolerancePct);
    }
    DECLARE_FUNCTION(execSpeakLine)
    {
        P_GET_OBJECT(AGearPawn,Addressee);
        P_GET_OBJECT(USoundCue,Audio);
        P_GET_STR(DebugText);
        P_GET_FLOAT(DelaySec);
        P_GET_BYTE_OPTX(Priority,0);
        P_GET_BYTE_OPTX(IntCondition,0);
        P_GET_UBOOL_OPTX(bNoHeadTrack,FALSE);
        P_GET_INT_OPTX(BroadcastFilter,0);
        P_GET_UBOOL_OPTX(bSuppressSubtitle,FALSE);
        P_GET_FLOAT_OPTX(InExtraHeadTrackTime,0);
        P_GET_UBOOL_OPTX(bClientSide,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SpeakLine(Addressee,Audio,DebugText,DelaySec,Priority,IntCondition,bNoHeadTrack,BroadcastFilter,bSuppressSubtitle,InExtraHeadTrackTime,bClientSide);
    }
    DECLARE_FUNCTION(execShouldSuppressSubtitlesForQueuedSpeakLine)
    {
        P_GET_UBOOL(bVersusMulti);
        P_FINISH;
        *(UBOOL*)Result=ShouldSuppressSubtitlesForQueuedSpeakLine(bVersusMulti);
    }
    DECLARE_FUNCTION(execShouldFilterOutSpeech)
    {
        P_GET_BYTE(Filter);
        P_GET_OBJECT(AGearPawn,Addressee);
        P_FINISH;
        *(UBOOL*)Result=ShouldFilterOutSpeech(Filter,Addressee);
    }
    DECLARE_FUNCTION(execPlayQueuedSpeakLine)
    {
        P_FINISH;
        PlayQueuedSpeakLine();
    }
    DECLARE_FUNCTION(execTickKnockDownMotorStrength)
    {
        P_GET_FLOAT(DeltaSeconds);
        P_FINISH;
        TickKnockDownMotorStrength(DeltaSeconds);
    }
    DECLARE_FUNCTION(execIsDBNO)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDBNO();
    }
    DECLARE_FUNCTION(execIsAHostage)
    {
        P_FINISH;
        *(UBOOL*)Result=IsAHostage();
    }
    DECLARE_FUNCTION(execIsAKidnapper)
    {
        P_FINISH;
        *(UBOOL*)Result=IsAKidnapper();
    }
    DECLARE_FUNCTION(execCanFireWeapon)
    {
        P_GET_UBOOL_OPTX(bTestingForTargeting,FALSE);
        P_FINISH;
        *(UBOOL*)Result=CanFireWeapon(bTestingForTargeting);
    }
    DECLARE_FUNCTION(execGetCameraNoRenderCylinder)
    {
        P_GET_FLOAT_REF(Radius);
        P_GET_FLOAT_REF(Height);
        P_GET_UBOOL(bViewTarget);
        P_GET_UBOOL(bHiddenLocally);
        P_FINISH;
        GetCameraNoRenderCylinder(Radius,Height,bViewTarget,bHiddenLocally);
    }
    DECLARE_FUNCTION(execSetMeshTranslationOffset)
    {
        P_GET_STRUCT(FVector,NewOffset);
        P_GET_UBOOL_OPTX(bForce,FALSE);
        P_FINISH;
        SetMeshTranslationOffset(NewOffset,bForce);
    }
    UBOOL eventIsFiringHOD()
    {
        GearPawn_eventIsFiringHOD_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsFiringHOD),&Parms);
        return Parms.ReturnValue;
    }
    void eventPlaySpeechGesture(FName GestureAnim)
    {
        GearPawn_eventPlaySpeechGesture_Parms Parms(EC_EventParm);
        Parms.GestureAnim=GestureAnim;
        ProcessEvent(FindFunctionChecked(GEARGAME_PlaySpeechGesture),&Parms);
    }
    void eventSpawnExecutionEffect_PunchLeftToRight()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnExecutionEffect_PunchLeftToRight),NULL);
    }
    void eventSpawnExecutionEffect_PunchRightToLeft()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnExecutionEffect_PunchRightToLeft),NULL);
    }
    void eventSpawnExecutionEffect_TorqueBow()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnExecutionEffect_TorqueBow),NULL);
    }
    void eventSpawnExecutionEffect_LongShot()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnExecutionEffect_LongShot),NULL);
    }
    void eventSpawnExecutionEffect_Boltok()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnExecutionEffect_Boltok),NULL);
    }
    void eventSplashBloodOnScreen_TorqueBow()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SplashBloodOnScreen_TorqueBow),NULL);
    }
    void eventSplashBloodOnScreen_SmashFace()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SplashBloodOnScreen_SmashFace),NULL);
    }
    void eventSplashBloodOnScreen_PunchFace()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SplashBloodOnScreen_PunchFace),NULL);
    }
    void eventSplashBloodOnScreen_ExecutionBoltok()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SplashBloodOnScreen_ExecutionBoltok),NULL);
    }
    void eventSplashPunchFaceBloodOnScreen()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SplashPunchFaceBloodOnScreen),NULL);
    }
    void eventSplashChainsawBloodOnScreen()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SplashChainsawBloodOnScreen),NULL);
    }
    UBOOL eventIsDeployingShield()
    {
        GearPawn_eventIsDeployingShield_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsDeployingShield),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsCarryingShield()
    {
        GearPawn_eventIsCarryingShield_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsCarryingShield),&Parms);
        return Parms.ReturnValue;
    }
    void eventPlayGibEffect(FVector HitLoc,FVector HitNorm,FLOAT SquaredForce)
    {
        GearPawn_eventPlayGibEffect_Parms Parms(EC_EventParm);
        Parms.HitLoc=HitLoc;
        Parms.HitNorm=HitNorm;
        Parms.SquaredForce=SquaredForce;
        ProcessEvent(FindFunctionChecked(GEARGAME_PlayGibEffect),&Parms);
    }
    void eventBumpLevel(FVector HitLocation,FVector HitNormal)
    {
        GearPawn_eventBumpLevel_Parms Parms(EC_EventParm);
        Parms.HitLocation=HitLocation;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(GEARGAME_BumpLevel),&Parms);
    }
    void eventKnockdownFailsafe()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_KnockdownFailsafe),NULL);
    }
    void eventSpeakLineFinished()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SpeakLineFinished),NULL);
    }
    UBOOL eventSetHeadTrackActor(class AActor* ActorToTrack,FName LookatBoneName=NAME_None,UBOOL bOverride=FALSE)
    {
        GearPawn_eventSetHeadTrackActor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ActorToTrack=ActorToTrack;
        Parms.LookatBoneName=LookatBoneName;
        Parms.bOverride=bOverride ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetHeadTrackActor),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetWeaponAlert(FLOAT Duration)
    {
        GearPawn_eventSetWeaponAlert_Parms Parms(EC_EventParm);
        Parms.Duration=Duration;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetWeaponAlert),&Parms);
    }
    UBOOL eventIsInAimingPose()
    {
        GearPawn_eventIsInAimingPose_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsInAimingPose),&Parms);
        return Parms.ReturnValue;
    }
    void eventStopCringe()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_StopCringe),NULL);
    }
    void eventCringe(FLOAT Duration=0)
    {
        GearPawn_eventCringe_Parms Parms(EC_EventParm);
        Parms.Duration=Duration;
        ProcessEvent(FindFunctionChecked(GEARGAME_Cringe),&Parms);
    }
    UBOOL eventIsPlayingCustomCameraAnim(FName SpecificAnimName=NAME_None)
    {
        GearPawn_eventIsPlayingCustomCameraAnim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SpecificAnimName=SpecificAnimName;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsPlayingCustomCameraAnim),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetConversing(UBOOL bConv,UBOOL bUseCommLink=FALSE)
    {
        GearPawn_eventSetConversing_Parms Parms(EC_EventParm);
        Parms.bConv=bConv ? FIRST_BITFIELD : FALSE;
        Parms.bUseCommLink=bUseCommLink ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetConversing),&Parms);
    }
    void eventReachedCoverSlot(INT SlotIdx)
    {
        GearPawn_eventReachedCoverSlot_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(GEARGAME_ReachedCoverSlot),&Parms);
    }
    void eventOnMirrorBlendOutNotify()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_OnMirrorBlendOutNotify),NULL);
    }
    void eventOnMirroredNotify()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_OnMirroredNotify),NULL);
    }
    void eventSetMirroredSide(UBOOL bDesiredMirrored)
    {
        GearPawn_eventSetMirroredSide_Parms Parms(EC_EventParm);
        Parms.bDesiredMirrored=bDesiredMirrored ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetMirroredSide),&Parms);
    }
    UBOOL eventRestoreAnimSetsToDefault()
    {
        GearPawn_eventRestoreAnimSetsToDefault_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_RestoreAnimSetsToDefault),&Parms);
        return Parms.ReturnValue;
    }
    void eventUpdateAttachmentVisibility()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_UpdateAttachmentVisibility),NULL);
    }
    FVector eventGetPhysicalFireStartLoc(FVector FireOffset)
    {
        GearPawn_eventGetPhysicalFireStartLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.FireOffset=FireOffset;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetPhysicalFireStartLoc),&Parms);
        return Parms.ReturnValue;
    }
    void eventMove2IdleTransitionFinished()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_Move2IdleTransitionFinished),NULL);
    }
    void eventConditionalMove2IdleTransition()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ConditionalMove2IdleTransition),NULL);
    }
    void eventEvadeAnimationFinished()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_EvadeAnimationFinished),NULL);
    }
    void eventLocalEndSpecialMove(BYTE SpecialMoveToEnd=0)
    {
        GearPawn_eventLocalEndSpecialMove_Parms Parms(EC_EventParm);
        Parms.SpecialMoveToEnd=SpecialMoveToEnd;
        ProcessEvent(FindFunctionChecked(GEARGAME_LocalEndSpecialMove),&Parms);
    }
    void eventServerEndSpecialMove(BYTE SpecialMoveToEnd=0)
    {
        GearPawn_eventServerEndSpecialMove_Parms Parms(EC_EventParm);
        Parms.SpecialMoveToEnd=SpecialMoveToEnd;
        ProcessEvent(FindFunctionChecked(GEARGAME_ServerEndSpecialMove),&Parms);
    }
    UBOOL eventCanDoSpecialMove(BYTE AMove,UBOOL bForceCheck=FALSE)
    {
        GearPawn_eventCanDoSpecialMove_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AMove=AMove;
        Parms.bForceCheck=bForceCheck ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_CanDoSpecialMove),&Parms);
        return Parms.ReturnValue;
    }
    void eventDoSpecialMove(BYTE NewMove,UBOOL bForceMove=FALSE,class AGearPawn* InInteractionPawn=NULL,INT InSpecialMoveFlags=0)
    {
        GearPawn_eventDoSpecialMove_Parms Parms(EC_EventParm);
        Parms.NewMove=NewMove;
        Parms.bForceMove=bForceMove ? FIRST_BITFIELD : FALSE;
        Parms.InInteractionPawn=InInteractionPawn;
        Parms.InSpecialMoveFlags=InSpecialMoveFlags;
        ProcessEvent(FindFunctionChecked(GEARGAME_DoSpecialMove),&Parms);
    }
    void eventPostAIFactorySpawned(class USeqAct_AIFactory* SpawningFactory,INT SpawnSetIdx)
    {
        GearPawn_eventPostAIFactorySpawned_Parms Parms(EC_EventParm);
        Parms.SpawningFactory=SpawningFactory;
        Parms.SpawnSetIdx=SpawnSetIdx;
        ProcessEvent(FindFunctionChecked(GEARGAME_PostAIFactorySpawned),&Parms);
    }
    void eventAI_AddDefaultInventory()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_AI_AddDefaultInventory),NULL);
    }
    void eventCoverActionAnimationFinished()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_CoverActionAnimationFinished),NULL);
    }
    void eventUpdateShadowSettings(UBOOL bInWantShadow)
    {
        GearPawn_eventUpdateShadowSettings_Parms Parms(EC_EventParm);
        Parms.bInWantShadow=bInWantShadow ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_UpdateShadowSettings),&Parms);
    }
    void eventBodyImpactBlendOutNotify()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_BodyImpactBlendOutNotify),NULL);
    }
    void eventScriptedDeath()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ScriptedDeath),NULL);
    }
    void eventOn360AimingChangeNotify()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_On360AimingChangeNotify),NULL);
    }
    void eventFixWeaponAimIKPosition(FLOAT DeltaTime)
    {
        GearPawn_eventFixWeaponAimIKPosition_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GEARGAME_FixWeaponAimIKPosition),&Parms);
    }
    FVector eventGetAimOffsetOrigin()
    {
        GearPawn_eventGetAimOffsetOrigin_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(GEARGAME_GetAimOffsetOrigin),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetHeadLookTargetLocation()
    {
        GearPawn_eventGetHeadLookTargetLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(GEARGAME_GetHeadLookTargetLocation),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AGearPawn,AGamePawn,0|CLASS_Config|CLASS_NativeReplication,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Pawn");}

	UBOOL ShouldApplyNudge(ACoverLink *Link, INT SlotIdx, UBOOL bIgnoreCurrentCoverAction = FALSE);

	virtual void	TickSpecial(FLOAT DeltaSeconds);

	virtual FLOAT GetGravityZ();

	virtual FGuid* GetGuid();

	/** smooths out player movement on steps/slopes, primarily by adding mesh translation to spread out the Z change over time
	 * @param OldLocation - the Pawn's previous Location to compare against for adjustments
	 */
	void PerformStepsSmoothing(const FVector& OldLocation, FLOAT DeltaSeconds);

	/** Update the mesh component to make it match the Floor surface normal better */
	void UpdateFloorConform(FLOAT DeltaSeconds);

	virtual FLOAT MaxSpeedModifier();
	FVector CheckForLedges(FVector AccelDir, FVector Delta, FVector GravDir, int &bCheckedFall, int &bMustJump );
	virtual void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);
	virtual void performPhysics(FLOAT DeltaSeconds);
	virtual void PostProcessPhysics( FLOAT DeltaSeconds, const FVector& OldVelocity );
	// called when physics == PHYS_RigidBody
	virtual void PostProcessRBPhysics(FLOAT DeltaSeconds, const FVector& OldVelocity);

	virtual void SetPostLandedPhysics(AActor *HitActor, FVector HitNormal);
	virtual void physicsRotation(FLOAT DeltaTime, FVector OldVelocity);
	virtual void TickSimulated(FLOAT DeltaSeconds);
	virtual void HandleSerpentineMovement(FVector& out_Direction, FLOAT Distance, const FVector& Dest ) { }
	virtual void stepUp(const FVector& GravDir, const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	virtual UBOOL ResolveAttachedMoveEncroachment(AActor* EncroachedBase, const FCheckResult& OverlapHit);
	virtual void SyncActorToRBPhysics();

	virtual void	SetAnchor( ANavigationPoint* NewAnchor );
	virtual INT		ModifyCostForReachSpec( UReachSpec* Spec, INT Cost );
	virtual void	InitForPathfinding( AActor* Goal, ANavigationPoint* EndAnchor );

	/** notification when actor has bumped against the level */
	virtual void NotifyBumpLevel(const FVector &HitLocation, const FVector& HitNormal);

	// Never try to jump over a wall
	virtual UBOOL TryJumpUp(FVector Dir, FVector Destination, DWORD TraceFlags, UBOOL bNoVisibility) { return FALSE; }

	// Support for Matinee Anim Control Tracks
	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs);
	virtual void PreviewBeginAnimControl(TArray<class UAnimSet*>& InAnimSets);
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping);
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);
	virtual void PreviewFinishAnimControl();

	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);

	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );

	UBOOL GetMoveDelta(FVector& out_Delta, const FVector& Dest);
	UBOOL moveToward(const FVector &Dest, AActor *GoalActor );

	void UpdateCoverActionAnimTransition(INT InTickTag, UBOOL bInDoingTransition);
	void UpdateTargetingNodeIsInIdleChannel(INT InTickTag, UBOOL bInAimingStance);

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );

	virtual void PreNetReceive();
	virtual void PostNetReceive();
	virtual void PostNetReceiveLocation();
	virtual void PostNetReceiveBase(AActor* NewBase);

	virtual UBOOL IsAliveAndWell() const;

	virtual UBOOL	IsValidAnchor( ANavigationPoint* AnchorCandidate );

private:
	void HeadTrackInterp( const FRotator & AimDeltaRot, const FRotator & HeadTrackDeltaRot, FRotator & OutDeltaRot );
	void UpdateHeadTrackInterp( const FLOAT & DeltaTime );
};

class AGearPawn_CarryCrate_Base : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_CarryCrate_Base
    class AGearPawn* MarcusPawn;
    FLOAT MarcusStickX;
    FLOAT MarcusStickY;
    FVector MarcusOldPos;
    class AGearPawn* DomPawn;
    FLOAT DomStickX;
    FLOAT DomStickY;
    FVector DomOldPos;
    FVector CarrierRelPos;
    FVector HandleRelPos;
    FLOAT CrateFriction;
    FLOAT CrateYawFriction;
    FLOAT YawVelocity;
    FLOAT YawAcceleration;
    FLOAT RepVelocityX;
    FLOAT RepVelocityY;
    FLOAT RepVelocityZ;
    FLOAT CrateLinAcceleration;
    FLOAT CrateYawAcceleration;
    FLOAT CrateSteerDeadZone;
    FLOAT CrateMaxYawVel;
    FLOAT CrateCoopYawFactor;
    FLOAT WalkAnimVelScale;
    FLOAT CrateWalkRotFactor;
    FLOAT CrateRollXTransFactor;
    FLOAT CrateAmbientTransFreq;
    FLOAT CrateAmbientTransMag;
    FLOAT AmbientTransVal;
    FLOAT CrateXSpringStiffness;
    FLOAT CrateXSpringDamping;
    FLOAT CrateXSpringAccelFactor;
    FLOAT CrateXSpringMaxDisplacement;
    FLOAT CrateXSpringVel;
    FLOAT OldForwardVel;
    FLOAT MaxCrateSpeed;
    class UStaticMeshComponent* CrateMeshComponent;
    //## END PROPS GearPawn_CarryCrate_Base

    DECLARE_CLASS(AGearPawn_CarryCrate_Base,AGearPawn,0|CLASS_Config|CLASS_NativeReplication,GearGame)
	virtual void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);
	virtual void physicsRotation(FLOAT DeltaTime, FVector OldVelocity);
	virtual void TickSimulated( FLOAT DeltaSeconds );

	virtual INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void PostNetReceive();
	virtual void PostNetReceiveLocation();

	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
};

struct FIdleBreakAnimInfo
{
    FName AnimName;
    BYTE CoverType;
    BYTE WeaponType;
    BITFIELD bAIOnly:1 GCC_BITFIELD_MAGIC;

    /** Constructors */
    FIdleBreakAnimInfo() {}
    FIdleBreakAnimInfo(EEventParm)
    {
        appMemzero(this, sizeof(FIdleBreakAnimInfo));
    }
};

struct FIdleBreakReplicationInfo
{
    BYTE Index;
    BYTE Count;
    BYTE padding1;
    BYTE padding2;

    /** Constructors */
    FIdleBreakReplicationInfo() {}
    FIdleBreakReplicationInfo(EEventParm)
    {
        appMemzero(this, sizeof(FIdleBreakReplicationInfo));
    }
};

class AGearPawn_Infantry : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_Infantry
    BITFIELD bHasHelmetOn:1;
    BITFIELD bDisableIdleBreaks:1;
    class UClass* HelmetType;
    class UClass* HelmetTypeReplicated;
    BYTE RemoveHelmet;
    BYTE RemoveHelmet2;
    BYTE RemoveShoulderPadLeft;
    BYTE RemoveShoulderPadRight;
    class UStaticMeshComponent* HeadSlotStaticMesh;
    class UStaticMeshComponent* HeadSlotStaticMesh2;
    class USkeletalMeshComponent* HeadSlotSkeletalMesh;
    class UParticleSystemComponent* PSC_HelmetParticleEffect;
    class UClass* ShoulderPadLeftType;
    class UClass* ShoulderPadLeftTypeReplicated;
    class UStaticMeshComponent* ShoulderPadLeftMesh;
    class UClass* ShoulderPadRightType;
    class UClass* ShoulderPadRightTypeReplicated;
    class UStaticMeshComponent* ShoulderPadRightMesh;
    TArrayNoInit<FName> StomachBones;
    TArrayNoInit<FName> RightShoulderBones;
    TArrayNoInit<FName> LeftShoulderBones;
    TArrayNoInit<FName> RightLegBones;
    TArrayNoInit<FName> LeftLegBones;
    FName HitReactionStomach;
    FName HitReactionLeftShoulder;
    FName HitReactionRightShoulder;
    TArrayNoInit<struct FIdleBreakAnimInfo> IdleBreakList;
    FVector2D IdleBreakFreq;
    INT LastIdleBreakAnimIndex;
    struct FIdleBreakReplicationInfo ReplicatedIdleBreakInfo;
    struct FBodyStance BS_LastIdleBreakAnim;
    //## END PROPS GearPawn_Infantry

    UBOOL MatchNameArray(FName NameToMatch,const TArray<FName>& NameArray);
    UBOOL InfantryStuckInWorld();
    DECLARE_FUNCTION(execMatchNameArray)
    {
        P_GET_NAME(NameToMatch);
        P_GET_TARRAY_REF(FName,NameArray);
        P_FINISH;
        *(UBOOL*)Result=MatchNameArray(NameToMatch,NameArray);
    }
    DECLARE_FUNCTION(execInfantryStuckInWorld)
    {
        P_FINISH;
        *(UBOOL*)Result=InfantryStuckInWorld();
    }
    DECLARE_ABSTRACT_CLASS(AGearPawn_Infantry,AGearPawn,0|CLASS_Config|CLASS_NativeReplication,GearGame)
	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AGearPawn_COGGear : public AGearPawn_Infantry
{
public:
    //## BEGIN PROPS GearPawn_COGGear
    //## END PROPS GearPawn_COGGear

    DECLARE_CLASS(AGearPawn_COGGear,AGearPawn_Infantry,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_COGGear)
};

class AGearPawn_COGDom : public AGearPawn_COGGear
{
public:
    //## BEGIN PROPS GearPawn_COGDom
    FLOAT DomAIHitPoints;
    FLOAT RatioOfDefaultToSimulatedHP;
    //## END PROPS GearPawn_COGDom

    DECLARE_CLASS(AGearPawn_COGDom,AGearPawn_COGGear,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_COGDom)
};

class AGearPawn_COGMarcus : public AGearPawn_COGGear
{
public:
    //## BEGIN PROPS GearPawn_COGMarcus
    //## END PROPS GearPawn_COGMarcus

    DECLARE_CLASS(AGearPawn_COGMarcus,AGearPawn_COGGear,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_COGMarcus)
};

class AGearPawn_LocustBase : public AGearPawn_Infantry
{
public:
    //## BEGIN PROPS GearPawn_LocustBase
    //## END PROPS GearPawn_LocustBase

    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustBase,AGearPawn_Infantry,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_LocustBase)
};

class AGearPawn_LocustKantusBase : public AGearPawn_LocustBase
{
public:
    //## BEGIN PROPS GearPawn_LocustKantusBase
    BYTE ThrowCount;
    TArrayNoInit<class USoundCue*> KantusAttackTelegraphDialogue;
    class UParticleSystem* ReviveParticleSystem;
    TArrayNoInit<class UClass*> MinionClasses;
    //## END PROPS GearPawn_LocustKantusBase

    UBOOL IsThrowingOffHandGrenade();
    virtual UBOOL CanFireWeapon(UBOOL bTestingForTargeting=FALSE);
    DECLARE_FUNCTION(execIsThrowingOffHandGrenade)
    {
        P_FINISH;
        *(UBOOL*)Result=IsThrowingOffHandGrenade();
    }
    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustKantusBase,AGearPawn_LocustBase,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_LocustKantusBase)
};

class AGearPawn_LocustSkorgeBase : public AGearPawn_LocustKantusBase
{
public:
    //## BEGIN PROPS GearPawn_LocustSkorgeBase
    BITFIELD bHideGun:1;
    BITFIELD bBlockingBullets:1;
    FLOAT CompleteStrafeAttackTime;
    BYTE ForcedOutcome;
    BYTE Stage;
    INT DuelingRequirements[4];
    class UAnimNodeSequence* ChargeAnimNode;
    class UAudioComponent* AC_StaffTwirl;
    //## END PROPS GearPawn_LocustSkorgeBase

    DECLARE_CLASS(AGearPawn_LocustSkorgeBase,AGearPawn_LocustKantusBase,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_LocustSkorgeBase)
};

struct FDmgDealingLimbStruct
{
    FName BoneName;
    FLOAT BoxSize;
    FVector LastLocation;

    /** Constructors */
    FDmgDealingLimbStruct() {}
    FDmgDealingLimbStruct(EEventParm)
    {
        appMemzero(this, sizeof(FDmgDealingLimbStruct));
    }
};

struct GearPawn_LocustBrumakBase_eventDmgDealingLimbsCollision_Parms
{
    class AActor* HitActor;
    FVector HitLocation;
    FVector HitNormal;
    GearPawn_LocustBrumakBase_eventDmgDealingLimbsCollision_Parms(EEventParm)
    {
    }
};
class AGearPawn_LocustBrumakBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_LocustBrumakBase
    class AGearPawn* Driver;
    class AGearPawn* BackupDriver;
    class UClass* DriverClass;
    FName DriverSocket;
    class UAnimTree* DriverAnimTree;
    class UAnimSet* DriverAnimSet;
    class AActor* MainGunTarget;
    FVector MainGunAimLocation;
    class USkelControlLookAt* MainGunAimController1;
    class USkelControlLookAt* MainGunAimController2;
    FLOAT LegHealth;
    FLOAT LegHealTime;
    FLOAT LastExposeDriverTime;
    FLOAT MinDriverSafeTime;
    class AGearPointOfInterest* DriverPOI;
    BITFIELD bDriverPOIEnabled:1;
    BITFIELD bLegPOIEnabled:1;
    BITFIELD bFlinching:1;
    BITFIELD bCanFireRockets:1;
    BITFIELD bEnableCentaurRepulsion:1;
    BITFIELD bShowCentaurRepulsion:1;
    class AGearPointOfInterest* LegPOI;
    FLOAT HeadHealth;
    FLOAT HeadHealTime;
    FLOAT MainGunHealth;
    BYTE RoarCount;
    BYTE LeftGunLives;
    BYTE RightGunLives;
    class UClass* SideGunClass;
    class APawn* RightGunPawn;
    class APawn* LeftGunPawn;
    class AGearPawn* HumanGunner;
    INT LeftGunHealth;
    INT RightGunHealth;
    FName LeftMuzzleSocketName;
    FName RightMuzzleSocketName;
    class USkelControlLookAt* LeftGunAimController;
    class USkelControlLookAt* RightGunAimController;
    class AActor* LeftGunTarget;
    class AActor* RightGunTarget;
    FVector LeftGunAimLocation;
    FVector RightGunAimLocation;
    FVector AimOffsetViewLoc;
    INT SideGunDestroyedHitPointPenalty;
    FName GunnerState;
    FVector2D LeftGunAimPct;
    FVector2D RightGunAimPct;
    TArrayNoInit<class UGearSkelCtrl_IKRecoil*> IKRecoilCtrl;
    class UAnimNodeBlend* LeftArmAimOffsetBlend;
    class UAnimNodeBlend* RightArmAimOffsetBlend;
    class UGearAnim_BlendByRefRelative* MainGunFireAdditiveBlend;
    FLOAT SideGunConeAngle;
    FVector SideGunOriginOffset;
    FLOAT MainGunConeAngle;
    FVector MainGunOriginOffset;
    class UStaticMeshComponent* LeftGunComponent;
    class UStaticMeshComponent* RightGunComponent;
    class UStaticMeshComponent* MaskComponent;
    class UGearAnim_TurnInPlace_Player* TurnPlayer;
    TArrayNoInit<struct FDmgDealingLimbStruct> DmgDealingLimbs;
    class UParticleSystem* PS_FootstepDust;
    class USoundCue* FootSound;
    class UParticleSystem* PS_BreathEffect;
    class UParticleSystemComponent* PSC_BreathEffect;
    class USoundCue* DyingSound;
    FVector OldCamPosition;
    FRotator OldCamRotation;
    FLOAT CentaurRepulsionRadius;
    FLOAT CentaurRepulsionStrength;
    //## END PROPS GearPawn_LocustBrumakBase

    virtual FVector GetPhysicalFireStartLoc(FVector FireOffset);
    void eventDmgDealingLimbsCollision(class AActor* HitActor,FVector HitLocation,FVector HitNormal)
    {
        GearPawn_LocustBrumakBase_eventDmgDealingLimbsCollision_Parms Parms(EC_EventParm);
        Parms.HitActor=HitActor;
        Parms.HitLocation=HitLocation;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(GEARGAME_DmgDealingLimbsCollision),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustBrumakBase,AGearPawn,0|CLASS_Config,GearGame)
	virtual FVector GetIdealCameraOrigin()
	{
		if( Driver )
		{
			return Driver->GetIdealCameraOrigin();
		}
		return Super::GetIdealCameraOrigin();
	}

	virtual void	TickSpecial(FLOAT DeltaSeconds);

	virtual UBOOL	IgnoreBlockingBy( const AActor* Other ) const;
};

class AGearPawn_LocustBrumakHelper_Base : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_LocustBrumakHelper_Base
    //## END PROPS GearPawn_LocustBrumakHelper_Base

    virtual FVector GetPawnViewLocation();
    DECLARE_CLASS(AGearPawn_LocustBrumakHelper_Base,AGearPawn,0|CLASS_Config,GearGame)
	virtual UBOOL IsAliveAndWell() const
	{
		return (!bDeleteMe);
	}
};

struct FMouthTentacle
{
    FName SkelCont_MoveName;
    FName SkelCont_SplineName;
    class USkelControlSingleBone* SkelCont_Move;
    class USkelControlSpline* SkelCont_Spline;
    class UAnimNodeBlendList* BlendList;
    FName MatParamName;
    FLOAT MatTimer;
    class AActor* Target;
    BYTE Status;
    FLOAT StatusTime;
    INT Health;
    class UAudioComponent* AC_TentacleTell;

    /** Constructors */
    FMouthTentacle() {}
    FMouthTentacle(EEventParm)
    {
        appMemzero(this, sizeof(FMouthTentacle));
    }
};

struct FRepMouthTentacle
{
    FVector TargetLocation;
    BYTE Status;

    /** Constructors */
    FRepMouthTentacle() {}
    FRepMouthTentacle(EEventParm)
    {
        appMemzero(this, sizeof(FRepMouthTentacle));
    }
};

class AGearPawn_LocustLeviathanBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_LocustLeviathanBase
    struct FMouthTentacle Tentacles[6];
    struct FRepMouthTentacle RepTentacles[6];
    class UGearAnim_BlendPerBone* TentacleMask;
    INT DefaultTentacleHealth;
    BYTE NumTentaclesHurt;
    BYTE MouthStatus;
    BYTE JawStatus;
    BYTE EyeStatus;
    FLOAT TentacleStartTime;
    FLOAT TentacleWarmUpTime;
    FLOAT TentacleAttackTime;
    FLOAT TentacleInterpTime;
    FLOAT TentaclePauseTime;
    FLOAT TentacleRetractTime;
    FLOAT TentacleHurtTime;
    FLOAT DurationMouthAttack;
    FVector2D DelayBetweenMouthTentacleAttacks;
    FLOAT TentacleImpactDamage;
    FLOAT TentacleImpactRadius;
    FLOAT LastTentacleDamageSoundTime;
    class USoundCue* TentacleTellSound;
    class USoundCue* TentacleStartAttackSound;
    class USoundCue* TentacleImpactSound;
    class USoundCue* TentacleHurtSound;
    BITFIELD bMouthGrenadeSuccess:1;
    BITFIELD bMouthClosedFail:1;
    BITFIELD bMouthOpen:1;
    BITFIELD bJawOpen:1;
    BITFIELD bJawAnimNotifyClosed:1;
    BITFIELD bEyeOpen:1;
    BITFIELD bSqueezeEyes:1;
    BITFIELD bEmergedFromWater:1;
    FLOAT MouthStatusTime;
    class UAnimNodeBlendList* MouthBlendList;
    class ATrigger_LeviathanMouth* MouthTrigger;
    FLOAT JawStatusTime;
    class UAnimNodeBlendList* JawBlendList;
    FLOAT EyeStatusTime;
    class UAnimNodeBlendList* RightEyeBlendList;
    class UAnimNodeBlendList* LeftEyeBlendList;
    class USoundCue* MouthOpenSound;
    class USoundCue* MouthOpenIdleSound;
    class USoundCue* MouthShutSound;
    class USoundCue* MouthDamagedSound;
    class USoundCue* MouthExplosionSound;
    class UParticleSystem* PS_MouthOpen;
    class UParticleSystemComponent* PSC_MouthOpen;
    class UParticleSystem* PS_MouthGrenDamage;
    class UParticleSystemComponent* PSC_MouthGrenDamage;
    class UParticleSystem* PS_MouthDrip;
    class UParticleSystemComponent* PSC_MouthDrip;
    class UParticleSystem* PS_MouthMucus;
    class UParticleSystemComponent* PSC_MouthMucus;
    class UParticleSystem* PS_FaceTentacleDrip;
    class UParticleSystemComponent* PSC_FaceTentacleDrip;
    //## END PROPS GearPawn_LocustLeviathanBase

    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustLeviathanBase,AGearPawn,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearPawn_LocustLeviathanBase)
};

class AGearPawn_LocustNemacystBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_LocustNemacystBase
    BYTE PlaySwoopAnimCount;
    BITFIELD bStartAttack:1 GCC_BITFIELD_MAGIC;
    struct FBodyStance SwoopAnim;
    struct FBodyStance StartAttackAnim;
    struct FBodyStance LoopAttackAnim;
    FLOAT ChargeMaxSpeed;
    FLOAT ChargeSpeedRampTime;
    FName PawnViewSocketName;
    //## END PROPS GearPawn_LocustNemacystBase

    virtual FVector GetPawnViewLocation();
    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustNemacystBase,AGearPawn,0|CLASS_Config,GearGame)
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);
};

class AGearPawn_LocustTickerBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_LocustTickerBase
    FLOAT TimeToStayFlippedOverMin;
    FLOAT TimeToStayFlippedOverMax;
    BITFIELD bCharging:1;
    BITFIELD bHiding:1;
    BITFIELD bExplode:1;
    BITFIELD bSpawnedFromKantus:1;
    BITFIELD bAllowFlipOver:1;
    BITFIELD bFlipped:1;
    FVector AngularFlipImpulse;
    FLOAT LinearFlipImpulseStrength;
    FLOAT GravityScaleZ;
    FLOAT ExplosionBaseDamage;
    FLOAT ExplosionDamageFalloff;
    FLOAT ExplosionDamageRadius;
    class UParticleSystem* KantusSpawnParticleSystem;
    //## END PROPS GearPawn_LocustTickerBase

    virtual UBOOL IsValidTargetFor(const class AController* C) const;
    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustTickerBase,AGearPawn,0|CLASS_Config,GearGame)
	virtual FLOAT GetGravityZ();

	virtual void PostProcessRBPhysics(FLOAT DeltaSeconds, const FVector& OldVelocity){/* Shhhh... it's cool */}

};

class AGearPawn_LocustWretchBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_LocustWretchBase
    FName LeftForeArmBoneName;
    FName RightForeArmBoneName;
    class UAudioComponent* AC_HandStepLeft;
    class UAudioComponent* AC_HandStepRight;
    BITFIELD bWaitForKnockOff:1;
    BITFIELD bSuicidal:1;
    BITFIELD bFleshTimer:1;
    class AGearPawn* Victim;
    FLOAT LeapSpeed;
    FVector ReplicatedFloor;
    //## END PROPS GearPawn_LocustWretchBase

    DECLARE_ABSTRACT_CLASS(AGearPawn_LocustWretchBase,AGearPawn,0|CLASS_Config,GearGame)
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
};

#define UCONST_COVER_TO_SEGMENTS_RATIO 2
#define UCONST_NUM_TAILSEGMENTS 15

struct GearPawn_RockWormBase_eventUpdateMarker_Parms
{
    class ACoverLink_Dynamic* Link;
    INT SlotIdx;
    GearPawn_RockWormBase_eventUpdateMarker_Parms(EEventParm)
    {
    }
};
class AGearPawn_RockWormBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_RockWormBase
    class ARockWorm_TailSegment* TailSegmentList;
    class ARockWorm_TailSegment* LastTailSegment;
    FVector InitialSegmentOffset;
    FVector CoverToSegmentOffset;
    class ACoverLink_Dynamic* LeftCover;
    class ACoverLink_Dynamic* RightCover;
    FVector LastCoverUpdatePos;
    TArrayNoInit<class UReachSpec*> ReachSpecsImBlocking;
    FLOAT MinDotReachable;
    FLOAT AngryGroundSpeed;
    FLOAT AngryGroundSpeedDuration;
    class UClass* TailSegmentClass;
    class APawn* ChompVictim;
    FName RearPivotBoneName;
    class USoundCue* AttackSound;
    FLOAT TailVelocityDelay;
    INT MinAngleToTail;
    class AScout* Scout;
    //## END PROPS GearPawn_RockWormBase

    virtual void UpdateBlockedReachSpecs();
    virtual FVector GetParentAttachPos(class AActor* Parent,FName ParentBoneName=FName(TEXT("None")));
    virtual void AddSlotToSlotSpecs();
    DECLARE_FUNCTION(execUpdateBlockedReachSpecs)
    {
        P_FINISH;
        UpdateBlockedReachSpecs();
    }
    DECLARE_FUNCTION(execGetParentAttachPos)
    {
        P_GET_OBJECT(AActor,Parent);
        P_GET_NAME_OPTX(ParentBoneName,FName(TEXT("None")));
        P_FINISH;
        *(FVector*)Result=GetParentAttachPos(Parent,ParentBoneName);
    }
    DECLARE_FUNCTION(execAddSlotToSlotSpecs)
    {
        P_FINISH;
        AddSlotToSlotSpecs();
    }
    void eventUpdateMarker(class ACoverLink_Dynamic* Link,INT SlotIdx)
    {
        GearPawn_RockWormBase_eventUpdateMarker_Parms Parms(EC_EventParm);
        Parms.Link=Link;
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(GEARGAME_UpdateMarker),&Parms);
    }
    DECLARE_CLASS(AGearPawn_RockWormBase,AGearPawn,0|CLASS_Config,GearGame)
	
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;

	// tail related functions
	void UpdateTail(FLOAT DeltaTime);
	void AdjustCoverSlotPositionAlongTail(ACoverLink* Link, const FVector& LinkLocation, ARockWorm_TailSegment* TailSegment, INT SlotIdx);
	void SetCoverSlotLocFromOffset(ACoverLink* Link, const FVector& LinkLocation, INT SlotIdx, const FVector& Offset, AActor* Parent, FName ParentBoneName = NAME_None);
	void UpdateCoverSlots();
	virtual void TickAuthoritative( FLOAT DeltaSeconds);
	virtual void TickSimulated( FLOAT DeltaSeconds);

	// overidden to invalidate actors outside our reachable angle
	virtual int actorReachable(AActor *Other, UBOOL bKnowVisible=0, UBOOL bNoAnchorCheck=0);

	// overidden to disallow anchors behind us (in the tail)
	virtual UBOOL	IsValidAnchor( ANavigationPoint* AnchorCandidate );

	UBOOL IsActorBlockedByTail( AActor* Actor );

	// overidden to disallow rotating into the tail
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);
	// overidden to return when we hit our rotation clamps
	virtual UBOOL ReachedDesiredRotation();


};

class AGearPawn_SecurityBotFlyingBase : public AGearPawn
{
public:
    //## BEGIN PROPS GearPawn_SecurityBotFlyingBase
    FLOAT WobbleMagMax;
    FLOAT WobbleMagMin;
    FLOAT MaxWobbleDist;
    FVector CurrentWobble;
    FVector CurrentAccumulatedWobbleOffset;
    FLOAT LastWobbleDot;
    class UGearExplosion* ExplosionTemplate;
    FLOAT ExploDamage;
    FLOAT ExploDamageRadius;
    FLOAT ExploDamageFalloffExp;
    FName PhysicalFireLocBoneName;
    FLOAT DamageTakenPct;
    BITFIELD bAngryBot:1;
    FLOAT DamageEffectPct;
    class UParticleSystem* PS_Eye;
    class UParticleSystem* PS_Eye_Angry;
    class UParticleSystemComponent* PSC_Eye;
    class UParticleSystem* PS_Jets;
    class UParticleSystemComponent* PSC_Jets;
    class UParticleSystem* PS_Damage;
    class UParticleSystemComponent* PSC_Damage;
    //## END PROPS GearPawn_SecurityBotFlyingBase

    virtual FVector GetPhysicalFireStartLoc(FVector FireOffset);
    DECLARE_ABSTRACT_CLASS(AGearPawn_SecurityBotFlyingBase,AGearPawn,0|CLASS_Config,GearGame)
	void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);
};

struct Gearpawn_SecurityBotStationaryBase_eventNotifyDoneRotating_Parms
{
    Gearpawn_SecurityBotStationaryBase_eventNotifyDoneRotating_Parms(EEventParm)
    {
    }
};
class AGearpawn_SecurityBotStationaryBase : public AGearPawn
{
public:
    //## BEGIN PROPS Gearpawn_SecurityBotStationaryBase
    INT PatrolArcDegrees;
    INT PatrolArcDegreesLeft;
    INT PatrolArcDegreesRight;
    FLOAT PatrolArcDelay;
    FLOAT PatrolArcPeriod;
    FLOAT PatrolPitchoffset;
    BITFIELD bEnabled:1;
    BITFIELD bInvulnerable:1;
    BITFIELD bDisableAIEvade:1;
    BITFIELD bTrackingAnEnemy:1;
    BITFIELD bFiring:1;
    BITFIELD bRotating:1;
    BITFIELD bDeployed:1;
    BITFIELD bConformLaserToGeometry:1;
    BITFIELD bLODFrozen:1;
    FLOAT DamageMultiplier;
    FLOAT DetectionRange;
    INT TargetTrackingSpeed;
    FLOAT StartFireDelay;
    FLOAT StopFireDelay;
    FLOAT ResetDelay;
    FLOAT AccuracyConeDegrees;
    FRotator DesiredTurretRot;
    FLOAT TurretRotationSpeed;
    class USkelControlSingleBone* GunRotControl;
    FName BarrelRotationSkelControlName;
    FName BarrelRotationBoneName;
    FRotator BoneRotOffset;
    FName PhysicalFireLocBoneName;
    FVector SecondPassOffset;
    TArrayNoInit<class UClass*> SecondTracePassValidClasses;
    FVector LaserHitPoint;
    FLOAT TimeNotRenderedUntilLODFreeze;
    //## END PROPS Gearpawn_SecurityBotStationaryBase

    virtual UBOOL CanDeploy();
    virtual FVector GetPhysicalFireStartLoc(FVector FireOffset);
    virtual FVector GetPawnViewLocation();
    DECLARE_FUNCTION(execCanDeploy)
    {
        P_FINISH;
        *(UBOOL*)Result=CanDeploy();
    }
    void eventNotifyDoneRotating()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyDoneRotating),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AGearpawn_SecurityBotStationaryBase,AGearPawn,0|CLASS_Config,GearGame)
	virtual UBOOL ReachedDesiredRotation();
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
	void GetBaseAimDir(FVector& out_AimDir);
	virtual void BeginDestroy();
	virtual UBOOL NeedsTick();
};

#endif // !INCLUDED_GEARGAME_PAWN_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AGearPawn,-1,execSetMeshTranslationOffset);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetCameraNoRenderCylinder);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execCanFireWeapon);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsAKidnapper);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsAHostage);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDBNO);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execTickKnockDownMotorStrength);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execPlayQueuedSpeakLine);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execShouldFilterOutSpeech);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execShouldSuppressSubtitlesForQueuedSpeakLine);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execSpeakLine);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsFacingOther);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetViewRotation);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetWeaponHandPosition);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetRightHandSocketName);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execMAT_FinishAnimControl);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execMAT_SetAnimWeights);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execMAT_SetAnimPosition);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execMAT_BeginAnimControl);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsReloadingWeapon);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetEarlyAnimEndNotify);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetAnimEndNotify);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetMirrorOptions);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetRootBoneAxisOptions);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_ScalePlayRate);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetPlayRate);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_GetPlayRate);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_GetTimeLeft);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetPosition);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_Override);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_StopAll);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SetPlayingFlag);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_Stop);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_SeqNodeBelongsTo);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_HasAnyWeight);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_IsPlaying);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_PlayByDuration);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execBS_Play);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execSetCoverInfoFromSlotInfo);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingMove2IdleTransition);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execPickClosestCoverSlot);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsAtCoverEdge);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsEvading);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execCanPerformMantleDown);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execFitCollision);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsSpecialMeleeVictim);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingSpecialMeleeAttack);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingMeleeHoldSpecialMove);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingASpecialMove);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingSpecialMove);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsPoppingUp);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsLeaning);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execReduceConstraintLimits);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingDeathAnimSpecialMove);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetResultingStoppingPower);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsProtectedByCover);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoingLeaningTo360Transition);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsDoing360ToLeaningTransition);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execSimulate360Aiming);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execUpdateAimOffset);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execUpdateMeshBoneControllersNative);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execAimInterpTo);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execUpdateAutomaticHeadTracking);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetStreamingInfo);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetCoverInfo);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execFillCoverPosInfo);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execValidatePotentialCover);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execFindCoverFromLocAndDir);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execUnclaimCover);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execClaimCover);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetCombatZoneForNav);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGuessAtCover);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsInCover);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetMaxSpeedModifier);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execIsValidEnemyTargetFor);
AUTOGENERATE_FUNCTION(AGearPawn,-1,execGetBestAnchor);
AUTOGENERATE_FUNCTION(AGearPawn_Infantry,-1,execInfantryStuckInWorld);
AUTOGENERATE_FUNCTION(AGearPawn_Infantry,-1,execMatchNameArray);
AUTOGENERATE_FUNCTION(AGearPawn_LocustBrumakBase,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearPawn_LocustBrumakHelper_Base,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(AGearPawn_LocustKantusBase,-1,execCanFireWeapon);
AUTOGENERATE_FUNCTION(AGearPawn_LocustKantusBase,-1,execIsThrowingOffHandGrenade);
AUTOGENERATE_FUNCTION(AGearPawn_LocustNemacystBase,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(AGearPawn_LocustTickerBase,-1,execIsValidTargetFor);
AUTOGENERATE_FUNCTION(AGearPawn_RockWormBase,-1,execAddSlotToSlotSpecs);
AUTOGENERATE_FUNCTION(AGearPawn_RockWormBase,-1,execGetParentAttachPos);
AUTOGENERATE_FUNCTION(AGearPawn_RockWormBase,-1,execUpdateBlockedReachSpecs);
AUTOGENERATE_FUNCTION(AGearPawn_SecurityBotFlyingBase,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearpawn_SecurityBotStationaryBase,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(AGearpawn_SecurityBotStationaryBase,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearpawn_SecurityBotStationaryBase,-1,execCanDeploy);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GEARGAME_PAWN_NATIVE_DEFS
#define GEARGAME_PAWN_NATIVE_DEFS

DECLARE_NATIVE_TYPE(GearGame,AGearPawn);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_CarryCrate_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_COGDom);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_COGGear);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_COGMarcus);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_Infantry);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustBrumakBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustBrumakHelper_Base);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustKantusBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustLeviathanBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustNemacystBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustSkorgeBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustTickerBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_LocustWretchBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_RockWormBase);
DECLARE_NATIVE_TYPE(GearGame,AGearPawn_SecurityBotFlyingBase);
DECLARE_NATIVE_TYPE(GearGame,AGearpawn_SecurityBotStationaryBase);

#define AUTO_INITIALIZE_REGISTRANTS_GEARGAME_PAWN \
	AGearPawn::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawnNative; \
	AGearPawn_CarryCrate_Base::StaticClass(); \
	AGearPawn_COGDom::StaticClass(); \
	AGearPawn_COGGear::StaticClass(); \
	AGearPawn_COGMarcus::StaticClass(); \
	AGearPawn_Infantry::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_InfantryNative; \
	AGearPawn_LocustBase::StaticClass(); \
	AGearPawn_LocustBrumakBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_LocustBrumakBaseNative; \
	AGearPawn_LocustBrumakHelper_Base::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_LocustBrumakHelper_BaseNative; \
	AGearPawn_LocustKantusBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_LocustKantusBaseNative; \
	AGearPawn_LocustLeviathanBase::StaticClass(); \
	AGearPawn_LocustNemacystBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_LocustNemacystBaseNative; \
	AGearPawn_LocustSkorgeBase::StaticClass(); \
	AGearPawn_LocustTickerBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_LocustTickerBaseNative; \
	AGearPawn_LocustWretchBase::StaticClass(); \
	AGearPawn_RockWormBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_RockWormBaseNative; \
	AGearPawn_SecurityBotFlyingBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearPawn_SecurityBotFlyingBaseNative; \
	AGearpawn_SecurityBotStationaryBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearpawn_SecurityBotStationaryBaseNative; \

#endif // GEARGAME_PAWN_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AGearPawn) GGearGameAGearPawnNatives[] = 
{ 
	MAP_NATIVE(AGearPawn,execSetMeshTranslationOffset)
	MAP_NATIVE(AGearPawn,execGetCameraNoRenderCylinder)
	MAP_NATIVE(AGearPawn,execCanFireWeapon)
	MAP_NATIVE(AGearPawn,execIsAKidnapper)
	MAP_NATIVE(AGearPawn,execIsAHostage)
	MAP_NATIVE(AGearPawn,execIsDBNO)
	MAP_NATIVE(AGearPawn,execTickKnockDownMotorStrength)
	MAP_NATIVE(AGearPawn,execPlayQueuedSpeakLine)
	MAP_NATIVE(AGearPawn,execShouldFilterOutSpeech)
	MAP_NATIVE(AGearPawn,execShouldSuppressSubtitlesForQueuedSpeakLine)
	MAP_NATIVE(AGearPawn,execSpeakLine)
	MAP_NATIVE(AGearPawn,execIsFacingOther)
	MAP_NATIVE(AGearPawn,execGetViewRotation)
	MAP_NATIVE(AGearPawn,execGetWeaponHandPosition)
	MAP_NATIVE(AGearPawn,execGetRightHandSocketName)
	MAP_NATIVE(AGearPawn,execMAT_FinishAnimControl)
	MAP_NATIVE(AGearPawn,execMAT_SetAnimWeights)
	MAP_NATIVE(AGearPawn,execMAT_SetAnimPosition)
	MAP_NATIVE(AGearPawn,execMAT_BeginAnimControl)
	MAP_NATIVE(AGearPawn,execIsReloadingWeapon)
	MAP_NATIVE(AGearPawn,execBS_SetEarlyAnimEndNotify)
	MAP_NATIVE(AGearPawn,execBS_SetAnimEndNotify)
	MAP_NATIVE(AGearPawn,execBS_SetMirrorOptions)
	MAP_NATIVE(AGearPawn,execBS_SetRootBoneAxisOptions)
	MAP_NATIVE(AGearPawn,execBS_ScalePlayRate)
	MAP_NATIVE(AGearPawn,execBS_SetPlayRate)
	MAP_NATIVE(AGearPawn,execBS_GetPlayRate)
	MAP_NATIVE(AGearPawn,execBS_GetTimeLeft)
	MAP_NATIVE(AGearPawn,execBS_SetPosition)
	MAP_NATIVE(AGearPawn,execBS_Override)
	MAP_NATIVE(AGearPawn,execBS_StopAll)
	MAP_NATIVE(AGearPawn,execBS_SetPlayingFlag)
	MAP_NATIVE(AGearPawn,execBS_Stop)
	MAP_NATIVE(AGearPawn,execBS_SeqNodeBelongsTo)
	MAP_NATIVE(AGearPawn,execBS_HasAnyWeight)
	MAP_NATIVE(AGearPawn,execBS_IsPlaying)
	MAP_NATIVE(AGearPawn,execBS_PlayByDuration)
	MAP_NATIVE(AGearPawn,execBS_Play)
	MAP_NATIVE(AGearPawn,execSetCoverInfoFromSlotInfo)
	MAP_NATIVE(AGearPawn,execGetPhysicalFireStartLoc)
	MAP_NATIVE(AGearPawn,execIsDoingMove2IdleTransition)
	MAP_NATIVE(AGearPawn,execPickClosestCoverSlot)
	MAP_NATIVE(AGearPawn,execIsAtCoverEdge)
	MAP_NATIVE(AGearPawn,execIsEvading)
	MAP_NATIVE(AGearPawn,execCanPerformMantleDown)
	MAP_NATIVE(AGearPawn,execFitCollision)
	MAP_NATIVE(AGearPawn,execIsSpecialMeleeVictim)
	MAP_NATIVE(AGearPawn,execIsDoingSpecialMeleeAttack)
	MAP_NATIVE(AGearPawn,execIsDoingMeleeHoldSpecialMove)
	MAP_NATIVE(AGearPawn,execIsDoingASpecialMove)
	MAP_NATIVE(AGearPawn,execIsDoingSpecialMove)
	MAP_NATIVE(AGearPawn,execGetPawnViewLocation)
	MAP_NATIVE(AGearPawn,execIsPoppingUp)
	MAP_NATIVE(AGearPawn,execIsLeaning)
	MAP_NATIVE(AGearPawn,execReduceConstraintLimits)
	MAP_NATIVE(AGearPawn,execIsDoingDeathAnimSpecialMove)
	MAP_NATIVE(AGearPawn,execGetResultingStoppingPower)
	MAP_NATIVE(AGearPawn,execIsProtectedByCover)
	MAP_NATIVE(AGearPawn,execIsDoingLeaningTo360Transition)
	MAP_NATIVE(AGearPawn,execIsDoing360ToLeaningTransition)
	MAP_NATIVE(AGearPawn,execSimulate360Aiming)
	MAP_NATIVE(AGearPawn,execUpdateAimOffset)
	MAP_NATIVE(AGearPawn,execUpdateMeshBoneControllersNative)
	MAP_NATIVE(AGearPawn,execAimInterpTo)
	MAP_NATIVE(AGearPawn,execUpdateAutomaticHeadTracking)
	MAP_NATIVE(AGearPawn,execGetStreamingInfo)
	MAP_NATIVE(AGearPawn,execGetCoverInfo)
	MAP_NATIVE(AGearPawn,execFillCoverPosInfo)
	MAP_NATIVE(AGearPawn,execValidatePotentialCover)
	MAP_NATIVE(AGearPawn,execFindCoverFromLocAndDir)
	MAP_NATIVE(AGearPawn,execUnclaimCover)
	MAP_NATIVE(AGearPawn,execClaimCover)
	MAP_NATIVE(AGearPawn,execGetCombatZoneForNav)
	MAP_NATIVE(AGearPawn,execGuessAtCover)
	MAP_NATIVE(AGearPawn,execIsInCover)
	MAP_NATIVE(AGearPawn,execGetMaxSpeedModifier)
	MAP_NATIVE(AGearPawn,execIsValidEnemyTargetFor)
	MAP_NATIVE(AGearPawn,execGetBestAnchor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn);

NATIVE_INFO(AGearPawn_Infantry) GGearGameAGearPawn_InfantryNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_Infantry,execInfantryStuckInWorld)
	MAP_NATIVE(AGearPawn_Infantry,execMatchNameArray)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_Infantry);

NATIVE_INFO(AGearPawn_LocustBrumakBase) GGearGameAGearPawn_LocustBrumakBaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_LocustBrumakBase,execGetPhysicalFireStartLoc)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_LocustBrumakBase);

NATIVE_INFO(AGearPawn_LocustBrumakHelper_Base) GGearGameAGearPawn_LocustBrumakHelper_BaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_LocustBrumakHelper_Base,execGetPawnViewLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_LocustBrumakHelper_Base);

NATIVE_INFO(AGearPawn_LocustKantusBase) GGearGameAGearPawn_LocustKantusBaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_LocustKantusBase,execCanFireWeapon)
	MAP_NATIVE(AGearPawn_LocustKantusBase,execIsThrowingOffHandGrenade)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_LocustKantusBase);

NATIVE_INFO(AGearPawn_LocustNemacystBase) GGearGameAGearPawn_LocustNemacystBaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_LocustNemacystBase,execGetPawnViewLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_LocustNemacystBase);

NATIVE_INFO(AGearPawn_LocustTickerBase) GGearGameAGearPawn_LocustTickerBaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_LocustTickerBase,execIsValidTargetFor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_LocustTickerBase);

NATIVE_INFO(AGearPawn_RockWormBase) GGearGameAGearPawn_RockWormBaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_RockWormBase,execAddSlotToSlotSpecs)
	MAP_NATIVE(AGearPawn_RockWormBase,execGetParentAttachPos)
	MAP_NATIVE(AGearPawn_RockWormBase,execUpdateBlockedReachSpecs)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_RockWormBase);

NATIVE_INFO(AGearPawn_SecurityBotFlyingBase) GGearGameAGearPawn_SecurityBotFlyingBaseNatives[] = 
{ 
	MAP_NATIVE(AGearPawn_SecurityBotFlyingBase,execGetPhysicalFireStartLoc)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearPawn_SecurityBotFlyingBase);

NATIVE_INFO(AGearpawn_SecurityBotStationaryBase) GGearGameAGearpawn_SecurityBotStationaryBaseNatives[] = 
{ 
	MAP_NATIVE(AGearpawn_SecurityBotStationaryBase,execGetPawnViewLocation)
	MAP_NATIVE(AGearpawn_SecurityBotStationaryBase,execGetPhysicalFireStartLoc)
	MAP_NATIVE(AGearpawn_SecurityBotStationaryBase,execCanDeploy)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearpawn_SecurityBotStationaryBase);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn,ReplicationRootBodyPos)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn,BaseEncroachHitLocation)
VERIFY_CLASS_SIZE_NODIE(AGearPawn)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_CarryCrate_Base,MarcusPawn)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_CarryCrate_Base,CrateMeshComponent)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_CarryCrate_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_COGDom,DomAIHitPoints)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_COGDom,RatioOfDefaultToSimulatedHP)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_COGDom)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_COGGear)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_COGMarcus)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_Infantry,HelmetType)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_Infantry,BS_LastIdleBreakAnim)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_Infantry)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustBrumakBase,Driver)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustBrumakBase,CentaurRepulsionStrength)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustBrumakBase)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustBrumakHelper_Base)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustKantusBase,ThrowCount)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustKantusBase,MinionClasses)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustKantusBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustLeviathanBase,Tentacles)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustLeviathanBase,PSC_FaceTentacleDrip)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustLeviathanBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustNemacystBase,PlaySwoopAnimCount)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustNemacystBase,PawnViewSocketName)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustNemacystBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustSkorgeBase,CompleteStrafeAttackTime)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustSkorgeBase,AC_StaffTwirl)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustSkorgeBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustTickerBase,TimeToStayFlippedOverMin)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustTickerBase,KantusSpawnParticleSystem)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustTickerBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustWretchBase,LeftForeArmBoneName)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_LocustWretchBase,ReplicatedFloor)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_LocustWretchBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_RockWormBase,TailSegmentList)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_RockWormBase,Scout)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_RockWormBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_SecurityBotFlyingBase,WobbleMagMax)
VERIFY_CLASS_OFFSET_NODIE(A,GearPawn_SecurityBotFlyingBase,PSC_Damage)
VERIFY_CLASS_SIZE_NODIE(AGearPawn_SecurityBotFlyingBase)
VERIFY_CLASS_OFFSET_NODIE(A,Gearpawn_SecurityBotStationaryBase,PatrolArcDegrees)
VERIFY_CLASS_OFFSET_NODIE(A,Gearpawn_SecurityBotStationaryBase,TimeNotRenderedUntilLODFreeze)
VERIFY_CLASS_SIZE_NODIE(AGearpawn_SecurityBotStationaryBase)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
