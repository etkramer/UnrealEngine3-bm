/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GEARGAME_WEAPON_ENUMS
#define INCLUDED_GEARGAME_WEAPON_ENUMS 1

enum EWeaponType
{
    WT_Normal               =0,
    WT_Holster              =1,
    WT_Item                 =2,
    WT_Heavy                =3,
    WT_MAX                  =4,
};
enum EWeaponAnimType
{
    EWAT_AssaultRifle       =0,
    EWAT_Shotgun            =1,
    EWAT_SniperRifle        =2,
    EWAT_Pistol             =3,
    EWAT_MAX                =4,
};

#endif // !INCLUDED_GEARGAME_WEAPON_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName GEARGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AttachMuzzleEffectsComponents)
AUTOGENERATE_NAME(DummyFire)
AUTOGENERATE_NAME(EmulateProjectileExplosion)
AUTOGENERATE_NAME(Explode)
AUTOGENERATE_NAME(GetDefaultHandSocketName)
AUTOGENERATE_NAME(GetDesiredAimPoint)
AUTOGENERATE_NAME(GetHoseOffset)
AUTOGENERATE_NAME(GetMountedCameraOffsets)
AUTOGENERATE_NAME(IsAimCorrect)
AUTOGENERATE_NAME(IsMounted)
AUTOGENERATE_NAME(LocalActiveReloadSuccess)
AUTOGENERATE_NAME(LocalFailedActiveReload)
AUTOGENERATE_NAME(ProjectileFireSimple)
AUTOGENERATE_NAME(ShouldReloadingPreventTargeting)
AUTOGENERATE_NAME(UpdateBarrelHeatMaterial)
AUTOGENERATE_NAME(WeaponFired)
AUTOGENERATE_NAME(WeaponStoppedFiring)

#ifndef NAMES_ONLY

#ifndef INCLUDED_GEARGAME_WEAPON_CLASSES
#define INCLUDED_GEARGAME_WEAPON_CLASSES 1

class AGearDroppedPickup_Shield : public AGearDroppedPickup
{
public:
    //## BEGIN PROPS GearDroppedPickup_Shield
    BITFIELD bDeployed:1;
    BITFIELD bKicked:1;
    class ACoverLink_Spawnable* DeployedLink_Rear;
    class ACoverLink_Spawnable* DeployedLink_Forward;
    class USkeletalMeshComponent* ShieldMeshComp;
    //## END PROPS GearDroppedPickup_Shield

    DECLARE_CLASS(AGearDroppedPickup_Shield,AGearDroppedPickup,0,GearGame)
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
};

struct FFlameBoneInfo
{
    FName BoneName;
    INT BoneIndex;
    FLOAT EffectScale;
    class UParticleSystemComponent* BonePSC0;
    class UParticleSystemComponent* BonePSC1;
    FLOAT SeedChainLoc;
    FVector LastLoc;
    FLOAT ParticleActivationDelay;

    /** Constructors */
    FFlameBoneInfo() {}
    FFlameBoneInfo(EEventParm)
    {
        appMemzero(this, sizeof(FFlameBoneInfo));
    }
};

struct FFlameSprayLight
{
    class UPointLightComponent* Light;
    INT BoneChainIndex;
    FLOAT FlickerIntensity;
    FLOAT FlickerInterpSpeed;
    FLOAT LastLightBrightness;

    /** Constructors */
    FFlameSprayLight() {}
    FFlameSprayLight(EEventParm)
    {
        appMemzero(this, sizeof(FFlameSprayLight));
    }
};

struct FFlameMeshContact
{
    INT BoneChainIndex;
    class AActor* Actor;
    FVector ContactPosition;
    FVector ContactNormal;
    class UPhysicalMaterial* PhysicalMaterial;

    /** Constructors */
    FFlameMeshContact() {}
    FFlameMeshContact(EEventParm)
    {
        appMemzero(this, sizeof(FFlameMeshContact));
    }
};

struct FFlameSpraySeed
{
    FVector Location;
    FVector Velocity;
    FLOAT Age;

    /** Constructors */
    FFlameSpraySeed() {}
    FFlameSpraySeed(EEventParm)
    {
        appMemzero(this, sizeof(FFlameSpraySeed));
    }
};

class AFlameThrowerSprayBase : public AActor
{
public:
    //## BEGIN PROPS FlameThrowerSprayBase
    FLOAT CurrentAge;
    BITFIELD bSkeletonHasBeenUpdated:1;
    BITFIELD bDoPerBoneFireFX:1;
    BITFIELD bSplashActive:1;
    BITFIELD bFlameMeshCollidedThisTick:1;
    BITFIELD bFlameMeshCollidedLastTick:1;
    BITFIELD bLeaveStickyFire:1;
    BITFIELD bDebugShowBones:1;
    BITFIELD bDebugShowContacts:1;
    BITFIELD bDebugShowCollision:1;
    BITFIELD bDebugShowSplashRadius:1;
    BITFIELD bDebugForceNonPlayerParticles:1;
    BITFIELD bTestCollideComplex:1;
    BITFIELD bDebugShowSeeds:1;
    BITFIELD bWaitingToDestroy:1;
    BITFIELD bDetached:1;
    class USkeletalMeshComponent* SkeletalSprayMesh;
    class UGearSkelCtrl_Prune* PruneSkelControl;
    FName PruneSkelControlName;
    class UGearSkelCtrl_FlamethrowerScaling* ScalingSkelControl;
    FVector2D GravityScaleRange;
    FLOAT GravityScaleInTime;
    TArrayNoInit<struct FFlameBoneInfo> BoneChain;
    FLOAT PerBoneFireFXGlobalScale;
    FVector2D PerBoneFireFXActivationDelayRange;
    FLOAT PerBoneFireFXActivationDelayTimer;
    FLOAT PerBoneFireFXActivationDist;
    class UParticleSystem* SplashGlancingEffect;
    class UParticleSystem* SplashDirectEffect;
    class UParticleSystem* SplashPawnEffect;
    class UParticleSystemComponent* CurrentSplashEffect;
    class UParticleSystemComponent* SplashGlancingPSC;
    class UParticleSystemComponent* SplashDirectPSC;
    class UParticleSystemComponent* SplashPawnPSC;
    class UParticleSystemComponent* SplashMaterialBasedPSC;
    class UAudioComponent* SplashPawnAC;
    class UAudioComponent* SplashDirectAC;
    class UAudioComponent* SplashGlancingAC;
    class UAudioComponent* SplashMaterialBasedAC;
    class UAudioComponent* CurrentSplashAC;
    FLOAT SplashGlancingDotLimit;
    INT LastBoneChainIndexThatCanSpawnSplashEffects;
    FLOAT SplashRotInterpSpeed;
    FLOAT SplashLocInterpSpeed;
    FRotator LastSplashRot;
    FVector LastSplashLoc;
    class UParticleSystemComponent* PSC_OwnerGlow;
    INT OwnerGlowBoneChainIndex;
    FLOAT OwnerGlowScaleInTime;
    TArrayNoInit<struct FFlameSprayLight> FlameLights;
    class UMaterialInstanceConstant* MIC_FlameMat0;
    class UMaterialInstanceConstant* MIC_FlameMat1;
    class UMaterialInstanceConstant* MIC_FlameMat2;
    FVector2D MaterialHeatRange;
    FLOAT MaterialHeatRampTime;
    FLOAT MatFadePow;
    FLOAT MaterialFadeOutTime;
    FLOAT MaterialCurrentFadeVal;
    class UParticleSystemComponent* StartFirePSC;
    FVector2D FlameDamagePerSec;
    FVector2D FlameDamagePerSecAR;
    FVector2D FlameDamageScaleDistRange;
    class UClass* MyDamageType;
    FLOAT SplashDamageRadius;
    FLOAT SplashDamagePerSecond;
    FLOAT SplashDamagePerSecondAR;
    FLOAT SplashDamageFalloffExponent;
    FLOAT MomentumScale;
    class USoundCue* FireSprayStartSound;
    class USoundCue* FireSprayStopSound;
    class USoundCue* FireSprayLoopSound;
    class UAudioComponent* AC_FireSprayLoop;
    FVector2D FireAudioAdj_RotVelRange;
    FVector2D FireAudioAdj_PitchRange;
    FVector2D FireAudioAdj_VolumeRange;
    FLOAT SprayAudioAdjInterpSpeed;
    FLOAT CurrentSprayPitchMult;
    FLOAT CurrentSprayVolumeMult;
    FRotator LastRotation;
    FLOAT RotationSpeed;
    struct FFlameMeshContact HighestFlameMeshContactThisTick;
    FLOAT bFlameMeshCollisionDuration;
    class UGearAnim_BlendList* AnimBlendNode;
    class UAnimNodeSequence* StartFireSeqNode;
    class UAnimNodeSequence* StartARFireSeqNode;
    class UAnimNodeSequence* EndFireSeqNode;
    FLOAT StickyFireOwnerSafeRadius;
    FLOAT StickyFireMinTimeBetweenSpawns;
    FLOAT StickyFireLastSpawnTime;
    FLOAT StickyFireInitialDelay;
    FVector StickyFireTestLocation;
    FLOAT StickyFireTestLocInterpSpeed;
    FLOAT StickyFireTestLocThreshold;
    TArrayNoInit<struct FFlameSpraySeed> Seeds;
    FLOAT SeedSprayVel;
    FLOAT SeedDecel;
    FLOAT SeedSprayVelAR;
    FLOAT SeedDecelAR;
    FLOAT SeedMaxAge;
    FLOAT SeedMinChainLength;
    FLOAT SeedSimFreq;
    FLOAT SeedSimTimeRemaining;
    FLOAT SeedWarmupTime;
    class AGearPawn* OwningGearPawn;
    //## END PROPS FlameThrowerSprayBase

    void UpdateFlameSeeds(FLOAT DeltaTime);
    virtual void DestroyIfAllEmittersFinished();
    void DebugRenderBones();
    void DoFlameCollisionDetection(FLOAT DeltaTime);
    virtual void ParticleSystemCleanUp();
    DECLARE_FUNCTION(execUpdateFlameSeeds)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateFlameSeeds(DeltaTime);
    }
    DECLARE_FUNCTION(execDestroyIfAllEmittersFinished)
    {
        P_FINISH;
        DestroyIfAllEmittersFinished();
    }
    DECLARE_FUNCTION(execDebugRenderBones)
    {
        P_FINISH;
        DebugRenderBones();
    }
    DECLARE_FUNCTION(execDoFlameCollisionDetection)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        DoFlameCollisionDetection(DeltaTime);
    }
    DECLARE_FUNCTION(execParticleSystemCleanUp)
    {
        P_FINISH;
        ParticleSystemCleanUp();
    }
    DECLARE_ABSTRACT_CLASS(AFlameThrowerSprayBase,AActor,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

private:
	void GetSeedChainLoc(FVector& OutLoc, FLOAT SeedCoord);

public:
	virtual FLOAT GetGravityZ()
	{
		// interpolate using the range
		FLOAT const Pct = Min<FLOAT>((CurrentAge / GravityScaleInTime), 1.f);
		return Lerp<FLOAT>(GravityScaleRange.X, GravityScaleRange.Y, Pct) * GWorld->GetGravityZ();
	}
};

struct GearExplosionActor_eventExplode_Parms
{
    class UGearExplosion* NewExplosionTemplate;
    GearExplosionActor_eventExplode_Parms(EEventParm)
    {
    }
};
class AGearExplosionActor : public AActor
{
public:
    //## BEGIN PROPS GearExplosionActor
    BITFIELD bHasExploded:1;
    BITFIELD bActiveReloadBonusActive:1;
    class UPointLightComponent* ExplosionLight;
    FLOAT LightFadeTime;
    FLOAT LightInitialBrightness;
    class UGearExplosion* ExplosionTemplate;
    class URB_RadialImpulseComponent* RadialImpulseComponent;
    class AController* InstigatorController;
    class AActor* HitActorFromPhysMaterialTrace;
    FVector HitLocationFromPhysMaterialTrace;
    //## END PROPS GearExplosionActor

    void eventExplode(class UGearExplosion* NewExplosionTemplate)
    {
        GearExplosionActor_eventExplode_Parms Parms(EC_EventParm);
        Parms.NewExplosionTemplate=NewExplosionTemplate;
        ProcessEvent(FindFunctionChecked(GEARGAME_Explode),&Parms);
    }
    DECLARE_CLASS(AGearExplosionActor,AActor,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

    NO_DEFAULT_CONSTRUCTOR(AGearExplosionActor)
};

struct GearExplosionActorReplicated_eventEmulateProjectileExplosion_Parms
{
    class UClass* ProjToEmulate;
    GearExplosionActorReplicated_eventEmulateProjectileExplosion_Parms(EEventParm)
    {
    }
};
class AGearExplosionActorReplicated : public AGearExplosionActor
{
public:
    //## BEGIN PROPS GearExplosionActorReplicated
    class UGearExplosion* ExploTemplateRef;
    class UClass* ProjExploToEmulate;
    //## END PROPS GearExplosionActorReplicated

    void eventEmulateProjectileExplosion(class UClass* ProjToEmulate)
    {
        GearExplosionActorReplicated_eventEmulateProjectileExplosion_Parms Parms(EC_EventParm);
        Parms.ProjToEmulate=ProjToEmulate;
        ProcessEvent(FindFunctionChecked(GEARGAME_EmulateProjectileExplosion),&Parms);
    }
    DECLARE_CLASS(AGearExplosionActorReplicated,AGearExplosionActor,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearExplosionActorReplicated)
};

class AGearDynamicFogVolume_Spherical : public AFogVolumeSphericalDensityInfo
{
public:
    //## BEGIN PROPS GearDynamicFogVolume_Spherical
    class AFogVolumeSphericalDensityInfo* FogVolumeArchetype;
    class UClass* DamageTypeToUseForPerLevelMaterialEffects;
    FLOAT DurationForMITV;
    //## END PROPS GearDynamicFogVolume_Spherical

    DECLARE_ABSTRACT_CLASS(AGearDynamicFogVolume_Spherical,AFogVolumeSphericalDensityInfo,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearDynamicFogVolume_Spherical)
};

class AGearFogVolume_Spawnable : public AGearDynamicFogVolume_Spherical
{
public:
    //## BEGIN PROPS GearFogVolume_Spawnable
    class UStaticMeshComponent* VisBlocker;
    FLOAT VisBlockerScale;
    FLOAT FadeInTime;
    FLOAT FadeOutTime;
    FLOAT CurrentFogOpacity;
    BITFIELD bFadingIn:1;
    BITFIELD bFadingOut:1;
    //## END PROPS GearFogVolume_Spawnable

    DECLARE_CLASS(AGearFogVolume_Spawnable,AGearDynamicFogVolume_Spherical,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

    NO_DEFAULT_CONSTRUCTOR(AGearFogVolume_Spawnable)
};

class AGearFogVolume_SmokeGrenade : public AGearFogVolume_Spawnable
{
public:
    //## BEGIN PROPS GearFogVolume_SmokeGrenade
    //## END PROPS GearFogVolume_SmokeGrenade

    DECLARE_CLASS(AGearFogVolume_SmokeGrenade,AGearFogVolume_Spawnable,0|CLASS_Config,GearGame)
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
};

class AGearShield : public AInventory
{
public:
    //## BEGIN PROPS GearShield
    BYTE WeaponID;
    class USkeletalMeshComponent* Mesh;
    class USkeletalMeshComponent* DeployedMesh;
    FLOAT DropAngularVelocity;
    FCanvasIcon PickupIcon;
    FName ExpandAnimName;
    FName RetractAnimName;
    BITFIELD bExpanded:1;
    class USoundCue* ShieldExpandSound;
    class USoundCue* ShieldRetractSound;
    class USoundCue* ShieldStickInGroundSound;
    class USoundCue* ShieldRemoveFromGroundSound;
    class USoundCue* ShieldDropSound;
    class UMaterialInstanceConstant* MIC_WeaponSkin;
    FLinearColor LC_EmisDefaultCOG;
    FLinearColor LC_EmisDefaultLocust;
    //## END PROPS GearShield

    DECLARE_ABSTRACT_CLASS(AGearShield,AInventory,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

    NO_DEFAULT_CONSTRUCTOR(AGearShield)
};

struct FTWeaponParam
{
    TArrayNoInit<FLOAT> Value;
    FName Name;

    /** Constructors */
    FTWeaponParam() {}
    FTWeaponParam(EEventParm)
    {
        appMemzero(this, sizeof(FTWeaponParam));
    }
};

struct FAmmoDrawData
{
    INT DisplayCount;
    FCanvasIcon AmmoIcon;
    FLOAT ULPerAmmo;

    /** Constructors */
    FAmmoDrawData() {}
    FAmmoDrawData(EEventParm)
    {
        appMemzero(this, sizeof(FAmmoDrawData));
    }
};

#define UCONST_STATS_LEVEL8 0x80
#define UCONST_ACTIVE_RELOAD_TIERS 3
#define UCONST_FIREMODE_ACTIVERELOADSUPERSUCCESS 11
#define UCONST_FIREMODE_ACTIVERELOADSUCCESS 10
#define UCONST_FIREMODE_FAILEDACTIVERELOAD 9
#define UCONST_FIREMODE_STOPGRENADESPIN 8
#define UCONST_FIREMODE_GRENADESPIN 7
#define UCONST_FIREMODE_FAILED 6
#define UCONST_FIREMODE_CHARGE 5
#define UCONST_SHOTGUN_COCK_FIREMODE 4
#define UCONST_ALTFIRE_FIREMODE 3
#define UCONST_MELEE_ATTACK_FIREMODE 2
#define UCONST_RELOAD_FIREMODE 1
#define UCONST_DEFAULT_FIREMODE 0

struct GearWeapon_eventShouldReloadingPreventTargeting_Parms
{
    UBOOL ReturnValue;
    GearWeapon_eventShouldReloadingPreventTargeting_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventUpdateBarrelHeatMaterial_Parms
{
    GearWeapon_eventUpdateBarrelHeatMaterial_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventProjectileFireSimple_Parms
{
    FLOAT AimErrorDeg;
    class AProjectile* ReturnValue;
    GearWeapon_eventProjectileFireSimple_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventAttachMuzzleEffectsComponents_Parms
{
    class USkeletalMeshComponent* SkelMesh;
    GearWeapon_eventAttachMuzzleEffectsComponents_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventGetDefaultHandSocketName_Parms
{
    class AGearPawn* P;
    FName ReturnValue;
    GearWeapon_eventGetDefaultHandSocketName_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventLocalActiveReloadSuccess_Parms
{
    UBOOL bDidSuperSweetReload;
    GearWeapon_eventLocalActiveReloadSuccess_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventLocalFailedActiveReload_Parms
{
    UBOOL bFailedActiveReload;
    GearWeapon_eventLocalFailedActiveReload_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventGetHoseOffset_Parms
{
    FRotator ReturnValue;
    GearWeapon_eventGetHoseOffset_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventDummyFire_Parms
{
    BYTE FireModeNum;
    FVector TargetLoc;
    class AActor* AttachedTo;
    FLOAT AimErrorDeg;
    class AActor* TargetActor;
    GearWeapon_eventDummyFire_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventWeaponStoppedFiring_Parms
{
    BYTE FiringMode;
    GearWeapon_eventWeaponStoppedFiring_Parms(EEventParm)
    {
    }
};
struct GearWeapon_eventWeaponFired_Parms
{
    BYTE FiringMode;
    FVector HitLocation;
    GearWeapon_eventWeaponFired_Parms(EEventParm)
    {
    }
};
class AGearWeapon : public AWeapon
{
public:
    //## BEGIN PROPS GearWeapon
    class AGearAI* GearAIController;
    BITFIELD bUniqueSpawn:1;
    BITFIELD bCanThrowActiveWeapon:1;
    BITFIELD bIgnoreDifficultyDamageScale:1;
    BITFIELD bInfiniteSpareAmmo:1;
    BITFIELD bForceWalkWhenTargeting:1;
    BITFIELD bPreventTargeting:1;
    BITFIELD bReloadingWeaponPreventsTargeting:1;
    BITFIELD bSlaveWeapon:1;
    BITFIELD bAltFireWeapon:1;
    BITFIELD bBlindFirable:1;
    BITFIELD bPlayDefaultBlindFireStance:1;
    BITFIELD bSupports360AimingInCover:1;
    BITFIELD bAllowsRoadieRunning:1;
    BITFIELD bAllowIdleStance:1;
    BITFIELD bAllowAimingStance:1;
    BITFIELD bAllowDownsightsStance:1;
    BITFIELD bNoAnimDelayFiring:1;
    BITFIELD bDisableLeftHandIK:1;
    BITFIELD bPlayIKRecoil:1;
    BITFIELD bAllowMeleeToFracture:1;
    BITFIELD bPlayFireCameraShake:1;
    BITFIELD bSuperSteadyCamWhileTargeting:1;
    BITFIELD bCanDisplayReloadTutorial:1;
    BITFIELD bWeaponCanBeReloaded:1;
    BITFIELD bLoopMuzzleFlashLight:1;
    BITFIELD bMuzFlashEmitterIsLooping:1;
    BITFIELD bActiveReloadAttempted:1;
    BITFIELD bActiveReloadTracerVisualEffectsActive:1;
    BITFIELD bOverrideDistanceForEnemyTrace:1;
    BITFIELD bUseMeleeHitTimer:1;
    BITFIELD bMeleeImpactNotifySemaphore:1;
    BITFIELD bSuppressMeleeAttackCameraBoneAnim:1;
    BITFIELD bDoMeleeAdhesion:1;
    BITFIELD bDoMeleeDamageShakes:1;
    BITFIELD bHitWallThisAttack:1;
    BITFIELD bIsSuppressive:1;
    BITFIELD bSniping:1;
    BITFIELD bCanNegateMeatShield:1;
    BITFIELD bIgnoresExecutionRules:1;
    BITFIELD bHose:1;
    BITFIELD bDebuggingShots:1;
    BITFIELD bCanSelectWithoutAmmo:1;
    BITFIELD bAutoSwitchWhenOutOfAmmo:1;
    BITFIELD bTemporaryHolster:1;
    BITFIELD bSwappable:1;
    BITFIELD bNoInteractionWhileEquipped:1;
    BITFIELD bDynamicMuzzleFlashes:1;
    BITFIELD bUseTargetingCamera:1;
    BITFIELD bSuppressMuzzleFlash:1;
    BITFIELD bSuppressTracers:1;
    BITFIELD bSuppressImpactFX:1;
    BITFIELD bSuppressAudio:1;
    BITFIELD bSuppressDamage:1;
    BITFIELD bDummyFireWeapon:1;
    BITFIELD bUsePreModCameraRotForAiming:1;
    BITFIELD bCanEquipWithShield:1;
    BITFIELD bAllowTracers:1;
    BITFIELD bClientSideInstantHit:1;
    BITFIELD bCanParryMelee:1;
    BITFIELD CQC_Long_bHolsterWeapon:1;
    BITFIELD bUseMuzzleLocForPhysicalFireStartLoc:1;
    BITFIELD bSupportsBarrelHeat:1;
    BYTE WeaponID GCC_BITFIELD_MAGIC;
    BYTE WeaponAnimType;
    BYTE PreviousFiringMode;
    BYTE WeaponType;
    BYTE CharacterSlot;
    BYTE TracerType;
    BYTE CQC_Long_EffortID;
    BYTE CQC_Quick_EffortID;
    class UGearPerMapColorConfig* GlobalDefaultColors;
    FLOAT Range_Melee;
    FLOAT Range_MeleeCharge;
    FLOAT Range_Short;
    FLOAT Range_Medium;
    FLOAT Range_Long;
    FVector2D MeleeAcquireDotFOV;
    FLOAT DamageMod_MeleeRange;
    FLOAT DamageMod_ShortRange;
    FLOAT DamageMod_MediumRange;
    FLOAT DamageMod_LongRange;
    FLOAT Base_AccScale_BlindFire;
    FVector2D AI_AccCone_Min;
    FVector2D AI_AccCone_Max;
    FLOAT AI_RateOfFire_Scale;
    FVector2D AI_BurstFireCount;
    FVector2D AI_BurstFireDelay;
    INT RemainingBurstFireCount;
    INT RemainingBurstsToFire;
    FVector2D AI_AimDelay;
    FVector2D AI_HoseInterpTimeRange;
    FLOAT AI_HoseInterpSetTime;
    FLOAT AI_HoseInterpFinishTime;
    FRotator AI_HoseDesiredOffset;
    FRotator AI_PreviousHoseOffset;
    FLOAT TargetingFOV;
    FLOAT AimingFOVAdjustment;
    class UGearAnim_Slot* CustomAnimNode;
    class UAnimTree* AnimTreeRootNode;
    FName WeaponFireAnim;
    FName WeaponReloadAnim;
    FName WeaponReloadAnimFail;
    FName WeaponReloadAnimSuccess;
    struct FScreenShakeStruct FireCameraShake;
    FLOAT FireCameraShakeScale;
    class UForceFeedbackWaveform* WeaponFireWaveForm;
    FLOAT ImpactRelevanceDistance;
    FLOAT DecalImpactRelevanceDistanceSkelMesh;
    class UParticleSystemComponent* PSC_ShellEject;
    class UParticleSystemComponent* PSC_ReloadBarrelSmoke;
    FLOAT WeaponDamage;
    FLOAT WeaponDamageAI;
    FLOAT WeaponMagSize;
    FLOAT WeaponMaxSpareAmmo;
    FLOAT WeaponRecoil;
    FVector2D WeaponAimError;
    FLOAT WeaponRateOfFire;
    INT MinBlindFireUpAimPitch;
    FRotator WeaponRecoilOffset;
    FLOAT RecoilInterpSpeed;
    FRotator AutoCorrectWeaponRecoilOffset;
    FLOAT RecoilAutoCorrectPct;
    FLOAT RecoilAutoCorrectSpeed;
    FLOAT RecoilAutoCorrectDelay;
    FLOAT RecoilAutoCorrectTime;
    struct FAmmoDrawData HUDDrawData;
    struct FAmmoDrawData HUDDrawDataSuper;
    FVector2D AmmoFromDrop;
    class UClass* DroppedWeaponClass;
    INT AmmoUsedCount;
    INT CriticalAmmoCount;
    INT SpareAmmoCount;
    INT InitialMagazines;
    FLOAT ReloadDuration;
    FLOAT ReloadStartTime;
    FName MuzzleSocketName;
    class UMeshComponent* MuzzleFlashMesh;
    class UPointLightComponent* MuzzleFlashLight;
    FLOAT MuzzleLightDuration;
    FLOAT MuzzleLightPulseFreq;
    FLOAT MuzzleLightPulseExp;
    FLOAT MuzzleLightPulseTime;
    FVector MuzzleLightOffsetFromCannon;
    class UParticleSystemComponent* MuzFlashEmitter;
    FLOAT TimeToHideMuzzleFlashPS;
    class UParticleSystem* MuzFlashParticleSystem;
    class UParticleSystem* MuzFlashParticleSystemActiveReload;
    class UParticleSystem* MuzSmokeParticleSystem;
    TArrayNoInit<class UAnimSet*> CustomAnimSets;
    TArrayNoInit<FName> AimOffsetProfileNames;
    struct FBodyStance HolsterShoulderLeft;
    struct FBodyStance HolsterShoulderRight;
    struct FBodyStance EquipShoulderLeft;
    struct FBodyStance EquipShoulderRight;
    struct FBodyStance BS_PawnWeaponReload;
    struct FBodyStance BS_PawnWeaponReloadSuccess;
    struct FBodyStance BS_PawnWeaponReloadFail;
    class USoundCue* FireSound_Player;
    class USoundCue* FireSound;
    class USoundCue* MeleeImpactSound;
    class USoundCue* FireNoAmmoSound;
    FLOAT NoAmmoFireSoundDelay;
    class USoundCue* WeaponWhipSound;
    FLOAT MinTimeBetweenBulletWhips;
    FLOAT BulletWhipChance;
    class USoundCue* WeaponReloadSound;
    class USoundCue* WeaponEquipSound;
    class USoundCue* WeaponDeEquipSound;
    class USoundCue* WeaponDropSound;
    FLOAT CrosshairExpandStrength;
    class UClass* AmmoTypeClass;
    FLOAT AR_TimeReloadButtonWasPressed;
    FLOAT AR_MagicBulletsTimeoutDuration;
    FLOAT AR_PreReactionWindowDuration;
    FLOAT AR_PossibleSuccessStartPoint;
    FLOAT AR_SuperSweetSpotDuration;
    FLOAT AR_SweetSpotDuration;
    FVector2D ActiveReload_DamageMultiplier;
    FVector2D ActiveReload_ExploRadiusMultiplier;
    FVector2D ActiveReload_RateOfFireMultiplier;
    INT ActiveReload_NumBonusShots;
    INT ActiveReload_NumShotsTaken;
    struct FTWeaponParam ActiveReload_SuperSweetSpotDurations;
    class UClass* ActiveReloadDamageType;
    class USoundCue* AR_FailSound;
    class USoundCue* AR_SuccessSound;
    class USoundCue* AR_SuperSuccessSound;
    FLOAT LastBulletStrongerPercent;
    FLOAT MaxFrictionDistance;
    FLOAT PeakFrictionDistance;
    FLOAT MinFrictionDistance;
    FVector2D FrictionMultiplierRange;
    FLOAT PeakFrictionRadiusScale;
    FLOAT PeakFrictionHeightScale;
    FVector FrictionTargetOffset;
    FLOAT MaxAdhesionTime;
    FLOAT MaxAdhesionDistance;
    FLOAT MaxAdhesionAimDistY;
    FLOAT MaxAdhesionAimDistZ;
    FVector2D AdhesionScaleRange;
    FLOAT MinAdhesionScaleAmount;
    FLOAT MinAdhesionTargetVelocity;
    FLOAT MinAdhesionPlayerVelocity;
    FLOAT MeleeAttackCoolDownInSeconds;
    FLOAT MeleeInitialImpactDelay;
    FLOAT MeleeImpactRetryDuration;
    FLOAT MeleeImpactCompleteTime;
    TArrayNoInit<struct FBodyStance> BS_MeleeAttack;
    TArrayNoInit<struct FCameraBoneAnimation> MeleeAttackCameraBoneAnims;
    FLOAT MeleeAttackRange;
    FVector MeleeTraceExtent;
    FLOAT MeleeAttackDamageMin;
    FLOAT MeleeAttackDamageMax;
    struct FScreenShakeStruct MeleeImpactCamShake;
    INT NumMeleeAttackAttempts;
    FLOAT TimeStartedSpecialMeleeAttack;
    FCanvasIcon WeaponIcon;
    INT IconXOffset;
    INT IconYOffset;
    FCanvasIcon AnnexWeaponIcon;
    class UTexture2D* CrosshairIcon;
    class UTexture2D* CrosshairIconSecondary;
    FVector DebugShotStartLoc;
    FRotator DebugShotAimRot;
    FLOAT AimAssistScale;
    FLOAT AimAssistScaleWhileTargeting;
    FLOAT ShowTracerDistance;
    FVector TracerScale;
    class UParticleSystem* TracerSmokeTrailEffect;
    class UParticleSystem* TracerSmokeTrailEffectAR;
    FLOAT TracerSmokeTrailFrequency;
    struct FRecoilDef Recoil_Hand;
    struct FRecoilDef Recoil_Spine;
    class USoundCue* NeedReloadNotifySound;
    INT NeedReloadNotifyThreshold;
    FName SocketAttachedTo;
    class UStaticMeshComponent* MagazineMesh;
    class AActor* DummyFireParent;
    FVector DummyFireTargetLoc;
    class AActor* DummyFireTargetActor;
    class UMaterialInstanceConstant* MIC_WeaponSkin;
    FLinearColor LC_EmisDefaultCOG;
    FLinearColor LC_EmisDefaultLocust;
    FLOAT WeaponDropAngularVelocity;
    class UClass* DamageTypeClassForUI;
    FLOAT ClientSideHitLeeway;
    FName CQC_Long_KillerAnim;
    FName CQC_Long_VictimAnim;
    TArrayNoInit<class UCameraAnim*> CQC_Long_CameraAnims;
    FLOAT CQC_Long_VictimDeathTime;
    FLOAT CQC_Long_VictimRotStartTime;
    FLOAT CQC_Long_VictimRotInterpSpeed;
    class UClass* CQC_Long_DamageType;
    FName CQC_Quick_KillerAnim;
    FLOAT CQC_Quick_VictimDeathTime;
    class UClass* CQC_Quick_DamageType;
    FLOAT CurrentBarrelHeat;
    FLOAT LastBarrelHeat;
    FLOAT GoalBarrelHeat;
    FLOAT MaxBarrelHeat;
    FLOAT BarrelHeatInterpSpeed;
    FLOAT BarrelHeatPerShot;
    FLOAT BarrelHeatCooldownTime;
    FName BarrelHeatMaterialParameterName;
    INT WeaponStatIndex;
    //## END PROPS GearWeapon

    virtual void GetMuzzleLocAndRot(FVector& Loc,FRotator& Rot);
    virtual FVector GetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm));
    virtual FVector GetMuzzleLoc();
    virtual void DetermineActiveReloadSuccessOrFailure();
    virtual void GetActiveReloadValues(FLOAT& ActiveReloadStartTime,FLOAT& PreReactionWindowDuration,FLOAT& SuperSweetSpotDuration,FLOAT& SweetSpotDuration);
    virtual void UpdateBarrelHeatMaterial();
    DECLARE_FUNCTION(execGetMuzzleLocAndRot)
    {
        P_GET_STRUCT_REF(FVector,Loc);
        P_GET_STRUCT_REF(FRotator,Rot);
        P_FINISH;
        GetMuzzleLocAndRot(Loc,Rot);
    }
    DECLARE_FUNCTION(execGetMuzzleLoc)
    {
        P_FINISH;
        *(FVector*)Result=GetMuzzleLoc();
    }
    DECLARE_FUNCTION(execDetermineActiveReloadSuccessOrFailure)
    {
        P_FINISH;
        DetermineActiveReloadSuccessOrFailure();
    }
    DECLARE_FUNCTION(execGetActiveReloadValues)
    {
        P_GET_FLOAT_REF(ActiveReloadStartTime);
        P_GET_FLOAT_REF(PreReactionWindowDuration);
        P_GET_FLOAT_REF(SuperSweetSpotDuration);
        P_GET_FLOAT_REF(SweetSpotDuration);
        P_FINISH;
        GetActiveReloadValues(ActiveReloadStartTime,PreReactionWindowDuration,SuperSweetSpotDuration,SweetSpotDuration);
    }
    DECLARE_FUNCTION(execUpdateBarrelHeatMaterial)
    {
        P_FINISH;
        UpdateBarrelHeatMaterial();
    }
    UBOOL eventShouldReloadingPreventTargeting()
    {
        GearWeapon_eventShouldReloadingPreventTargeting_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_ShouldReloadingPreventTargeting),&Parms);
        return Parms.ReturnValue;
    }
    void eventUpdateBarrelHeatMaterial()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_UpdateBarrelHeatMaterial),NULL);
    }
    class AProjectile* eventProjectileFireSimple(FLOAT AimErrorDeg=0)
    {
        GearWeapon_eventProjectileFireSimple_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.AimErrorDeg=AimErrorDeg;
        ProcessEvent(FindFunctionChecked(GEARGAME_ProjectileFireSimple),&Parms);
        return Parms.ReturnValue;
    }
    void eventAttachMuzzleEffectsComponents(class USkeletalMeshComponent* SkelMesh)
    {
        GearWeapon_eventAttachMuzzleEffectsComponents_Parms Parms(EC_EventParm);
        Parms.SkelMesh=SkelMesh;
        ProcessEvent(FindFunctionChecked(GEARGAME_AttachMuzzleEffectsComponents),&Parms);
    }
    FName eventGetDefaultHandSocketName(class AGearPawn* P)
    {
        GearWeapon_eventGetDefaultHandSocketName_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NAME_None;
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDefaultHandSocketName),&Parms);
        return Parms.ReturnValue;
    }
    void eventLocalActiveReloadSuccess(UBOOL bDidSuperSweetReload)
    {
        GearWeapon_eventLocalActiveReloadSuccess_Parms Parms(EC_EventParm);
        Parms.bDidSuperSweetReload=bDidSuperSweetReload ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_LocalActiveReloadSuccess),&Parms);
    }
    void eventLocalFailedActiveReload(UBOOL bFailedActiveReload)
    {
        GearWeapon_eventLocalFailedActiveReload_Parms Parms(EC_EventParm);
        Parms.bFailedActiveReload=bFailedActiveReload ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_LocalFailedActiveReload),&Parms);
    }
    FRotator eventGetHoseOffset()
    {
        GearWeapon_eventGetHoseOffset_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(GEARGAME_GetHoseOffset),&Parms);
        return Parms.ReturnValue;
    }
    void eventDummyFire(BYTE FireModeNum,FVector TargetLoc,class AActor* AttachedTo=NULL,FLOAT AimErrorDeg=0,class AActor* TargetActor=NULL)
    {
        GearWeapon_eventDummyFire_Parms Parms(EC_EventParm);
        Parms.FireModeNum=FireModeNum;
        Parms.TargetLoc=TargetLoc;
        Parms.AttachedTo=AttachedTo;
        Parms.AimErrorDeg=AimErrorDeg;
        Parms.TargetActor=TargetActor;
        ProcessEvent(FindFunctionChecked(GEARGAME_DummyFire),&Parms);
    }
    void eventWeaponStoppedFiring(BYTE FiringMode)
    {
        GearWeapon_eventWeaponStoppedFiring_Parms Parms(EC_EventParm);
        Parms.FiringMode=FiringMode;
        ProcessEvent(FindFunctionChecked(GEARGAME_WeaponStoppedFiring),&Parms);
    }
    void eventWeaponFired(BYTE FiringMode,FVector HitLocation=FVector(EC_EventParm))
    {
        GearWeapon_eventWeaponFired_Parms Parms(EC_EventParm);
        Parms.FiringMode=FiringMode;
        Parms.HitLocation=HitLocation;
        ProcessEvent(FindFunctionChecked(GEARGAME_WeaponFired),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AGearWeapon,AWeapon,0|CLASS_Config|CLASS_NativeReplication,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

	// Networking
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void TickSpecial( FLOAT DeltaSeconds );
};

struct GearVehicleWeapon_eventIsAimCorrect_Parms
{
    UBOOL ReturnValue;
    GearVehicleWeapon_eventIsAimCorrect_Parms(EEventParm)
    {
    }
};
struct GearVehicleWeapon_eventGetDesiredAimPoint_Parms
{
    class AActor* TargetActor;
    FVector ReturnValue;
    GearVehicleWeapon_eventGetDesiredAimPoint_Parms(EEventParm)
    {
    }
};
class AGearVehicleWeapon : public AGearWeapon
{
public:
    //## BEGIN PROPS GearVehicleWeapon
    INT SeatIndex;
    class AGearVehicle* MyVehicle;
    TArrayNoInit<FName> FireTriggerTags;
    TArrayNoInit<FName> AltFireTriggerTags;
    class USoundCue* BulletWhip;
    FLOAT LastCorrectAimTime;
    FLOAT LastInCorrectAimTime;
    FLOAT CurrentCrosshairScaling;
    FLOAT AimTraceRange;
    TArrayNoInit<class AActor*> AimingTraceIgnoredActors;
    FLOAT MaxFinalAimAdjustment;
    BITFIELD bPlaySoundFromSocket:1;
    BITFIELD bCurrentlyZoomed:1;
    BITFIELD bIgnoreSocketPitchRotation:1;
    BITFIELD bIgnoreDownwardPitch:1;
    BITFIELD bDebugTurret:1;
    class UClass* VehicleClass;
    FLOAT AR_FailReloadPenanltySeconds;
    //## END PROPS GearVehicleWeapon

    virtual FVector GetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm));
    virtual FLOAT GetMaxFinalAimAdjustment();
    DECLARE_FUNCTION(execGetMaxFinalAimAdjustment)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMaxFinalAimAdjustment();
    }
    UBOOL eventIsAimCorrect()
    {
        GearVehicleWeapon_eventIsAimCorrect_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsAimCorrect),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetDesiredAimPoint(class AActor** TargetActor=NULL)
    {
        GearVehicleWeapon_eventGetDesiredAimPoint_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        if(TargetActor){Parms.TargetActor=*TargetActor;}
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDesiredAimPoint),&Parms);
        if ( TargetActor ) { *TargetActor=Parms.TargetActor; }
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AGearVehicleWeapon,AGearWeapon,0|CLASS_Config|CLASS_NativeReplication,GearGame)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AGearWeap_GrenadeBase : public AGearWeapon
{
public:
    //## BEGIN PROPS GearWeap_GrenadeBase
    FVector SimulationStart;
    FVector SimulationDir;
    FVector FocusPoint;
    class AGearProj_Grenade* SimulatedGrenade;
    class AEmitter* EM_StartPoint;
    class UParticleSystem* PS_StartPoint;
    class UParticleSystemComponent* PSC_Trail;
    class UParticleSystem* PS_TrailCOG;
    class UParticleSystem* PS_TrailLocust;
    class AEmitter* EM_EndPoint;
    class UParticleSystem* PS_EndPointCOG;
    class UParticleSystem* PS_EndPointLocust;
    struct FBodyStance BS_PawnThrowGrenade;
    struct FBodyStance BS_PawnPrepare;
    struct FBodyStance BS_PawnLoop;
    struct FBodyStance BS_PawnRelease;
    FName WeapAnimPrepare;
    FName WeapAnimLoop;
    FName WeapAnimRelease;
    FLOAT ThrowAnimLength;
    BITFIELD bSpinningGrenade:1;
    BITFIELD bThrownBoloStyle:1;
    BITFIELD bDisplayingArc:1;
    FLOAT GlobalPlayRate;
    FLOAT AI_TimeTweenGrenade;
    FLOAT AI_ChanceToUseGrenade;
    class USoundCue* ThrowGrenadeSound;
    class USoundCue* GrenadeSwingSound;
    FVector2D GrenadeAimingCameraPitchLimit;
    FLOAT GrenadeAimingSensitivityMultiplier;
    FLOAT GrenadeAimingCameraPitchCorrectionInterpSpeed;
    FLOAT GrenadeAimingTrajectoryPitchMultiplier;
    INT GrenadeAimingTrajectoryPitchAdjustment;
    FVector2D GrenadeVelRange;
    FVector2D GrenadeVelRangeBlindFiring;
    FLOAT GrenadeVelRangePow;
    FVector FireStartOffset_Base;
    FVector FireStartOffset_CoverLeftOrRight;
    FVector FireStartOffset_CoverDefault;
    FVector FireStartOffset_CoverLean_Low;
    FVector FireStartOffset_CoverLean_High;
    FVector FireStartOffset_CoverBlindUp;
    FLOAT FireStartOffset_CoverZOffset_Low;
    FLOAT FireStartOffset_CoverZOffset_Mid;
    FLOAT FireStartOffset_CoverZOffset_High;
    FVector2D TargetingFOVRange;
    FVector2D TargetingFOVDistRange;
    class UParticleSystem* SpinningParticleEffectTemplate;
    FName SpinningEffectSocketName;
    class UParticleSystemComponent* PSC_SpinningParticleEffect;
    INT MinBlindFireUpPitch;
    FLOAT BlindFireUpThrowDelay;
    FLOAT BlindFireSideThrowDelay;
    FLOAT UntargetedThrowDelay;
    //## END PROPS GearWeap_GrenadeBase

    virtual FVector GetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm));
    virtual FVector GetMuzzleLoc();
    DECLARE_ABSTRACT_CLASS(AGearWeap_GrenadeBase,AGearWeapon,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearWeap_GrenadeBase)
};

struct GearWeap_HeavyBase_eventIsMounted_Parms
{
    UBOOL ReturnValue;
    GearWeap_HeavyBase_eventIsMounted_Parms(EEventParm)
    {
    }
};
struct GearWeap_HeavyBase_eventGetMountedCameraOffsets_Parms
{
    FVector OffsetLow;
    FVector OffsetMid;
    FVector OffsetHigh;
    GearWeap_HeavyBase_eventGetMountedCameraOffsets_Parms(EEventParm)
    {
    }
};
class AGearWeap_HeavyBase : public AGearWeapon
{
public:
    //## BEGIN PROPS GearWeap_HeavyBase
    FLOAT MountedWeaponAimError;
    FVector2D AI_AccCone_Mounted_Min;
    FVector2D AI_AccCone_Mounted_Max;
    FLOAT MountedWeaponRecoil;
    FLOAT MountedCameraFOV;
    FVector MountedCameraViewOffsetsLow;
    FVector MountedCameraViewOffsetsMid;
    FVector MountedCameraViewOffsetsHigh;
    FVector MountedCameraViewOffsetsLow_OnLowCover;
    FVector MountedCameraViewOffsetsMid_OnLowCover;
    FVector MountedCameraViewOffsetsHigh_OnLowCover;
    FVector MountedCameraViewOffsetsLow_LeanCover;
    FVector MountedCameraViewOffsetsMid_LeanCover;
    FVector MountedCameraViewOffsetsHigh_LeanCover;
    FLOAT MaxTargetedAimAdjustYaw;
    INT PitchLimitMountedMin;
    INT PitchLimitMountedMax;
    FLOAT MountedLookRightScale;
    FLOAT MountedLookUpScale;
    FName StandSocketName;
    class UParticleSystem* PS_MountedImpact;
    class USoundCue* MountedImpactSound;
    BITFIELD bIsMounted:1;
    BITFIELD bPlayingRotAudio:1;
    class USoundCue* RotateLoopSound;
    class UAudioComponent* RotateLoopAC;
    FLOAT RotAudioStartVelThreshold;
    FLOAT RotAudioStopVelThreshold;
    INT LastControllerYaw;
    FVector2D RotAudioVolumeVelRange;
    FVector2D RotAudioVolumeRange;
    //## END PROPS GearWeap_HeavyBase

    UBOOL eventIsMounted()
    {
        GearWeap_HeavyBase_eventIsMounted_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsMounted),&Parms);
        return Parms.ReturnValue;
    }
    void eventGetMountedCameraOffsets(FVector& OffsetLow,FVector& OffsetMid,FVector& OffsetHigh)
    {
        GearWeap_HeavyBase_eventGetMountedCameraOffsets_Parms Parms(EC_EventParm);
        Parms.OffsetLow=OffsetLow;
        Parms.OffsetMid=OffsetMid;
        Parms.OffsetHigh=OffsetHigh;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetMountedCameraOffsets),&Parms);
        OffsetLow=Parms.OffsetLow;
        OffsetMid=Parms.OffsetMid;
        OffsetHigh=Parms.OffsetHigh;
    }
    DECLARE_ABSTRACT_CLASS(AGearWeap_HeavyBase,AGearWeapon,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearWeap_HeavyBase)
};

class AGearWeap_PistolBase : public AGearWeapon
{
public:
    //## BEGIN PROPS GearWeap_PistolBase
    FLOAT ZoomFOV;
    class USoundCue* ZoomActivatedSound;
    class USoundCue* ZoomDeActivatedSound;
    FLOAT FireAnimRateScale;
    struct FBodyStance ShieldReloadOverride;
    struct FBodyStance ShieldReloadFailedOverride;
    struct FBodyStance CrateCarryReloadOverride;
    struct FBodyStance CrateCarryReloadFailedOverride;
    struct FBodyStance BS_MeleeAttackKidnapper;
    struct FBodyStance BS_MeleeAttackHostage;
    class AGearWeap_GrenadeBase* GrenWeap;
    //## END PROPS GearWeap_PistolBase

    DECLARE_ABSTRACT_CLASS(AGearWeap_PistolBase,AGearWeapon,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearWeap_PistolBase)
};

class AGearProjectile : public AProjectile
{
public:
    //## BEGIN PROPS GearProjectile
    BITFIELD bSuppressAudio:1;
    BITFIELD bAutoStartInFlightAudio:1;
    BITFIELD bAddBaseVelocity:1;
    BITFIELD bIgnoreInstigatorCollision:1;
    BITFIELD bStoppedByGrenadeBlockingVolume:1;
    FLOAT GravityScale;
    class UAudioComponent* InFlightSound;
    class USoundCue* InFlightSoundTemplate;
    FVector InitialFrameOfRefVelocity;
    class UParticleSystem* TrailTemplate;
    class ASpawnedGearEmitter* TrailEmitter;
    class UDynamicLightEnvironmentComponent* ProjLightEnvironment;
    FLOAT FluidForceRadius;
    //## END PROPS GearProjectile

    DECLARE_CLASS(AGearProjectile,AProjectile,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
};

class AGearProj_ExplosiveBase : public AGearProjectile
{
public:
    //## BEGIN PROPS GearProj_ExplosiveBase
    BITFIELD bAutoDestroyOnExplosion:1;
    BITFIELD bHasExploded:1;
    BITFIELD bAttachExplosionToHitMover:1;
    FLOAT ExploDamage;
    FLOAT ExploDamageRadius;
    FLOAT ExploDamageFalloffExp;
    FLOAT KnockDownRadius;
    FLOAT KnockDownRadiusMP;
    FLOAT CringeRadius;
    FLOAT CringeRadiusMP;
    FLOAT AIDamageScale;
    class UGearExplosion* ExplosionTemplate;
    class UClass* SmokeEmitterClass;
    //## END PROPS GearProj_ExplosiveBase

    DECLARE_ABSTRACT_CLASS(AGearProj_ExplosiveBase,AGearProjectile,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearProj_ExplosiveBase)
};

#define UCONST_STATS_LEVEL3 0x04

class AGearProj_Grenade : public AGearProj_ExplosiveBase
{
public:
    //## BEGIN PROPS GearProj_Grenade
    BITFIELD bPerformGravity:1;
    BITFIELD bIsSimulating:1;
    BITFIELD bHitPhysicsVolume:1;
    BITFIELD bEnabledGrenadePhysics:1;
    BITFIELD bGrenadeHasExploded:1;
    BITFIELD bAttachedToWallAutoExplosionTriggered:1;
    BITFIELD bFreeze:1;
    BITFIELD bInstigatorCannotTriggerTrap:1;
    INT MaxBounceCount;
    INT MaxBounceCountToArm;
    FLOAT MaxSimulationTime;
    class UPrimitiveComponent* Mesh;
    INT BounceCount;
    FVector FirstBounceLoc;
    FLOAT VelocityDampingFactor;
    FLOAT Bounciness;
    FLOAT StopSimulatingVelocityThreshhold;
    class USoundCue* GrenadeAttachingToFoeSound;
    class USoundCue* GrenadeAttachingToWorldSound;
    class USoundCue* BeepBeepAboutToExplodeSound;
    class USoundCue* GrenadeBounceSound;
    class AController* AttacheeController;
    FLOAT SimFixedTimeStep;
    FLOAT TimeTilNextGravUpdate;
    FLOAT SimInternalGravityAdvanceTime;
    FLOAT TimeBeforeBeep;
    FLOAT TimeAfterBeep;
    class AActor* MeleeVictim;
    class APawn* HoldVictim;
    FLOAT AttachedtoWallTriggerDelay;
    FLOAT AttachedToWallMaxLifespan;
    FLOAT AttachedToWallDetonationTriggerRadius;
    FLOAT GrenadeTagExplosionDelay;
    FLOAT GrenadeAttachNormalOffset;
    INT TakenDamage;
    INT DamageToDetonate;
    class UClass* MartyrDamageType;
    class UClass* StickyDamageType;
    FVector HeadFacingNormal;
    BYTE BeepCount;
    BYTE TeamNum;
    class AAIAvoidanceCylinder* AvoidanceCylinder;
    FLOAT InstigatorTrapSafetyDelay;
    //## END PROPS GearProj_Grenade

    virtual void RunPhysicsSimulationTilEnd(FLOAT GrenadeLifeSpan);
    DECLARE_FUNCTION(execRunPhysicsSimulationTilEnd)
    {
        P_GET_FLOAT(GrenadeLifeSpan);
        P_FINISH;
        RunPhysicsSimulationTilEnd(GrenadeLifeSpan);
    }
    DECLARE_ABSTRACT_CLASS(AGearProj_Grenade,AGearProj_ExplosiveBase,0|CLASS_Config,GearGame)
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual void physProjectile(FLOAT DeltaTime, INT Iterations);
};

class AGearProj_HomingRocket : public AGearProj_ExplosiveBase
{
public:
    //## BEGIN PROPS GearProj_HomingRocket
    FLOAT RocketLaunchSpeed;
    class AActor* TargetActor;
    class AActor* SourceActor;
    FVector SourcePosActorSpace;
    FLOAT StopHomingDistance;
    FLOAT TrackingStrength;
    BITFIELD bUseInterpPhysics:1;
    FLOAT InterpTime;
    FLOAT CurrentAlpha;
    //## END PROPS GearProj_HomingRocket

    DECLARE_CLASS(AGearProj_HomingRocket,AGearProj_ExplosiveBase,0|CLASS_Config,GearGame)
	virtual void physProjectile(FLOAT DeltaTime, INT Iterations);
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
	virtual void TickSpecial( FLOAT DeltaSeconds );
};

#endif // !INCLUDED_GEARGAME_WEAPON_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AFlameThrowerSprayBase,-1,execParticleSystemCleanUp);
AUTOGENERATE_FUNCTION(AFlameThrowerSprayBase,-1,execDoFlameCollisionDetection);
AUTOGENERATE_FUNCTION(AFlameThrowerSprayBase,-1,execDebugRenderBones);
AUTOGENERATE_FUNCTION(AFlameThrowerSprayBase,-1,execDestroyIfAllEmittersFinished);
AUTOGENERATE_FUNCTION(AFlameThrowerSprayBase,-1,execUpdateFlameSeeds);
AUTOGENERATE_FUNCTION(AGearProj_Grenade,-1,execRunPhysicsSimulationTilEnd);
AUTOGENERATE_FUNCTION(AGearVehicleWeapon,-1,execGetMaxFinalAimAdjustment);
AUTOGENERATE_FUNCTION(AGearVehicleWeapon,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearWeap_GrenadeBase,-1,execGetMuzzleLoc);
AUTOGENERATE_FUNCTION(AGearWeap_GrenadeBase,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearWeapon,-1,execUpdateBarrelHeatMaterial);
AUTOGENERATE_FUNCTION(AGearWeapon,-1,execGetActiveReloadValues);
AUTOGENERATE_FUNCTION(AGearWeapon,-1,execDetermineActiveReloadSuccessOrFailure);
AUTOGENERATE_FUNCTION(AGearWeapon,-1,execGetMuzzleLoc);
AUTOGENERATE_FUNCTION(AGearWeapon,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AGearWeapon,-1,execGetMuzzleLocAndRot);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GEARGAME_WEAPON_NATIVE_DEFS
#define GEARGAME_WEAPON_NATIVE_DEFS

DECLARE_NATIVE_TYPE(GearGame,AFlameThrowerSprayBase);
DECLARE_NATIVE_TYPE(GearGame,AGearDroppedPickup_Shield);
DECLARE_NATIVE_TYPE(GearGame,AGearDynamicFogVolume_Spherical);
DECLARE_NATIVE_TYPE(GearGame,AGearExplosionActor);
DECLARE_NATIVE_TYPE(GearGame,AGearExplosionActorReplicated);
DECLARE_NATIVE_TYPE(GearGame,AGearFogVolume_SmokeGrenade);
DECLARE_NATIVE_TYPE(GearGame,AGearFogVolume_Spawnable);
DECLARE_NATIVE_TYPE(GearGame,AGearProj_ExplosiveBase);
DECLARE_NATIVE_TYPE(GearGame,AGearProj_Grenade);
DECLARE_NATIVE_TYPE(GearGame,AGearProj_HomingRocket);
DECLARE_NATIVE_TYPE(GearGame,AGearProjectile);
DECLARE_NATIVE_TYPE(GearGame,AGearShield);
DECLARE_NATIVE_TYPE(GearGame,AGearVehicleWeapon);
DECLARE_NATIVE_TYPE(GearGame,AGearWeap_GrenadeBase);
DECLARE_NATIVE_TYPE(GearGame,AGearWeap_HeavyBase);
DECLARE_NATIVE_TYPE(GearGame,AGearWeap_PistolBase);
DECLARE_NATIVE_TYPE(GearGame,AGearWeapon);

#define AUTO_INITIALIZE_REGISTRANTS_GEARGAME_WEAPON \
	AFlameThrowerSprayBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAFlameThrowerSprayBaseNative; \
	AGearDroppedPickup_Shield::StaticClass(); \
	AGearDynamicFogVolume_Spherical::StaticClass(); \
	AGearExplosionActor::StaticClass(); \
	AGearExplosionActorReplicated::StaticClass(); \
	AGearFogVolume_SmokeGrenade::StaticClass(); \
	AGearFogVolume_Spawnable::StaticClass(); \
	AGearProj_ExplosiveBase::StaticClass(); \
	AGearProj_Grenade::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearProj_GrenadeNative; \
	AGearProj_HomingRocket::StaticClass(); \
	AGearProjectile::StaticClass(); \
	AGearShield::StaticClass(); \
	AGearVehicleWeapon::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearVehicleWeaponNative; \
	AGearWeap_GrenadeBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearWeap_GrenadeBaseNative; \
	AGearWeap_HeavyBase::StaticClass(); \
	AGearWeap_PistolBase::StaticClass(); \
	AGearWeapon::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearWeaponNative; \

#endif // GEARGAME_WEAPON_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AFlameThrowerSprayBase) GGearGameAFlameThrowerSprayBaseNatives[] = 
{ 
	MAP_NATIVE(AFlameThrowerSprayBase,execParticleSystemCleanUp)
	MAP_NATIVE(AFlameThrowerSprayBase,execDoFlameCollisionDetection)
	MAP_NATIVE(AFlameThrowerSprayBase,execDebugRenderBones)
	MAP_NATIVE(AFlameThrowerSprayBase,execDestroyIfAllEmittersFinished)
	MAP_NATIVE(AFlameThrowerSprayBase,execUpdateFlameSeeds)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AFlameThrowerSprayBase);

NATIVE_INFO(AGearProj_Grenade) GGearGameAGearProj_GrenadeNatives[] = 
{ 
	MAP_NATIVE(AGearProj_Grenade,execRunPhysicsSimulationTilEnd)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearProj_Grenade);

NATIVE_INFO(AGearVehicleWeapon) GGearGameAGearVehicleWeaponNatives[] = 
{ 
	MAP_NATIVE(AGearVehicleWeapon,execGetMaxFinalAimAdjustment)
	MAP_NATIVE(AGearVehicleWeapon,execGetPhysicalFireStartLoc)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearVehicleWeapon);

NATIVE_INFO(AGearWeap_GrenadeBase) GGearGameAGearWeap_GrenadeBaseNatives[] = 
{ 
	MAP_NATIVE(AGearWeap_GrenadeBase,execGetMuzzleLoc)
	MAP_NATIVE(AGearWeap_GrenadeBase,execGetPhysicalFireStartLoc)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearWeap_GrenadeBase);

NATIVE_INFO(AGearWeapon) GGearGameAGearWeaponNatives[] = 
{ 
	MAP_NATIVE(AGearWeapon,execUpdateBarrelHeatMaterial)
	MAP_NATIVE(AGearWeapon,execGetActiveReloadValues)
	MAP_NATIVE(AGearWeapon,execDetermineActiveReloadSuccessOrFailure)
	MAP_NATIVE(AGearWeapon,execGetMuzzleLoc)
	MAP_NATIVE(AGearWeapon,execGetPhysicalFireStartLoc)
	MAP_NATIVE(AGearWeapon,execGetMuzzleLocAndRot)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearWeapon);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,FlameThrowerSprayBase,CurrentAge)
VERIFY_CLASS_OFFSET_NODIE(A,FlameThrowerSprayBase,OwningGearPawn)
VERIFY_CLASS_SIZE_NODIE(AFlameThrowerSprayBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearDroppedPickup_Shield,DeployedLink_Rear)
VERIFY_CLASS_OFFSET_NODIE(A,GearDroppedPickup_Shield,ShieldMeshComp)
VERIFY_CLASS_SIZE_NODIE(AGearDroppedPickup_Shield)
VERIFY_CLASS_OFFSET_NODIE(A,GearDynamicFogVolume_Spherical,FogVolumeArchetype)
VERIFY_CLASS_OFFSET_NODIE(A,GearDynamicFogVolume_Spherical,DurationForMITV)
VERIFY_CLASS_SIZE_NODIE(AGearDynamicFogVolume_Spherical)
VERIFY_CLASS_OFFSET_NODIE(A,GearExplosionActor,ExplosionLight)
VERIFY_CLASS_OFFSET_NODIE(A,GearExplosionActor,HitLocationFromPhysMaterialTrace)
VERIFY_CLASS_SIZE_NODIE(AGearExplosionActor)
VERIFY_CLASS_OFFSET_NODIE(A,GearExplosionActorReplicated,ExploTemplateRef)
VERIFY_CLASS_OFFSET_NODIE(A,GearExplosionActorReplicated,ProjExploToEmulate)
VERIFY_CLASS_SIZE_NODIE(AGearExplosionActorReplicated)
VERIFY_CLASS_SIZE_NODIE(AGearFogVolume_SmokeGrenade)
VERIFY_CLASS_OFFSET_NODIE(A,GearFogVolume_Spawnable,VisBlocker)
VERIFY_CLASS_OFFSET_NODIE(A,GearFogVolume_Spawnable,CurrentFogOpacity)
VERIFY_CLASS_SIZE_NODIE(AGearFogVolume_Spawnable)
VERIFY_CLASS_OFFSET_NODIE(A,GearProj_ExplosiveBase,ExploDamage)
VERIFY_CLASS_OFFSET_NODIE(A,GearProj_ExplosiveBase,SmokeEmitterClass)
VERIFY_CLASS_SIZE_NODIE(AGearProj_ExplosiveBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearProj_Grenade,MaxBounceCount)
VERIFY_CLASS_OFFSET_NODIE(A,GearProj_Grenade,InstigatorTrapSafetyDelay)
VERIFY_CLASS_SIZE_NODIE(AGearProj_Grenade)
VERIFY_CLASS_OFFSET_NODIE(A,GearProj_HomingRocket,RocketLaunchSpeed)
VERIFY_CLASS_OFFSET_NODIE(A,GearProj_HomingRocket,CurrentAlpha)
VERIFY_CLASS_SIZE_NODIE(AGearProj_HomingRocket)
VERIFY_CLASS_OFFSET_NODIE(A,GearProjectile,GravityScale)
VERIFY_CLASS_OFFSET_NODIE(A,GearProjectile,FluidForceRadius)
VERIFY_CLASS_SIZE_NODIE(AGearProjectile)
VERIFY_CLASS_OFFSET_NODIE(A,GearShield,WeaponID)
VERIFY_CLASS_OFFSET_NODIE(A,GearShield,LC_EmisDefaultLocust)
VERIFY_CLASS_SIZE_NODIE(AGearShield)
VERIFY_CLASS_OFFSET_NODIE(A,GearVehicleWeapon,SeatIndex)
VERIFY_CLASS_OFFSET_NODIE(A,GearVehicleWeapon,AR_FailReloadPenanltySeconds)
VERIFY_CLASS_SIZE_NODIE(AGearVehicleWeapon)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeap_GrenadeBase,SimulationStart)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeap_GrenadeBase,UntargetedThrowDelay)
VERIFY_CLASS_SIZE_NODIE(AGearWeap_GrenadeBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeap_HeavyBase,MountedWeaponAimError)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeap_HeavyBase,RotAudioVolumeRange)
VERIFY_CLASS_SIZE_NODIE(AGearWeap_HeavyBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeap_PistolBase,ZoomFOV)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeap_PistolBase,GrenWeap)
VERIFY_CLASS_SIZE_NODIE(AGearWeap_PistolBase)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeapon,GearAIController)
VERIFY_CLASS_OFFSET_NODIE(A,GearWeapon,WeaponStatIndex)
VERIFY_CLASS_SIZE_NODIE(AGearWeapon)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
