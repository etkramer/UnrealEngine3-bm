/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GEARGAME_UIPRIVATE_ENUMS
#define INCLUDED_GEARGAME_UIPRIVATE_ENUMS 1

enum EListExpansionState
{
    LES_Collapsed           =0,
    LES_Expanded            =1,
    LES_Collapsing          =2,
    LES_Expanding           =3,
    LES_MAX                 =4,
};

#endif // !INCLUDED_GEARGAME_UIPRIVATE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName GEARGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(CanSubmitValue)
AUTOGENERATE_NAME(IsCollapseAllowed)
AUTOGENERATE_NAME(IsExpandAllowed)
AUTOGENERATE_NAME(ListCollapseBegin)
AUTOGENERATE_NAME(ListCollapseComplete)
AUTOGENERATE_NAME(ListExpansionBegin)
AUTOGENERATE_NAME(ListExpansionComplete)
AUTOGENERATE_NAME(OnAcceptOptions)
AUTOGENERATE_NAME(OnListCollapsed)
AUTOGENERATE_NAME(OnListCollapsing)
AUTOGENERATE_NAME(OnListExpanded)
AUTOGENERATE_NAME(OnListExpanding)
AUTOGENERATE_NAME(OnListOptionSubmitted)
AUTOGENERATE_NAME(OnOptionChanged)
AUTOGENERATE_NAME(OnOptionFocused)
AUTOGENERATE_NAME(OnRegeneratedOptions)
AUTOGENERATE_NAME(RefreshScreenshots)
AUTOGENERATE_NAME(SetupOptionBindings)

#ifndef NAMES_ONLY

#ifndef INCLUDED_GEARGAME_UIPRIVATE_CLASSES
#define INCLUDED_GEARGAME_UIPRIVATE_CLASSES 1

class UUIComp_GearCaption : public UUIComp_DrawCaption
{
public:
    //## BEGIN PROPS UIComp_GearCaption
    //## END PROPS UIComp_GearCaption

    DECLARE_CLASS(UUIComp_GearCaption,UUIComp_DrawCaption,0,GearGame)
	/* === UUIComp_DrawString interface === */
	/**
	 * Calculates the position and size of the bounding region available for rendering this component's string, taking
	 * into account any configured bounding region clamping.
	 *
	 * @param	[out] BoundingRegionStart	receives the location of the upper left corner of the bounding region, in
	 *										pixels relative to the upper left corner of the screen.
	 * @param	[out] BoundingRegionSize	receives the size of the bounding region, in absolute pixels.
	 */
	virtual void CalculateBoundingRegion( FLOAT* BoundingRegionStart[UIORIENT_MAX], FLOAT* BoundingRegionSize[UIORIENT_MAX] ) const;

protected:
	/**
	 * Initializes the render parameters that will be used for formatting the string.
	 *
	 * @param	Face			the face that was being resolved
	 * @param	out_Parameters	[out] the formatting parameters to use for formatting the string.
	 *
	 * @return	TRUE if the formatting data is ready to be applied to the string, taking into account the autosize settings.
	 */
	virtual UBOOL GetStringFormatParameters( EUIWidgetFace Face, struct FRenderParameters& out_Parameters ) const;

	/**
	 * Wrapper for getting the docking-state of the owning widget's four faces.  No special logic here, but child classes
	 * can use this method to make the formatting code ignore the fact that the widget may be docked (in cases where it is
	 * irrelevant)
	 *
	 * @param	bFaceDocked		[out] an array of bools representing whether the widget is docked on the respective face.
	 */
	virtual void GetOwnerDockingState( UBOOL* bFaceDocked[UIFACE_MAX] ) const;

	/**
	 * Adjusts the owning widget's bounds according to the wrapping mode and autosize behaviors.
	 */
	virtual void UpdateOwnerBounds( struct FRenderParameters& Parameters );
};

class UUIComp_CollapsingListPresenter : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_CollapsingListPresenter
    FLOAT AnimationOpacity;
    FVector RenderOffsetPercentage;
    //## END PROPS UIComp_CollapsingListPresenter

    DECLARE_CLASS(UUIComp_CollapsingListPresenter,UUIComp_ListPresenter,0,GearGame)
    DECLARE_WITHIN(UGearUICollapsingSelectionList)
	/* === UUIComp_ListPresenter interface === */
	/**
	 * Renders the elements in this list.
	 *
	 * @param	RI					the render interface to use for rendering
	 */
	virtual void Render_List( FCanvas* Canvas );

	/**
	 * Renders the overlay image for a single list element.  Moved into a separate function to allow child classes to easily override
	 * and modify the way that the overlay is rendered.
	 *
	 * @param	same as Render_ListElement, except that no values are passed back to the caller.
	 */
	virtual void Render_ElementOverlay( FCanvas* Canvas, INT ElementIndex, const FRenderParameters& Parameters, const FVector2D& DefaultCellSize );

	/* === UUIComp_ListPresenterBase interface === */
	/**
	 * Determines the appropriate position for the selection hint object based on the size of the list's rows and any padding that must be taken
	 * into account.
	 *
	 * @param	SelectionHintObject		the widget that will display the selection hint (usually a label).
	 * @param	ElementIndex			the index of the element to display the selection hint next to.
	 */
	virtual UBOOL SetSelectionHintPosition( UUIObject* SelectionHintObject, INT ElementIndex );

	/**
	 * Initializes the render parameters that will be used for formatting the list elements.
	 *
	 * @param	Face			the face that was being resolved
	 * @param	out_Parameters	[out] the formatting parameters to use when calling ApplyFormatting.
	 *
	 * @return	TRUE if the formatting data is ready to be applied to the list elements, taking into account the autosize settings.
	 */
	virtual UBOOL GetListRenderParameters( EUIWidgetFace Face, FRenderParameters& out_Parameters );

	/**
	 * Wrapper for getting the docking-state of the owning widget's four faces.  No special logic here, but child classes
	 * can use this method to make the formatting code ignore the fact that the widget may be docked (in cases where it is
	 * irrelevant)
	 *
	 * @param	bFaceDocked		[out] an array of bools representing whether the widget is docked on the respective face.
	 */
	virtual void GetOwnerDockingState( UBOOL* bFaceDocked[UIFACE_MAX] ) const;

	/**
	 * Adjusts the owning widget's bounds according to the autosize settings.
	 */
	virtual void UpdateOwnerBounds( FRenderParameters& Parameters );

	/**
	 * Setup the left, top, width, and height values that will be used to render the list.  This will typically be the list's
	 * RenderBounds, unless the elements should be rendered in a subportion of the list.
	 *
	 * @fixme ronp - mmmmm, this is a bit hacky..  we're already doing something similar on the formatting side...seems like
	 * we should be able to leverage that work so that we don't get out of sync.  :\
	 */
	virtual void InitializeRenderingParms( FRenderParameters& Parameters, FCanvas* Canvas=NULL );
};

#define UCONST_LOADING_MOVIE TEXT("LoadingMovie")

class UGearUIInteraction : public UUIInteraction
{
public:
    //## BEGIN PROPS GearUIInteraction
    BITFIELD bAttractModeAllowed:1;
private:
    BITFIELD bAttractMoviePlaying:1;
    FLOAT IdleSeconds;
public:
    FLOAT MaxIdleSeconds;
    //## END PROPS GearUIInteraction

    UBOOL IsMatureLanguageSupported() const;
    DECLARE_FUNCTION(execIsMatureLanguageSupported)
    {
        P_FINISH;
        *(UBOOL*)Result=IsMatureLanguageSupported();
    }
    DECLARE_CLASS(UGearUIInteraction,UUIInteraction,0|CLASS_Transient|CLASS_Config,GearGame)
    DECLARE_WITHIN(UGearGameViewportClient)
	/* === UGearUIInteraction interface === */
	/**
	 * Begin playing the attract-mode movie.
	 */
	void BeginAttractMovie();

	/**
	 * Stop playing the attract mode movie.
	 */
	void EndAttractMovie();

	/**
	 * @return	TRUE if the attract mode movie is currently playing
	 */
	UBOOL IsAttractMoviePlaying() const
	{
		return bAttractMoviePlaying;
	}

	/* === UUIInteraction interface === */
	/**
	 * Called once a frame to update the interaction's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick( FLOAT DeltaTime );

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);
};

struct GearUIDataProvider_Screenshots_eventRefreshScreenshots_Parms
{
    GearUIDataProvider_Screenshots_eventRefreshScreenshots_Parms(EEventParm)
    {
    }
};
class UGearUIDataProvider_Screenshots : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS GearUIDataProvider_Screenshots
    TArrayNoInit<struct FSavedScreenshotInfo> Screenshots;
    FStringNoInit RatingCol;
    FStringNoInit GameTypeCol;
    FStringNoInit MapNameCol;
    FStringNoInit DateTimeCol;
    //## END PROPS GearUIDataProvider_Screenshots

    virtual void SortScreenshots();
    DECLARE_FUNCTION(execSortScreenshots)
    {
        P_FINISH;
        SortScreenshots();
    }
    void eventRefreshScreenshots()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_RefreshScreenshots),NULL);
    }
    DECLARE_CLASS(UGearUIDataProvider_Screenshots,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,GearGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags)
	{
		CellTags.Set(FName(TEXT("Rating")),*RatingCol);
		CellTags.Set(FName(TEXT("GameType")),*GameTypeCol);
		CellTags.Set(FName(TEXT("MapName")),*MapNameCol);
		CellTags.Set(FName(TEXT("DateTime")),*DateTimeCol);
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& CellFieldType)
	{
		CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Screenshots")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UGearUIDataStore_GameResource : public UUIDataStore_GameResource
{
public:
    //## BEGIN PROPS GearUIDataStore_GameResource
    FName ResourceDataStoreTeamNames[2];
    class UObject* ResourceDataStoreTeamIdTypes[2];
    //## END PROPS GearUIDataStore_GameResource

    DECLARE_CLASS(UGearUIDataStore_GameResource,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,GearGame)
	/* === UUIDataStore interface === */
	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );
};

class UGearUIDataStore_OnlinePlayerData : public UUIDataStore_OnlinePlayerData
{
public:
    //## BEGIN PROPS GearUIDataStore_OnlinePlayerData
    class UGearUIDataProvider_Screenshots* ScreenshotsProvider;
    FStringNoInit ScreenshotsProviderClassName;
    class UClass* ScreenshotsProviderClass;
    //## END PROPS GearUIDataStore_OnlinePlayerData

    DECLARE_CLASS(UGearUIDataStore_OnlinePlayerData,UUIDataStore_OnlinePlayerData,0|CLASS_Transient|CLASS_Config,GearGame)
	/* === UIDataStore interface === */

	/**
	* Loads the game specific OnlineProfileSettings class
	*/
	virtual void LoadDependentClasses(void);

	/**
	* Creates the data providers exposed by this data store
	*/
	virtual void InitializeDataStore(void);

	/**
	* Forwards the calls to the data providers so they can do their start up
	*
	* @param Player the player that will be associated with this DataStore
	*/
	virtual void OnRegister(ULocalPlayer* Player);

	/**
	* Tells all of the child providers to clear their player data
	*
	* @param Player ignored
	*/
	virtual void OnUnregister(ULocalPlayer*);

	/**
	* Gets the list of data fields exposed by this data provider
	*
	* @param OutFields Filled in with the list of fields supported by its aggregated providers
	*/
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	* Retrieves the list elements associated with the data tag specified.
	*
	* @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	*							from GetElementProviderTags.
	* @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	*
	* @return	TRUE if this data store contains a list element data provider matching the tag specified.
	*/
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	* Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	* Used by the UI editor to know which cells are available for binding to individual list cells.
	*
	* @param	FieldName		the tag of the list element data provider that we want the schema for.
	*
	* @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	*			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	*/
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );
};

#define UCONST_STATS_VIEW_SKILL_STANDARD_VERSUS 0xFFFE0002
#define UCONST_STATS_VIEW_SKILL_STANDARD_PARTY 0xFFFE0001
#define UCONST_STATS_VIEW_SKILL_STANDARD_COOP 0xFFFE0000
#define UCONST_STATS_VIEW_SKILL_RANKED_VERSUS 0xFFFF0002
#define UCONST_STATS_VIEW_SKILL_RANKED_PARTY 0xFFFF0001
#define UCONST_STATS_VIEW_SKILL_RANKED_COOP 0xFFFF0000
#define UCONST_PROPERTY_INSANEDIFFICULTY 0x1000001E
#define UCONST_PROPERTY_HARDCOREDIFFICULTY 0x1000001D
#define UCONST_PROPERTY_NORMALDIFFICULTY 0x1000001C
#define UCONST_PROPERTY_CASUALDIFFICULTY 0x1000001B
#define UCONST_PROPERTY_DIFFICULTY 0x1000001A
#define UCONST_PROPERTY_MEATFLAGCAPTURE 0x10000019
#define UCONST_PROPERTY_RINGPOINTS 0x10000018
#define UCONST_PROPERTY_RINGBREAK 0x10000017
#define UCONST_PROPERTY_RINGCAPTURE 0x10000016
#define UCONST_PROPERTY_MINIONKILL 0x10000015
#define UCONST_PROPERTY_GRUNTKILL 0x10000014
#define UCONST_PROPERTY_MINIBOSSKILL 0x10000013
#define UCONST_PROPERTY_ROUNDSDRAW 0x10000012
#define UCONST_PROPERTY_ROUNDSLOST 0x10000011
#define UCONST_PROPERTY_ROUNDSWON 0x10000010
#define UCONST_PROPERTY_ROUNDSPLAYED 0x1000000F
#define UCONST_PROPERTY_MATCHESLOST 0x1000000E
#define UCONST_PROPERTY_MATCHESWON 0x1000000D
#define UCONST_PROPERTY_MATCHESPLAYED 0x1000000C
#define UCONST_PROPERTY_WAVE 0x1000000A
#define UCONST_PROPERTY_POINTSRATED 0x20000009
#define UCONST_PROPERTY_POINTS 0x10000008
#define UCONST_PROPERTY_REVIVES 0x10000007
#define UCONST_PROPERTY_TAKEDOWNS 0x10000006
#define UCONST_PROPERTY_DEATHS 0x10000005
#define UCONST_PROPERTY_KILLS 0x10000004
#define UCONST_STATS_COLUMN_HORDE_POINTS 2
#define UCONST_STATS_COLUMN_HORDE_WAVE 1
#define UCONST_STATS_COLUMN_POINTSPERROUND_RATIO 32
#define UCONST_STATS_COLUMN_POINTSPERMATCH_RATIO 31
#define UCONST_STATS_COLUMN_KILLDEATH_RATIO 30
#define UCONST_STATS_COLUMN_MEATFLAG_MEATFLAGCAPTURES 13
#define UCONST_STATS_COLUMN_KOTH_RINGPOINTS 19
#define UCONST_STATS_COLUMN_INSANEDIFFICULTY 18
#define UCONST_STATS_COLUMN_HARDCOREDIFFICULTY 17
#define UCONST_STATS_COLUMN_NORMALDIFFICULTY 16
#define UCONST_STATS_COLUMN_CASUALDIFFICULTY 15
#define UCONST_STATS_COLUMN_ANNEX_BREAKS 14
#define UCONST_STATS_COLUMN_ANNEX_CAPTURES 13
#define UCONST_STATS_COLUMN_ROUNDSDRAW 12
#define UCONST_STATS_COLUMN_ROUNDSLOST 11
#define UCONST_STATS_COLUMN_ROUNDSWON 10
#define UCONST_STATS_COLUMN_ROUNDSPLAYED 9
#define UCONST_STATS_COLUMN_MATCHESLOST 8
#define UCONST_STATS_COLUMN_MATCHESWON 7
#define UCONST_STATS_COLUMN_MATCHESPLAYED 6
#define UCONST_STATS_COLUMN_POINTS 5
#define UCONST_STATS_COLUMN_TAKEDOWNS 4
#define UCONST_STATS_COLUMN_REVIVES 3
#define UCONST_STATS_COLUMN_DEATHS 2
#define UCONST_STATS_COLUMN_KILLS 1
#define UCONST_STATS_COLUMN_SIGMA 64
#define UCONST_STATS_COLUMN_MU 63
#define UCONST_STATS_COLUMN_GAMESPLAYED 62
#define UCONST_STATS_COLUMN_SKILL 61
#define UCONST_STATS_VIEW_WINGMANALLTIMEPRIVATE 59
#define UCONST_STATS_VIEW_WARZONEALLTIMEPRIVATE 58
#define UCONST_STATS_VIEW_MEATFLAGALLTIMEPRIVATE 57
#define UCONST_STATS_VIEW_KOTHALLTIMEPRIVATE 56
#define UCONST_STATS_VIEW_GUARDIANALLTIMEPRIVATE 55
#define UCONST_STATS_VIEW_EXECUTIONALLTIMEPRIVATE 54
#define UCONST_STATS_VIEW_MEATFLAGALLTIME 29
#define UCONST_STATS_VIEW_MEATFLAGMONTHLY 28
#define UCONST_STATS_VIEW_MEATFLAGWEEKLY 27
#define UCONST_STATS_VIEW_MEATFLAGDAILY 26
#define UCONST_STATS_VIEW_KOTHALLTIME 25
#define UCONST_STATS_VIEW_KOTHMONTHLY 24
#define UCONST_STATS_VIEW_KOTHWEEKLY 23
#define UCONST_STATS_VIEW_KOTHDAILY 22
#define UCONST_STATS_VIEW_ANNEXALLTIME 21
#define UCONST_STATS_VIEW_ANNEXMONTHLY 20
#define UCONST_STATS_VIEW_ANNEXWEEKLY 19
#define UCONST_STATS_VIEW_ANNEXDAILY 18
#define UCONST_STATS_VIEW_WINGMANALLTIME 17
#define UCONST_STATS_VIEW_WINGMANMONTHLY 16
#define UCONST_STATS_VIEW_WINGMANWEEKLY 15
#define UCONST_STATS_VIEW_WINGMANDAILY 14
#define UCONST_STATS_VIEW_GUARDIANALLTIME 13
#define UCONST_STATS_VIEW_GUARDIANMONTHLY 12
#define UCONST_STATS_VIEW_GUARDIANWEEKLY 11
#define UCONST_STATS_VIEW_GUARDIANDAILY 10
#define UCONST_STATS_VIEW_EXECUTIONALLTIME 9
#define UCONST_STATS_VIEW_EXECUTIONMONTHLY 8
#define UCONST_STATS_VIEW_EXECUTIONWEEKLY 7
#define UCONST_STATS_VIEW_EXECUTIONDAILY 6
#define UCONST_STATS_VIEW_WARZONEMONTHLY 5
#define UCONST_STATS_VIEW_WARZONEWEEKLY 4
#define UCONST_STATS_VIEW_WARZONEDAILY 3
#define UCONST_STATS_VIEW_ANNEXALLTIMEPRIVATE 2
#define UCONST_STATS_VIEW_WARZONEALLTIME 1
#define UCONST_CONTEXT_COOP_INVITE 14
#define UCONST_PROPERTY_CHAPTERNUM 0x10000003
#define UCONST_PROPERTY_ACTNUM 0x10000002
#define UCONST_CONTEXT_WINGMAN_SCOREGOAL_30 4
#define UCONST_CONTEXT_WINGMAN_SCOREGOAL_25 3
#define UCONST_CONTEXT_WINGMAN_SCOREGOAL_20 2
#define UCONST_CONTEXT_WINGMAN_SCOREGOAL_15 1
#define UCONST_CONTEXT_WINGMAN_SCOREGOAL_10 0
#define UCONST_CONTEXT_WINGMAN_SCOREGOAL 13
#define UCONST_CONTEXT_HORDE_WAVE_49 49
#define UCONST_CONTEXT_HORDE_WAVE_48 48
#define UCONST_CONTEXT_HORDE_WAVE_47 47
#define UCONST_CONTEXT_HORDE_WAVE_46 46
#define UCONST_CONTEXT_HORDE_WAVE_45 45
#define UCONST_CONTEXT_HORDE_WAVE_44 44
#define UCONST_CONTEXT_HORDE_WAVE_43 43
#define UCONST_CONTEXT_HORDE_WAVE_42 42
#define UCONST_CONTEXT_HORDE_WAVE_41 41
#define UCONST_CONTEXT_HORDE_WAVE_40 40
#define UCONST_CONTEXT_HORDE_WAVE_39 39
#define UCONST_CONTEXT_HORDE_WAVE_38 38
#define UCONST_CONTEXT_HORDE_WAVE_37 37
#define UCONST_CONTEXT_HORDE_WAVE_36 36
#define UCONST_CONTEXT_HORDE_WAVE_35 35
#define UCONST_CONTEXT_HORDE_WAVE_34 34
#define UCONST_CONTEXT_HORDE_WAVE_33 33
#define UCONST_CONTEXT_HORDE_WAVE_32 32
#define UCONST_CONTEXT_HORDE_WAVE_31 31
#define UCONST_CONTEXT_HORDE_WAVE_30 30
#define UCONST_CONTEXT_HORDE_WAVE_29 29
#define UCONST_CONTEXT_HORDE_WAVE_28 28
#define UCONST_CONTEXT_HORDE_WAVE_27 27
#define UCONST_CONTEXT_HORDE_WAVE_26 26
#define UCONST_CONTEXT_HORDE_WAVE_25 25
#define UCONST_CONTEXT_HORDE_WAVE_24 24
#define UCONST_CONTEXT_HORDE_WAVE_23 23
#define UCONST_CONTEXT_HORDE_WAVE_22 22
#define UCONST_CONTEXT_HORDE_WAVE_21 21
#define UCONST_CONTEXT_HORDE_WAVE_20 20
#define UCONST_CONTEXT_HORDE_WAVE_19 19
#define UCONST_CONTEXT_HORDE_WAVE_18 18
#define UCONST_CONTEXT_HORDE_WAVE_17 17
#define UCONST_CONTEXT_HORDE_WAVE_16 16
#define UCONST_CONTEXT_HORDE_WAVE_15 15
#define UCONST_CONTEXT_HORDE_WAVE_14 14
#define UCONST_CONTEXT_HORDE_WAVE_13 13
#define UCONST_CONTEXT_HORDE_WAVE_12 12
#define UCONST_CONTEXT_HORDE_WAVE_11 11
#define UCONST_CONTEXT_HORDE_WAVE_10 10
#define UCONST_CONTEXT_HORDE_WAVE_9 9
#define UCONST_CONTEXT_HORDE_WAVE_8 8
#define UCONST_CONTEXT_HORDE_WAVE_7 7
#define UCONST_CONTEXT_HORDE_WAVE_6 6
#define UCONST_CONTEXT_HORDE_WAVE_5 5
#define UCONST_CONTEXT_HORDE_WAVE_4 4
#define UCONST_CONTEXT_HORDE_WAVE_3 3
#define UCONST_CONTEXT_HORDE_WAVE_2 2
#define UCONST_CONTEXT_HORDE_WAVE_1 1
#define UCONST_CONTEXT_HORDE_WAVE_0 0
#define UCONST_CONTEXT_HORDE_WAVE 12
#define UCONST_CONTEXT_NUMBOTS_9 9
#define UCONST_CONTEXT_NUMBOTS_8 8
#define UCONST_CONTEXT_NUMBOTS_7 7
#define UCONST_CONTEXT_NUMBOTS_6 6
#define UCONST_CONTEXT_NUMBOTS_5 5
#define UCONST_CONTEXT_NUMBOTS_4 4
#define UCONST_CONTEXT_NUMBOTS_3 3
#define UCONST_CONTEXT_NUMBOTS_2 2
#define UCONST_CONTEXT_NUMBOTS_1 1
#define UCONST_CONTEXT_NUMBOTS_0 0
#define UCONST_CONTEXT_NUMBOTS 11
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_240 6
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_210 5
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_180 4
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_150 3
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_120 2
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_90 1
#define UCONST_CONTEXT_ROUNDSCORE_KOTH_60 0
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_480 6
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_420 5
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_360 4
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_300 3
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_240 2
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_180 1
#define UCONST_CONTEXT_ROUNDSCORE_ANNEX_120 0
#define UCONST_CONTEXT_ROUNDSCORE 10
#define UCONST_CONTEXT_AIDIFFICULTY_INSANE 3
#define UCONST_CONTEXT_AIDIFFICULTY_HARDCORE 2
#define UCONST_CONTEXT_AIDIFFICULTY_NORMAL 1
#define UCONST_CONTEXT_AIDIFFICULTY_CASUAL 0
#define UCONST_CONTEXT_MEATFLAGDIFFICULTY 9
#define UCONST_CONTEXT_ENEMYDIFFICULTY 8
#define UCONST_CONTEXT_BOTDIFFICULTY 7
#define UCONST_CONTEXT_ROUNDSTOWIN_FIFTEEN 14
#define UCONST_CONTEXT_ROUNDSTOWIN_FOURTEEN 13
#define UCONST_CONTEXT_ROUNDSTOWIN_THIRTEEN 12
#define UCONST_CONTEXT_ROUNDSTOWIN_TWELVE 11
#define UCONST_CONTEXT_ROUNDSTOWIN_ELEVEN 10
#define UCONST_CONTEXT_ROUNDSTOWIN_TEN 9
#define UCONST_CONTEXT_ROUNDSTOWIN_NINE 8
#define UCONST_CONTEXT_ROUNDSTOWIN_EIGHT 7
#define UCONST_CONTEXT_ROUNDSTOWIN_SEVEN 6
#define UCONST_CONTEXT_ROUNDSTOWIN_SIX 5
#define UCONST_CONTEXT_ROUNDSTOWIN_FIVE 4
#define UCONST_CONTEXT_ROUNDSTOWIN_FOUR 3
#define UCONST_CONTEXT_ROUNDSTOWIN_THREE 2
#define UCONST_CONTEXT_ROUNDSTOWIN_TWO 1
#define UCONST_CONTEXT_ROUNDSTOWIN_ONE 0
#define UCONST_CONTEXT_ROUNDSTOWIN 6
#define UCONST_CONTEXT_WEAPONSWAP_CUSTOM 2
#define UCONST_CONTEXT_WEAPONSWAP_NORMAL 1
#define UCONST_CONTEXT_WEAPONSWAP_CYCLE 0
#define UCONST_CONTEXT_WEAPONSWAP 5
#define UCONST_CONTEXT_BLEEDOUTTIME_SIXTY 5
#define UCONST_CONTEXT_BLEEDOUTTIME_THIRTY 4
#define UCONST_CONTEXT_BLEEDOUTTIME_TWENTY 3
#define UCONST_CONTEXT_BLEEDOUTTIME_FIFTEEN 2
#define UCONST_CONTEXT_BLEEDOUTTIME_TEN 1
#define UCONST_CONTEXT_BLEEDOUTTIME_FIVE 0
#define UCONST_CONTEXT_BLEEDOUTTIME 4
#define UCONST_CONTEXT_ROUNDTIME_TEN 9
#define UCONST_CONTEXT_ROUNDTIME_NINE 8
#define UCONST_CONTEXT_ROUNDTIME_EIGHT 7
#define UCONST_CONTEXT_ROUNDTIME_SEVEN 6
#define UCONST_CONTEXT_ROUNDTIME_SIX 5
#define UCONST_CONTEXT_ROUNDTIME_FIVE 4
#define UCONST_CONTEXT_ROUNDTIME_FOUR 3
#define UCONST_CONTEXT_ROUNDTIME_THREE 2
#define UCONST_CONTEXT_ROUNDTIME_TWO 1
#define UCONST_CONTEXT_ROUNDTIME_ONE 0
#define UCONST_CONTEXT_ROUNDTIME 3
#define UCONST_CONTEXT_FRIENDLYFIRE_YES 1
#define UCONST_CONTEXT_FRIENDLYFIRE_NO 0
#define UCONST_CONTEXT_FRIENDLYFIRE 2
#define UCONST_CONTEXT_MAPNAME_WAYSTATION 3
#define UCONST_CONTEXT_MAPNAME_HAIL 2
#define UCONST_CONTEXT_MAPNAME_GRIDLOCK 1
#define UCONST_CONTEXT_MAPNAME_FLOOD 0
#define UCONST_CONTEXT_MAPNAME 1
#define UCONST_CONTEXT_VERSUSMODES 0
#define UCONST_PROPERTY_PLAYLISTID 0x1000000B
#define UCONST_CONTEXT_PARTYSLOT_ANY 3
#define UCONST_CONTEXT_PARTYSLOT_NEEDS 2
#define UCONST_CONTEXT_PARTYSLOT_WANTS 1
#define UCONST_CONTEXT_PARTYSLOT_BLOCKED 0
#define UCONST_CONTEXT_PARTYSLOT_5 6
#define UCONST_CONTEXT_PARTYSLOT_4 5
#define UCONST_CONTEXT_PARTYSLOT_3 4
#define UCONST_CONTEXT_PARTYSLOT_2 3
#define UCONST_CONTEXT_PARTYSLOT_1 2
#define UCONST_PROPERTY_ISPUBLICPARTY 0x10000001
#define UCONST_SESSION_MATCH_QUERY_VERSUS 2
#define UCONST_SESSION_MATCH_QUERY_PARTY 1
#define UCONST_SESSION_MATCH_QUERY_COOP 0
#define UCONST_CONTEXT_GAME_MODE_VERSUS 2
#define UCONST_CONTEXT_GAME_MODE_PARTY 1
#define UCONST_CONTEXT_GAME_MODE_COOP 0
#define UCONST_CONTEXT_GAME_MODE 0x0000800B
#define UCONST_CONTEXT_COOPCHARNAME_DOM 1
#define UCONST_CONTEXT_COOPCHARNAME_MARCUS 0
#define UCONST_CONTEXT_COOPCHARNAME 7
#define UCONST_CONTEXT_PRESENCE_TRAININGGROUNDSPRESENCE 11
#define UCONST_CONTEXT_PRESENCE_HORDEPRESENCE 10
#define UCONST_CONTEXT_PRESENCE_PRIVATEVERSUSPRESENCE 9
#define UCONST_CONTEXT_PRESENCE_SYSTEMLINKVERSUSPRESENCE 8
#define UCONST_CONTEXT_PRESENCE_CAMPAIGNPARTYPRESENCE 7
#define UCONST_CONTEXT_PRESENCE_SYSTEMLINKPARTYPRESENCE 6
#define UCONST_CONTEXT_PRESENCE_PRIVATEPARTYPRESENCE 5
#define UCONST_CONTEXT_PRESENCE_VERSUSPRESENCE 4
#define UCONST_CONTEXT_PRESENCE_PARTYSEARCHPRESENCE 3
#define UCONST_CONTEXT_PRESENCE_PARTYWAITPRESENCE 2
#define UCONST_CONTEXT_PRESENCE_COOPPRESENCE 1
#define UCONST_CONTEXT_PRESENCE_MENUPRESENCE 0

class UGearLeaderboardsDataStoreBase : public UUIDataStore_OnlineStats
{
public:
    //## BEGIN PROPS GearLeaderboardsDataStoreBase
    class UClass* LeaderboardSettingsClass;
    class USettings* LeaderboardSettings;
    class UUIDataProvider_Settings* SettingsProvider;
    //## END PROPS GearLeaderboardsDataStoreBase

    DECLARE_CLASS(UGearLeaderboardsDataStoreBase,UUIDataStore_OnlineStats,0|CLASS_Transient,GearGame)
private:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered filter object
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Returns the stats read results as a collection and appends the filter provider
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields)
	{
		Super::GetSupportedDataFields(OutFields);
		// Append our settings provider
		new(OutFields)FUIDataProviderField(FName(TEXT("Filters")),DATATYPE_Provider,SettingsProvider);
	}

	/**
	 * Returns the list element provider for the specified proprety name
	 *
	 * @param PropertyName the name of the property to look up
	 *
	 * @return pointer to the interface or null if the property name is invalid
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName)
	{
		// Make a copy because we potentially modify the string
		FString CompareName(PropertyName);
		FString ProviderName;
		// If there is an intervening provider name, snip it off
		if (ParseNextDataTag(CompareName,ProviderName) == FALSE)
		{
			CompareName = ProviderName;
		}
		// Check for the stats results
		if (FName(*CompareName) == StatsReadName)
		{
			return this;
		}
		// See if this is for one of our filters
		return SettingsProvider->ResolveListElementProvider(CompareName);
	}
};

struct FControllerMap
{
    FName KeyName;
    FStringNoInit XBoxMapping;

    /** Constructors */
    FControllerMap() {}
    FControllerMap(EEventParm)
    {
        appMemzero(this, sizeof(FControllerMap));
    }
};

struct FBindCacheElement
{
    FName KeyName;
    FStringNoInit MappingString;
    INT FieldIndex;

    /** Constructors */
    FBindCacheElement() {}
    FBindCacheElement(EEventParm)
    {
        appMemzero(this, sizeof(FBindCacheElement));
    }
};

#define UCONST_SABM_FIND_FIRST_BIND -2

class UGearUIDataStore_StringAliasBindingsMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS GearUIDataStore_StringAliasBindingsMap
    BITFIELD bPreviousUsingGamepadValue:1;
    TMap<FName, FBindCacheElement> CommandToBindNames;
    TArrayNoInit<struct FControllerMap> ControllerMapArray;
    //## END PROPS GearUIDataStore_StringAliasBindingsMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    virtual INT GetBoundStringWithFieldName(const FString& FieldName,FString& MappedString,INT* StartIndex=NULL,FString* BindString=NULL);
    UBOOL FindMappingInBoundKeyCache(const FString& Command,FString& MappingStr,INT& FieldIndex);
    void AddMappingToBoundKeyCache(const FString& Command,const FString& MappingStr,INT FieldIndex);
    void ClearBoundKeyCache();
    DECLARE_FUNCTION(execGetBoundStringWithFieldName)
    {
        P_GET_STR(FieldName);
        P_GET_STR_REF(MappedString);
        P_GET_INT_OPTX_REF(StartIndex,0);
        P_GET_STR_OPTX_REF(BindString,TEXT(""));
        P_FINISH;
        *(INT*)Result=GetBoundStringWithFieldName(FieldName,MappedString,pStartIndex ? &StartIndex : NULL,pBindString ? &BindString : NULL);
    }
    DECLARE_FUNCTION(execFindMappingInBoundKeyCache)
    {
        P_GET_STR(Command);
        P_GET_STR_REF(MappingStr);
        P_GET_INT_REF(FieldIndex);
        P_FINISH;
        *(UBOOL*)Result=FindMappingInBoundKeyCache(Command,MappingStr,FieldIndex);
    }
    DECLARE_FUNCTION(execAddMappingToBoundKeyCache)
    {
        P_GET_STR(Command);
        P_GET_STR(MappingStr);
        P_GET_INT(FieldIndex);
        P_FINISH;
        AddMappingToBoundKeyCache(Command,MappingStr,FieldIndex);
    }
    DECLARE_FUNCTION(execClearBoundKeyCache)
    {
        P_FINISH;
        ClearBoundKeyCache();
    }
    DECLARE_CLASS(UGearUIDataStore_StringAliasBindingsMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

    NO_DEFAULT_CONSTRUCTOR(UGearUIDataStore_StringAliasBindingsMap)
};

class UGearUIDataStore_StringAliasMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS GearUIDataStore_StringAliasMap
    //## END PROPS GearUIDataStore_StringAliasMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_CLASS(UGearUIDataStore_StringAliasMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

    NO_DEFAULT_CONSTRUCTOR(UGearUIDataStore_StringAliasMap)
};

struct FNavigationItemData
{
    FStringNoInit ItemTag;
    FStringNoInit DestinationScenePath;
    FStringNoInit AttractMarkId;
    class UUIScene* DestinationScene;
    FStringNoInit DisplayName;
    FStringNoInit ItemHelpText;
    BITFIELD bDisplayAttractIcon:1;
    BITFIELD bItemDisabled:1;

    /** Constructors */
    FNavigationItemData() {}
    FNavigationItemData(EEventParm)
    {
        appMemzero(this, sizeof(FNavigationItemData));
    }
};

class UGearDataProvider_SceneNavigationData : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS GearDataProvider_SceneNavigationData
    TArrayNoInit<struct FNavigationItemData> NavigationItems;
    FStringNoInit AttractIconMarkup;
    //## END PROPS GearDataProvider_SceneNavigationData

    DECLARE_CLASS(UGearDataProvider_SceneNavigationData,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters )
	{
		// we never want our elements to be sorted
		return TRUE;
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct FStringValueCollection
{
    FName CollectionName;
    FStringNoInit CollectionFriendlyName;
    INT CurrentValueIndex;
    INT DefaultValueIndex;
    TArrayNoInit<FString> StringValues;

    /** Constructors */
    FStringValueCollection() {}
    FStringValueCollection(EEventParm)
    {
        appMemzero(this, sizeof(FStringValueCollection));
    }
};

class UGearDataProvider_StringValueCollection : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS GearDataProvider_StringValueCollection
    TArrayNoInit<struct FStringValueCollection> StringValueCollections;
    //## END PROPS GearDataProvider_StringValueCollection

    INT FindCollectionIndex(FName CollectionTag) const;
    INT FindStringValueIndex(FName CollectionTag,const FString& SearchString) const;
    DECLARE_FUNCTION(execFindCollectionIndex)
    {
        P_GET_NAME(CollectionTag);
        P_FINISH;
        *(INT*)Result=FindCollectionIndex(CollectionTag);
    }
    DECLARE_FUNCTION(execFindStringValueIndex)
    {
        P_GET_NAME(CollectionTag);
        P_GET_STR(SearchString);
        P_FINISH;
        *(INT*)Result=FindStringValueIndex(CollectionTag,SearchString);
    }
    DECLARE_CLASS(UGearDataProvider_StringValueCollection,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters )
	{
		// we never want our elements to be sorted
		return TRUE;
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UGearResourceDataProvider : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS GearResourceDataProvider
    //## END PROPS GearResourceDataProvider

    DECLARE_ABSTRACT_CLASS(UGearResourceDataProvider,UUIResourceDataProvider,0|CLASS_Transient,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UGearResourceDataProvider)
};

class UGearCampaignResourceProvider : public UGearResourceDataProvider
{
public:
    //## BEGIN PROPS GearCampaignResourceProvider
    BYTE ActType GCC_BITFIELD_MAGIC;
    FStringNoInit ScreenshotPathName;
    FStringNoInit DisplayName;
    FStringNoInit ListName;
    FStringNoInit Description;
    TArrayNoInit<class UGearCollectableDataProvider*> Collectables;
    //## END PROPS GearCampaignResourceProvider

    DECLARE_ABSTRACT_CLASS(UGearCampaignResourceProvider,UGearResourceDataProvider,0|CLASS_Transient|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearCampaignResourceProvider)
};

class UGearCampaignActData : public UGearCampaignResourceProvider
{
public:
    //## BEGIN PROPS GearCampaignActData
    TArrayNoInit<class UGearCampaignChapterData*> ChapterProviders;
    BITFIELD bRequiredActForGameCompletion:1;
    //## END PROPS GearCampaignActData

    DECLARE_CLASS(UGearCampaignActData,UGearCampaignResourceProvider,0|CLASS_Transient|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearCampaignActData)
};

class UGearCampaignChapterData : public UGearCampaignResourceProvider
{
public:
    //## BEGIN PROPS GearCampaignChapterData
    BYTE ChapterType;
    FStringNoInit MapName;
    //## END PROPS GearCampaignChapterData

    DECLARE_CLASS(UGearCampaignChapterData,UGearCampaignResourceProvider,0|CLASS_Transient|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearCampaignChapterData)
};

class UGearCollectableDataProvider : public UGearResourceDataProvider
{
public:
    //## BEGIN PROPS GearCollectableDataProvider
    BYTE CollectableId GCC_BITFIELD_MAGIC;
    BYTE ContainingChapterId;
    FStringNoInit CollectableName;
    FStringNoInit CollectableDetails;
    FStringNoInit LockedIcon_Markup;
    FStringNoInit UnlockedIcon_Markup;
    FStringNoInit UnlockedImage_Markup;
    class UGearCampaignChapterData* ContainingChapterProvider;
    //## END PROPS GearCollectableDataProvider

    DECLARE_CLASS(UGearCollectableDataProvider,UGearResourceDataProvider,0|CLASS_Transient|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearCollectableDataProvider)
};

struct FGeneratedObjectInfo
{
    FName OptionProviderName;
    class UUIObject* LabelObj;
    class UUIObject* OptionObj;
    class UUIDataProvider* OptionProvider;
    FLOAT OptionY;
    FLOAT OptionHeight;
    FLOAT OptionX;
    FLOAT OptionWidth;

    /** Constructors */
    FGeneratedObjectInfo() {}
    FGeneratedObjectInfo(EEventParm)
    {
        appMemzero(this, sizeof(FGeneratedObjectInfo));
    }
};

struct GearUIObjectList_eventSetupOptionBindings_Parms
{
    GearUIObjectList_eventSetupOptionBindings_Parms(EEventParm)
    {
    }
};
struct GearUIObjectList_eventOnRegeneratedOptions_Parms
{
    class UGearUIObjectList* ObjectList;
    GearUIObjectList_eventOnRegeneratedOptions_Parms(EEventParm)
    {
    }
};
struct GearUIObjectList_eventOnAcceptOptions_Parms
{
    class UUIScreenObject* InObject;
    INT PlayerIndex;
    GearUIObjectList_eventOnAcceptOptions_Parms(EEventParm)
    {
    }
};
struct GearUIObjectList_eventOnListOptionSubmitted_Parms
{
    class UUIList* InListObject;
    FName OptionName;
    INT PlayerIndex;
    GearUIObjectList_eventOnListOptionSubmitted_Parms(EEventParm)
    {
    }
};
struct GearUIObjectList_eventOnOptionChanged_Parms
{
    class UUIScreenObject* InObject;
    FName OptionName;
    INT PlayerIndex;
    GearUIObjectList_eventOnOptionChanged_Parms(EEventParm)
    {
    }
};
struct GearUIObjectList_eventOnOptionFocused_Parms
{
    class UUIScreenObject* InObject;
    class UUIDataProvider* OptionProvider;
    GearUIObjectList_eventOnOptionFocused_Parms(EEventParm)
    {
    }
};
class UGearUIObjectList : public UUIObject, public IUIDataStoreSubscriber, public IUITickableObject
{
public:
    //## BEGIN PROPS GearUIObjectList
    class UUIScrollbar* VerticalScrollbar;
    INT CurrentIndex;
    INT PreviousIndex;
    FLOAT StartMovementTime;
    BITFIELD bAnimatingBGPrefab:1;
    BITFIELD bClosedListNavigation:1;
private:
    BITFIELD bRepositionOptions:1;
    BITFIELD bRegenOptions:1;
public:
    TArrayNoInit<struct FGeneratedObjectInfo> GeneratedObjects;
    struct FUIDataStoreBinding DataSource;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    class UUIPrefab* BGPrefab;
    struct FUIScreenValue_Extent OptionHeight;
    struct FUIScreenValue_Extent OptionPadding;
    struct FUIScreenValue_Extent OptionSize;
    struct FUIScreenValue_Extent CollapsingListCaptionSize;
    FName LabelCaptionStyleName;
    FName LabelBackgroundStyleName;
    class UUIComp_DrawImage* SelectionOverlayImage;
    FLOAT OverlayImageBounds[4];
    class UUIPrefabInstance* BGPrefabInstance;
    INT MaxVisibleItems;
    class UClass* SpinnerClass;
    class UClass* SliderClass;
    class UClass* EditboxClass;
    class UClass* CheckboxClass;
    class UClass* ComboBoxClass;
    class UClass* ConsoleOptionClass;
    FScriptDelegate __OnOptionFocused__Delegate;
    FScriptDelegate __OnOptionChanged__Delegate;
    FScriptDelegate __OnListOptionSubmitted__Delegate;
    FScriptDelegate __OnAcceptOptions__Delegate;
    FScriptDelegate __OnRegeneratedOptions__Delegate;
    //## END PROPS GearUIObjectList

    void RequestOptionListReformat();
    void RequestOptionListRegeneration();
    virtual void SetSelectedOptionIndex(INT OptionIdx);
    virtual void InitializeComboboxWidgets();
    virtual void InitializeScrollbars();
    UBOOL IsValidListOption(class UUIObject* CheckObj) const;
    INT FindObjectIndexByName(FName ProviderName) const;
    INT FindObjectIndexByRef(class UUIObject* SearchObj) const;
    class UUIObject* GetSelectedOption() const;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    DECLARE_FUNCTION(execRequestOptionListReformat)
    {
        P_FINISH;
        RequestOptionListReformat();
    }
    DECLARE_FUNCTION(execRequestOptionListRegeneration)
    {
        P_FINISH;
        RequestOptionListRegeneration();
    }
    DECLARE_FUNCTION(execSetSelectedOptionIndex)
    {
        P_GET_INT(OptionIdx);
        P_FINISH;
        SetSelectedOptionIndex(OptionIdx);
    }
    DECLARE_FUNCTION(execInitializeComboboxWidgets)
    {
        P_FINISH;
        InitializeComboboxWidgets();
    }
    DECLARE_FUNCTION(execInitializeScrollbars)
    {
        P_FINISH;
        InitializeScrollbars();
    }
    DECLARE_FUNCTION(execIsValidListOption)
    {
        P_GET_OBJECT(UUIObject,CheckObj);
        P_FINISH;
        *(UBOOL*)Result=IsValidListOption(CheckObj);
    }
    DECLARE_FUNCTION(execFindObjectIndexByName)
    {
        P_GET_NAME(ProviderName);
        P_FINISH;
        *(INT*)Result=FindObjectIndexByName(ProviderName);
    }
    DECLARE_FUNCTION(execFindObjectIndexByRef)
    {
        P_GET_OBJECT(UUIObject,SearchObj);
        P_FINISH;
        *(INT*)Result=FindObjectIndexByRef(SearchObj);
    }
    DECLARE_FUNCTION(execGetSelectedOption)
    {
        P_FINISH;
        *(class UUIObject**)Result=GetSelectedOption();
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    void eventSetupOptionBindings()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_SetupOptionBindings),NULL);
    }
    void delegateOnRegeneratedOptions(class UGearUIObjectList* ObjectList)
    {
        GearUIObjectList_eventOnRegeneratedOptions_Parms Parms(EC_EventParm);
        Parms.ObjectList=ObjectList;
        ProcessDelegate(GEARGAME_OnRegeneratedOptions,&__OnRegeneratedOptions__Delegate,&Parms);
    }
    void delegateOnAcceptOptions(class UUIScreenObject* InObject,INT PlayerIndex)
    {
        GearUIObjectList_eventOnAcceptOptions_Parms Parms(EC_EventParm);
        Parms.InObject=InObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(GEARGAME_OnAcceptOptions,&__OnAcceptOptions__Delegate,&Parms);
    }
    void delegateOnListOptionSubmitted(class UUIList* InListObject,FName OptionName,INT PlayerIndex)
    {
        GearUIObjectList_eventOnListOptionSubmitted_Parms Parms(EC_EventParm);
        Parms.InListObject=InListObject;
        Parms.OptionName=OptionName;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(GEARGAME_OnListOptionSubmitted,&__OnListOptionSubmitted__Delegate,&Parms);
    }
    void delegateOnOptionChanged(class UUIScreenObject* InObject,FName OptionName,INT PlayerIndex)
    {
        GearUIObjectList_eventOnOptionChanged_Parms Parms(EC_EventParm);
        Parms.InObject=InObject;
        Parms.OptionName=OptionName;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(GEARGAME_OnOptionChanged,&__OnOptionChanged__Delegate,&Parms);
    }
    void delegateOnOptionFocused(class UUIScreenObject* InObject,class UUIDataProvider* OptionProvider)
    {
        GearUIObjectList_eventOnOptionFocused_Parms Parms(EC_EventParm);
        Parms.InObject=InObject;
        Parms.OptionProvider=OptionProvider;
        ProcessDelegate(GEARGAME_OnOptionFocused,&__OnOptionFocused__Delegate,&Parms);
    }
    DECLARE_CLASS(UGearUIObjectList,UUIObject,0|CLASS_Config,GearGame)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
    virtual UObject* GetUObjectInterfaceUITickableObject(){return this;}
protected:
	/* === UGearUIObjectList interface === */
	/** Generates widgets for all of the options. */
	virtual void RegenerateOptions();

	/** Repositions all of the visible options. */
	virtual void RepositionOptions();

public:
	/* === UUIObject interface === */
	/**
	 * Repositions all option widgets.
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void Render_Children( FCanvas* Canvas, EUIPostProcessGroup UIPostProcessGroup );

	/* === IUITickableObject interface === */
	/**
	 * Called each frame to allow the object to perform work.  This version updates the positioning of the background prefab.
	 *
	 * @param	PreviousFrameSeconds	amount of time (in seconds) between the start of this frame and the start of the previous frame.
	 */
	virtual void Tick( FLOAT PreviousFrameSeconds );

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version removes all items from the Children array and flags the widget to regenerate them.
	 */
	virtual void PreSave();
};

#define UCONST_COLLAPSESELECTION_CAPTION_DATABINDING_INDEX 1
#define UCONST_COLLAPSESELECTION_LIST_DATABINDING_INDEX 0

struct GearUICollapsingSelectionList_eventOnListExpanding_Parms
{
    GearUICollapsingSelectionList_eventOnListExpanding_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventOnListCollapsing_Parms
{
    GearUICollapsingSelectionList_eventOnListCollapsing_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventListExpansionComplete_Parms
{
    GearUICollapsingSelectionList_eventListExpansionComplete_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventListExpansionBegin_Parms
{
    GearUICollapsingSelectionList_eventListExpansionBegin_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventListCollapseComplete_Parms
{
    GearUICollapsingSelectionList_eventListCollapseComplete_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventListCollapseBegin_Parms
{
    GearUICollapsingSelectionList_eventListCollapseBegin_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventCanSubmitValue_Parms
{
    class UGearUICollapsingSelectionList* Sender;
    INT PlayerIndex;
    UBOOL ReturnValue;
    GearUICollapsingSelectionList_eventCanSubmitValue_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventOnListExpanded_Parms
{
    class UGearUICollapsingSelectionList* Sender;
    GearUICollapsingSelectionList_eventOnListExpanded_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventOnListCollapsed_Parms
{
    class UGearUICollapsingSelectionList* Sender;
    GearUICollapsingSelectionList_eventOnListCollapsed_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventIsExpandAllowed_Parms
{
    class UGearUICollapsingSelectionList* Sender;
    UBOOL ReturnValue;
    GearUICollapsingSelectionList_eventIsExpandAllowed_Parms(EEventParm)
    {
    }
};
struct GearUICollapsingSelectionList_eventIsCollapseAllowed_Parms
{
    class UGearUICollapsingSelectionList* Sender;
    UBOOL ReturnValue;
    GearUICollapsingSelectionList_eventIsCollapseAllowed_Parms(EEventParm)
    {
    }
};
class UGearUICollapsingSelectionList : public UUIList
{
public:
    //## BEGIN PROPS GearUICollapsingSelectionList
    class UUIComp_DrawString* CaptionComponent;
    class UUIComp_DrawString* ValueComponent;
    class UUIComp_DrawImage* FocusIndicator;
    struct FUIDataStoreBinding CaptionDataSource;
    struct FUIScreenValue_Extent CaptionSize;
    struct FUIScreenValue_Extent ValueSize;
    struct FUIScreenValue_Extent ListIndent;
    struct FUIScreenValue_Extent FocusIndicatorSize;
    BITFIELD bIndexChangeUpdatesValue:1;
    BITFIELD bFadingSelectionHintOut:1;
    struct FUIScreenValue_Extent VertBackgroundPadding[2];
    struct FUIScreenValue_Extent HorzBackgroundPadding[2];
    BYTE ListExpansionState;
    class UUIAnimationSeq* CollapseAnimation;
    class UUIAnimationSeq* ExpandAnimation;
    class UUIAnimationSeq* ExpandFocusHintAnimation;
    class UUIAnimationSeq* CollapseFocusHintAnimation;
    INT SubmittedIndex;
    FName ExpandCue;
    FName CollapseAcceptCue;
    FName CollapseCancelCue;
    FScriptDelegate __IsCollapseAllowed__Delegate;
    FScriptDelegate __IsExpandAllowed__Delegate;
    FScriptDelegate __OnListCollapsed__Delegate;
    FScriptDelegate __OnListExpanded__Delegate;
    FScriptDelegate __CanSubmitValue__Delegate;
    //## END PROPS GearUICollapsingSelectionList

    FLOAT GetMaxLabelHeight() const;
    FLOAT GetCaptionLabelHeight() const;
    FLOAT GetValueLabelHeight() const;
    UBOOL Expand();
    UBOOL Collapse();
    virtual void ListCollapseBegin();
    virtual void ListCollapseComplete();
    virtual void ListExpansionBegin();
    virtual void ListExpansionComplete();
    UBOOL SetStringValue(const FString& StringToSelect);
    virtual UBOOL SetIndexValue(INT NewIndex,INT PlayerIndex,UBOOL bClampValue=TRUE,UBOOL bSkipNotification=FALSE);
    DECLARE_FUNCTION(execGetMaxLabelHeight)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMaxLabelHeight();
    }
    DECLARE_FUNCTION(execGetCaptionLabelHeight)
    {
        P_FINISH;
        *(FLOAT*)Result=GetCaptionLabelHeight();
    }
    DECLARE_FUNCTION(execGetValueLabelHeight)
    {
        P_FINISH;
        *(FLOAT*)Result=GetValueLabelHeight();
    }
    DECLARE_FUNCTION(execExpand)
    {
        P_FINISH;
        *(UBOOL*)Result=Expand();
    }
    DECLARE_FUNCTION(execCollapse)
    {
        P_FINISH;
        *(UBOOL*)Result=Collapse();
    }
    DECLARE_FUNCTION(execListCollapseBegin)
    {
        P_FINISH;
        ListCollapseBegin();
    }
    DECLARE_FUNCTION(execListCollapseComplete)
    {
        P_FINISH;
        ListCollapseComplete();
    }
    DECLARE_FUNCTION(execListExpansionBegin)
    {
        P_FINISH;
        ListExpansionBegin();
    }
    DECLARE_FUNCTION(execListExpansionComplete)
    {
        P_FINISH;
        ListExpansionComplete();
    }
    DECLARE_FUNCTION(execSetStringValue)
    {
        P_GET_STR(StringToSelect);
        P_FINISH;
        *(UBOOL*)Result=SetStringValue(StringToSelect);
    }
    DECLARE_FUNCTION(execSetIndexValue)
    {
        P_GET_INT(NewIndex);
        P_GET_INT(PlayerIndex);
        P_GET_UBOOL_OPTX(bClampValue,TRUE);
        P_GET_UBOOL_OPTX(bSkipNotification,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetIndexValue(NewIndex,PlayerIndex,bClampValue,bSkipNotification);
    }
    DECLARE_FUNCTION(execSetCellBinding)
    {
        P_GET_NAME(CellDataBinding);
        P_GET_STR_REF(ColumnHeader);
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(UBOOL*)Result=SetCellBinding(CellDataBinding,ColumnHeader,BindingIndex);
    }
    void eventOnListExpanding()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_OnListExpanding),NULL);
    }
    void eventOnListCollapsing()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_OnListCollapsing),NULL);
    }
    void eventListExpansionComplete()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ListExpansionComplete),NULL);
    }
    void eventListExpansionBegin()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ListExpansionBegin),NULL);
    }
    void eventListCollapseComplete()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ListCollapseComplete),NULL);
    }
    void eventListCollapseBegin()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ListCollapseBegin),NULL);
    }
    UBOOL delegateCanSubmitValue(class UGearUICollapsingSelectionList* Sender,INT PlayerIndex)
    {
        GearUICollapsingSelectionList_eventCanSubmitValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(GEARGAME_CanSubmitValue,&__CanSubmitValue__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnListExpanded(class UGearUICollapsingSelectionList* Sender)
    {
        GearUICollapsingSelectionList_eventOnListExpanded_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(GEARGAME_OnListExpanded,&__OnListExpanded__Delegate,&Parms);
    }
    void delegateOnListCollapsed(class UGearUICollapsingSelectionList* Sender)
    {
        GearUICollapsingSelectionList_eventOnListCollapsed_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(GEARGAME_OnListCollapsed,&__OnListCollapsed__Delegate,&Parms);
    }
    UBOOL delegateIsExpandAllowed(class UGearUICollapsingSelectionList* Sender)
    {
        GearUICollapsingSelectionList_eventIsExpandAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        ProcessDelegate(GEARGAME_IsExpandAllowed,&__IsExpandAllowed__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateIsCollapseAllowed(class UGearUICollapsingSelectionList* Sender)
    {
        GearUICollapsingSelectionList_eventIsCollapseAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        ProcessDelegate(GEARGAME_IsCollapseAllowed,&__IsCollapseAllowed__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UGearUICollapsingSelectionList,UUIList,0|CLASS_Config,GearGame)
	/* === UGearUICollapsingSelectionList interface === */
	/** Wrappers for checking the state of the list */
	UBOOL IsExpanded() const
	{
		return ListExpansionState == LES_Expanded;
	}
	UBOOL IsExpanding() const
	{
		return ListExpansionState == LES_Expanding;
	}
	UBOOL IsCollapsed() const
	{
		return ListExpansionState == LES_Collapsed;
	}
	UBOOL IsCollapsing() const
	{
		return ListExpansionState == LES_Collapsing;
	}
	UBOOL IsTransitioning() const
	{
		return (IsCollapsing() || IsExpanding());
	}

	/* === UUIList interface === */
	/**
	 * Sets the list's index to the value specified and activates the appropriate notification events.
	 *
	 * @param	NewIndex			An index into the Items array that should become the new Index for the list.
	 * @param	bClampValue			if TRUE, NewIndex will be clamped to a valid value in the range of 0 -> ItemCount - 1
	 * @param	bSkipNotification	if TRUE, no events are generated as a result of updating the list's index.
	 *
	 * @return	TRUE if the list's Index was successfully changed.
	 */
	virtual UBOOL SetIndex( INT NewIndex, UBOOL bClampValue=TRUE, UBOOL bSkipNotification=FALSE );

	/**
	 * Called when the list's index has changed.
	 *
	 * @param	PreviousIndex	the list's Index before it was changed
	 * @param	PlayerIndex		the index of the player associated with this index change.
	 */
	virtual void NotifyIndexChanged( INT PreviousIndex, INT PlayerIndex );

	/**
	 * Called whenever the user chooses an item while this list is focused.  Activates the SubmitSelection kismet event and calls
	 * the OnSubmitSelection delegate.
	 */
	virtual void NotifySubmitSelection( INT PlayerIndex );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Wrapper for calculating the amount of additional room the list needs at the top to render headers or other things.
	 */
	virtual FLOAT GetHeaderSize() const;

	/**
	 * Render this list.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Renders the list's background image, if assigned.
	 */
	virtual void RenderBackgroundImage( FCanvas* Canvas, const FRenderParameters& Parameters );

	/**
	 * Called immediately before and after the scene perform an update.  Only called if bEnableSceneUpdateNotifications
	 * is set to TRUE on this widget.
	 */
	virtual void PreSceneUpdate();
	virtual void PostSceneUpdate();

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/** === IUIDataStorePublisher interface === */
	/**
	 * Sets the data store binding for this object to the text specified.
	 *
	 * @param	MarkupText			a markup string which resolves to data exposed by a data store.  The expected format is:
	 *								<DataStoreTag:DataFieldTag>
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 */
	virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=INDEX_NONE);

	/**
	 * Retrieves the markup string corresponding to the data store that this object is bound to.
	 *
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	a datastore markup string which resolves to the datastore field that this object is bound to, in the format:
	 *			<DataStoreTag:DataFieldTag>
	 */
	virtual FString GetDataStoreBinding(INT BindingIndex=INDEX_NONE) const;

	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/**
	 * Handler for the UIDataStore.OnDataStoreValueUpdated delegate.  Used by data stores to indicate that some data provided by the data
	 * has changed.  Subscribers should use this function to refresh any data store values being displayed with the updated value.
	 * notify subscribers when they should refresh their values from this data store.
	 *
	 * @param	SourceDataStore		the data store that generated the refresh notification; useful for subscribers with multiple data store
	 *								bindings, to tell which data store sent the notification.
	 * @param	PropertyTag			the tag associated with the data field that was updated; Subscribers can use this tag to determine whether
	 *								there is any need to refresh their data values.
	 * @param	SourceProvider		for data stores which contain nested providers, the provider that contains the data which changed.
	 * @param	ArrayIndex			for collection fields, indicates which element was changed.  value of INDEX_NONE indicates not an array
	 *								or that the entire array was updated.
	 */
	virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);

	/**
	 * Retrieves the list of data stores bound by this subscriber.
	 *
	 * @param	out_BoundDataStores		receives the array of data stores that subscriber is bound to.
	 */
	virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * Initializes the string components.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( class UUIScene* inOwnerScene, class UUIObject* inOwner=NULL );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

	/**
	 * Retrieves the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to retrieve
	 * @param	out_CurrentValue	receives the current data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_GetValue( BYTE AnimationType, FUIAnimationRawData& out_CurrentValue ) const;
	/**
	 * Updates the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to set
	 * @param	out_CurrentValue	contains the updated data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_SetValue( BYTE AnimationType, const FUIAnimationRawData& NewValue );

protected:
	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UGearUINavigationList : public UUINavigationList
{
public:
    //## BEGIN PROPS GearUINavigationList
    //## END PROPS GearUINavigationList

    DECLARE_CLASS(UGearUINavigationList,UUINavigationList,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(UGearUINavigationList)
};

#endif // !INCLUDED_GEARGAME_UIPRIVATE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGearDataProvider_StringValueCollection,-1,execFindStringValueIndex);
AUTOGENERATE_FUNCTION(UGearDataProvider_StringValueCollection,-1,execFindCollectionIndex);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execSetCellBinding);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execSetIndexValue);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execSetStringValue);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execListExpansionComplete);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execListExpansionBegin);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execListCollapseComplete);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execListCollapseBegin);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execCollapse);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execExpand);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execGetValueLabelHeight);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execGetCaptionLabelHeight);
AUTOGENERATE_FUNCTION(UGearUICollapsingSelectionList,-1,execGetMaxLabelHeight);
AUTOGENERATE_FUNCTION(UGearUIDataProvider_Screenshots,-1,execSortScreenshots);
AUTOGENERATE_FUNCTION(UGearUIDataStore_StringAliasBindingsMap,-1,execClearBoundKeyCache);
AUTOGENERATE_FUNCTION(UGearUIDataStore_StringAliasBindingsMap,-1,execAddMappingToBoundKeyCache);
AUTOGENERATE_FUNCTION(UGearUIDataStore_StringAliasBindingsMap,-1,execFindMappingInBoundKeyCache);
AUTOGENERATE_FUNCTION(UGearUIDataStore_StringAliasBindingsMap,-1,execGetBoundStringWithFieldName);
AUTOGENERATE_FUNCTION(UGearUIDataStore_StringAliasBindingsMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UGearUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UGearUIInteraction,-1,execIsMatureLanguageSupported);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execGetSelectedOption);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execFindObjectIndexByRef);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execFindObjectIndexByName);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execIsValidListOption);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execInitializeScrollbars);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execInitializeComboboxWidgets);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execSetSelectedOptionIndex);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execRequestOptionListRegeneration);
AUTOGENERATE_FUNCTION(UGearUIObjectList,-1,execRequestOptionListReformat);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GEARGAME_UIPRIVATE_NATIVE_DEFS
#define GEARGAME_UIPRIVATE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(GearGame,UGearCampaignActData);
DECLARE_NATIVE_TYPE(GearGame,UGearCampaignChapterData);
DECLARE_NATIVE_TYPE(GearGame,UGearCampaignResourceProvider);
DECLARE_NATIVE_TYPE(GearGame,UGearCollectableDataProvider);
DECLARE_NATIVE_TYPE(GearGame,UGearDataProvider_SceneNavigationData);
DECLARE_NATIVE_TYPE(GearGame,UGearDataProvider_StringValueCollection);
DECLARE_NATIVE_TYPE(GearGame,UGearLeaderboardsDataStoreBase);
DECLARE_NATIVE_TYPE(GearGame,UGearResourceDataProvider);
DECLARE_NATIVE_TYPE(GearGame,UGearUICollapsingSelectionList);
DECLARE_NATIVE_TYPE(GearGame,UGearUIDataProvider_Screenshots);
DECLARE_NATIVE_TYPE(GearGame,UGearUIDataStore_GameResource);
DECLARE_NATIVE_TYPE(GearGame,UGearUIDataStore_OnlinePlayerData);
DECLARE_NATIVE_TYPE(GearGame,UGearUIDataStore_StringAliasBindingsMap);
DECLARE_NATIVE_TYPE(GearGame,UGearUIDataStore_StringAliasMap);
DECLARE_NATIVE_TYPE(GearGame,UGearUIInteraction);
DECLARE_NATIVE_TYPE(GearGame,UGearUINavigationList);
DECLARE_NATIVE_TYPE(GearGame,UGearUIObjectList);
DECLARE_NATIVE_TYPE(GearGame,UUIComp_CollapsingListPresenter);
DECLARE_NATIVE_TYPE(GearGame,UUIComp_GearCaption);

#define AUTO_INITIALIZE_REGISTRANTS_GEARGAME_UIPRIVATE \
	UGearCampaignActData::StaticClass(); \
	UGearCampaignChapterData::StaticClass(); \
	UGearCampaignResourceProvider::StaticClass(); \
	UGearCollectableDataProvider::StaticClass(); \
	UGearDataProvider_SceneNavigationData::StaticClass(); \
	UGearDataProvider_StringValueCollection::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearDataProvider_StringValueCollectionNative; \
	UGearLeaderboardsDataStoreBase::StaticClass(); \
	UGearResourceDataProvider::StaticClass(); \
	UGearUICollapsingSelectionList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearUICollapsingSelectionListNative; \
	UGearUIDataProvider_Screenshots::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearUIDataProvider_ScreenshotsNative; \
	UGearUIDataStore_GameResource::StaticClass(); \
	UGearUIDataStore_OnlinePlayerData::StaticClass(); \
	UGearUIDataStore_StringAliasBindingsMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearUIDataStore_StringAliasBindingsMapNative; \
	UGearUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearUIDataStore_StringAliasMapNative; \
	UGearUIInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearUIInteractionNative; \
	UGearUINavigationList::StaticClass(); \
	UGearUIObjectList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGearUIObjectListNative; \
	UUIComp_CollapsingListPresenter::StaticClass(); \
	UUIComp_GearCaption::StaticClass(); \

#endif // GEARGAME_UIPRIVATE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UGearDataProvider_StringValueCollection) GGearGameUGearDataProvider_StringValueCollectionNatives[] = 
{ 
	MAP_NATIVE(UGearDataProvider_StringValueCollection,execFindStringValueIndex)
	MAP_NATIVE(UGearDataProvider_StringValueCollection,execFindCollectionIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearDataProvider_StringValueCollection);

NATIVE_INFO(UGearUICollapsingSelectionList) GGearGameUGearUICollapsingSelectionListNatives[] = 
{ 
	MAP_NATIVE(UGearUICollapsingSelectionList,execSetCellBinding)
	MAP_NATIVE(UGearUICollapsingSelectionList,execSetIndexValue)
	MAP_NATIVE(UGearUICollapsingSelectionList,execSetStringValue)
	MAP_NATIVE(UGearUICollapsingSelectionList,execListExpansionComplete)
	MAP_NATIVE(UGearUICollapsingSelectionList,execListExpansionBegin)
	MAP_NATIVE(UGearUICollapsingSelectionList,execListCollapseComplete)
	MAP_NATIVE(UGearUICollapsingSelectionList,execListCollapseBegin)
	MAP_NATIVE(UGearUICollapsingSelectionList,execCollapse)
	MAP_NATIVE(UGearUICollapsingSelectionList,execExpand)
	MAP_NATIVE(UGearUICollapsingSelectionList,execGetValueLabelHeight)
	MAP_NATIVE(UGearUICollapsingSelectionList,execGetCaptionLabelHeight)
	MAP_NATIVE(UGearUICollapsingSelectionList,execGetMaxLabelHeight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearUICollapsingSelectionList);

NATIVE_INFO(UGearUIDataProvider_Screenshots) GGearGameUGearUIDataProvider_ScreenshotsNatives[] = 
{ 
	MAP_NATIVE(UGearUIDataProvider_Screenshots,execSortScreenshots)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearUIDataProvider_Screenshots);

NATIVE_INFO(UGearUIDataStore_StringAliasBindingsMap) GGearGameUGearUIDataStore_StringAliasBindingsMapNatives[] = 
{ 
	MAP_NATIVE(UGearUIDataStore_StringAliasBindingsMap,execClearBoundKeyCache)
	MAP_NATIVE(UGearUIDataStore_StringAliasBindingsMap,execAddMappingToBoundKeyCache)
	MAP_NATIVE(UGearUIDataStore_StringAliasBindingsMap,execFindMappingInBoundKeyCache)
	MAP_NATIVE(UGearUIDataStore_StringAliasBindingsMap,execGetBoundStringWithFieldName)
	MAP_NATIVE(UGearUIDataStore_StringAliasBindingsMap,execGetStringWithFieldName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearUIDataStore_StringAliasBindingsMap);

NATIVE_INFO(UGearUIDataStore_StringAliasMap) GGearGameUGearUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UGearUIDataStore_StringAliasMap,execGetStringWithFieldName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearUIDataStore_StringAliasMap);

NATIVE_INFO(UGearUIInteraction) GGearGameUGearUIInteractionNatives[] = 
{ 
	MAP_NATIVE(UGearUIInteraction,execIsMatureLanguageSupported)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearUIInteraction);

NATIVE_INFO(UGearUIObjectList) GGearGameUGearUIObjectListNatives[] = 
{ 
	MAP_NATIVE(UGearUIObjectList,execClearBoundDataStores)
	MAP_NATIVE(UGearUIObjectList,execGetBoundDataStores)
	MAP_NATIVE(UGearUIObjectList,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UGearUIObjectList,execRefreshSubscriberValue)
	MAP_NATIVE(UGearUIObjectList,execGetDataStoreBinding)
	MAP_NATIVE(UGearUIObjectList,execSetDataStoreBinding)
	MAP_NATIVE(UGearUIObjectList,execGetSelectedOption)
	MAP_NATIVE(UGearUIObjectList,execFindObjectIndexByRef)
	MAP_NATIVE(UGearUIObjectList,execFindObjectIndexByName)
	MAP_NATIVE(UGearUIObjectList,execIsValidListOption)
	MAP_NATIVE(UGearUIObjectList,execInitializeScrollbars)
	MAP_NATIVE(UGearUIObjectList,execInitializeComboboxWidgets)
	MAP_NATIVE(UGearUIObjectList,execSetSelectedOptionIndex)
	MAP_NATIVE(UGearUIObjectList,execRequestOptionListRegeneration)
	MAP_NATIVE(UGearUIObjectList,execRequestOptionListReformat)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGearUIObjectList);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,GearCampaignActData,ChapterProviders)
VERIFY_CLASS_SIZE_NODIE(UGearCampaignActData)
VERIFY_CLASS_OFFSET_NODIE(U,GearCampaignChapterData,ChapterType)
VERIFY_CLASS_OFFSET_NODIE(U,GearCampaignChapterData,MapName)
VERIFY_CLASS_SIZE_NODIE(UGearCampaignChapterData)
VERIFY_CLASS_OFFSET_NODIE(U,GearCampaignResourceProvider,ActType)
VERIFY_CLASS_OFFSET_NODIE(U,GearCampaignResourceProvider,Collectables)
VERIFY_CLASS_SIZE_NODIE(UGearCampaignResourceProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GearCollectableDataProvider,CollectableId)
VERIFY_CLASS_OFFSET_NODIE(U,GearCollectableDataProvider,ContainingChapterProvider)
VERIFY_CLASS_SIZE_NODIE(UGearCollectableDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GearDataProvider_SceneNavigationData,NavigationItems)
VERIFY_CLASS_OFFSET_NODIE(U,GearDataProvider_SceneNavigationData,AttractIconMarkup)
VERIFY_CLASS_SIZE_NODIE(UGearDataProvider_SceneNavigationData)
VERIFY_CLASS_OFFSET_NODIE(U,GearDataProvider_StringValueCollection,StringValueCollections)
VERIFY_CLASS_SIZE_NODIE(UGearDataProvider_StringValueCollection)
VERIFY_CLASS_OFFSET_NODIE(U,GearLeaderboardsDataStoreBase,LeaderboardSettingsClass)
VERIFY_CLASS_OFFSET_NODIE(U,GearLeaderboardsDataStoreBase,SettingsProvider)
VERIFY_CLASS_SIZE_NODIE(UGearLeaderboardsDataStoreBase)
VERIFY_CLASS_SIZE_NODIE(UGearResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GearUICollapsingSelectionList,CaptionComponent)
VERIFY_CLASS_OFFSET_NODIE(U,GearUICollapsingSelectionList,__CanSubmitValue__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGearUICollapsingSelectionList)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataProvider_Screenshots,Screenshots)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataProvider_Screenshots,DateTimeCol)
VERIFY_CLASS_SIZE_NODIE(UGearUIDataProvider_Screenshots)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataStore_GameResource,ResourceDataStoreTeamNames)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataStore_GameResource,ResourceDataStoreTeamIdTypes)
VERIFY_CLASS_SIZE_NODIE(UGearUIDataStore_GameResource)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataStore_OnlinePlayerData,ScreenshotsProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataStore_OnlinePlayerData,ScreenshotsProviderClass)
VERIFY_CLASS_SIZE_NODIE(UGearUIDataStore_OnlinePlayerData)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataStore_StringAliasBindingsMap,CommandToBindNames)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIDataStore_StringAliasBindingsMap,ControllerMapArray)
VERIFY_CLASS_SIZE_NODIE(UGearUIDataStore_StringAliasBindingsMap)
VERIFY_CLASS_SIZE_NODIE(UGearUIDataStore_StringAliasMap)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIInteraction,IdleSeconds)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIInteraction,MaxIdleSeconds)
VERIFY_CLASS_SIZE_NODIE(UGearUIInteraction)
VERIFY_CLASS_SIZE_NODIE(UGearUINavigationList)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIObjectList,VerticalScrollbar)
VERIFY_CLASS_OFFSET_NODIE(U,GearUIObjectList,__OnRegeneratedOptions__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGearUIObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_CollapsingListPresenter,AnimationOpacity)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_CollapsingListPresenter,RenderOffsetPercentage)
VERIFY_CLASS_SIZE_NODIE(UUIComp_CollapsingListPresenter)
VERIFY_CLASS_SIZE_NODIE(UUIComp_GearCaption)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
