/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GEARGAME_AI_ENUMS
#define INCLUDED_GEARGAME_AI_ENUMS 1

enum ELocationType
{
    LT_Known                =0,
    LT_Exact                =1,
    LT_InterpVisibility     =2,
    LT_MAX                  =3,
};
enum EPerceptionType
{
    PT_Sight                =0,
    PT_Heard                =1,
    PT_HurtBy               =2,
    PT_Force                =3,
    PT_SightPlayer          =4,
    PT_MAX                  =5,
};
enum EGearSquadFormationType
{
    GSF_None                =0,
    GSF_Column              =1,
    GSF_Line                =2,
    GSF_MAX                 =3,
};
enum EAcquireCoverType
{
    ACT_None                =0,
    ACT_Immediate           =1,
    ACT_DesireBetter        =2,
    ACT_MAX                 =3,
};
enum EAIMoveMood
{
    AIMM_None               =0,
    AIMM_Normal             =1,
    AIMM_WithCover          =2,
    AIMM_MAX                =3,
};
enum ECombatMood
{
    AICM_None               =0,
    AICM_Normal             =1,
    AICM_Passive            =2,
    AICM_Aggressive         =3,
    AICM_Ambush             =4,
    AICM_MAX                =5,
};
enum EPerceptionMood
{
    AIPM_None               =0,
    AIPM_Normal             =1,
    AIPM_Alert              =2,
    AIPM_Unaware            =3,
    AIPM_Oblivious          =4,
    AIPM_MAX                =5,
};
enum EBrumakSearchType
{
    BrumakSearchType_All    =0,
    BrumakSearchType_Direct =1,
    BrumakSearchType_Flank  =2,
    BrumakSearchType_MAX    =3,
};
enum ECoverSearchType
{
    SearchType_Towards      =0,
    SearchType_Away         =1,
    SearchType_Near         =2,
    SearchType_Ambush       =3,
    SearchType_AlongPath    =4,
    SearchType_MAX          =5,
};

#endif // !INCLUDED_GEARGAME_AI_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName GEARGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AddCoverGoalConstraint)
AUTOGENERATE_NAME(AILog_Internal)
AUTOGENERATE_NAME(AutoAcquireEnemy)
AUTOGENERATE_NAME(AutoNotifyEnemy)
AUTOGENERATE_NAME(CanFireAt)
AUTOGENERATE_NAME(CanRun2Cover)
AUTOGENERATE_NAME(ForcePauseAndRepath)
AUTOGENERATE_NAME(ForceReLink)
AUTOGENERATE_NAME(GeneratePathTo)
AUTOGENERATE_NAME(GetActionString)
AUTOGENERATE_NAME(GetAimLocation)
AUTOGENERATE_NAME(GetDistanceFromSquadLeader)
AUTOGENERATE_NAME(GetEvadeChanceScale)
AUTOGENERATE_NAME(InternalShouldAIAvoidMe)
AUTOGENERATE_NAME(IsAtCover)
AUTOGENERATE_NAME(MoveToCombatZone)
AUTOGENERATE_NAME(NoticedEnemy)
AUTOGENERATE_NAME(NotifyAnchorBeingStreamedOut)
AUTOGENERATE_NAME(NotifyEnemyBecameVisible)
AUTOGENERATE_NAME(NotifyEnemyHeard)
AUTOGENERATE_NAME(NotifyEnemySeen)
AUTOGENERATE_NAME(NotifyLostEnemyVisibility)
AUTOGENERATE_NAME(SetCombatMood)
AUTOGENERATE_NAME(SetCurrentCombatZone)
AUTOGENERATE_NAME(SetMoveGoal)
AUTOGENERATE_NAME(SetMovementMood)
AUTOGENERATE_NAME(SetMovePoint)
AUTOGENERATE_NAME(SetPendingCombatZone)
AUTOGENERATE_NAME(SetPerceptionMood)
AUTOGENERATE_NAME(SetSquadName)
AUTOGENERATE_NAME(SetSquadRoute)
AUTOGENERATE_NAME(SetSquadRouteIndex)
AUTOGENERATE_NAME(ShouldBlindFire)
AUTOGENERATE_NAME(ShouldDo360Aiming)
AUTOGENERATE_NAME(SpawnerSetTether)
AUTOGENERATE_NAME(StartFiring)
AUTOGENERATE_NAME(StepAsideFor)
AUTOGENERATE_NAME(TeleportToLocation)
AUTOGENERATE_NAME(UseTurret)

#ifndef NAMES_ONLY

#ifndef INCLUDED_GEARGAME_AI_CLASSES
#define INCLUDED_GEARGAME_AI_CLASSES 1

class UCombatZoneRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS CombatZoneRenderingComponent
    //## END PROPS CombatZoneRenderingComponent

    DECLARE_CLASS(UCombatZoneRenderingComponent,UPrimitiveComponent,0,GearGame)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;
};

struct AIAvoidanceCylinderComponent_eventInternalShouldAIAvoidMe_Parms
{
    class AGearAI* AskingAI;
    UBOOL ReturnValue;
    AIAvoidanceCylinderComponent_eventInternalShouldAIAvoidMe_Parms(EEventParm)
    {
    }
};
struct AIAvoidanceCylinderComponent_eventSetEnabled_Parms
{
    UBOOL bInEnabled;
    AIAvoidanceCylinderComponent_eventSetEnabled_Parms(EEventParm)
    {
    }
};
struct AIAvoidanceCylinderComponent_eventForceReLink_Parms
{
    AIAvoidanceCylinderComponent_eventForceReLink_Parms(EEventParm)
    {
    }
};
class UAIAvoidanceCylinderComponent : public UCylinderComponent
{
public:
    //## BEGIN PROPS AIAvoidanceCylinderComponent
    TMap< ANavigationPoint*,UBOOL > LinkedNavigationPoints;
    TMap< UReachSpec*,UBOOL > LinkedReachSpecs;
    FVector LastReLinkLocation;
    FLOAT UpdateThreshold;
    BITFIELD bEnabled:1;
    BYTE TeamThatShouldFleeMe GCC_BITFIELD_MAGIC;
    //## END PROPS AIAvoidanceCylinderComponent

    UBOOL IsNavPointWithin(class ANavigationPoint* Pt);
    UBOOL DoesSpecIntersect(class UReachSpec* Spec);
    UBOOL BuildListOfAffectingCylinders(class AGearAI* AskingAI,TArray<class UAIAvoidanceCylinderComponent*>& InAffectingCylinders);
    virtual UBOOL ShouldAIAvoidMe(class AGearAI* AskingAI);
    DECLARE_FUNCTION(execIsNavPointWithin)
    {
        P_GET_OBJECT(ANavigationPoint,Pt);
        P_FINISH;
        *(UBOOL*)Result=IsNavPointWithin(Pt);
    }
    DECLARE_FUNCTION(execDoesSpecIntersect)
    {
        P_GET_OBJECT(UReachSpec,Spec);
        P_FINISH;
        *(UBOOL*)Result=DoesSpecIntersect(Spec);
    }
    DECLARE_FUNCTION(execBuildListOfAffectingCylinders)
    {
        P_GET_OBJECT(AGearAI,AskingAI);
        P_GET_TARRAY_REF(class UAIAvoidanceCylinderComponent*,InAffectingCylinders);
        P_FINISH;
        *(UBOOL*)Result=BuildListOfAffectingCylinders(AskingAI,InAffectingCylinders);
    }
    DECLARE_FUNCTION(execShouldAIAvoidMe)
    {
        P_GET_OBJECT(AGearAI,AskingAI);
        P_FINISH;
        *(UBOOL*)Result=ShouldAIAvoidMe(AskingAI);
    }
    UBOOL eventInternalShouldAIAvoidMe(class AGearAI* AskingAI)
    {
        AIAvoidanceCylinderComponent_eventInternalShouldAIAvoidMe_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AskingAI=AskingAI;
        ProcessEvent(FindFunctionChecked(GEARGAME_InternalShouldAIAvoidMe),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetEnabled(UBOOL bInEnabled)
    {
        AIAvoidanceCylinderComponent_eventSetEnabled_Parms Parms(EC_EventParm);
        Parms.bInEnabled=bInEnabled ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetEnabled),&Parms);
    }
    void eventForceReLink()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_ForceReLink),NULL);
    }
    DECLARE_CLASS(UAIAvoidanceCylinderComponent,UCylinderComponent,0,GearGame)
	static TDoubleLinkedList<UAIAvoidanceCylinderComponent*> GAvoidanceCylinders;
	public:
		virtual void Attach()
		{
			Super::Attach();

			if (GIsGame)
			{
				GAvoidanceCylinders.AddHead(this);
			}
		}
		virtual void Detach(UBOOL bWillReattach)
		{
			Super::Detach(bWillReattach);
			GAvoidanceCylinders.RemoveNode(this);
		}

		static TDoubleLinkedList<UAIAvoidanceCylinderComponent*>& GetList()
		{
			return GAvoidanceCylinders;
		}

		/** Called whenever isNavPointWithin or DoesSpecIntersect is called, and will update specs and navpoints if we have moved sufficiently far away */
		void ConditionalReLinkToSpecsAndNavPts();

		virtual void OverrideTraceFlagsForNonCollisionComponentChecks( DWORD& Flags )
		{
			// we only care about pawns!
			Flags = TRACE_Pawns;
		}
};

struct FLadderMeshes
{
    class UStaticMesh* Base;

    /** Constructors */
    FLadderMeshes() {}
    FLadderMeshes(EEventParm)
    {
        appMemzero(this, sizeof(FLadderMeshes));
    }
};

class ULadderMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS LadderMeshComponent
    TArrayNoInit<struct FLadderMeshes> Meshes;
    FVector LocationOffset;
    //## END PROPS LadderMeshComponent

    DECLARE_CLASS(ULadderMeshComponent,UStaticMeshComponent,0,GearGame)
	void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;
	virtual void UpdateMeshes() {};
};

class USecurityBotStationaryRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS SecurityBotStationaryRenderingComponent
    //## END PROPS SecurityBotStationaryRenderingComponent

    DECLARE_CLASS(USecurityBotStationaryRenderingComponent,UPrimitiveComponent,0,GearGame)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class AAIAvoidanceCylinder : public AActor
{
public:
    //## BEGIN PROPS AIAvoidanceCylinder
    BITFIELD bEnabled:1;
    class UAIAvoidanceCylinderComponent* AvoidanceComp;
    BYTE TeamThatShouldFleeMe;
    FName OwnerName;
    //## END PROPS AIAvoidanceCylinder

    virtual void ForceReTouch();
    DECLARE_FUNCTION(execForceReTouch)
    {
        P_FINISH;
        ForceReTouch();
    }
    DECLARE_CLASS(AAIAvoidanceCylinder,AActor,0,GearGame)
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

};

struct FSquadMemberInfo
{
    class AController* Member;

    /** Constructors */
    FSquadMemberInfo() {}
    FSquadMemberInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSquadMemberInfo));
    }
};

struct FPlayerInfo
{
    FLOAT LastUpdateTime;
    class APawn* Pawn;
    class AGearPawn* GearPawn;
    FVector KnownLocation;
    struct FCoverInfo Cover;
    class AActor* Base;
    FLOAT InitialSeenTime;
    FLOAT LastSeenTime;
    FLOAT LastNotifyTime;

    /** Constructors */
    FPlayerInfo() {}
    FPlayerInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerInfo));
    }
};

struct FDelayUpdateInfo
{
    BYTE Type;
    class APawn* Pawn;
    FLOAT UpdateTime;
    FName EventName;

    /** Constructors */
    FDelayUpdateInfo() {}
    FDelayUpdateInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDelayUpdateInfo));
    }
};

struct FDecayedCover
{
    class ACoverSlotMarker* CoverMarker;
    INT ExtraCoverCost;

    /** Constructors */
    FDecayedCover() {}
    FDecayedCover(EEventParm)
    {
        appMemzero(this, sizeof(FDecayedCover));
    }
};

struct GearSquad_eventSetSquadRouteIndex_Parms
{
    INT Idx;
    GearSquad_eventSetSquadRouteIndex_Parms(EEventParm)
    {
    }
};
struct GearSquad_eventSetSquadRoute_Parms
{
    class AGameplayRoute* RG;
    GearSquad_eventSetSquadRoute_Parms(EEventParm)
    {
    }
};
class AGearSquad : public AInfo
{
public:
    //## BEGIN PROPS GearSquad
    FName SquadName;
    class AGearTeamInfo* Team;
    TArrayNoInit<struct FSquadMemberInfo> SquadMembers;
    class AController* Leader;
    class AGearSquadFormation* Formation;
    class AGameplayRoute* SquadRoute;
    INT SquadRouteIndex;
    BITFIELD bPlayerSquad:1;
    BITFIELD bInterSquadCommunication:1;
    TArrayNoInit<struct FPlayerInfo> EnemyList;
    TArrayNoInit<struct FDelayUpdateInfo> DelayUpdateList;
    TArrayNoInit<struct FDecayedCover> DecayedCoverList;
    TMap<ACoverSlotMarker*, INT> DecayedCoverMap;
    FLOAT AdjacentDecayMult;
    INT DecayRecoveryPerSecond;
    FLOAT DecayRecoveryIntervalRemaining;
    //## END PROPS GearSquad

    UBOOL ProcessStimulus(const class AGearAI* AI,class APawn* Enemy,BYTE Type,FName EventName);
    UBOOL BroadcastStimulus(class APawn* Enemy,BYTE Type,FName EventName);
    void SetKnownEnemyInfo(INT EnemyIdx,class AGearPawn* E,FVector EnemyLoc);
    INT AddEnemy(const class AGearAI* AI,class APawn* NewEnemy);
    UBOOL RemoveEnemy(class APawn* DeadEnemy);
    INT GetEnemyIndex(class APawn* Enemy);
    FVector GetEnemyLocation(class APawn* TestPawn,BYTE LT=0);
    FVector GetEnemyLocationByIndex(INT Idx,BYTE LT=0);
    FLOAT GetEnemyLastSeenTime(class APawn* TestPawn);
    class AActor* GetSquadLeaderPosition();
    FVector GetSquadLeaderLocation();
    struct FCoverInfo GetEnemyCover(class APawn* TestPawn);
    void AddCoverDecay(class ACoverSlotMarker* CoverMarker,INT Amount);
    FVector GetSquadCentroid();
    FLOAT GetChanceToDuckBackIntoCover(class AGearAI* AI);
    DECLARE_FUNCTION(execProcessStimulus)
    {
        P_GET_OBJECT(AGearAI,AI);
        P_GET_OBJECT(APawn,Enemy);
        P_GET_BYTE(Type);
        P_GET_NAME(EventName);
        P_FINISH;
        *(UBOOL*)Result=ProcessStimulus(AI,Enemy,Type,EventName);
    }
    DECLARE_FUNCTION(execBroadcastStimulus)
    {
        P_GET_OBJECT(APawn,Enemy);
        P_GET_BYTE(Type);
        P_GET_NAME(EventName);
        P_FINISH;
        *(UBOOL*)Result=BroadcastStimulus(Enemy,Type,EventName);
    }
    DECLARE_FUNCTION(execSetKnownEnemyInfo)
    {
        P_GET_INT(EnemyIdx);
        P_GET_OBJECT(AGearPawn,E);
        P_GET_STRUCT(FVector,EnemyLoc);
        P_FINISH;
        SetKnownEnemyInfo(EnemyIdx,E,EnemyLoc);
    }
    DECLARE_FUNCTION(execAddEnemy)
    {
        P_GET_OBJECT(AGearAI,AI);
        P_GET_OBJECT(APawn,NewEnemy);
        P_FINISH;
        *(INT*)Result=AddEnemy(AI,NewEnemy);
    }
    DECLARE_FUNCTION(execRemoveEnemy)
    {
        P_GET_OBJECT(APawn,DeadEnemy);
        P_FINISH;
        *(UBOOL*)Result=RemoveEnemy(DeadEnemy);
    }
    DECLARE_FUNCTION(execGetEnemyIndex)
    {
        P_GET_OBJECT(APawn,Enemy);
        P_FINISH;
        *(INT*)Result=GetEnemyIndex(Enemy);
    }
    DECLARE_FUNCTION(execGetEnemyLocation)
    {
        P_GET_OBJECT(APawn,TestPawn);
        P_GET_BYTE_OPTX(LT,0);
        P_FINISH;
        *(FVector*)Result=GetEnemyLocation(TestPawn,LT);
    }
    DECLARE_FUNCTION(execGetEnemyLocationByIndex)
    {
        P_GET_INT(Idx);
        P_GET_BYTE_OPTX(LT,0);
        P_FINISH;
        *(FVector*)Result=GetEnemyLocationByIndex(Idx,LT);
    }
    DECLARE_FUNCTION(execGetEnemyLastSeenTime)
    {
        P_GET_OBJECT(APawn,TestPawn);
        P_FINISH;
        *(FLOAT*)Result=GetEnemyLastSeenTime(TestPawn);
    }
    DECLARE_FUNCTION(execGetSquadLeaderPosition)
    {
        P_FINISH;
        *(class AActor**)Result=GetSquadLeaderPosition();
    }
    DECLARE_FUNCTION(execGetSquadLeaderLocation)
    {
        P_FINISH;
        *(FVector*)Result=GetSquadLeaderLocation();
    }
    DECLARE_FUNCTION(execGetEnemyCover)
    {
        P_GET_OBJECT(APawn,TestPawn);
        P_FINISH;
        *(struct FCoverInfo*)Result=GetEnemyCover(TestPawn);
    }
    DECLARE_FUNCTION(execAllEnemies);
    DECLARE_FUNCTION(execAllMembers);
    DECLARE_FUNCTION(execAddCoverDecay)
    {
        P_GET_OBJECT(ACoverSlotMarker,CoverMarker);
        P_GET_INT(Amount);
        P_FINISH;
        AddCoverDecay(CoverMarker,Amount);
    }
    DECLARE_FUNCTION(execGetSquadCentroid)
    {
        P_FINISH;
        *(FVector*)Result=GetSquadCentroid();
    }
    DECLARE_FUNCTION(execGetChanceToDuckBackIntoCover)
    {
        P_GET_OBJECT(AGearAI,AI);
        P_FINISH;
        *(FLOAT*)Result=GetChanceToDuckBackIntoCover(AI);
    }
    void eventSetSquadRouteIndex(INT Idx)
    {
        GearSquad_eventSetSquadRouteIndex_Parms Parms(EC_EventParm);
        Parms.Idx=Idx;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetSquadRouteIndex),&Parms);
    }
    void eventSetSquadRoute(class AGameplayRoute* RG)
    {
        GearSquad_eventSetSquadRoute_Parms Parms(EC_EventParm);
        Parms.RG=RG;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetSquadRoute),&Parms);
    }
    DECLARE_CLASS(AGearSquad,AInfo,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("AI");}

private:
	void UpdateDecayedCoverMap();
public:
	virtual void TickSpecial(FLOAT DeltaTime);
};

struct FFormationPosition
{
    FName PosName;
    INT RelIdx;
    INT YawOffset;
    FLOAT Distance;
    FLOAT LastUpdateTime;
    FVector LastUpdatePosition;
    FVector IdealPosition;
    class ANavigationPoint* Nav;
    class AGearAI* AI;
    FColor DebugColor;

    /** Constructors */
    FFormationPosition() {}
    FFormationPosition(EEventParm)
    {
        appMemzero(this, sizeof(FFormationPosition));
    }
};

#define UCONST_MAXPOSITIONDISTSQ 1048576
#define UCONST_MAXPOSITIONDIST 1024

class AGearSquadFormation : public AInfo
{
public:
    //## BEGIN PROPS GearSquadFormation
    class AGearSquad* Squad;
    TArrayNoInit<struct FFormationPosition> Positions;
    FVector LastSquadPosition;
    FVector CurrentSquadPosition;
    //## END PROPS GearSquadFormation

    virtual INT GetNumSquadMembersThatUsePositions();
    DECLARE_FUNCTION(execGetNumSquadMembersThatUsePositions)
    {
        P_FINISH;
        *(INT*)Result=GetNumSquadMembersThatUsePositions();
    }
    DECLARE_CLASS(AGearSquadFormation,AInfo,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearSquadFormation)
};

class AGameplayRoute : public ARoute
{
public:
    //## BEGIN PROPS GameplayRoute
    BITFIELD bAllowBackwardProgression:1;
    //## END PROPS GameplayRoute

    DECLARE_CLASS(AGameplayRoute,ARoute,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGameplayRoute)
};

struct FLocalEnemyInfo
{
    BITFIELD bVisible:1;
    BITFIELD bSeenLastFrame:1;
    class APawn* Pawn;
    FLOAT InitialVisibleTime;
    FLOAT LastVisibleTime;
    FVector AsyncVisibleLocation;
    FLOAT LastFailedPathTime;
    BYTE FootStepCount;
    FLOAT LastFootStepTime;

    /** Constructors */
    FLocalEnemyInfo() {}
    FLocalEnemyInfo(EEventParm)
    {
        appMemzero(this, sizeof(FLocalEnemyInfo));
    }
};

struct FInvalidAnchorItem
{
    class ANavigationPoint* InvalidNav;
    FLOAT InvalidTime;

    /** Constructors */
    FInvalidAnchorItem() {}
    FInvalidAnchorItem(EEventParm)
    {
        appMemzero(this, sizeof(FInvalidAnchorItem));
    }
};

struct GearAI_eventNotifyAnchorBeingStreamedOut_Parms
{
    GearAI_eventNotifyAnchorBeingStreamedOut_Parms(EEventParm)
    {
    }
};
struct GearAI_eventStepAsideFor_Parms
{
    class APawn* ChkPawn;
    UBOOL ReturnValue;
    GearAI_eventStepAsideFor_Parms(EEventParm)
    {
    }
};
struct GearAI_eventGetEvadeChanceScale_Parms
{
    FLOAT ReturnValue;
    GearAI_eventGetEvadeChanceScale_Parms(EEventParm)
    {
    }
};
struct GearAI_eventGetAimLocation_Parms
{
    FVector StartLoc;
    UBOOL bActuallyFiring;
    class AActor* AimTarget;
    FVector ReturnValue;
    GearAI_eventGetAimLocation_Parms(EEventParm)
    {
    }
};
struct GearAI_eventCanFireAt_Parms
{
    class AActor* ChkTarget;
    FVector ViewPt;
    UBOOL bUseRotation;
    class AGearWeapon* Weap;
    UBOOL ReturnValue;
    GearAI_eventCanFireAt_Parms(EEventParm)
    {
    }
};
struct GearAI_eventStartFiring_Parms
{
    INT InBurstsToFire;
    GearAI_eventStartFiring_Parms(EEventParm)
    {
    }
};
struct GearAI_eventTeleportToLocation_Parms
{
    FVector NewLoc;
    FRotator NewRot;
    UBOOL bCancelCombat;
    UBOOL bCancelMovement;
    UBOOL ReturnValue;
    GearAI_eventTeleportToLocation_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetMovePoint_Parms
{
    FVector NewMovePoint;
    class AActor* NewMoveFocus;
    UBOOL bInterruptable;
    FLOAT OffsetDist;
    UBOOL bIsValidCache;
    UBOOL bAllowedToFire;
    UBOOL bAllowPartialPath;
    GearAI_eventSetMovePoint_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetMoveGoal_Parms
{
    class AActor* NewMoveGoal;
    class AActor* NewMoveFocus;
    UBOOL bInterruptable;
    FLOAT OffsetDist;
    UBOOL bIsValidCache;
    UBOOL bInCanPathfind;
    UBOOL bForce;
    UBOOL bAllowedToFire;
    UBOOL bAllowPartialPath;
    GearAI_eventSetMoveGoal_Parms(EEventParm)
    {
    }
};
struct GearAI_eventGeneratePathTo_Parms
{
    class AActor* Goal;
    FLOAT Distance;
    UBOOL bAllowPartialPath;
    class AActor* ReturnValue;
    GearAI_eventGeneratePathTo_Parms(EEventParm)
    {
    }
};
struct GearAI_eventMoveToCombatZone_Parms
{
    UBOOL ReturnValue;
    GearAI_eventMoveToCombatZone_Parms(EEventParm)
    {
    }
};
struct GearAI_eventIsAtCover_Parms
{
    UBOOL ReturnValue;
    GearAI_eventIsAtCover_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetCombatMood_Parms
{
    BYTE NewMood;
    class APawn* MoodInstigator;
    UBOOL ReturnValue;
    GearAI_eventSetCombatMood_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSpawnerSetTether_Parms
{
    class AActor* NewTether;
    UBOOL bInterruptable;
    GearAI_eventSpawnerSetTether_Parms(EEventParm)
    {
    }
};
struct GearAI_eventForcePauseAndRepath_Parms
{
    class AActor* InInstigator;
    GearAI_eventForcePauseAndRepath_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetMovementMood_Parms
{
    BYTE NewMood;
    GearAI_eventSetMovementMood_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetPerceptionMood_Parms
{
    BYTE NewMood;
    FLOAT UnawareSightRadius;
    GearAI_eventSetPerceptionMood_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetCurrentCombatZone_Parms
{
    class ACombatZone* NewCZ;
    GearAI_eventSetCurrentCombatZone_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetPendingCombatZone_Parms
{
    class ACombatZone* NewCZ;
    GearAI_eventSetPendingCombatZone_Parms(EEventParm)
    {
    }
};
struct GearAI_eventAutoNotifyEnemy_Parms
{
    GearAI_eventAutoNotifyEnemy_Parms(EEventParm)
    {
    }
};
struct GearAI_eventAutoAcquireEnemy_Parms
{
    GearAI_eventAutoAcquireEnemy_Parms(EEventParm)
    {
    }
};
struct GearAI_eventGetDistanceFromSquadLeader_Parms
{
    FVector TestLocation;
    FLOAT ReturnValue;
    GearAI_eventGetDistanceFromSquadLeader_Parms(EEventParm)
    {
    }
};
struct GearAI_eventSetSquadName_Parms
{
    FName NewSquadName;
    UBOOL bLeader;
    GearAI_eventSetSquadName_Parms(EEventParm)
    {
    }
};
struct GearAI_eventNotifyEnemySeen_Parms
{
    class APawn* SeenEnemy;
    GearAI_eventNotifyEnemySeen_Parms(EEventParm)
    {
    }
};
struct GearAI_eventNotifyEnemyHeard_Parms
{
    class APawn* HeardEnemy;
    FName NoiseType;
    GearAI_eventNotifyEnemyHeard_Parms(EEventParm)
    {
    }
};
struct GearAI_eventNotifyLostEnemyVisibility_Parms
{
    class APawn* LostEnemy;
    GearAI_eventNotifyLostEnemyVisibility_Parms(EEventParm)
    {
    }
};
struct GearAI_eventNotifyEnemyBecameVisible_Parms
{
    class APawn* VisibleEnemy;
    FLOAT TimeSinceLastVisible;
    GearAI_eventNotifyEnemyBecameVisible_Parms(EEventParm)
    {
    }
};
struct GearAI_eventNoticedEnemy_Parms
{
    class APawn* NewEnemy;
    GearAI_eventNoticedEnemy_Parms(EEventParm)
    {
    }
};
struct GearAI_eventGetActionString_Parms
{
    FString ReturnValue;
    GearAI_eventGetActionString_Parms(EEventParm)
    {
    }
};
struct GearAI_eventAILog_Internal_Parms
{
    FString LogText;
    FName LogCategory;
    UBOOL bForce;
    GearAI_eventAILog_Internal_Parms(EEventParm)
    {
    }
};
class AGearAI : public AAIController
{
public:
    //## BEGIN PROPS GearAI
    BYTE PerceptionMood;
    BYTE CombatMood;
    BYTE MovementMood;
    BYTE EmergeSpecialMove;
    BYTE QueuedSpecialmove;
    BYTE AcquireCover;
    TArrayNoInit<struct FLocalEnemyInfo> LocalEnemyList;
    FLOAT PlayIntialCombatReactionChance;
    class USeqAct_AIFactory* SpawnFactory;
    TArrayNoInit<class AActor*> TargetList;
    TArrayNoInit<class AActor*> ProhibitedTargetList;
    class ATurret* CurrentTurret;
    class ATurret* LastTurret;
    BITFIELD bIgnoreFlank:1;
    BITFIELD bWantsLedgeCheck:1;
    BITFIELD bAlwaysHear:1;
    BITFIELD bIgnoreSquadPosition:1;
    BITFIELD bShouldRoadieRun:1;
    BITFIELD bReevaluatePath:1;
    BITFIELD bSkipRouteCacheUpdates:1;
    BITFIELD bReachedMoveGoal:1;
    BITFIELD bMoveGoalInterruptable:1;
    BITFIELD bMovingToGoal:1;
    BITFIELD bMovingToCover:1;
    BITFIELD bMovingToRoute:1;
    BITFIELD bReachedTurret:1;
    BITFIELD bMovingToTether:1;
    BITFIELD bReachedTether:1;
    BITFIELD bDoingMeleeAttack:1;
    BITFIELD bWeaponCanFire:1;
    BITFIELD bCanHeadshot:1;
    BITFIELD bAvoidIdleMantling:1;
    BITFIELD bCanExecute:1;
    BITFIELD bCanRevive:1;
    BITFIELD bDynamicTether:1;
    BITFIELD bMovingToSquadLeader:1;
    BITFIELD bKeepTether:1;
    BITFIELD bTetherIsCoverGoal:1;
    BITFIELD bTeleportOnTetherFailure:1;
    BITFIELD bSpawnerTetherInterruptable:1;
    BITFIELD bFailedToFireFromCover:1;
    BITFIELD bFailedToFireFromOpen:1;
    BITFIELD bFailedToMoveToEnemy:1;
    BITFIELD bUseFireTickets:1;
    BITFIELD bAILogging:1;
    BITFIELD bDrawAIDebug:1;
    BITFIELD bDrawAIDebug_Range:1;
    BITFIELD bDrawAIDebug_Enemy:1;
    BITFIELD bAILogToWindow:1;
    BITFIELD bFlushAILogEachLine:1;
    BITFIELD bMapBasedLogName:1;
    BITFIELD bAllowCombatTransitions:1;
    BITFIELD bInValidCombatZone:1;
    BITFIELD bReachedCover:1;
    BITFIELD bTurtle:1;
    BITFIELD bIgnoreStepAside:1;
    BITFIELD bDestroyOnPawnDeath:1;
    BITFIELD bIdleMoveToNearestEnemy:1;
    BITFIELD bDeleteWhenStale:1;
    BITFIELD bForceFire:1;
    BITFIELD bCanUseCoverSlipMove:1;
    BITFIELD bHasRunawayCommandList:1;
    BITFIELD bHasBanzaiReTriggers:1;
    FLOAT TimeLastHadContactWithEnemy;
    FLOAT LastGrenadeTime;
    FLOAT GrenadeChanceScale;
    FLOAT GrenadeMartyrChance;
    FLOAT WeaponAimDelay;
    TArrayNoInit<FName> WaitEvents;
    FLOAT EnemyDistance_Short;
    FLOAT EnemyDistance_Medium;
    FLOAT EnemyDistance_Long;
    FLOAT EnemyDistance_Melee;
    FLOAT EnemyDistance_MeleeCharge;
    FLOAT GrenAwarnessDistance;
    FLOAT GrenAwarnessDelay;
    FLOAT FriendlyDistance_Medium;
    FLOAT Response_MinEnemySeenTime;
    FLOAT Response_MinEnemyHearTime;
    FLOAT Response_MinEnemyHurtTime;
    FLOAT Response_EnemyTooLongNoSeeTime;
    class AActor* FearActor;
    FVector FearLocation;
    class AActor* FireTarget;
    class AGearSquad* Squad;
    FLOAT ActiveReloadAttemptPct;
    FLOAT ActiveReloadSweetPct;
    FLOAT ActiveReloadJamPct;
    class AActor* MoveGoal;
    struct FBasedPosition MovePosition;
    class AActor* MoveFocus;
    FLOAT MoveOffset;
    class APawn* StepAsideGoal;
    FLOAT MaxStepAsideDist;
    FLOAT LastObstructionTime;
    FLOAT LastDetourCheckTime;
    FLOAT ExtraPathCost;
    class ARoute* ActiveRoute;
    class AFileLog* AILogFile;
    FLOAT LastActionTransitionTime;
    FLOAT NextFlankAllowedTime;
    FLOAT LastShotAtTime;
    FLOAT LastSecondaryActionTime;
    FLOAT LastAnimTransitionTime;
    class AActor* SearchTarget;
    FVector SearchPoint;
    FLOAT SearchStartTime;
    FLOAT LastPeekTime;
    FLOAT DamageReceivedInAction;
    FLOAT LastDamageReceivedTime;
    FLOAT MinDamageReceivedTime;
    FLOAT ChanceToCoverUnderFire;
    FLOAT ChanceToEvade;
    FLOAT ChanceToEvadeGrenade;
    FLOAT ChanceToBeSuprisedByFlank;
    FLOAT InterpEnemyLocSpeed;
    INT DesiredBurstsToFire;
    FLOAT AI_NearMissDistance;
    FLOAT TargetAquisitionTime;
    FLOAT AI_Base_Acc_Standing;
    FLOAT AI_Base_Acc_BlindFire;
    FLOAT AI_Base_Acc_Target;
    FLOAT AI_mod_Acc_Move;
    FLOAT AI_mod_Acc_TargMove;
    FLOAT AI_mod_Acc_Evade;
    FLOAT AI_mod_Acc_BriefVisibility;
    FLOAT AI_mod_Acc_BriefAcquire;
    FLOAT AI_mod_Acc_Shield;
    FLOAT AI_modrng_Short;
    FLOAT AI_modrng_Medium;
    FLOAT AI_modrng_Long;
    FLOAT MinDistBetweenMantles;
    class AActor* TetherActor;
    FLOAT DesiredTetherDistance;
    FLOAT TetherDistance;
    FLOAT TetherPersistDuration;
    FLOAT TetherAcquireTime;
    class USeqAct_AIMove* MoveAction;
    FVector LastSquadLeaderPosition;
    FVector Debug_ViewLoc;
    FVector Debug_EnemyViewLoc;
    FVector Debug_LookDir;
    FRotator Debug_StepRot;
    struct FBasedPosition Debug_StepLoc;
    FLOAT DebugSearchRadius;
    FVector DebugSearchLocation;
    TArrayNoInit<FName> AILogFilter;
    class APawn* TargetedEnemy;
    FLOAT StumbleDownFromCloseRangeShotDistance;
    FLOAT ExecuteDelay;
    FLOAT ReviveDelay;
    class AActor* SearchGoalActor;
    INT SearchIndex;
    class AActor* SpecialMoveAlignActor;
    class AGearPawn* MyGearPawn;
    TArrayNoInit<struct FInvalidAnchorItem> InvalidAnchorList;
    class ACombatZone* PendingCombatZone;
    class ACombatZone* CurrentCombatZone;
    TArrayNoInit<class ACombatZone*> CombatZoneList;
    class UAICommand* CommandList;
    class UClass* DefaultCommand;
    class UClass* MeleeCommand;
    class UAIReactionManager* ReactionManager;
    TArrayNoInit<class UAIReactCondition_Base*> DefaultReactConditions;
    TArrayNoInit<class UClass*> DefaultReactConditionClasses;
    FStringNoInit DemoActionString;
    class AWeapon* ForcedWeapon;
    FGuid MyGuid;
    FLOAT StaleTimeout;
    FLOAT AimErrorMultiplier;
    FLOAT RotationRateMultiplier;
    class USeqAct_AIMove* PendingCheckpointMoveAction;
    FLOAT LastMoveFinishTime;
    //## END PROPS GearAI

    void PushCommand(class UAICommand* NewCommand);
    void PopCommand(class UAICommand* NewCommand);
    UBOOL AbortCommand(class UAICommand* AbortCmd,class UClass* AbortClass=NULL);
    class UAICommand* GetActiveCommand();
    void CheckCommandCount();
    void DumpCommandStack();
    void DumpPathConstraints();
    UBOOL GetNavigationPointsNear(FVector chkLocation,FLOAT ChkDistance,TArray<class ANavigationPoint*>& Nodes);
    virtual UBOOL IgnoreNotifies() const;
    virtual void SeePlayer(class APawn* Seen);
    UBOOL ProcessStimulus(class APawn* E,BYTE Type,FName EventName);
    UBOOL IsFriendlyPawn(class APawn* TestPlayer);
    virtual UBOOL IsFriendly(class AController* TestPlayer);
    UBOOL HasValidTarget(class AActor* TestTarget=NULL);
    UBOOL HasEnemyWithinDistance(FLOAT Distance,class APawn** out_EnemyPawn=NULL,UBOOL bExact=FALSE);
    UBOOL ShouldCheckToSeeEnemy(class APawn* E,FVector& LineChkStart,FVector& LineChkEnd);
    FVector GetFireTargetLocation(BYTE LT=0);
    FVector GetEnemyLocation(class APawn* TestPawn=NULL,BYTE LT=0);
    UBOOL IsMeleeRange(FVector TestLocation);
    UBOOL IsEnemyVisible(class APawn* EnemyPawn);
    UBOOL GetPlayerCover(class AGearPawn* chkPlayer,struct FCoverInfo& out_Cover,UBOOL bCanGuess=FALSE);
    UBOOL IsCoverExposedToAnEnemy(struct FCoverInfo TestCover,class APawn* TestEnemy=NULL,FLOAT* out_ExposedScale=NULL);
    UBOOL IsCoverWithinCombatZone(struct FCoverInfo TestCover);
    UBOOL IsWithinCombatZone(FVector TestLocation);
    virtual void AssignAnchor(class APawn* P,class ANavigationPoint* NewAnchor);
    UBOOL IsWithinTether(FVector TestPoint);
    FLOAT GetRouteCacheDistance();
    virtual UBOOL CanEvade(UBOOL bCheckChanceToEvade=FALSE,FLOAT InChanceToEvade=-1.000000,FLOAT ChanceToEvadeScale=1.000000);
    void NotifyDidSomethingInteresting(FLOAT TimeOfInterestingThing=-1.000000);
    DECLARE_FUNCTION(execPushCommand)
    {
        P_GET_OBJECT(UAICommand,NewCommand);
        P_FINISH;
        PushCommand(NewCommand);
    }
    DECLARE_FUNCTION(execPopCommand)
    {
        P_GET_OBJECT(UAICommand,NewCommand);
        P_FINISH;
        PopCommand(NewCommand);
    }
    DECLARE_FUNCTION(execAbortCommand)
    {
        P_GET_OBJECT(UAICommand,AbortCmd);
        P_GET_OBJECT_OPTX(UClass,AbortClass,NULL);
        P_FINISH;
        *(UBOOL*)Result=AbortCommand(AbortCmd,AbortClass);
    }
    DECLARE_FUNCTION(execGetActiveCommand)
    {
        P_FINISH;
        *(class UAICommand**)Result=GetActiveCommand();
    }
    DECLARE_FUNCTION(execCheckCommandCount)
    {
        P_FINISH;
        CheckCommandCount();
    }
    DECLARE_FUNCTION(execDumpCommandStack)
    {
        P_FINISH;
        DumpCommandStack();
    }
    DECLARE_FUNCTION(execDumpPathConstraints)
    {
        P_FINISH;
        DumpPathConstraints();
    }
    DECLARE_FUNCTION(execFindCommandOfClass);
    DECLARE_FUNCTION(execGetNavigationPointsNear)
    {
        P_GET_STRUCT(FVector,chkLocation);
        P_GET_FLOAT(ChkDistance);
        P_GET_TARRAY_REF(class ANavigationPoint*,Nodes);
        P_FINISH;
        *(UBOOL*)Result=GetNavigationPointsNear(chkLocation,ChkDistance,Nodes);
    }
    DECLARE_FUNCTION(execIgnoreNotifies)
    {
        P_FINISH;
        *(UBOOL*)Result=IgnoreNotifies();
    }
    DECLARE_FUNCTION(execSeePlayer)
    {
        P_GET_OBJECT(APawn,Seen);
        P_FINISH;
        SeePlayer(Seen);
    }
    DECLARE_FUNCTION(execProcessStimulus)
    {
        P_GET_OBJECT(APawn,E);
        P_GET_BYTE(Type);
        P_GET_NAME(EventName);
        P_FINISH;
        *(UBOOL*)Result=ProcessStimulus(E,Type,EventName);
    }
    DECLARE_FUNCTION(execIsFriendlyPawn)
    {
        P_GET_OBJECT(APawn,TestPlayer);
        P_FINISH;
        *(UBOOL*)Result=IsFriendlyPawn(TestPlayer);
    }
    DECLARE_FUNCTION(execIsFriendly)
    {
        P_GET_OBJECT(AController,TestPlayer);
        P_FINISH;
        *(UBOOL*)Result=IsFriendly(TestPlayer);
    }
    DECLARE_FUNCTION(execHasValidTarget)
    {
        P_GET_OBJECT_OPTX(AActor,TestTarget,NULL);
        P_FINISH;
        *(UBOOL*)Result=HasValidTarget(TestTarget);
    }
    DECLARE_FUNCTION(execHasEnemyWithinDistance)
    {
        P_GET_FLOAT(Distance);
        P_GET_OBJECT_OPTX_REF(APawn,out_EnemyPawn,NULL);
        P_GET_UBOOL_OPTX(bExact,FALSE);
        P_FINISH;
        *(UBOOL*)Result=HasEnemyWithinDistance(Distance,pout_EnemyPawn ? &out_EnemyPawn : NULL,bExact);
    }
    DECLARE_FUNCTION(execShouldCheckToSeeEnemy)
    {
        P_GET_OBJECT(APawn,E);
        P_GET_STRUCT_REF(FVector,LineChkStart);
        P_GET_STRUCT_REF(FVector,LineChkEnd);
        P_FINISH;
        *(UBOOL*)Result=ShouldCheckToSeeEnemy(E,LineChkStart,LineChkEnd);
    }
    DECLARE_FUNCTION(execGetFireTargetLocation)
    {
        P_GET_BYTE_OPTX(LT,0);
        P_FINISH;
        *(FVector*)Result=GetFireTargetLocation(LT);
    }
    DECLARE_FUNCTION(execGetEnemyLocation)
    {
        P_GET_OBJECT_OPTX(APawn,TestPawn,NULL);
        P_GET_BYTE_OPTX(LT,0);
        P_FINISH;
        *(FVector*)Result=GetEnemyLocation(TestPawn,LT);
    }
    DECLARE_FUNCTION(execIsMeleeRange)
    {
        P_GET_STRUCT(FVector,TestLocation);
        P_FINISH;
        *(UBOOL*)Result=IsMeleeRange(TestLocation);
    }
    DECLARE_FUNCTION(execIsEnemyVisible)
    {
        P_GET_OBJECT(APawn,EnemyPawn);
        P_FINISH;
        *(UBOOL*)Result=IsEnemyVisible(EnemyPawn);
    }
    DECLARE_FUNCTION(execGetPlayerCover)
    {
        P_GET_OBJECT(AGearPawn,chkPlayer);
        P_GET_STRUCT_REF(struct FCoverInfo,out_Cover);
        P_GET_UBOOL_OPTX(bCanGuess,FALSE);
        P_FINISH;
        *(UBOOL*)Result=GetPlayerCover(chkPlayer,out_Cover,bCanGuess);
    }
    DECLARE_FUNCTION(execIsCoverExposedToAnEnemy)
    {
        P_GET_STRUCT(struct FCoverInfo,TestCover);
        P_GET_OBJECT_OPTX(APawn,TestEnemy,NULL);
        P_GET_FLOAT_OPTX_REF(out_ExposedScale,0);
        P_FINISH;
        *(UBOOL*)Result=IsCoverExposedToAnEnemy(TestCover,TestEnemy,pout_ExposedScale ? &out_ExposedScale : NULL);
    }
    DECLARE_FUNCTION(execIsCoverWithinCombatZone)
    {
        P_GET_STRUCT(struct FCoverInfo,TestCover);
        P_FINISH;
        *(UBOOL*)Result=IsCoverWithinCombatZone(TestCover);
    }
    DECLARE_FUNCTION(execIsWithinCombatZone)
    {
        P_GET_STRUCT(FVector,TestLocation);
        P_FINISH;
        *(UBOOL*)Result=IsWithinCombatZone(TestLocation);
    }
    DECLARE_FUNCTION(execAssignAnchor)
    {
        P_GET_OBJECT(APawn,P);
        P_GET_OBJECT(ANavigationPoint,NewAnchor);
        P_FINISH;
        AssignAnchor(P,NewAnchor);
    }
    DECLARE_FUNCTION(execIsWithinTether)
    {
        P_GET_STRUCT(FVector,TestPoint);
        P_FINISH;
        *(UBOOL*)Result=IsWithinTether(TestPoint);
    }
    DECLARE_FUNCTION(execGetRouteCacheDistance)
    {
        P_FINISH;
        *(FLOAT*)Result=GetRouteCacheDistance();
    }
    DECLARE_FUNCTION(execCanEvade)
    {
        P_GET_UBOOL_OPTX(bCheckChanceToEvade,FALSE);
        P_GET_FLOAT_OPTX(InChanceToEvade,-1.000000);
        P_GET_FLOAT_OPTX(ChanceToEvadeScale,1.000000);
        P_FINISH;
        *(UBOOL*)Result=CanEvade(bCheckChanceToEvade,InChanceToEvade,ChanceToEvadeScale);
    }
    DECLARE_FUNCTION(execNotifyDidSomethingInteresting)
    {
        P_GET_FLOAT_OPTX(TimeOfInterestingThing,-1.000000);
        P_FINISH;
        NotifyDidSomethingInteresting(TimeOfInterestingThing);
    }
    void eventNotifyAnchorBeingStreamedOut()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyAnchorBeingStreamedOut),NULL);
    }
    UBOOL eventStepAsideFor(class APawn* ChkPawn)
    {
        GearAI_eventStepAsideFor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ChkPawn=ChkPawn;
        ProcessEvent(FindFunctionChecked(GEARGAME_StepAsideFor),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventGetEvadeChanceScale()
    {
        GearAI_eventGetEvadeChanceScale_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetEvadeChanceScale),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetAimLocation(FVector StartLoc,UBOOL bActuallyFiring=FALSE,class AActor* AimTarget=NULL)
    {
        GearAI_eventGetAimLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.StartLoc=StartLoc;
        Parms.bActuallyFiring=bActuallyFiring ? FIRST_BITFIELD : FALSE;
        Parms.AimTarget=AimTarget;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetAimLocation),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventCanFireAt(class AActor* ChkTarget,FVector ViewPt,UBOOL bUseRotation=FALSE,class AGearWeapon* Weap=NULL)
    {
        GearAI_eventCanFireAt_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ChkTarget=ChkTarget;
        Parms.ViewPt=ViewPt;
        Parms.bUseRotation=bUseRotation ? FIRST_BITFIELD : FALSE;
        Parms.Weap=Weap;
        ProcessEvent(FindFunctionChecked(GEARGAME_CanFireAt),&Parms);
        return Parms.ReturnValue;
    }
    void eventStartFiring(INT InBurstsToFire=-1)
    {
        GearAI_eventStartFiring_Parms Parms(EC_EventParm);
        Parms.InBurstsToFire=InBurstsToFire;
        ProcessEvent(FindFunctionChecked(GEARGAME_StartFiring),&Parms);
    }
    UBOOL eventTeleportToLocation(FVector NewLoc,FRotator NewRot,UBOOL bCancelCombat=TRUE,UBOOL bCancelMovement=TRUE)
    {
        GearAI_eventTeleportToLocation_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewLoc=NewLoc;
        Parms.NewRot=NewRot;
        Parms.bCancelCombat=bCancelCombat ? FIRST_BITFIELD : FALSE;
        Parms.bCancelMovement=bCancelMovement ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_TeleportToLocation),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetMovePoint(FVector NewMovePoint,class AActor* NewMoveFocus=NULL,UBOOL bInterruptable=FALSE,FLOAT OffsetDist=0,UBOOL bIsValidCache=FALSE,UBOOL bAllowedToFire=TRUE,UBOOL bAllowPartialPath=FALSE)
    {
        GearAI_eventSetMovePoint_Parms Parms(EC_EventParm);
        Parms.NewMovePoint=NewMovePoint;
        Parms.NewMoveFocus=NewMoveFocus;
        Parms.bInterruptable=bInterruptable ? FIRST_BITFIELD : FALSE;
        Parms.OffsetDist=OffsetDist;
        Parms.bIsValidCache=bIsValidCache ? FIRST_BITFIELD : FALSE;
        Parms.bAllowedToFire=bAllowedToFire ? FIRST_BITFIELD : FALSE;
        Parms.bAllowPartialPath=bAllowPartialPath ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetMovePoint),&Parms);
    }
    void eventSetMoveGoal(class AActor* NewMoveGoal,class AActor* NewMoveFocus=NULL,UBOOL bInterruptable=FALSE,FLOAT OffsetDist=0,UBOOL bIsValidCache=FALSE,UBOOL bInCanPathfind=TRUE,UBOOL bForce=FALSE,UBOOL bAllowedToFire=TRUE,UBOOL bAllowPartialPath=FALSE)
    {
        GearAI_eventSetMoveGoal_Parms Parms(EC_EventParm);
        Parms.NewMoveGoal=NewMoveGoal;
        Parms.NewMoveFocus=NewMoveFocus;
        Parms.bInterruptable=bInterruptable ? FIRST_BITFIELD : FALSE;
        Parms.OffsetDist=OffsetDist;
        Parms.bIsValidCache=bIsValidCache ? FIRST_BITFIELD : FALSE;
        Parms.bInCanPathfind=bInCanPathfind ? FIRST_BITFIELD : FALSE;
        Parms.bForce=bForce ? FIRST_BITFIELD : FALSE;
        Parms.bAllowedToFire=bAllowedToFire ? FIRST_BITFIELD : FALSE;
        Parms.bAllowPartialPath=bAllowPartialPath ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetMoveGoal),&Parms);
    }
    class AActor* eventGeneratePathTo(class AActor* Goal,FLOAT Distance=0,UBOOL bAllowPartialPath=FALSE)
    {
        GearAI_eventGeneratePathTo_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Goal=Goal;
        Parms.Distance=Distance;
        Parms.bAllowPartialPath=bAllowPartialPath ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_GeneratePathTo),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventMoveToCombatZone()
    {
        GearAI_eventMoveToCombatZone_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_MoveToCombatZone),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsAtCover()
    {
        GearAI_eventIsAtCover_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_IsAtCover),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetCombatMood(BYTE NewMood,class APawn* MoodInstigator=NULL)
    {
        GearAI_eventSetCombatMood_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewMood=NewMood;
        Parms.MoodInstigator=MoodInstigator;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetCombatMood),&Parms);
        return Parms.ReturnValue;
    }
    void eventSpawnerSetTether(class AActor* NewTether,UBOOL bInterruptable=FALSE)
    {
        GearAI_eventSpawnerSetTether_Parms Parms(EC_EventParm);
        Parms.NewTether=NewTether;
        Parms.bInterruptable=bInterruptable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SpawnerSetTether),&Parms);
    }
    void eventForcePauseAndRepath(class AActor* InInstigator)
    {
        GearAI_eventForcePauseAndRepath_Parms Parms(EC_EventParm);
        Parms.InInstigator=InInstigator;
        ProcessEvent(FindFunctionChecked(GEARGAME_ForcePauseAndRepath),&Parms);
    }
    void eventSetMovementMood(BYTE NewMood)
    {
        GearAI_eventSetMovementMood_Parms Parms(EC_EventParm);
        Parms.NewMood=NewMood;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetMovementMood),&Parms);
    }
    void eventSetPerceptionMood(BYTE NewMood,FLOAT UnawareSightRadius=-1.000000)
    {
        GearAI_eventSetPerceptionMood_Parms Parms(EC_EventParm);
        Parms.NewMood=NewMood;
        Parms.UnawareSightRadius=UnawareSightRadius;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetPerceptionMood),&Parms);
    }
    void eventSetCurrentCombatZone(class ACombatZone* NewCZ)
    {
        GearAI_eventSetCurrentCombatZone_Parms Parms(EC_EventParm);
        Parms.NewCZ=NewCZ;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetCurrentCombatZone),&Parms);
    }
    void eventSetPendingCombatZone(class ACombatZone* NewCZ)
    {
        GearAI_eventSetPendingCombatZone_Parms Parms(EC_EventParm);
        Parms.NewCZ=NewCZ;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetPendingCombatZone),&Parms);
    }
    void eventAutoNotifyEnemy()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_AutoNotifyEnemy),NULL);
    }
    void eventAutoAcquireEnemy()
    {
        ProcessEvent(FindFunctionChecked(GEARGAME_AutoAcquireEnemy),NULL);
    }
    FLOAT eventGetDistanceFromSquadLeader(FVector TestLocation)
    {
        GearAI_eventGetDistanceFromSquadLeader_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.TestLocation=TestLocation;
        ProcessEvent(FindFunctionChecked(GEARGAME_GetDistanceFromSquadLeader),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetSquadName(FName NewSquadName,UBOOL bLeader=FALSE)
    {
        GearAI_eventSetSquadName_Parms Parms(EC_EventParm);
        Parms.NewSquadName=NewSquadName;
        Parms.bLeader=bLeader ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_SetSquadName),&Parms);
    }
    void eventNotifyEnemySeen(class APawn* SeenEnemy)
    {
        GearAI_eventNotifyEnemySeen_Parms Parms(EC_EventParm);
        Parms.SeenEnemy=SeenEnemy;
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyEnemySeen),&Parms);
    }
    void eventNotifyEnemyHeard(class APawn* HeardEnemy,FName NoiseType)
    {
        GearAI_eventNotifyEnemyHeard_Parms Parms(EC_EventParm);
        Parms.HeardEnemy=HeardEnemy;
        Parms.NoiseType=NoiseType;
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyEnemyHeard),&Parms);
    }
    void eventNotifyLostEnemyVisibility(class APawn* LostEnemy)
    {
        GearAI_eventNotifyLostEnemyVisibility_Parms Parms(EC_EventParm);
        Parms.LostEnemy=LostEnemy;
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyLostEnemyVisibility),&Parms);
    }
    void eventNotifyEnemyBecameVisible(class APawn* VisibleEnemy,FLOAT TimeSinceLastVisible)
    {
        GearAI_eventNotifyEnemyBecameVisible_Parms Parms(EC_EventParm);
        Parms.VisibleEnemy=VisibleEnemy;
        Parms.TimeSinceLastVisible=TimeSinceLastVisible;
        ProcessEvent(FindFunctionChecked(GEARGAME_NotifyEnemyBecameVisible),&Parms);
    }
    void eventNoticedEnemy(class APawn* NewEnemy)
    {
        GearAI_eventNoticedEnemy_Parms Parms(EC_EventParm);
        Parms.NewEnemy=NewEnemy;
        ProcessEvent(FindFunctionChecked(GEARGAME_NoticedEnemy),&Parms);
    }
    FString eventGetActionString()
    {
        GearAI_eventGetActionString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(GEARGAME_GetActionString),&Parms);
        return Parms.ReturnValue;
    }
    void eventAILog_Internal(const FString& LogText,FName LogCategory=NAME_None,UBOOL bForce=FALSE)
    {
        GearAI_eventAILog_Internal_Parms Parms(EC_EventParm);
        Parms.LogText=LogText;
        Parms.LogCategory=LogCategory;
        Parms.bForce=bForce ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_AILog_Internal),&Parms);
    }
    DECLARE_CLASS(AGearAI,AAIController,0|CLASS_Config,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("AI");}

	virtual void PreBeginPlay();

	virtual FGuid* GetGuid() { return &MyGuid; }

	virtual void AdjustHearingLocation(FVector &out_Location);

	virtual EGotoState GotoState( FName State, UBOOL bForceEvents = 0, UBOOL bKeepStack = 0 );
	virtual void ProcessState( FLOAT DeltaSeconds );

	virtual UBOOL IsPlayerOwner()
	{
		return FALSE;
	}

	virtual UBOOL WantsLedgeCheck();

	virtual FVector DesiredDirection()
	{
		return Pawn->Velocity;
	}

	virtual void	UpdatePawnRotation();
	virtual void	ShowSelf(){/*SILENCE! (handled with async visiblity, see AIVisibilityManager)*/}
	virtual DWORD	SeePawn( APawn *Other, UBOOL bMaySkipChecks = TRUE );
	virtual void	ProcessSightCheckResult( APawn* Other, UBOOL bVisible, FVector& VisLoc );
	virtual UBOOL   CanHear(const FVector& NoiseLoc, FLOAT Loudness, AActor *Other);

	virtual void	RouteCache_Empty();
	virtual void	RouteCache_AddItem( ANavigationPoint* Nav );
	virtual void	RouteCache_InsertItem( ANavigationPoint* Nav, INT Idx );
	virtual void	RouteCache_RemoveItem( ANavigationPoint* Nav );
	virtual void	RouteCache_RemoveIndex( INT Index, INT Count );

	virtual void ClearCrossLevelPaths(ULevel *Level);

// here is an easy way to disable AI logging :D
#define DO_AI_LOGGING (1 && !(NO_LOGGING || FINAL_RELEASE || LOOKING_FOR_PERF_ISSUES))
#if !DO_AI_LOGGING
	#if COMPILER_SUPPORTS_NOOP
		#define AIObjLog	__noop
		#define AILog		__noop
	#else
		#define AIObjLog	GNull->Logf
		#define AILog		GNull->Logf
	#endif
#else
	#define AIObjLog	AI->AILog
	VARARG_DECL(void,void,{},AILog,VARARG_NONE,const TCHAR*,VARARG_NONE,VARARG_NONE);
	VARARG_DECL(void,void,{},AILog,VARARG_NONE,const TCHAR*,VARARG_EXTRA(enum EName E),VARARG_EXTRA(E));
#endif

	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );


	virtual void GetLookDir(FVector& LookDir);
	virtual FRotator SetRotationRate(FLOAT DeltaTime);

	virtual UBOOL ShouldOffsetCorners() { return FALSE; }
	virtual UBOOL ShouldUsePathLanes() { return FALSE; }

	virtual void FailMove();

	virtual UBOOL ShouldIgnoreNavigationBlockingFor(const AActor* Other);
};

class AGearAI_Berserker : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_Berserker
    BITFIELD bPreparingCharge:1;
    BITFIELD bDirectCharge:1;
    BITFIELD bChargeAgain:1;
    class AActor* ChargeActor;
    FVector ChargeLocation;
    FVector ChargePivot;
    FLOAT ChargeUpdateTime;
    BYTE ChargeBreakCount;
    TArrayNoInit<class AActor*> ChargeHitList;
    FLOAT MaxSearchTime;
    FLOAT ChargeAdjustFOV;
    FLOAT ChargeAdjustDist;
    FLOAT NextHearTime;
    FVector2D SniffTime;
    INT NumFootSteps;
    //## END PROPS GearAI_Berserker

    DECLARE_CLASS(AGearAI_Berserker,AGearAI,0|CLASS_Config,GearGame)
	void AdjustHearingLocation(FVector &out_Location);
};

class AGearAI_Bloodmount : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_Bloodmount
    FLOAT LastMeleeCheckTime;
    class AGearPawn_LocustBloodmount* MyBloodMountPawn;
    FLOAT MaxRoamDist;
    FLOAT RoamEnvelopeOuter;
    FLOAT RoamEnvelopeInner;
    FLOAT RoamWaitMax;
    FLOAT RoamWaitMin;
    FLOAT OverallRoamDurationMax;
    FLOAT RoamStartTime;
    class UAIReactCond_EnemyCloseAndVisible* ChargeCondition;
    BITFIELD bHelmetGone:1;
    //## END PROPS GearAI_Bloodmount

    DECLARE_CLASS(AGearAI_Bloodmount,AGearAI,0|CLASS_Config,GearGame)
	virtual void UpdatePawnRotation();
};

struct FBrumakFirePattern
{
    FLOAT LeftGunFireTime;
    FLOAT LeftGunTimer;
    FLOAT RightGunFireTime;
    FLOAT RightGunTimer;
    FLOAT MainGunFireTime;
    FLOAT MainGunTimer;
    FLOAT SuperGunFireTime;
    FLOAT SuperGunTimer;
    FLOAT DelayEndTime;
    FLOAT DelayEndTimer;
    FName PatternName;

    /** Constructors */
    FBrumakFirePattern() {}
    FBrumakFirePattern(EEventParm)
    {
        appMemzero(this, sizeof(FBrumakFirePattern));
    }
};

struct FBrumakMeleeAttackDef
{
    BYTE AttackSpecialMove;
    BITFIELD bRequiresBrumakToStop:1 GCC_BITFIELD_MAGIC;
    FLOAT Chance;

    /** Constructors */
    FBrumakMeleeAttackDef() {}
    FBrumakMeleeAttackDef(EEventParm)
    {
        appMemzero(this, sizeof(FBrumakMeleeAttackDef));
    }
};

class AGearAI_Brumak : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_Brumak
    class AGearPawn_LocustBrumakBase* Brumak;
    class AGearAI_BrumakDriver* DriverAI;
    class AGearAI_Brumak_SideGun* LeftGunAI;
    class AGearAI_Brumak_SideGun* RightGunAI;
    BITFIELD bHijackedByLD:1;
    BITFIELD bDebugCyclePatterns:1;
    FVector MainGunFireOffset;
    FVector LeftGunFireOffset;
    FVector RightGunFireOffset;
    FLOAT LastMoveTime;
    TArrayNoInit<class APawn*> Internal_ActiveList;
    TArrayNoInit<struct FBrumakFirePattern> FirePattern;
    INT FirePatternIdx;
    FVector2D FirePatternDelayRange;
    struct FBrumakMeleeAttackDef CurrentBrumakMeleeAttack;
    TArrayNoInit<struct FBrumakMeleeAttackDef> BrumakMeleeAttackList;
    //## END PROPS GearAI_Brumak

    virtual UBOOL GetActiveEnemyList(TArray<class APawn*>& ActiveList);
    virtual UBOOL CanFireAtTarget(class AGearAI_Brumak_Slave* GunAI,class APawn* TestEnemy=NULL,FVector TestBaseLocation=FVector(EC_EventParm),FVector GunOffset=FVector(EC_EventParm),FRotator PawnRot=FRotator(EC_EventParm));
    virtual UBOOL CanFireAtAnyTarget(class APawn* TestEnemy=NULL,FVector TestBaseLocation=FVector(EC_EventParm),FRotator PawnRot=FRotator(EC_EventParm));
    virtual FVector GetVectorAvg(const TArray<class APawn*>& PawnList,FVector TestBaseLocation);
    DECLARE_FUNCTION(execGetActiveEnemyList)
    {
        P_GET_TARRAY_REF(class APawn*,ActiveList);
        P_FINISH;
        *(UBOOL*)Result=GetActiveEnemyList(ActiveList);
    }
    DECLARE_FUNCTION(execCanFireAtTarget)
    {
        P_GET_OBJECT(AGearAI_Brumak_Slave,GunAI);
        P_GET_OBJECT_OPTX(APawn,TestEnemy,NULL);
        P_GET_STRUCT_OPTX(FVector,TestBaseLocation,FVector(EC_EventParm));
        P_GET_STRUCT_OPTX(FVector,GunOffset,FVector(EC_EventParm));
        P_GET_STRUCT_OPTX(FRotator,PawnRot,FRotator(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=CanFireAtTarget(GunAI,TestEnemy,TestBaseLocation,GunOffset,PawnRot);
    }
    DECLARE_FUNCTION(execCanFireAtAnyTarget)
    {
        P_GET_OBJECT_OPTX(APawn,TestEnemy,NULL);
        P_GET_STRUCT_OPTX(FVector,TestBaseLocation,FVector(EC_EventParm));
        P_GET_STRUCT_OPTX(FRotator,PawnRot,FRotator(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=CanFireAtAnyTarget(TestEnemy,TestBaseLocation,PawnRot);
    }
    DECLARE_FUNCTION(execGetVectorAvg)
    {
        P_GET_TARRAY(class APawn*,PawnList);
        P_GET_STRUCT(FVector,TestBaseLocation);
        P_FINISH;
        *(FVector*)Result=GetVectorAvg(PawnList,TestBaseLocation);
    }
    DECLARE_CLASS(AGearAI_Brumak,AGearAI,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearAI_Brumak)
};

#define UCONST_TIMER_ADJUSTTOSLOT_LIMIT 5.f

struct GearAI_Cover_eventUseTurret_Parms
{
    class ATurret* inTurret;
    UBOOL inbIgnoreFlank;
    UBOOL inbTeleportToTurret;
    UBOOL ReturnValue;
    GearAI_Cover_eventUseTurret_Parms(EEventParm)
    {
    }
};
struct GearAI_Cover_eventShouldDo360Aiming_Parms
{
    FVector TargLoc;
    UBOOL ReturnValue;
    GearAI_Cover_eventShouldDo360Aiming_Parms(EEventParm)
    {
    }
};
struct GearAI_Cover_eventShouldBlindFire_Parms
{
    UBOOL ReturnValue;
    GearAI_Cover_eventShouldBlindFire_Parms(EEventParm)
    {
    }
};
struct GearAI_Cover_eventCanRun2Cover_Parms
{
    UBOOL ReturnValue;
    GearAI_Cover_eventCanRun2Cover_Parms(EEventParm)
    {
    }
};
class AGearAI_Cover : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_Cover
    struct FCoverInfo Cover;
    struct FCoverInfo CoverGoal;
    struct FCoverInfo LastCover;
    FLOAT EnterCoverTime;
    FLOAT MinStayAtCoverTime;
    struct FFireLinkItem PendingFireLinkItem;
    BYTE OldCoverType;
    BITFIELD bIgnoreFireLinks:1 GCC_BITFIELD_MAGIC;
    BITFIELD bShouldRun2Cover:1;
    BITFIELD bSkipMinCoverDistCheck:1;
    BITFIELD bSkipMaxCoverDistCheck:1;
    BITFIELD bLeaveCoverFast:1;
    FLOAT LastRun2CoverTime;
    FLOAT LastFireFromCoverTime;
    FLOAT LastChangeCoverTime;
    FLOAT DesiredCoverMoveDist;
    FLOAT MinCoverMoveDist;
    FLOAT MaxCoverMoveDist;
    FLOAT AdjustToSlotTime;
    class ACoverSlotMarker* Run2CoverMarker;
    FLOAT NextAllowPeekTime;
    FLOAT LastMeatShieldReactionTime;
    FLOAT MeatShield_Reaction_MinTimeInterval;
    FLOAT MeatShield_Reaction_Chance;
    FLOAT MeatShield_Reaction_Delay;
    class AGearPawn* MeatShield_Reaction_Target;
    TArrayNoInit<class UClass*> SPItemsToConsider;
    class UGoal_AtCover* AtCover_Toward;
    class UGoal_AtCover* AtCover_Away;
    class UGoal_AtCover* AtCover_Near;
    class UGoal_AtCover* AtCover_Squad;
    class UGoal_AtCover* AtCover_Ambush;
    class UGoal_AtCover* AtCover_AlongPath;
    TArrayNoInit<class ACoverLink*> AllowedCoverLinks;
    class UAIReactCond_StoppingPowerThreshold* StoppingPowerReactionTemplate;
    //## END PROPS GearAI_Cover

    void ForceLog(const FString& S);
    virtual UBOOL IsLookingAtWall();
    UBOOL IsValidCover(const struct FCoverInfo& TestCover);
    UBOOL HasValidCover();
    UBOOL GetCoverAction(struct FCoverInfo& ChkCover,class AActor* ChkTarget=NULL,UBOOL bAnyAction=FALSE,UBOOL bTest=FALSE,FName DebugTag=NAME_None);
    DECLARE_FUNCTION(execForceLog)
    {
        P_GET_STR(S);
        P_FINISH;
        ForceLog(S);
    }
    DECLARE_FUNCTION(execIsLookingAtWall)
    {
        P_FINISH;
        *(UBOOL*)Result=IsLookingAtWall();
    }
    DECLARE_FUNCTION(execIsValidCover)
    {
        P_GET_STRUCT_REF(struct FCoverInfo,TestCover);
        P_FINISH;
        *(UBOOL*)Result=IsValidCover(TestCover);
    }
    DECLARE_FUNCTION(execHasValidCover)
    {
        P_FINISH;
        *(UBOOL*)Result=HasValidCover();
    }
    DECLARE_FUNCTION(execGetCoverAction)
    {
        P_GET_STRUCT_REF(struct FCoverInfo,ChkCover);
        P_GET_OBJECT_OPTX(AActor,ChkTarget,NULL);
        P_GET_UBOOL_OPTX(bAnyAction,FALSE);
        P_GET_UBOOL_OPTX(bTest,FALSE);
        P_GET_NAME_OPTX(DebugTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=GetCoverAction(ChkCover,ChkTarget,bAnyAction,bTest,DebugTag);
    }
    DECLARE_FUNCTION(execAdjustToSlot);
    UBOOL eventUseTurret(class ATurret* inTurret,UBOOL inbIgnoreFlank,UBOOL inbTeleportToTurret=FALSE)
    {
        GearAI_Cover_eventUseTurret_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.inTurret=inTurret;
        Parms.inbIgnoreFlank=inbIgnoreFlank ? FIRST_BITFIELD : FALSE;
        Parms.inbTeleportToTurret=inbTeleportToTurret ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_UseTurret),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShouldDo360Aiming(FVector TargLoc)
    {
        GearAI_Cover_eventShouldDo360Aiming_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.TargLoc=TargLoc;
        ProcessEvent(FindFunctionChecked(GEARGAME_ShouldDo360Aiming),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShouldBlindFire()
    {
        GearAI_Cover_eventShouldBlindFire_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_ShouldBlindFire),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventCanRun2Cover()
    {
        GearAI_Cover_eventCanRun2Cover_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(GEARGAME_CanRun2Cover),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AGearAI_Cover,AGearAI,0|CLASS_Config,GearGame)
	virtual void ClearCrossLevelPaths(ULevel *Level);

	DECLARE_FUNCTION(execPollAdjustToSlot);
	DECLARE_FUNCTION(execPollMoveToward);
};

class AGearAI_COGGear : public AGearAI_Cover
{
public:
    //## BEGIN PROPS GearAI_COGGear
    class AGearPC* Player;
    FLOAT CurBumpVal;
    FLOAT BumpThreshold;
    FLOAT BumpDecayRate;
    FLOAT BumpGrowthRate;
    BITFIELD bBumpedThisFrame:1;
    class AGearPawn* lastbumper;
    //## END PROPS GearAI_COGGear

    virtual UBOOL BumperSomewhereToGo();
    DECLARE_FUNCTION(execBumperSomewhereToGo)
    {
        P_FINISH;
        *(UBOOL*)Result=BumperSomewhereToGo();
    }
    DECLARE_CLASS(AGearAI_COGGear,AGearAI_Cover,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearAI_COGGear)
};

class AGearAI_TDM : public AGearAI_Cover
{
public:
    //## BEGIN PROPS GearAI_TDM
    FLOAT HammerburstChance;
    class AActor* RoamGoal;
    BITFIELD bRoamGoalCacheValid:1;
    BITFIELD bForceWeaponRush:1;
    BITFIELD bCheckedEnemySpawnPoint:1;
    FLOAT LastGrenadePlantTime;
    class UAIReactCondition_Base* DamageInterruptReaction;
    class UAIReactCondition_Base* LeaderDamageInterruptReaction;
    class UGoal_AtCover* AtCover_VeryNear;
    class UGoal_AtCover* AtCover_TowardEnemyAggressive;
    //## END PROPS GearAI_TDM

    DECLARE_CLASS(AGearAI_TDM,AGearAI_Cover,0|CLASS_Config,GearGame)
	virtual UBOOL IsPlayerOwner()
	{
		return TRUE;
	}
};

#define UCONST_ChargeRadius 1768
#define UCONST_ExplosionRadius 300

class AGearAI_Ticker : public AGearAI_Cover
{
public:
    //## BEGIN PROPS GearAI_Ticker
    INT ExplosionHealthThresh;
    FLOAT LastSawEnemyTime;
    //## END PROPS GearAI_Ticker

    DECLARE_CLASS(AGearAI_Ticker,AGearAI_Cover,0|CLASS_Config,GearGame)
	virtual void UpdatePawnRotation();
};

class AGearAI_Wretch : public AGearAI_Cover
{
public:
    //## BEGIN PROPS GearAI_Wretch
    //## END PROPS GearAI_Wretch

    DECLARE_CLASS(AGearAI_Wretch,AGearAI_Cover,0|CLASS_Config,GearGame)
	virtual void UpdatePawnRotation();
};

class AGearAI_Jack : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_Jack
    class AVehicle_Jack_Base* Jack;
    FVector LastIdleLocation;
    FVector LastMoveLocation;
    FLOAT NextPOITime;
    FLOAT NextIdleMoveTime;
    BITFIELD bScriptedCloaking:1;
    BITFIELD bTeleporting:1;
    BITFIELD bLDSetPOI:1;
    FLOAT CloakByEnemyTime;
    FLOAT LastReachedMoveGoalTime;
    TArrayNoInit<class AJackPointOfInterest*> JackInterestList;
    //## END PROPS GearAI_Jack

    virtual UBOOL FindGoodTeleportSpot(FVector ChkExtent,FVector& out_Dest);
    DECLARE_FUNCTION(execFindGoodTeleportSpot)
    {
        P_GET_STRUCT(FVector,ChkExtent);
        P_GET_STRUCT_REF(FVector,out_Dest);
        P_FINISH;
        *(UBOOL*)Result=FindGoodTeleportSpot(ChkExtent,out_Dest);
    }
    DECLARE_CLASS(AGearAI_Jack,AGearAI,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearAI_Jack)
};

class AGearAI_Nemacyst : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_Nemacyst
    class APawn* LastEnemy;
    FLOAT AlignToVelThreshold;
    BITFIELD bRestoreAirSpeed:1;
    BITFIELD bLaunching:1;
    FRotator SpinRot;
    FLOAT SpinDir;
    FLOAT HearingRadius;
    class AVolume_Nemacyst* CurrentVolume;
    //## END PROPS GearAI_Nemacyst

    class AVolume_Nemacyst* GetActiveNemacystVolume();
    virtual UBOOL SuggestNewMovePoint(FVector& out_NewMovePt,FVector TryThisDirFirst,FLOAT MoveDist=1024.000000);
    DECLARE_FUNCTION(execGetActiveNemacystVolume)
    {
        P_FINISH;
        *(class AVolume_Nemacyst**)Result=GetActiveNemacystVolume();
    }
    DECLARE_FUNCTION(execSuggestNewMovePoint)
    {
        P_GET_STRUCT_REF(FVector,out_NewMovePt);
        P_GET_STRUCT(FVector,TryThisDirFirst);
        P_GET_FLOAT_OPTX(MoveDist,1024.000000);
        P_FINISH;
        *(UBOOL*)Result=SuggestNewMovePoint(out_NewMovePt,TryThisDirFirst,MoveDist);
    }
    DECLARE_CLASS(AGearAI_Nemacyst,AGearAI,0|CLASS_Config,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearAI_Nemacyst)
};

class AGearAI_SecurityNemacyst : public AGearAI_Nemacyst
{
public:
    //## BEGIN PROPS GearAI_SecurityNemacyst
    FLOAT HoverHeight;
    FLOAT OldAirSpeed;
    //## END PROPS GearAI_SecurityNemacyst

    DECLARE_CLASS(AGearAI_SecurityNemacyst,AGearAI_Nemacyst,0|CLASS_Config,GearGame)
	virtual void GetLookDir(FVector& LookDir);
};

class AGearAI_RockWorm : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_RockWorm
    //## END PROPS GearAI_RockWorm

    virtual UBOOL IsFriendly(class AController* TestPlayer);
    DECLARE_CLASS(AGearAI_RockWorm,AGearAI,0|CLASS_Config,GearGame)
	virtual UBOOL ShouldIgnoreNavigationBlockingFor(const AActor* Other);
	virtual void ClearCrossLevelPaths(ULevel* Level);
	virtual void UpdatePawnRotation();
};

class AGearAI_SecurityBotStationary : public AGearAI
{
public:
    //## BEGIN PROPS GearAI_SecurityBotStationary
    INT PatrolArcDegreesLeft;
    INT PatrolArcDegreesRight;
    FLOAT PatrolDelay;
    FLOAT PatrolPeriod;
    BITFIELD bEnabled:1;
    FRotator InitialRot;
    FRotator TempRot;
    class AGearpawn_SecurityBotStationaryBase* MyBotPawn;
    class AGearPawn* GearEnemy;
    class AGearTeamInfo* MyTeam;
    //## END PROPS GearAI_SecurityBotStationary

    DECLARE_CLASS(AGearAI_SecurityBotStationary,AGearAI,0|CLASS_Config,GearGame)
	virtual void PostScriptDestroyed();
};

class AGearAI_Brumak_Slave : public AAIController
{
public:
    //## BEGIN PROPS GearAI_Brumak_Slave
    class AGearPawn_LocustBrumakBase* Brumak;
    class AGearAI_Brumak* BrumakAI;
    BITFIELD bAbleToFire:1;
    class AActor* ScriptedFireTarget;
    //## END PROPS GearAI_Brumak_Slave

    DECLARE_CLASS(AGearAI_Brumak_Slave,AAIController,0,GearGame)
    static const TCHAR* StaticConfigName() {return TEXT("AI");}

	virtual UBOOL IsPlayerOwner()
	{
		return FALSE;
	}
};

class AGearAI_Brumak_SideGun : public AGearAI_Brumak_Slave
{
public:
    //## BEGIN PROPS GearAI_Brumak_SideGun
    class AGearPawn_LocustBrumak_SideGun* Gun;
    //## END PROPS GearAI_Brumak_SideGun

    DECLARE_CLASS(AGearAI_Brumak_SideGun,AGearAI_Brumak_Slave,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearAI_Brumak_SideGun)
};

class AGearAI_BrumakDriver : public AGearAI_Brumak_Slave
{
public:
    //## BEGIN PROPS GearAI_BrumakDriver
    //## END PROPS GearAI_BrumakDriver

    DECLARE_CLASS(AGearAI_BrumakDriver,AGearAI_Brumak_Slave,0,GearGame)
    NO_DEFAULT_CONSTRUCTOR(AGearAI_BrumakDriver)
};

class UAIReactCond_NewEnemy : public UAIReactCond_Conduit_Base
{
public:
    //## BEGIN PROPS AIReactCond_NewEnemy
    FLOAT TimeSinceSeenThresholdSeconds;
    //## END PROPS AIReactCond_NewEnemy

    DECLARE_CLASS(UAIReactCond_NewEnemy,UAIReactCond_Conduit_Base,0,GearGame)
	virtual UBOOL ShouldActivateNative(AActor* Instigator, UAIReactChannel* OriginatingChannel);
};

class UAIReactCond_SurpriseEnemyLoc : public UAIReactCond_Conduit_Base
{
public:
    //## BEGIN PROPS AIReactCond_SurpriseEnemyLoc
    //## END PROPS AIReactCond_SurpriseEnemyLoc

    DECLARE_CLASS(UAIReactCond_SurpriseEnemyLoc,UAIReactCond_Conduit_Base,0,GearGame)
	virtual UBOOL ShouldActivateNative(AActor* Instigator, UAIReactChannel* OriginatingChannel);
};

class UAIReactCond_Targeted : public UAIReactCondition_Base
{
public:
    //## BEGIN PROPS AIReactCond_Targeted
    class APawn* shooter;
    FLOAT ShooterRangeThreshold;
    //## END PROPS AIReactCond_Targeted

    DECLARE_CLASS(UAIReactCond_Targeted,UAIReactCondition_Base,0,GearGame)
	virtual UBOOL ShouldActivateNative(AActor* Instigator, UAIReactChannel* OriginatingChannel);
};

#define UCONST_bUseAsyncLineChecksForVisibility 0
#define UCONST_MaxLineChecksPerFrame 15
#define UCONST_PoolSize 50

class UAIVisibilityManager : public UObject
{
public:
    //## BEGIN PROPS AIVisibilityManager
    INT ControllerIttStartPoint;
    BITFIELD bDrawVisTests:1;
    //## END PROPS AIVisibilityManager

    void NotifyPawnDestroy(class APawn* Pawn);
    void Reset();
    DECLARE_FUNCTION(execNotifyPawnDestroy)
    {
        P_GET_OBJECT(APawn,Pawn);
        P_FINISH;
        NotifyPawnDestroy(Pawn);
    }
    DECLARE_FUNCTION(execReset)
    {
        P_FINISH;
        Reset();
    }
    DECLARE_CLASS(UAIVisibilityManager,UObject,0,GearGame)
	class LineCheckResult: public FAsyncLineCheckResult
	{

	public:
		typedef UBOOL (AGearAI::*ShouldLineCheckCb)( APawn *E, FVector& LineChkStart, FVector& LineChkEnd );
		typedef void (AGearAI::*FinishedCallback)(APawn* TestedPawn, UBOOL bVisible, FVector& VisLoc );

		LineCheckResult() :
		  FAsyncLineCheckResult()
		  ,TestingAI(NULL)
		  ,PawnToTestAgainst(NULL)
		  ,bStale(FALSE)
		  ,Next(NULL)
		  ,FinishedCallBackFunction(NULL)
		  ,ShouldCheckFunction(NULL)
		  ,CheckStart(0.f)
		  ,CheckEnd(0.f)
		  {}

		void InitLineCheck(AGearAI* InTestingAI, APawn* InPawnToTestAgainst, ShouldLineCheckCb ShouldCheckCallBack, FinishedCallback FinCallback)
		{
			TestingAI = InTestingAI;
			PawnToTestAgainst = InPawnToTestAgainst;
			FinishedCallBackFunction = FinCallback;
			ShouldCheckFunction = ShouldCheckCallBack;
			bCheckStarted = FALSE;
			bCheckCompleted = FALSE;
			bHit = FALSE;
			bStale=FALSE;
		}

		void TestFinished()
		{
			if(bStale == FALSE && TestingAI && FinishedCallBackFunction)
			{
				((*TestingAI).*FinishedCallBackFunction)(PawnToTestAgainst,!bHit,CheckEnd);
			}
		}

		virtual void Serialize( FArchive& Ar )
		{
			Ar << TestingAI;
			Ar << PawnToTestAgainst;
		}

		/**
		 * calls ShouldCheckCallback to determine endpoints for linecheck, and see if we should early out
		 * @return returns TRUE if a sight check was queued
		 */
		UBOOL TriggerLineCheck();

		/** Pawn we're testing from **/
		AGearAI* TestingAI;
		/** Pawn we're testing to **/
		APawn* PawnToTestAgainst;

		/** Bool that indicates one or both of the pawns involved in this linecheck have been deleted, so don't call the callback if this is true! **/
		UBOOL bStale;

		LineCheckResult* Next;

		FinishedCallback FinishedCallBackFunction;
		ShouldLineCheckCb ShouldCheckFunction;

		// The start/end of this line check
		// Visibility position is marked at CheckEnd because target likely moved during the async check
		FVector CheckStart, CheckEnd;
	};

public:
	UAIVisibilityManager() :
	  FreeLineCheckResList(NULL)
	  ,BusyLineCheckResList(NULL)
	  ,PendingLineCheckHead(NULL)
	  ,PendingLineCheckTail(NULL)
	{
		if (!IsTemplate())
		{
			Init();
		}
	}
	virtual void FinishDestroy()
	{
		Super::FinishDestroy();
		Flush();
	}


	/** RequestSightCheckForAToB
		* Will return the current known status of the test requested, and kick off a new test if needed
		* @param PawnA  - the pawn who wants to do a sight check
		* @param PawnB  - the pawn to sight check against (e.g. PawnA wants to know if it can see pawnB)
		* @param FromPt - start point for Line Check
		* @param ToPt   - end point for Line Check
		* @param Cb	  - callback function to call when we have a result
		*/
	UBOOL RequestSightCheck(AGearAI* InTestingAI, APawn* PawnToTest, LineCheckResult::ShouldLineCheckCb ShouldCheckCb, LineCheckResult::FinishedCallback FinishedCb);
	/** iterates through the list of pending tests to see if they're done **/
	void Tick(FLOAT DeltaTime);
	/** wipes all records and pending tests MT->how do we do this safely? (physics might still have a ptr) **/
	void Flush();

	void Init();

	virtual void AddReferencedObjects(TArray<UObject*>& ObjectArray);
private:
   /** AddBackToPool
	* moves LineCheckRes from the busy list to the free list
	* @param LineCheckResToMove - the line check to move
	* @param PrevLineCheckRes - the line check result in the list just before the one we're moving
    */
	void AddBackToPool(LineCheckResult* LineCheckResToMove, LineCheckResult* PrevLineCheckRes, LineCheckResult*& DestPool, LineCheckResult*& SrcPool);

	/**
	 * iterates over busy line check results checking to see if they've gotten a result back yet, if so move them back to free lsit
	 */
	void UpdateBusyLineChecks();

	/**
	 * initiates requests to physics for pending line checks until we hit the max per frame
	 */
	void DoPhysRequestsForPendingLineChecks();

	/**
	 * (replaces ShowSelf() iterates over all controllers and queues up line check requests when neccesary
	 *  This replaces ShowSelf so that we can rotate through the controller list round-robin style and make sure everyone gets
	 *  a sight result
	 */
	void QueueUpVisRequests();

	UBOOL SuccessfullyShowedController(AController* Controller);

	LineCheckResult* FreeLineCheckResList;
	LineCheckResult* BusyLineCheckResList;
	LineCheckResult* PendingLineCheckHead;
	LineCheckResult* PendingLineCheckTail;

};

class UPath_AvoidanceVolumes : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_AvoidanceVolumes
    class AGearAI* MyGearAI;
    TArrayNoInit<class UAIAvoidanceCylinderComponent*> AffectingCylinders;
    //## END PROPS Path_AvoidanceVolumes

    DECLARE_CLASS(UPath_AvoidanceVolumes,UPathConstraint,0,GearGame)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

struct FEnemyCoverInfo
{
    class AGearPawn* Enemy;
    struct FCoverInfo Cover;

    /** Constructors */
    FEnemyCoverInfo() {}
    FEnemyCoverInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEnemyCoverInfo));
    }
};

class UPath_AvoidFireFromCover : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_AvoidFireFromCover
    class AGearAI* AI;
    TArrayNoInit<struct FEnemyCoverInfo> EnemyList;
    //## END PROPS Path_AvoidFireFromCover

    DECLARE_CLASS(UPath_AvoidFireFromCover,UPathConstraint,0,GearGame)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_PreferCover : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_PreferCover
    //## END PROPS Path_PreferCover

    DECLARE_CLASS(UPath_PreferCover,UPathConstraint,0,GearGame)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_WithinCombatZone : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_WithinCombatZone
    class ACombatZone* SpecificCombatZone;
    class AGearAI* AI;
    INT LeavingCombatZonePenalty;
    //## END PROPS Path_WithinCombatZone

    DECLARE_CLASS(UPath_WithinCombatZone,UPathConstraint,0,GearGame)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

struct Goal_AtCover_eventAddCoverGoalConstraint_Parms
{
    class UCoverGoalConstraint* Constraint;
    Goal_AtCover_eventAddCoverGoalConstraint_Parms(EEventParm)
    {
    }
};
class UGoal_AtCover : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_AtCover
    class AGearAI_Cover* AI;
    class ACoverSlotMarker* BestMarker;
    INT BestRating;
    INT MaxToRate;
    INT NumMarkersTested;
    class AActor* TetherActor;
    TArrayNoInit<class UCoverGoalConstraint*> CoverGoalConstraints;
    //## END PROPS Goal_AtCover

    virtual void InitNative();
    DECLARE_FUNCTION(execInitNative)
    {
        P_FINISH;
        InitNative();
    }
    DECLARE_FUNCTION(execRateSlotMarker);
    void eventAddCoverGoalConstraint(class UCoverGoalConstraint* Constraint)
    {
        Goal_AtCover_eventAddCoverGoalConstraint_Parms Parms(EC_EventParm);
        Parms.Constraint=Constraint;
        ProcessEvent(FindFunctionChecked(GEARGAME_AddCoverGoalConstraint),&Parms);
    }
    DECLARE_CLASS(UGoal_AtCover,UPathGoalEvaluator,0,GearGame)
	// Interface
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal( ANavigationPoint*& out_GoalNav );
	void RateSlotMarker(ACoverSlotMarker* Marker, APawn* Pawn, INT BaseRating);
	virtual void NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess );
	UBOOL IsValid(ACoverSlotMarker* Marker, APawn* Pawn);
};

class UGoal_InCombatZone : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_InCombatZone
    class AGearAI* AI;
    //## END PROPS Goal_InCombatZone

    DECLARE_CLASS(UGoal_InCombatZone,UPathGoalEvaluator,0,GearGame)
	// Interface
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
};

class UGoal_OutsideAvoidanceVolumes : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_OutsideAvoidanceVolumes
    class AGearAI* AI;
    //## END PROPS Goal_OutsideAvoidanceVolumes

    DECLARE_CLASS(UGoal_OutsideAvoidanceVolumes,UPathGoalEvaluator,0,GearGame)
	// Interface
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
};

class UGoal_SpawnPoints : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_SpawnPoints
    class AGearAI_Cover* AI;
    TArrayNoInit<class ANavigationPoint*> PickedSpawnPoints;
    TArrayNoInit<class ANavigationPoint*> BackupSpawnPoints;
    INT NumSpawnpointsNeeded;
    FLOAT MinDistToEnemy;
    //## END PROPS Goal_SpawnPoints

    DECLARE_CLASS(UGoal_SpawnPoints,UPathGoalEvaluator,0,GearGame)
	// Interface
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal( ANavigationPoint*& out_GoalNav );
};

class UMantleReachSpec_Rockworm : public UMantleReachSpec
{
public:
    //## BEGIN PROPS MantleReachSpec_Rockworm
    //## END PROPS MantleReachSpec_Rockworm

    DECLARE_CLASS(UMantleReachSpec_Rockworm,UMantleReachSpec,0,GearGame)
	virtual UBOOL CanBeSkipped(APawn* P);
};

#endif // !INCLUDED_GEARGAME_AI_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AAIAvoidanceCylinder,-1,execForceReTouch);
AUTOGENERATE_FUNCTION(UAIAvoidanceCylinderComponent,-1,execShouldAIAvoidMe);
AUTOGENERATE_FUNCTION(UAIAvoidanceCylinderComponent,-1,execBuildListOfAffectingCylinders);
AUTOGENERATE_FUNCTION(UAIAvoidanceCylinderComponent,-1,execDoesSpecIntersect);
AUTOGENERATE_FUNCTION(UAIAvoidanceCylinderComponent,-1,execIsNavPointWithin);
AUTOGENERATE_FUNCTION(UAIVisibilityManager,-1,execReset);
AUTOGENERATE_FUNCTION(UAIVisibilityManager,-1,execNotifyPawnDestroy);
AUTOGENERATE_FUNCTION(AGearAI,-1,execNotifyDidSomethingInteresting);
AUTOGENERATE_FUNCTION(AGearAI,-1,execCanEvade);
AUTOGENERATE_FUNCTION(AGearAI,-1,execGetRouteCacheDistance);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsWithinTether);
AUTOGENERATE_FUNCTION(AGearAI,-1,execAssignAnchor);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsWithinCombatZone);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsCoverWithinCombatZone);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsCoverExposedToAnEnemy);
AUTOGENERATE_FUNCTION(AGearAI,-1,execGetPlayerCover);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsEnemyVisible);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsMeleeRange);
AUTOGENERATE_FUNCTION(AGearAI,-1,execGetEnemyLocation);
AUTOGENERATE_FUNCTION(AGearAI,-1,execGetFireTargetLocation);
AUTOGENERATE_FUNCTION(AGearAI,-1,execShouldCheckToSeeEnemy);
AUTOGENERATE_FUNCTION(AGearAI,-1,execHasEnemyWithinDistance);
AUTOGENERATE_FUNCTION(AGearAI,-1,execHasValidTarget);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsFriendly);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIsFriendlyPawn);
AUTOGENERATE_FUNCTION(AGearAI,-1,execProcessStimulus);
AUTOGENERATE_FUNCTION(AGearAI,-1,execSeePlayer);
AUTOGENERATE_FUNCTION(AGearAI,-1,execIgnoreNotifies);
AUTOGENERATE_FUNCTION(AGearAI,-1,execGetNavigationPointsNear);
AUTOGENERATE_FUNCTION(AGearAI,-1,execFindCommandOfClass);
AUTOGENERATE_FUNCTION(AGearAI,-1,execDumpPathConstraints);
AUTOGENERATE_FUNCTION(AGearAI,-1,execDumpCommandStack);
AUTOGENERATE_FUNCTION(AGearAI,-1,execCheckCommandCount);
AUTOGENERATE_FUNCTION(AGearAI,-1,execGetActiveCommand);
AUTOGENERATE_FUNCTION(AGearAI,-1,execAbortCommand);
AUTOGENERATE_FUNCTION(AGearAI,-1,execPopCommand);
AUTOGENERATE_FUNCTION(AGearAI,-1,execPushCommand);
AUTOGENERATE_FUNCTION(AGearAI_Brumak,-1,execGetVectorAvg);
AUTOGENERATE_FUNCTION(AGearAI_Brumak,-1,execCanFireAtAnyTarget);
AUTOGENERATE_FUNCTION(AGearAI_Brumak,-1,execCanFireAtTarget);
AUTOGENERATE_FUNCTION(AGearAI_Brumak,-1,execGetActiveEnemyList);
AUTOGENERATE_FUNCTION(AGearAI_COGGear,-1,execBumperSomewhereToGo);
AUTOGENERATE_FUNCTION(AGearAI_Cover,-1,execAdjustToSlot);
AUTOGENERATE_FUNCTION(AGearAI_Cover,-1,execGetCoverAction);
AUTOGENERATE_FUNCTION(AGearAI_Cover,-1,execHasValidCover);
AUTOGENERATE_FUNCTION(AGearAI_Cover,-1,execIsValidCover);
AUTOGENERATE_FUNCTION(AGearAI_Cover,-1,execIsLookingAtWall);
AUTOGENERATE_FUNCTION(AGearAI_Cover,-1,execForceLog);
AUTOGENERATE_FUNCTION(AGearAI_Jack,-1,execFindGoodTeleportSpot);
AUTOGENERATE_FUNCTION(AGearAI_Nemacyst,-1,execSuggestNewMovePoint);
AUTOGENERATE_FUNCTION(AGearAI_Nemacyst,-1,execGetActiveNemacystVolume);
AUTOGENERATE_FUNCTION(AGearAI_RockWorm,-1,execIsFriendly);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetChanceToDuckBackIntoCover);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetSquadCentroid);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execAddCoverDecay);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execAllMembers);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execAllEnemies);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetEnemyCover);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetSquadLeaderLocation);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetSquadLeaderPosition);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetEnemyLastSeenTime);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetEnemyLocationByIndex);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetEnemyLocation);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execGetEnemyIndex);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execRemoveEnemy);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execAddEnemy);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execSetKnownEnemyInfo);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execBroadcastStimulus);
AUTOGENERATE_FUNCTION(AGearSquad,-1,execProcessStimulus);
AUTOGENERATE_FUNCTION(AGearSquadFormation,-1,execGetNumSquadMembersThatUsePositions);
AUTOGENERATE_FUNCTION(UGoal_AtCover,-1,execRateSlotMarker);
AUTOGENERATE_FUNCTION(UGoal_AtCover,-1,execInitNative);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GEARGAME_AI_NATIVE_DEFS
#define GEARGAME_AI_NATIVE_DEFS

DECLARE_NATIVE_TYPE(GearGame,AAIAvoidanceCylinder);
DECLARE_NATIVE_TYPE(GearGame,UAIAvoidanceCylinderComponent);
DECLARE_NATIVE_TYPE(GearGame,UAIReactCond_NewEnemy);
DECLARE_NATIVE_TYPE(GearGame,UAIReactCond_SurpriseEnemyLoc);
DECLARE_NATIVE_TYPE(GearGame,UAIReactCond_Targeted);
DECLARE_NATIVE_TYPE(GearGame,UAIVisibilityManager);
DECLARE_NATIVE_TYPE(GearGame,UCombatZoneRenderingComponent);
DECLARE_NATIVE_TYPE(GearGame,AGameplayRoute);
DECLARE_NATIVE_TYPE(GearGame,AGearAI);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Berserker);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Bloodmount);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Brumak);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Brumak_SideGun);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Brumak_Slave);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_BrumakDriver);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_COGGear);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Cover);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Jack);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Nemacyst);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_RockWorm);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_SecurityBotStationary);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_SecurityNemacyst);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_TDM);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Ticker);
DECLARE_NATIVE_TYPE(GearGame,AGearAI_Wretch);
DECLARE_NATIVE_TYPE(GearGame,AGearSquad);
DECLARE_NATIVE_TYPE(GearGame,AGearSquadFormation);
DECLARE_NATIVE_TYPE(GearGame,UGoal_AtCover);
DECLARE_NATIVE_TYPE(GearGame,UGoal_InCombatZone);
DECLARE_NATIVE_TYPE(GearGame,UGoal_OutsideAvoidanceVolumes);
DECLARE_NATIVE_TYPE(GearGame,UGoal_SpawnPoints);
DECLARE_NATIVE_TYPE(GearGame,ULadderMeshComponent);
DECLARE_NATIVE_TYPE(GearGame,UMantleReachSpec_Rockworm);
DECLARE_NATIVE_TYPE(GearGame,UPath_AvoidanceVolumes);
DECLARE_NATIVE_TYPE(GearGame,UPath_AvoidFireFromCover);
DECLARE_NATIVE_TYPE(GearGame,UPath_PreferCover);
DECLARE_NATIVE_TYPE(GearGame,UPath_WithinCombatZone);
DECLARE_NATIVE_TYPE(GearGame,USecurityBotStationaryRenderingComponent);

#define AUTO_INITIALIZE_REGISTRANTS_GEARGAME_AI \
	AAIAvoidanceCylinder::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAAIAvoidanceCylinderNative; \
	UAIAvoidanceCylinderComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIAvoidanceCylinderComponentNative; \
	UAIReactCond_NewEnemy::StaticClass(); \
	UAIReactCond_SurpriseEnemyLoc::StaticClass(); \
	UAIReactCond_Targeted::StaticClass(); \
	UAIVisibilityManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUAIVisibilityManagerNative; \
	UCombatZoneRenderingComponent::StaticClass(); \
	AGameplayRoute::StaticClass(); \
	AGearAI::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAINative; \
	AGearAI_Berserker::StaticClass(); \
	AGearAI_Bloodmount::StaticClass(); \
	AGearAI_Brumak::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAI_BrumakNative; \
	AGearAI_Brumak_SideGun::StaticClass(); \
	AGearAI_Brumak_Slave::StaticClass(); \
	AGearAI_BrumakDriver::StaticClass(); \
	AGearAI_COGGear::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAI_COGGearNative; \
	AGearAI_Cover::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAI_CoverNative; \
	AGearAI_Jack::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAI_JackNative; \
	AGearAI_Nemacyst::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAI_NemacystNative; \
	AGearAI_RockWorm::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearAI_RockWormNative; \
	AGearAI_SecurityBotStationary::StaticClass(); \
	AGearAI_SecurityNemacyst::StaticClass(); \
	AGearAI_TDM::StaticClass(); \
	AGearAI_Ticker::StaticClass(); \
	AGearAI_Wretch::StaticClass(); \
	AGearSquad::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearSquadNative; \
	AGearSquadFormation::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameAGearSquadFormationNative; \
	UGoal_AtCover::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindGearGameUGoal_AtCoverNative; \
	UGoal_InCombatZone::StaticClass(); \
	UGoal_OutsideAvoidanceVolumes::StaticClass(); \
	UGoal_SpawnPoints::StaticClass(); \
	ULadderMeshComponent::StaticClass(); \
	UMantleReachSpec_Rockworm::StaticClass(); \
	UPath_AvoidanceVolumes::StaticClass(); \
	UPath_AvoidFireFromCover::StaticClass(); \
	UPath_PreferCover::StaticClass(); \
	UPath_WithinCombatZone::StaticClass(); \
	USecurityBotStationaryRenderingComponent::StaticClass(); \

#endif // GEARGAME_AI_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AAIAvoidanceCylinder) GGearGameAAIAvoidanceCylinderNatives[] = 
{ 
	MAP_NATIVE(AAIAvoidanceCylinder,execForceReTouch)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AAIAvoidanceCylinder);

NATIVE_INFO(UAIAvoidanceCylinderComponent) GGearGameUAIAvoidanceCylinderComponentNatives[] = 
{ 
	MAP_NATIVE(UAIAvoidanceCylinderComponent,execShouldAIAvoidMe)
	MAP_NATIVE(UAIAvoidanceCylinderComponent,execBuildListOfAffectingCylinders)
	MAP_NATIVE(UAIAvoidanceCylinderComponent,execDoesSpecIntersect)
	MAP_NATIVE(UAIAvoidanceCylinderComponent,execIsNavPointWithin)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIAvoidanceCylinderComponent);

NATIVE_INFO(UAIVisibilityManager) GGearGameUAIVisibilityManagerNatives[] = 
{ 
	MAP_NATIVE(UAIVisibilityManager,execReset)
	MAP_NATIVE(UAIVisibilityManager,execNotifyPawnDestroy)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UAIVisibilityManager);

NATIVE_INFO(AGearAI) GGearGameAGearAINatives[] = 
{ 
	MAP_NATIVE(AGearAI,execNotifyDidSomethingInteresting)
	MAP_NATIVE(AGearAI,execCanEvade)
	MAP_NATIVE(AGearAI,execGetRouteCacheDistance)
	MAP_NATIVE(AGearAI,execIsWithinTether)
	MAP_NATIVE(AGearAI,execAssignAnchor)
	MAP_NATIVE(AGearAI,execIsWithinCombatZone)
	MAP_NATIVE(AGearAI,execIsCoverWithinCombatZone)
	MAP_NATIVE(AGearAI,execIsCoverExposedToAnEnemy)
	MAP_NATIVE(AGearAI,execGetPlayerCover)
	MAP_NATIVE(AGearAI,execIsEnemyVisible)
	MAP_NATIVE(AGearAI,execIsMeleeRange)
	MAP_NATIVE(AGearAI,execGetEnemyLocation)
	MAP_NATIVE(AGearAI,execGetFireTargetLocation)
	MAP_NATIVE(AGearAI,execShouldCheckToSeeEnemy)
	MAP_NATIVE(AGearAI,execHasEnemyWithinDistance)
	MAP_NATIVE(AGearAI,execHasValidTarget)
	MAP_NATIVE(AGearAI,execIsFriendly)
	MAP_NATIVE(AGearAI,execIsFriendlyPawn)
	MAP_NATIVE(AGearAI,execProcessStimulus)
	MAP_NATIVE(AGearAI,execSeePlayer)
	MAP_NATIVE(AGearAI,execIgnoreNotifies)
	MAP_NATIVE(AGearAI,execGetNavigationPointsNear)
	MAP_NATIVE(AGearAI,execFindCommandOfClass)
	MAP_NATIVE(AGearAI,execDumpPathConstraints)
	MAP_NATIVE(AGearAI,execDumpCommandStack)
	MAP_NATIVE(AGearAI,execCheckCommandCount)
	MAP_NATIVE(AGearAI,execGetActiveCommand)
	MAP_NATIVE(AGearAI,execAbortCommand)
	MAP_NATIVE(AGearAI,execPopCommand)
	MAP_NATIVE(AGearAI,execPushCommand)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI);

NATIVE_INFO(AGearAI_Brumak) GGearGameAGearAI_BrumakNatives[] = 
{ 
	MAP_NATIVE(AGearAI_Brumak,execGetVectorAvg)
	MAP_NATIVE(AGearAI_Brumak,execCanFireAtAnyTarget)
	MAP_NATIVE(AGearAI_Brumak,execCanFireAtTarget)
	MAP_NATIVE(AGearAI_Brumak,execGetActiveEnemyList)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI_Brumak);

NATIVE_INFO(AGearAI_COGGear) GGearGameAGearAI_COGGearNatives[] = 
{ 
	MAP_NATIVE(AGearAI_COGGear,execBumperSomewhereToGo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI_COGGear);

NATIVE_INFO(AGearAI_Cover) GGearGameAGearAI_CoverNatives[] = 
{ 
	MAP_NATIVE(AGearAI_Cover,execAdjustToSlot)
	MAP_NATIVE(AGearAI_Cover,execGetCoverAction)
	MAP_NATIVE(AGearAI_Cover,execHasValidCover)
	MAP_NATIVE(AGearAI_Cover,execIsValidCover)
	MAP_NATIVE(AGearAI_Cover,execIsLookingAtWall)
	MAP_NATIVE(AGearAI_Cover,execForceLog)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI_Cover);

NATIVE_INFO(AGearAI_Jack) GGearGameAGearAI_JackNatives[] = 
{ 
	MAP_NATIVE(AGearAI_Jack,execFindGoodTeleportSpot)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI_Jack);

NATIVE_INFO(AGearAI_Nemacyst) GGearGameAGearAI_NemacystNatives[] = 
{ 
	MAP_NATIVE(AGearAI_Nemacyst,execSuggestNewMovePoint)
	MAP_NATIVE(AGearAI_Nemacyst,execGetActiveNemacystVolume)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI_Nemacyst);

NATIVE_INFO(AGearAI_RockWorm) GGearGameAGearAI_RockWormNatives[] = 
{ 
	MAP_NATIVE(AGearAI_RockWorm,execIsFriendly)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearAI_RockWorm);

NATIVE_INFO(AGearSquad) GGearGameAGearSquadNatives[] = 
{ 
	MAP_NATIVE(AGearSquad,execGetChanceToDuckBackIntoCover)
	MAP_NATIVE(AGearSquad,execGetSquadCentroid)
	MAP_NATIVE(AGearSquad,execAddCoverDecay)
	MAP_NATIVE(AGearSquad,execAllMembers)
	MAP_NATIVE(AGearSquad,execAllEnemies)
	MAP_NATIVE(AGearSquad,execGetEnemyCover)
	MAP_NATIVE(AGearSquad,execGetSquadLeaderLocation)
	MAP_NATIVE(AGearSquad,execGetSquadLeaderPosition)
	MAP_NATIVE(AGearSquad,execGetEnemyLastSeenTime)
	MAP_NATIVE(AGearSquad,execGetEnemyLocationByIndex)
	MAP_NATIVE(AGearSquad,execGetEnemyLocation)
	MAP_NATIVE(AGearSquad,execGetEnemyIndex)
	MAP_NATIVE(AGearSquad,execRemoveEnemy)
	MAP_NATIVE(AGearSquad,execAddEnemy)
	MAP_NATIVE(AGearSquad,execSetKnownEnemyInfo)
	MAP_NATIVE(AGearSquad,execBroadcastStimulus)
	MAP_NATIVE(AGearSquad,execProcessStimulus)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearSquad);

NATIVE_INFO(AGearSquadFormation) GGearGameAGearSquadFormationNatives[] = 
{ 
	MAP_NATIVE(AGearSquadFormation,execGetNumSquadMembersThatUsePositions)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,AGearSquadFormation);

NATIVE_INFO(UGoal_AtCover) GGearGameUGoal_AtCoverNatives[] = 
{ 
	MAP_NATIVE(UGoal_AtCover,execRateSlotMarker)
	MAP_NATIVE(UGoal_AtCover,execInitNative)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(GearGame,UGoal_AtCover);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,AIAvoidanceCylinder,AvoidanceComp)
VERIFY_CLASS_OFFSET_NODIE(A,AIAvoidanceCylinder,OwnerName)
VERIFY_CLASS_SIZE_NODIE(AAIAvoidanceCylinder)
VERIFY_CLASS_OFFSET_NODIE(U,AIAvoidanceCylinderComponent,LinkedNavigationPoints)
VERIFY_CLASS_OFFSET_NODIE(U,AIAvoidanceCylinderComponent,TeamThatShouldFleeMe)
VERIFY_CLASS_SIZE_NODIE(UAIAvoidanceCylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_NewEnemy,TimeSinceSeenThresholdSeconds)
VERIFY_CLASS_SIZE_NODIE(UAIReactCond_NewEnemy)
VERIFY_CLASS_SIZE_NODIE(UAIReactCond_SurpriseEnemyLoc)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_Targeted,shooter)
VERIFY_CLASS_OFFSET_NODIE(U,AIReactCond_Targeted,ShooterRangeThreshold)
VERIFY_CLASS_SIZE_NODIE(UAIReactCond_Targeted)
VERIFY_CLASS_OFFSET_NODIE(U,AIVisibilityManager,ControllerIttStartPoint)
VERIFY_CLASS_SIZE_NODIE(UAIVisibilityManager)
VERIFY_CLASS_SIZE_NODIE(UCombatZoneRenderingComponent)
VERIFY_CLASS_SIZE_NODIE(AGameplayRoute)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI,PerceptionMood)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI,LastMoveFinishTime)
VERIFY_CLASS_SIZE_NODIE(AGearAI)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Berserker,ChargeActor)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Berserker,NumFootSteps)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Berserker)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Bloodmount,LastMeleeCheckTime)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Bloodmount,ChargeCondition)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Bloodmount)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Brumak,Brumak)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Brumak,BrumakMeleeAttackList)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Brumak)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Brumak_SideGun,Gun)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Brumak_SideGun)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Brumak_Slave,Brumak)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Brumak_Slave,ScriptedFireTarget)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Brumak_Slave)
VERIFY_CLASS_SIZE_NODIE(AGearAI_BrumakDriver)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_COGGear,Player)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_COGGear,lastbumper)
VERIFY_CLASS_SIZE_NODIE(AGearAI_COGGear)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Cover,Cover)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Cover,StoppingPowerReactionTemplate)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Cover)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Jack,Jack)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Jack,JackInterestList)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Jack)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Nemacyst,LastEnemy)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Nemacyst,CurrentVolume)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Nemacyst)
VERIFY_CLASS_SIZE_NODIE(AGearAI_RockWorm)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_SecurityBotStationary,PatrolArcDegreesLeft)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_SecurityBotStationary,MyTeam)
VERIFY_CLASS_SIZE_NODIE(AGearAI_SecurityBotStationary)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_SecurityNemacyst,HoverHeight)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_SecurityNemacyst,OldAirSpeed)
VERIFY_CLASS_SIZE_NODIE(AGearAI_SecurityNemacyst)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_TDM,HammerburstChance)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_TDM,AtCover_TowardEnemyAggressive)
VERIFY_CLASS_SIZE_NODIE(AGearAI_TDM)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Ticker,ExplosionHealthThresh)
VERIFY_CLASS_OFFSET_NODIE(A,GearAI_Ticker,LastSawEnemyTime)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Ticker)
VERIFY_CLASS_SIZE_NODIE(AGearAI_Wretch)
VERIFY_CLASS_OFFSET_NODIE(A,GearSquad,SquadName)
VERIFY_CLASS_OFFSET_NODIE(A,GearSquad,DecayRecoveryIntervalRemaining)
VERIFY_CLASS_SIZE_NODIE(AGearSquad)
VERIFY_CLASS_OFFSET_NODIE(A,GearSquadFormation,Squad)
VERIFY_CLASS_OFFSET_NODIE(A,GearSquadFormation,CurrentSquadPosition)
VERIFY_CLASS_SIZE_NODIE(AGearSquadFormation)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_AtCover,AI)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_AtCover,CoverGoalConstraints)
VERIFY_CLASS_SIZE_NODIE(UGoal_AtCover)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_InCombatZone,AI)
VERIFY_CLASS_SIZE_NODIE(UGoal_InCombatZone)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_OutsideAvoidanceVolumes,AI)
VERIFY_CLASS_SIZE_NODIE(UGoal_OutsideAvoidanceVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_SpawnPoints,AI)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_SpawnPoints,MinDistToEnemy)
VERIFY_CLASS_SIZE_NODIE(UGoal_SpawnPoints)
VERIFY_CLASS_OFFSET_NODIE(U,LadderMeshComponent,Meshes)
VERIFY_CLASS_OFFSET_NODIE(U,LadderMeshComponent,LocationOffset)
VERIFY_CLASS_SIZE_NODIE(ULadderMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UMantleReachSpec_Rockworm)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AvoidanceVolumes,MyGearAI)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AvoidanceVolumes,AffectingCylinders)
VERIFY_CLASS_SIZE_NODIE(UPath_AvoidanceVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AvoidFireFromCover,AI)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AvoidFireFromCover,EnemyList)
VERIFY_CLASS_SIZE_NODIE(UPath_AvoidFireFromCover)
VERIFY_CLASS_SIZE_NODIE(UPath_PreferCover)
VERIFY_CLASS_OFFSET_NODIE(U,Path_WithinCombatZone,SpecificCombatZone)
VERIFY_CLASS_OFFSET_NODIE(U,Path_WithinCombatZone,LeavingCombatZonePenalty)
VERIFY_CLASS_SIZE_NODIE(UPath_WithinCombatZone)
VERIFY_CLASS_SIZE_NODIE(USecurityBotStationaryRenderingComponent)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
