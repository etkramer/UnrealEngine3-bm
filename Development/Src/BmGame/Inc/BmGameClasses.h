/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_BMGAME_ENUMS
#define INCLUDED_BMGAME_ENUMS 1


#endif // !INCLUDED_BMGAME_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName BMGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(SampleEvent)

#ifndef NAMES_ONLY

#ifndef INCLUDED_BMGAME_CLASSES
#define INCLUDED_BMGAME_CLASSES 1

struct SampleClass_eventSampleEvent_Parms
{
    INT I;
    SampleClass_eventSampleEvent_Parms(EEventParm)
    {
    }
};
class ASampleClass : public AActor
{
public:
    //## BEGIN PROPS SampleClass
    INT MyInteger;
    FStringNoInit MyString;
    BITFIELD MyBool:1;
    FVector MyVector;
    FString* MyPointer;
    //## END PROPS SampleClass

    virtual INT SampleNativeFunction(INT I,const FString& S,FVector V);
    DECLARE_FUNCTION(execSampleNativeFunction)
    {
        P_GET_INT(I);
        P_GET_STR(S);
        P_GET_STRUCT(FVector,V);
        P_FINISH;
        *(INT*)Result=SampleNativeFunction(I,S,V);
    }
    void eventSampleEvent(INT I)
    {
        SampleClass_eventSampleEvent_Parms Parms(EC_EventParm);
        Parms.I=I;
        ProcessEvent(FindFunctionChecked(BMGAME_SampleEvent),&Parms);
    }
    DECLARE_CLASS(ASampleClass,AActor,0|CLASS_Config,BmGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(ASampleClass)
};

#endif // !INCLUDED_BMGAME_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ASampleClass,-1,execSampleNativeFunction);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef BMGAME_NATIVE_DEFS
#define BMGAME_NATIVE_DEFS

DECLARE_NATIVE_TYPE(BmGame,ASampleClass);

#define AUTO_INITIALIZE_REGISTRANTS_BMGAME \
	ASampleClass::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindBmGameASampleClassNative; \

#endif // BMGAME_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(ASampleClass) GBmGameASampleClassNatives[] = 
{ 
	MAP_NATIVE(ASampleClass,execSampleNativeFunction)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(BmGame,ASampleClass);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,SampleClass,MyInteger)
VERIFY_CLASS_OFFSET_NODIE(A,SampleClass,MyPointer)
VERIFY_CLASS_SIZE_NODIE(ASampleClass)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
