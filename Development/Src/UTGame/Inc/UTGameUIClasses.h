/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UTGAME_UI_ENUMS
#define INCLUDED_UTGAME_UI_ENUMS 1

enum EUTOptionType
{
    UTOT_ComboReadOnly      =0,
    UTOT_ComboNumeric       =1,
    UTOT_CheckBox           =2,
    UTOT_Slider             =3,
    UTOT_Spinner            =4,
    UTOT_EditBox            =5,
    UTOT_CollectionCheckBox =6,
    UTOT_MAX                =7,
};
enum EUTRecordDemo
{
    UTRecordDemo_No         =0,
    UTRecordDemo_Yes        =1,
    UTRecordDemo_MAX        =2,
};
enum EUTBotTeam
{
    UTBotTeam_Random        =0,
    UTBotTeam_Ironguard     =1,
    UTBotTeam_TwinSouls     =2,
    UTBotTeam_Krall         =3,
    UTBotTeam_Liandri       =4,
    UTBotTeam_Necris        =5,
    UTBotTeam_MAX           =6,
};
enum EAnimPropType
{
    EAPT_None               =0,
    EAPT_PositionLeft       =1,
    EAPT_PositionTop        =2,
    EAPT_MAX                =3,
};
enum EOptionButtonArrow
{
    OPTBUT_ArrowLeft        =0,
    OPTBUT_ArrowRight       =1,
    OPTBUT_MAX              =2,
};

#endif // !INCLUDED_UTGAME_UI_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UTGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AddItem)
AUTOGENERATE_NAME(BeginLoading)
AUTOGENERATE_NAME(BlockUIInput)
AUTOGENERATE_NAME(ClearUIInputBlocks)
AUTOGENERATE_NAME(DrawDelegate)
AUTOGENERATE_NAME(DrawPanel)
AUTOGENERATE_NAME(Empty)
AUTOGENERATE_NAME(EndLoading)
AUTOGENERATE_NAME(FadeTo)
AUTOGENERATE_NAME(Finish)
AUTOGENERATE_NAME(FinishToast)
AUTOGENERATE_NAME(GetCurrentValue)
AUTOGENERATE_NAME(GetCurrentValueIndex)
AUTOGENERATE_NAME(GetItemScale)
AUTOGENERATE_NAME(GetStatsReadObject)
AUTOGENERATE_NAME(ImportStringList)
AUTOGENERATE_NAME(InsertItem)
AUTOGENERATE_NAME(IsControllerInput)
AUTOGENERATE_NAME(Num)
AUTOGENERATE_NAME(OnAnimationFinished)
AUTOGENERATE_NAME(OnClosed)
AUTOGENERATE_NAME(OnDrawItem)
AUTOGENERATE_NAME(OnDrawSelectionBar)
AUTOGENERATE_NAME(OnHideAnimationEnded)
AUTOGENERATE_NAME(OnHideComplete)
AUTOGENERATE_NAME(OnItemChosen)
AUTOGENERATE_NAME(OnMBInputKey)
AUTOGENERATE_NAME(OnMoveSelectionLeft)
AUTOGENERATE_NAME(OnMoveSelectionRight)
AUTOGENERATE_NAME(OnPostDrawSelectionBar)
AUTOGENERATE_NAME(OnSaveFinished)
AUTOGENERATE_NAME(OnSceneOpened)
AUTOGENERATE_NAME(OnSelection)
AUTOGENERATE_NAME(OnSelectionChange)
AUTOGENERATE_NAME(OnShowAnimationEnded)
AUTOGENERATE_NAME(OnShowComplete)
AUTOGENERATE_NAME(OnSubmitSelection)
AUTOGENERATE_NAME(OnTick)
AUTOGENERATE_NAME(PerformSave)
AUTOGENERATE_NAME(PlayerOwnerIsSpectating)
AUTOGENERATE_NAME(RefreshBarPosition)
AUTOGENERATE_NAME(RemoveItem)
AUTOGENERATE_NAME(RemoveString)
AUTOGENERATE_NAME(SelectItem)
AUTOGENERATE_NAME(SetCurrentValueIndex)
AUTOGENERATE_NAME(SetItemSelectionIndex)
AUTOGENERATE_NAME(SetOpacity)
AUTOGENERATE_NAME(ShutDown)
AUTOGENERATE_NAME(SizeList)
AUTOGENERATE_NAME(SupportedByCurrentGameMode)
AUTOGENERATE_NAME(SupportsCurrentGameMode)
AUTOGENERATE_NAME(Tick_Widget)
AUTOGENERATE_NAME(TickScene)
AUTOGENERATE_NAME(UpdateVote)
AUTOGENERATE_NAME(WidgetTick)

#ifndef NAMES_ONLY

#ifndef INCLUDED_UTGAME_UI_CLASSES
#define INCLUDED_UTGAME_UI_CLASSES 1

struct FDamageInfo
{
    FLOAT FadeTime;
    FLOAT FadeValue;
    class UMaterialInstanceConstant* MatConstant;

    /** Constructors */
    FDamageInfo() {}
    FDamageInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDamageInfo));
    }
};

class AUTHUD : public AGameHUD
{
public:
    //## BEGIN PROPS UTHUD
    class UClass* WeaponSwitchMessage;
    TArrayNoInit<class AActor*> PostRenderedActors;
    class UTexture2D* AltHudTexture;
    class UTexture2D* IconHudTexture;
    FStringNoInit ConsoleIconFontClassName;
    class UFont* ConsoleIconFont;
    struct FTextureCoordinates ToolTipSepCoords;
    FLOAT LastTimeTooltipDrawn;
    FLinearColor LC_White;
    FColor LightGoldColor;
    FColor LightGreenColor;
    FColor GrayColor;
    FLOAT LastPickupTime;
    FLOAT LastAmmoPickupTime;
    FLOAT LastHealthPickupTime;
    FLOAT LastArmorPickupTime;
    class APawn* PawnOwner;
    class AUTPawn* UTPawnOwner;
    class AUTPlayerController* UTPlayerOwner;
    class AUTPlayerReplicationInfo* UTOwnerPRI;
    BITFIELD bCrosshairShow:1;
    BITFIELD bShowAllAI:1;
    BITFIELD bHudMessageRendered:1;
    BITFIELD bCrosshairOnFriendly:1;
    BITFIELD bGreenCrosshair:1;
    BITFIELD bShowWeaponbar:1;
    BITFIELD bShowOnlyAvailableWeapons:1;
    BITFIELD bOnlyShowWeaponBarIfChanging:1;
    BITFIELD bNoWeaponNumbers:1;
    BITFIELD bFadeOutHitEffect:1;
    BITFIELD bShowQuickPick:1;
    BITFIELD bShowAllWeapons:1;
    BITFIELD bQuickPickMadeNewSelection:1;
    BITFIELD bShowClock:1;
    BITFIELD bShowDoll:1;
    BITFIELD bShowAmmo:1;
    BITFIELD bHasMap:1;
    BITFIELD bShowMap:1;
    BITFIELD bShowPowerups:1;
    BITFIELD bDisplayingPowerups:1;
    BITFIELD bShowScoring:1;
    BITFIELD bShowFragCount:1;
    BITFIELD bHasLeaderboard:1;
    BITFIELD bShowLeaderboard:1;
    BITFIELD bShowVehicle:1;
    BITFIELD bShowVehicleArmorCount:1;
    BITFIELD bIsSplitScreen:1;
    BITFIELD bIsFirstPlayer:1;
    class AUTGameReplicationInfo* UTGRI;
    FLOAT ResolutionScale;
    FLOAT ResolutionScaleX;
    class UUTUIScene_Scoreboard* ScoreboardSceneTemplate;
    class UClass* MusicManagerClass;
    TArrayNoInit<class UFont*> HudFonts;
    class UMaterial* CharPortraitMaterial;
    class UMaterialInstanceConstant* CharPortraitMI;
    FLOAT CharPortraitYPerc;
    FLOAT CharPortraitXPerc;
    FLOAT CharPortraitTime;
    FLOAT CharPortraitSlideTime;
    FLOAT CharPortraitSlideTransitionTime;
    FVector2D CharPortraitSize;
    class AUTPlayerReplicationInfo* CharPRI;
    class AUTPlayerReplicationInfo* CharPendingPRI;
    FLOAT WeaponBarScale;
    FLOAT WeaponBoxWidth;
    FLOAT WeaponBoxHeight;
    FLOAT HUDScaleX;
    FLOAT HUDScaleY;
    FLinearColor TeamHUDColor;
    FColor TeamColor;
    FColor TeamTextColor;
    FLOAT WeaponBarY;
    class AUTWeapon* WeaponList[10];
    FLOAT CurrentWeaponScale[10];
    FLOAT SelectedWeaponScale;
    FLOAT BounceWeaponScale;
    FLOAT SelectedWeaponAlpha;
    FLOAT OffWeaponAlpha;
    FLOAT EmptyWeaponAlpha;
    FLOAT LastHUDUpdateTime;
    INT BouncedWeapon;
    FLOAT WeaponScaleSpeed;
    FLOAT WeaponBarXOffset;
    FLOAT WeaponXOffset;
    FLOAT SelectedBoxScale;
    FLOAT WeaponYScale;
    FLOAT WeaponYOffset;
    FLOAT WeaponAmmoLength;
    FLOAT WeaponAmmoThickness;
    FLOAT WeaponAmmoOffsetX;
    FLOAT WeaponAmmoOffsetY;
    FLOAT SelectedWeaponAmmoOffsetX;
    FLOAT LastWeaponBarDrawnTime;
    class UUTUIScene_MOTD* MOTDSceneTemplate;
    FLOAT MessageOffset[7];
    FColor BlackColor;
    FColor GoldColor;
    class UTexture2D* MapBackground;
    FLOAT MapDefaultSize;
    FStringNoInit DisplayedOrders;
    FLOAT OrderUpdateTime;
    class AWeapon* LastSelectedWeapon;
    class UFont* GlowFonts[2];
    FLOAT SafeRegionPct;
    FLOAT FullWidth;
    FLOAT FullHeight;
    INT MaxNoOfIndicators;
    TArrayNoInit<struct FDamageInfo> DamageData;
    class UMaterial* BaseMaterial;
    FLOAT FadeTime;
    FName PositionalParamName;
    FName FadeParamName;
    FLOAT HitEffectIntensity;
    FLinearColor MaxHitEffectColor;
    FLOAT HitEffectFadeTime;
    class UMaterialEffect* HitEffect;
    class UMaterialInstanceConstant* HitEffectMaterialInstance;
    TArrayNoInit<class AUTWeapon*> QuickPickClasses;
    class APawn* QuickPickTarget;
    INT QuickPickNumCells;
    FLOAT QuickPickDeltaAngle;
    FLOAT QuickPickRadius;
    INT QuickPickCurrentSelection;
    class UTexture2D* QuickPickBkgImage;
    struct FTextureCoordinates QuickPickBkgCoords;
    class UTexture2D* QuickPickSelImage;
    struct FTextureCoordinates QuickPickSelCoords;
    class UTexture2D* QuickPickCircleImage;
    struct FTextureCoordinates QuickPickCircleCoords;
    class UForceFeedbackWaveform* QuickPickWaveForm;
    FVector2D ClockPosition;
    FLOAT LastDollUpdate;
    FLOAT DollVisibility;
    INT LastHealth;
    FLOAT HealthPulseTime;
    INT LastArmorAmount;
    FLOAT ArmorPulseTime;
    FVector2D AmmoPosition;
    class AUTWeapon* LastWeapon;
    INT LastAmmoCount;
    FLOAT AmmoPulseTime;
    FVector2D MapPosition;
    FVector2D PowerupDims;
    FLOAT PowerupYPos;
    FLOAT PowerupTransitionTime;
    FVector2D ScoringPosition;
    FLOAT FragPulseTime;
    INT LastFragCount;
    FVector2D VehiclePosition;
    FLOAT DamageIndicatorSize;
    FLOAT PulseDuration;
    FLOAT PulseSplit;
    FLOAT PulseMultiplier;
    FStringNoInit WarmupString;
    FStringNoInit WaitingForMatch;
    FStringNoInit PressFireToBegin;
    FStringNoInit SpectatorMessage;
    FStringNoInit DeadMessage;
    FStringNoInit FireToRespawnMessage;
    FStringNoInit YouHaveWon;
    FStringNoInit YouHaveLost;
    FStringNoInit PlaceMarks[4];
    FLOAT THeight;
    FLOAT TX;
    FLOAT TY;
    FLinearColor AmmoBarColor;
    FLinearColor RedLinearColor;
    FLinearColor BlueLinearColor;
    FLinearColor DMLinearColor;
    FLinearColor WhiteLinearColor;
    FLinearColor GoldLinearColor;
    FLOAT ConfiguredCrosshairScaling;
    FLOAT OldHeroScore;
    FLOAT LastHeroScoreBumpTime;
    INT LastHeroBump;
    struct FTextureCoordinates HeroToolTipIconCoords;
    class UTexture2D* BkgTexture;
    struct FTextureCoordinates BkgTexCoords;
    FColor BkgTexColor;
    //## END PROPS UTHUD

    virtual void DrawGlowText(const FString& Text,FLOAT X,FLOAT Y,FLOAT MaxHeightInPixels=0.000000,FLOAT PulseTime=-100.000000,UBOOL bRightJustified=FALSE);
    virtual void LinkToHudScene();
    virtual void DisplayWeaponBar();
    virtual void DrawActorOverlays(FVector ViewPoint,FRotator ViewRotation);
    void TranslateBindToFont(const FString& InBindStr,class UFont*& DrawFont,FString& OutBindStr);
    DECLARE_FUNCTION(execDrawGlowText)
    {
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT_OPTX(MaxHeightInPixels,0.000000);
        P_GET_FLOAT_OPTX(PulseTime,-100.000000);
        P_GET_UBOOL_OPTX(bRightJustified,FALSE);
        P_FINISH;
        DrawGlowText(Text,X,Y,MaxHeightInPixels,PulseTime,bRightJustified);
    }
    DECLARE_FUNCTION(execLinkToHudScene)
    {
        P_FINISH;
        LinkToHudScene();
    }
    DECLARE_FUNCTION(execDisplayWeaponBar)
    {
        P_FINISH;
        DisplayWeaponBar();
    }
    DECLARE_FUNCTION(execDrawActorOverlays)
    {
        P_GET_STRUCT(FVector,ViewPoint);
        P_GET_STRUCT(FRotator,ViewRotation);
        P_FINISH;
        DrawActorOverlays(ViewPoint,ViewRotation);
    }
    DECLARE_FUNCTION(execTranslateBindToFont)
    {
        P_GET_STR(InBindStr);
        P_GET_OBJECT_REF(UFont,DrawFont);
        P_GET_STR_REF(OutBindStr);
        P_FINISH;
        TranslateBindToFont(InBindStr,DrawFont,OutBindStr);
    }
    DECLARE_CLASS(AUTHUD,AGameHUD,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(AUTHUD)
};

class UUIComp_DrawTeamColoredImage : public UUIComp_DrawImage
{
public:
    //## BEGIN PROPS UIComp_DrawTeamColoredImage
    TArrayNoInit<FLinearColor> TeamColors;
    INT EditorTeamIndex;
    //## END PROPS UIComp_DrawTeamColoredImage

    DECLARE_CLASS(UUIComp_DrawTeamColoredImage,UUIComp_DrawImage,0,UTGame)
	virtual void RenderComponent( class FCanvas* Canvas, FRenderParameters Parameters );
};

class UUIComp_UTDrawStateImage : public UUIComp_DrawImage
{
public:
    //## BEGIN PROPS UIComp_UTDrawStateImage
    class UClass* ImageState;
    //## END PROPS UIComp_UTDrawStateImage

    DECLARE_CLASS(UUIComp_UTDrawStateImage,UUIComp_DrawImage,0,UTGame)
 	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the component's image.
	 */
	void RefreshAppliedStyleData();
};

class UUIComp_UTGlowString : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_UTGlowString
    struct FUIStyleReference GlowStyle;
    //## END PROPS UIComp_UTGlowString

    DECLARE_CLASS(UUIComp_UTGlowString,UUIComp_DrawString,0,UTGame)
	/* === UUIComp_DrawString interface === */
	/**
	 * Returns the combo style data being used by this string rendering component.  If the component's StringStyle is not set, the style data
	 * will be pulled from the owning widget's PrimaryStyle, if possible.
	 *
	 * This version resolves the additional style reference property declared by the UTGlowString component.
	 *
	 * @param	DesiredMenuState	the menu state for the style data to retrieve; if not specified, uses the owning widget's current menu state.
	 * @param	SourceSkin			the skin to use for resolving this component's combo style; only relevant when the component's combo style is invalid
	 *								(or if TRUE is passed for bClearExistingValue). If the combo style is invalid and a value is not specified, returned value
	 *								will be NULL.
	 * @param	bClearExistingValue	used to force the component's combo style to be re-resolved from the specified skin; if TRUE, you must supply a valid value for
	 *								SourceSkin.
	 *
	 * @return	the combo style data used to render this component's string for the specified menu state.
	 */
	virtual class UUIStyle_Combo* GetAppliedStringStyle( class UUIState* DesiredMenuState=NULL, class UUISkin* SourceSkin=NULL, UBOOL bClearExistingValue=FALSE );

	/**
	 * Resolves the glow style for this string rendering component.
	 *
	 * @param	ActiveSkin			the skin the use for resolving the style reference.
	 * @param	bClearExistingValue	if TRUE, style references will be invalidated first.
	 * @param	CurrentMenuState	the menu state to use for resolving the style data; if not specified, uses the current
	 *								menu state of the owning widget.
	 * @param	StyleProperty		if specified, only the style reference corresponding to the specified property
	 *								will be resolved; otherwise, all style references will be resolved.
	 */
	virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None);

protected:
	/**
	 * We override InternalRender_String so that we can render twice.  Once with the glow style, once with the normal
	 * style
	 *
	 * @param	Canvas	the canvas to use for rendering this string
	 */
	virtual void InternalRender_String( FCanvas* Canvas, FRenderParameters& Parameters );
};

struct FPrefabMarkupReplace
{
    FName WidgetTag;
    FName CellTag;

    /** Constructors */
    FPrefabMarkupReplace() {}
    FPrefabMarkupReplace(EEventParm)
    {
        appMemzero(this, sizeof(FPrefabMarkupReplace));
    }
};

struct FInstancedPrefabInfo
{
    class UUIPrefabInstance* PrefabInstance;
    TArrayNoInit<class UUIObject*> ResolvedObjects;

    /** Constructors */
    FInstancedPrefabInfo() {}
    FInstancedPrefabInfo(EEventParm)
    {
        appMemzero(this, sizeof(FInstancedPrefabInfo));
    }
};

class UUIComp_UTUIMenuListPresenter : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_UTUIMenuListPresenter
    INT SelectedItemHeight;
    class UUIPrefab* SelectedItemPrefab;
    class UUIPrefab* NormalItemPrefab;
    TArrayNoInit<struct FPrefabMarkupReplace> PrefabMarkupReplaceList;
    TArrayNoInit<struct FInstancedPrefabInfo> InstancedPrefabs;
    //## END PROPS UIComp_UTUIMenuListPresenter

    DECLARE_CLASS(UUIComp_UTUIMenuListPresenter,UUIComp_ListPresenter,0,UTGame)
	friend class UUIList;

	/**
	 * Initializes the component's prefabs.
	 */
	virtual void InitializePrefabs();

	/**
	 * Renders the elements in this list.
	 *
	 * @param	RI					the render interface to use for rendering
	 */
	virtual void Render_List( FCanvas* Canvas );

	/**
	 * Renders the list element specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	ElementIndex	the index for the list element to render
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in]	specifies the pixel location of the start of the horizontal bounding region that should be used for
	 *												rendering this element
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the pixel Y location of the bounding region that should be used for rendering this list element.
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering this element.  This is the Y position for rendering
	 *												the next element should be rendered
	 *							DrawXL:		[in]	specifies the pixel location of the end of the horizontal bounding region that should be used for rendering this element.
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in pixels.  If this value is not large enough to render the specified element,
	 *												the element will not be rendered.
	 *										[out]	Will be reduced by the height of the element that was rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the element
	 */
	void Render_ListElement( FCanvas* Canvas, INT ElementIndex, FRenderParameters& Parameters );

	/**
	 * Called when a member property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Updates the prefab widgets we are dynamically changing the markup of to use a new list row for their datasource.
	 *
	 * @param NewIndex	New list row index to rebind the widgets with.
	 */
	virtual void UpdatePrefabMarkup();

	/** Updates the position of the selected item prefab. */
	virtual void UpdatePrefabPosition();
};

struct UTGameInteraction_eventBlockUIInput_Parms
{
    UBOOL bBlock;
    UTGameInteraction_eventBlockUIInput_Parms(EEventParm)
    {
    }
};
struct UTGameInteraction_eventClearUIInputBlocks_Parms
{
    UTGameInteraction_eventClearUIInputBlocks_Parms(EEventParm)
    {
    }
};
class UUTGameInteraction : public UUIInteraction
{
public:
    //## BEGIN PROPS UTGameInteraction
    INT BlockUIInputSemaphore;
    //## END PROPS UTGameInteraction

    UBOOL ShouldProcessUIInput() const;
    DECLARE_FUNCTION(execShouldProcessUIInput)
    {
        P_FINISH;
        *(UBOOL*)Result=ShouldProcessUIInput();
    }
    void eventBlockUIInput(UBOOL bBlock)
    {
        UTGameInteraction_eventBlockUIInput_Parms Parms(EC_EventParm);
        Parms.bBlock=bBlock ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_BlockUIInput),&Parms);
    }
    void eventClearUIInputBlocks()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_ClearUIInputBlocks),NULL);
    }
    DECLARE_CLASS(UUTGameInteraction,UUIInteraction,0|CLASS_Transient|CLASS_Config,UTGame)
	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);
};

class UUTUIDataProvider_OnlineFriendMessages : public UUIDataProvider_OnlineFriendMessages
{
public:
    //## BEGIN PROPS UTUIDataProvider_OnlineFriendMessages
    //## END PROPS UTUIDataProvider_OnlineFriendMessages

    DECLARE_CLASS(UUTUIDataProvider_OnlineFriendMessages,UUIDataProvider_OnlineFriendMessages,0|CLASS_Transient,UTGame)
	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

};

class UUTUIDataProvider_OnlineFriends : public UUIDataProvider_OnlineFriends
{
public:
    //## BEGIN PROPS UTUIDataProvider_OnlineFriends
    //## END PROPS UTUIDataProvider_OnlineFriends

    DECLARE_CLASS(UUTUIDataProvider_OnlineFriends,UUIDataProvider_OnlineFriends,0|CLASS_Transient,UTGame)
	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

};

class UUTUIDataStore_MenuItems : public UUIDataStore_GameResource, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataStore_MenuItems
    TArrayNoInit<INT> EnabledMutators;
    TArrayNoInit<INT> MapCycle;
    TArrayNoInit<INT> WeaponPriority;
    INT GameModeFilter;
    //## END PROPS UTUIDataStore_MenuItems

    virtual INT GetProviderCount(FName FieldName);
    virtual UBOOL IsProviderFiltered(FName FieldName,INT ProviderIdx);
    void GetAllResourceDataProviders(class UClass* ProviderClass,TArray<class UUTUIResourceDataProvider*>& Providers);
    virtual INT FindValueInProviderSet(FName ProviderFieldName,FName SearchTag,const FString& SearchValue);
    virtual UBOOL GetValueFromProviderSet(FName ProviderFieldName,FName SearchTag,INT ListIndex,FString& OutValue);
    virtual UBOOL GetProviderSet(FName ProviderFieldName,TArray<class UUTUIResourceDataProvider*>& OutProviders);
    DECLARE_FUNCTION(execIsProviderFiltered)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ProviderIdx);
        P_FINISH;
        *(UBOOL*)Result=IsProviderFiltered(FieldName,ProviderIdx);
    }
    DECLARE_FUNCTION(execGetAllResourceDataProviders)
    {
        P_GET_OBJECT(UClass,ProviderClass);
        P_GET_TARRAY_REF(class UUTUIResourceDataProvider*,Providers);
        P_FINISH;
        GetAllResourceDataProviders(ProviderClass,Providers);
    }
    DECLARE_FUNCTION(execFindValueInProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_STR(SearchValue);
        P_FINISH;
        *(INT*)Result=FindValueInProviderSet(ProviderFieldName,SearchTag,SearchValue);
    }
    DECLARE_FUNCTION(execGetValueFromProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_INT(ListIndex);
        P_GET_STR_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetValueFromProviderSet(ProviderFieldName,SearchTag,ListIndex,OutValue);
    }
    DECLARE_FUNCTION(execGetProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_TARRAY_REF(class UUTUIResourceDataProvider*,OutProviders);
        P_FINISH;
        *(UBOOL*)Result=GetProviderSet(ProviderFieldName,OutProviders);
    }
    DECLARE_CLASS(UUTUIDataStore_MenuItems,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

protected:
	/**
	 * Sorts the list of map and mutator data providers according to whether they're official or not, then alphabetically.
	 */
	void SortRelevantProviders();

public:

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUTUIResourceDataProvider*> &OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );


	/**
	 * Attempts to find a simple menu with the field name provided.
	 *
	 * @param FieldName		Field name of the simple menu.  Defined in UUTUIDataProvider_SimpleMenu::FieldName
	 */
	virtual class UUTUIDataProvider_SimpleMenu* FindSimpleMenu(FName FieldName);


// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

};

class UUTUIDataStore_Options : public UUIDataStore_GameResource
{
public:
    //## BEGIN PROPS UTUIDataStore_Options
    TMultiMap<FName, class UUTUIResourceDataProvider*> OptionProviders;
    TArrayNoInit<class UUTUIResourceDataProvider*> DynamicProviders;
    //## END PROPS UTUIDataStore_Options

    virtual void ClearSet(FName SetName);
    virtual void AppendToSet(FName SetName,INT NumOptions);
    virtual void GetSet(FName SetName,TArray<class UUTUIResourceDataProvider*>& OutProviders);
    DECLARE_FUNCTION(execClearSet)
    {
        P_GET_NAME(SetName);
        P_FINISH;
        ClearSet(SetName);
    }
    DECLARE_FUNCTION(execAppendToSet)
    {
        P_GET_NAME(SetName);
        P_GET_INT(NumOptions);
        P_FINISH;
        AppendToSet(SetName,NumOptions);
    }
    DECLARE_FUNCTION(execGetSet)
    {
        P_GET_NAME(SetName);
        P_GET_TARRAY_REF(class UUTUIResourceDataProvider*,OutProviders);
        P_FINISH;
        GetSet(SetName,OutProviders);
    }
    DECLARE_CLASS(UUTUIDataStore_Options,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,UTGame)
	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUTUIResourceDataProvider*> &OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );
};

class UUTDataStore_GameSearchBase : public UUIDataStore_OnlineGameSearch
{
public:
    //## BEGIN PROPS UTDataStore_GameSearchBase
    class UUTUIDataProvider_ServerDetails* ServerDetailsProvider;
    //## END PROPS UTDataStore_GameSearchBase

    virtual UBOOL GetEnabledMutators(TArray<INT>& MutatorIndices);
    DECLARE_FUNCTION(execGetEnabledMutators)
    {
        P_GET_TARRAY_REF(INT,MutatorIndices);
        P_FINISH;
        *(UBOOL*)Result=GetEnabledMutators(MutatorIndices);
    }
    DECLARE_ABSTRACT_CLASS(UUTDataStore_GameSearchBase,UUIDataStore_OnlineGameSearch,0|CLASS_Transient,UTGame)
	/**
	 * Initializes the dataproviders for all of the various character parts.
	 */
	virtual void InitializeDataStore();

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/* === UIListElementProvider === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

   	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );
};

struct FControllerMap
{
    FName KeyName;
    FStringNoInit XBoxMapping;
    FStringNoInit PS3Mapping;

    /** Constructors */
    FControllerMap() {}
    FControllerMap(EEventParm)
    {
        appMemzero(this, sizeof(FControllerMap));
    }
};

struct FBindCacheElement
{
    FName KeyName;
    FStringNoInit MappingString;
    INT FieldIndex;

    /** Constructors */
    FBindCacheElement() {}
    FBindCacheElement(EEventParm)
    {
        appMemzero(this, sizeof(FBindCacheElement));
    }
};

#define UCONST_SABM_FIND_FIRST_BIND -2

class UUTUIDataStore_StringAliasBindingsMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS UTUIDataStore_StringAliasBindingsMap
    INT FakePlatform;
    TMap<FName, FBindCacheElement> CommandToBindNames;
    TArrayNoInit<struct FControllerMap> ControllerMapArray;
    //## END PROPS UTUIDataStore_StringAliasBindingsMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    virtual INT GetBoundStringWithFieldName(const FString& FieldName,FString& MappedString,INT* StartIndex=NULL,FString* BindString=NULL);
    UBOOL FindMappingInBoundKeyCache(const FString& Command,FString& MappingStr,INT& FieldIndex);
    void AddMappingToBoundKeyCache(const FString& Command,const FString& MappingStr,INT FieldIndex);
    void ClearBoundKeyCache();
    DECLARE_FUNCTION(execGetBoundStringWithFieldName)
    {
        P_GET_STR(FieldName);
        P_GET_STR_REF(MappedString);
        P_GET_INT_OPTX_REF(StartIndex,0);
        P_GET_STR_OPTX_REF(BindString,TEXT(""));
        P_FINISH;
        *(INT*)Result=GetBoundStringWithFieldName(FieldName,MappedString,pStartIndex ? &StartIndex : NULL,pBindString ? &BindString : NULL);
    }
    DECLARE_FUNCTION(execFindMappingInBoundKeyCache)
    {
        P_GET_STR(Command);
        P_GET_STR_REF(MappingStr);
        P_GET_INT_REF(FieldIndex);
        P_FINISH;
        *(UBOOL*)Result=FindMappingInBoundKeyCache(Command,MappingStr,FieldIndex);
    }
    DECLARE_FUNCTION(execAddMappingToBoundKeyCache)
    {
        P_GET_STR(Command);
        P_GET_STR(MappingStr);
        P_GET_INT(FieldIndex);
        P_FINISH;
        AddMappingToBoundKeyCache(Command,MappingStr,FieldIndex);
    }
    DECLARE_FUNCTION(execClearBoundKeyCache)
    {
        P_FINISH;
        ClearBoundKeyCache();
    }
    DECLARE_CLASS(UUTUIDataStore_StringAliasBindingsMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataStore_StringAliasBindingsMap)
};

class UUTUIDataStore_StringAliasMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS UTUIDataStore_StringAliasMap
    INT FakePlatform;
    //## END PROPS UTUIDataStore_StringAliasMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_CLASS(UUTUIDataStore_StringAliasMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataStore_StringAliasMap)
};

struct FEStringListData
{
    FName Tag;
    FStringNoInit ColumnHeaderText;
    FStringNoInit CurrentValue;
    INT DefaultValueIndex;
    TArrayNoInit<FString> Strings;
    class UUTUIDataProvider_StringArray* DataProvider;

    /** Constructors */
    FEStringListData() {}
    FEStringListData(EEventParm)
    {
        appMemzero(this, sizeof(FEStringListData));
    }
};

#define UCONST_INVALIDFIELD -1

struct UTUIDataStore_StringList_eventNum_Parms
{
    FName FieldName;
    INT ReturnValue;
    UTUIDataStore_StringList_eventNum_Parms(EEventParm)
    {
    }
};
struct UTUIDataStore_StringList_eventSetCurrentValueIndex_Parms
{
    FName FieldName;
    INT NewValueIndex;
    INT ReturnValue;
    UTUIDataStore_StringList_eventSetCurrentValueIndex_Parms(EEventParm)
    {
    }
};
struct UTUIDataStore_StringList_eventGetCurrentValueIndex_Parms
{
    FName FieldName;
    INT ReturnValue;
    UTUIDataStore_StringList_eventGetCurrentValueIndex_Parms(EEventParm)
    {
    }
};
struct UTUIDataStore_StringList_eventGetCurrentValue_Parms
{
    FName FieldName;
    FString out_Value;
    UBOOL ReturnValue;
    UTUIDataStore_StringList_eventGetCurrentValue_Parms(EEventParm)
    {
    }
};
class UUTUIDataStore_StringList : public UUIDataStore_StringBase, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataStore_StringList
    TArrayNoInit<struct FEStringListData> StringData;
    //## END PROPS UTUIDataStore_StringList

    virtual INT GetFieldIndex(FName FieldName);
    virtual void AddStr(FName FieldName,const FString& NewString,UBOOL bBatchOp=FALSE);
    virtual void InsertStr(FName FieldName,const FString& NewString,INT InsertIndex,UBOOL bBatchOp=FALSE);
    virtual void RemoveStr(FName FieldName,const FString& StringToRemove,UBOOL bBatchOp=FALSE);
    virtual void RemoveStrByIndex(FName FieldName,INT Index,INT Count=1,UBOOL bBatchOp=FALSE);
    virtual void Empty(FName FieldName,UBOOL bBatchOp=FALSE);
    virtual INT FindStr(FName FieldName,const FString& SearchString);
    virtual FString GetStr(FName FieldName,INT StrIndex);
    virtual TArray<FString> GetList(FName FieldName);
    DECLARE_FUNCTION(execGetFieldIndex)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(INT*)Result=GetFieldIndex(FieldName);
    }
    DECLARE_FUNCTION(execAddStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(NewString);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        AddStr(FieldName,NewString,bBatchOp);
    }
    DECLARE_FUNCTION(execInsertStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(NewString);
        P_GET_INT(InsertIndex);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        InsertStr(FieldName,NewString,InsertIndex,bBatchOp);
    }
    DECLARE_FUNCTION(execRemoveStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(StringToRemove);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        RemoveStr(FieldName,StringToRemove,bBatchOp);
    }
    DECLARE_FUNCTION(execRemoveStrByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(Index);
        P_GET_INT_OPTX(Count,1);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        RemoveStrByIndex(FieldName,Index,Count,bBatchOp);
    }
    DECLARE_FUNCTION(execEmpty)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        Empty(FieldName,bBatchOp);
    }
    DECLARE_FUNCTION(execFindStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(SearchString);
        P_FINISH;
        *(INT*)Result=FindStr(FieldName,SearchString);
    }
    DECLARE_FUNCTION(execGetStr)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(StrIndex);
        P_FINISH;
        *(FString*)Result=GetStr(FieldName,StrIndex);
    }
    DECLARE_FUNCTION(execGetList)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(TArray<FString>*)Result=GetList(FieldName);
    }
    INT eventNum(FName FieldName)
    {
        UTUIDataStore_StringList_eventNum_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(UTGAME_Num),&Parms);
        return Parms.ReturnValue;
    }
    INT eventSetCurrentValueIndex(FName FieldName,INT NewValueIndex)
    {
        UTUIDataStore_StringList_eventSetCurrentValueIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        Parms.NewValueIndex=NewValueIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_SetCurrentValueIndex),&Parms);
        return Parms.ReturnValue;
    }
    INT eventGetCurrentValueIndex(FName FieldName)
    {
        UTUIDataStore_StringList_eventGetCurrentValueIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(UTGAME_GetCurrentValueIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetCurrentValue(FName FieldName,FString& out_Value)
    {
        UTUIDataStore_StringList_eventGetCurrentValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.out_Value=out_Value;
        ProcessEvent(FindFunctionChecked(UTGAME_GetCurrentValue),&Parms);
        out_Value=Parms.out_Value;
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataStore_StringList,UUIDataStore_StringBase,0|CLASS_Transient|CLASS_Config,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === UIListElementProvider === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

   	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );


/* === UIListElementCellProvider === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );



/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Adds a new field to the list
	 *
	 * @param	FieldName		the data field to resolve the value for
	 * @param	NewString		The first string to add.
	 * @param bBatchOp		if TRUE, doesn't call RefreshSubscribers()
	 */
	virtual INT AddNewField(FName FieldName, const FString &NewString, UBOOL bBatchOp=FALSE);


};

class UUTUIDataProvider_SearchResult : public UUIDataProvider_Settings
{
public:
    //## BEGIN PROPS UTUIDataProvider_SearchResult
    FName PlayerRatioTag;
    FName GameModeFriendlyNameTag;
    FName ServerFlagsTag;
    FName MapNameTag;
    FStringNoInit IconFontPathName;
    //## END PROPS UTUIDataProvider_SearchResult

    DECLARE_CLASS(UUTUIDataProvider_SearchResult,UUIDataProvider_Settings,0|CLASS_Transient,UTGame)
	/** === UUTUIDataProvider_SearchResult interface === */
	/**
	 * @return	TRUE if server corresponding to this search result is a pure server.
	 */
	UBOOL IsPureServer();

	/**
	 * @return	TRUE if server corresponding to this search result is password protected.
	 */
	UBOOL IsPrivateServer();

	/**
	 * @return	TRUE if server corresponding to this search result allows players to use keyboard & mouse.
	 */
	UBOOL AllowsKeyboardMouse();

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Gets the list of data fields (and their localized friendly name) for the fields exposed this provider.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the name/friendly name pairs for all data fields in this provider.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );
};

class UUTUIResourceDataProvider : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIResourceDataProvider
    BITFIELD bSearchAllInis:1 GCC_BITFIELD_MAGIC;
    BITFIELD bRemoveOn360:1;
    BITFIELD bRemoveOnPC:1;
    BITFIELD bRemoveOnPS3:1;
    FStringNoInit IniName;
    //## END PROPS UTUIResourceDataProvider

    virtual UBOOL IsFiltered();
    DECLARE_FUNCTION(execIsFiltered)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFiltered();
    }
    DECLARE_CLASS(UUTUIResourceDataProvider,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags )
	{
		Super::GetElementCellTags(FieldName,out_CellTags);
	}

	/** called by UTUIDataStore_MenuItems::InitializeListElementProviders() to give the provider an opportunity
	 * to create an add additional providers that are "based on" this one
	 */
	virtual void AddChildProviders(TArray<UUTUIResourceDataProvider*>& Providers)
	{
	}
};

class UUTUIDataProvider_CommunityMenuItem : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_CommunityMenuItem
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_CommunityMenuItem

    DECLARE_CLASS(UUTUIDataProvider_CommunityMenuItem,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_CommunityMenuItem)
};

class UUTUIDataProvider_DemoFile : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_DemoFile
    FStringNoInit Filename;
    //## END PROPS UTUIDataProvider_DemoFile

    DECLARE_CLASS(UUTUIDataProvider_DemoFile,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_DemoFile)
};

class UUTUIDataProvider_GameModeInfo : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_GameModeInfo
    FStringNoInit GameMode;
    FStringNoInit DefaultMap;
    FStringNoInit GameSettingsClass;
    FStringNoInit GameSearchClass;
    FStringNoInit OptionSet;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit PreviewImageMarkup;
    FStringNoInit Prefixes;
    FStringNoInit IconImage;
    BITFIELD bIsCampaign:1;
    FLOAT IconU;
    FLOAT IconV;
    FLOAT IconUL;
    FLOAT IconVL;
    //## END PROPS UTUIDataProvider_GameModeInfo

    DECLARE_CLASS(UUTUIDataProvider_GameModeInfo,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/** @return 	TRUE if this data provider represents the campaign gametype */
	virtual UBOOL IsFiltered();
};

class UUTUIDataProvider_KeyBinding : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_KeyBinding
    FStringNoInit FriendlyName;
    FStringNoInit Command;
    BITFIELD bIsCrucialBind:1;
    //## END PROPS UTUIDataProvider_KeyBinding

    DECLARE_CLASS(UUTUIDataProvider_KeyBinding,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_KeyBinding)
};

class UUTUIDataProvider_MainMenuItems : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MainMenuItems
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_MainMenuItems

    DECLARE_CLASS(UUTUIDataProvider_MainMenuItems,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_MainMenuItems)
};

struct UTUIDataProvider_MapInfo_eventSupportedByCurrentGameMode_Parms
{
    UBOOL ReturnValue;
    UTUIDataProvider_MapInfo_eventSupportedByCurrentGameMode_Parms(EEventParm)
    {
    }
};
class UUTUIDataProvider_MapInfo : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MapInfo
    INT MapId;
    FStringNoInit MapName;
    FStringNoInit NumPlayers;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit PreviewImageMarkup;
    BITFIELD bOfficialMap:1;
    //## END PROPS UTUIDataProvider_MapInfo

    UBOOL IsOfficialMap() const;
    DECLARE_FUNCTION(execIsOfficialMap)
    {
        P_FINISH;
        *(UBOOL*)Result=IsOfficialMap();
    }
    UBOOL eventSupportedByCurrentGameMode()
    {
        UTUIDataProvider_MapInfo_eventSupportedByCurrentGameMode_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_SupportedByCurrentGameMode),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataProvider_MapInfo,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	virtual void AddChildProviders(TArray<UUTUIResourceDataProvider*>& Providers);

	/** @return 	TRUE if this data provider is not supported by the currently selected gametype */
	virtual UBOOL IsFiltered();
};

class UUTUIDataProvider_MenuOption : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MenuOption
    BYTE OptionType;
    BYTE EditboxAllowedChars;
    TArrayNoInit<FName> OptionSet;
    FStringNoInit DataStoreMarkup;
    FName RequiredGameMode;
    FStringNoInit FriendlyName;
    FStringNoInit CustomFriendlyName;
    FStringNoInit Description;
    BITFIELD bEditableCombo:1;
    BITFIELD bNumericCombo:1;
    BITFIELD bKeyboardOrMouseOption:1;
    BITFIELD bOnlineOnly:1;
    BITFIELD bOfflineOnly:1;
    INT EditBoxMaxLength;
    struct FUIRangeData RangeData;
    //## END PROPS UTUIDataProvider_MenuOption

    DECLARE_CLASS(UUTUIDataProvider_MenuOption,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/** @return 	TRUE if this menu option's configuration isn't compatible with the desired game settings  */
	virtual UBOOL IsFiltered();
};

class UUTUIDataProvider_MultiplayerMenuItem : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MultiplayerMenuItem
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    BITFIELD bRequiresOnlineAccess:1;
    //## END PROPS UTUIDataProvider_MultiplayerMenuItem

    DECLARE_CLASS(UUTUIDataProvider_MultiplayerMenuItem,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/** @return 	TRUE if this data provider requires online access but is not able or allowed to play online */
	virtual UBOOL IsFiltered();
};

struct UTUIDataProvider_Mutator_eventSupportsCurrentGameMode_Parms
{
    UBOOL ReturnValue;
    UTUIDataProvider_Mutator_eventSupportsCurrentGameMode_Parms(EEventParm)
    {
    }
};
class UUTUIDataProvider_Mutator : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_Mutator
    FStringNoInit ClassName;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit GroupNames;
    FStringNoInit UIConfigScene;
    TArrayNoInit<FString> SupportedGameTypes;
    BITFIELD bStandaloneOnly:1;
    BITFIELD bOfficialMutator:1;
    //## END PROPS UTUIDataProvider_Mutator

    UBOOL IsOfficialMutator() const;
    DECLARE_FUNCTION(execIsOfficialMutator)
    {
        P_FINISH;
        *(UBOOL*)Result=IsOfficialMutator();
    }
    UBOOL eventSupportsCurrentGameMode()
    {
        UTUIDataProvider_Mutator_eventSupportsCurrentGameMode_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_SupportsCurrentGameMode),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataProvider_Mutator,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/** @return 	TRUE if this data provider is not supported by the currently selected gametype */
	virtual UBOOL IsFiltered();
};

class UUTUIDataProvider_SettingsMenuItem : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_SettingsMenuItem
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    BITFIELD bFrontEndOnly:1;
    //## END PROPS UTUIDataProvider_SettingsMenuItem

    DECLARE_CLASS(UUTUIDataProvider_SettingsMenuItem,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/** @return 	TRUE if this data provider represents the campaign gametype */
	virtual UBOOL IsFiltered();
};

class UUTUIDataProvider_SimpleMenu : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_SimpleMenu
    FName FieldName;
    TArrayNoInit<FString> Options;
    //## END PROPS UTUIDataProvider_SimpleMenu

    DECLARE_CLASS(UUTUIDataProvider_SimpleMenu,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );


	/* === UIDataProvider interface === */
	/**
	 * Returns the data tag associated with the specified provider.
	 *
	 * @return	the data field tag associated with the provider specified, or NAME_None if the provider specified is not
	 *			contained by this data store.
	 */
	virtual FName GetProviderDataTag( class UUIDataProvider* Provider );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex ) { return TRUE; }
};

class UUTUIDataProvider_Weapon : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_Weapon
    FStringNoInit ClassName;
    FStringNoInit AmmoClassPath;
    FStringNoInit Flags;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit MeshReference;
    //## END PROPS UTUIDataProvider_Weapon

    DECLARE_CLASS(UUTUIDataProvider_Weapon,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_Weapon)
};

class UUTUIDataProvider_Character : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_Character
    struct FCharacterInfo CustomData;
    //## END PROPS UTUIDataProvider_Character

    virtual UBOOL IsFiltered();
    DECLARE_FUNCTION(execIsFiltered)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFiltered();
    }
    DECLARE_CLASS(UUTUIDataProvider_Character,UUIDataProvider,0|CLASS_Transient,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/** Sets the data for this provider. */
	void SetData(FCharacterInfo &InData);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUTUIDataProvider_CharacterFaction : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_CharacterFaction
    struct FFactionInfo CustomData;
    //## END PROPS UTUIDataProvider_CharacterFaction

    DECLARE_CLASS(UUTUIDataProvider_CharacterFaction,UUIDataProvider,0|CLASS_Transient,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/** Sets the data for this provider. */
	void SetData(FFactionInfo &InData);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUTUIDataProvider_SimpleElementProvider : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_SimpleElementProvider
    //## END PROPS UTUIDataProvider_SimpleElementProvider

    virtual INT GetElementCount();
    DECLARE_FUNCTION(execGetElementCount)
    {
        P_FINISH;
        *(INT*)Result=GetElementCount();
    }
    DECLARE_CLASS(UUTUIDataProvider_SimpleElementProvider,UUIDataProvider,0|CLASS_Transient,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

struct FAvailableContentPackage
{
    FStringNoInit ContentName;
    FStringNoInit ContentFriendlyName;
    FStringNoInit ContentDescription;

    /** Constructors */
    FAvailableContentPackage() {}
    FAvailableContentPackage(EEventParm)
    {
        appMemzero(this, sizeof(FAvailableContentPackage));
    }
};

class UUTUIDataProvider_AvailableContent : public UUTUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_AvailableContent
    TArrayNoInit<struct FAvailableContentPackage> Packages;
    //## END PROPS UTUIDataProvider_AvailableContent

    virtual INT GetElementCount();
    virtual void ParseContentString(const FString& ContentStr);
    DECLARE_FUNCTION(execParseContentString)
    {
        P_GET_STR(ContentStr);
        P_FINISH;
        ParseContentString(ContentStr);
    }
    DECLARE_CLASS(UUTUIDataProvider_AvailableContent,UUTUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUTUIDataProvider_InstalledContent : public UUTUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_InstalledContent
    //## END PROPS UTUIDataProvider_InstalledContent

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_InstalledContent,UUTUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUTUIDataProvider_ServerDetails : public UUTUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_ServerDetails
    INT SearchResultsRow;
    //## END PROPS UTUIDataProvider_ServerDetails

    virtual class UUIDataProvider_Settings* GetSearchResultsProvider();
    virtual INT GetElementCount();
    DECLARE_FUNCTION(execGetSearchResultsProvider)
    {
        P_FINISH;
        *(class UUIDataProvider_Settings**)Result=GetSearchResultsProvider();
    }
    DECLARE_CLASS(UUTUIDataProvider_ServerDetails,UUTUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UTGame)
public:
	/**
	 * Determines whether the specified field should be included when the user requests to see a list of this server's details.
	 */
	static UBOOL ShouldDisplayField( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct UTUIDataProvider_StatsElementProvider_eventGetStatsReadObject_Parms
{
    class UOnlineStatsRead* ReturnValue;
    UTUIDataProvider_StatsElementProvider_eventGetStatsReadObject_Parms(EEventParm)
    {
    }
};
class UUTUIDataProvider_StatsElementProvider : public UUTUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_StatsElementProvider
    class UOnlineStatsRead* ReadObject;
    //## END PROPS UTUIDataProvider_StatsElementProvider

    virtual FString GetColumnValue(const struct FOnlineStatsRow& StatsRow,FName ColumnId);
    virtual FString GetColumnName(FName StatName);
    DECLARE_FUNCTION(execGetColumnValue)
    {
        P_GET_STRUCT_INIT_REF(struct FOnlineStatsRow,StatsRow);
        P_GET_NAME(ColumnId);
        P_FINISH;
        *(FString*)Result=GetColumnValue(StatsRow,ColumnId);
    }
    DECLARE_FUNCTION(execGetColumnName)
    {
        P_GET_NAME(StatName);
        P_FINISH;
        *(FString*)Result=GetColumnName(StatName);
    }
    class UOnlineStatsRead* eventGetStatsReadObject()
    {
        UTUIDataProvider_StatsElementProvider_eventGetStatsReadObject_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(UTGAME_GetStatsReadObject),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataProvider_StatsElementProvider,UUTUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UTGame)
	/** 
	 * Returns a reference to the stats row that is used to expose data.
	 *
	 * @param StatsRow	Object to hold the stats row.
	 *
	 * @return TRUE if a stats row was found, FALSE otherwise. 
	 */
	virtual UBOOL GetStatsRow(FOnlineStatsRow& OutStatsRow);

	/** 
	* Returns a reference to the stats id in this particular view that is used to expose data.
	*
	* @param StatsName	Name of the stat we want a mapping in this view for.
	*
	* @return ColumnId if a stats row was found, -1 otherwise. 
	*/
	virtual INT GetColumnIdFromStatName(const FName StatName);
};

struct FGeneralStatsRow
{
    FName StatName;

    /** Constructors */
    FGeneralStatsRow() {}
    FGeneralStatsRow(EEventParm)
    {
        appMemzero(this, sizeof(FGeneralStatsRow));
    }
};

class UUTUIDataProvider_StatsGeneral : public UUTUIDataProvider_StatsElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_StatsGeneral
    TArrayNoInit<struct FGeneralStatsRow> Stats;
    //## END PROPS UTUIDataProvider_StatsGeneral

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_StatsGeneral,UUTUIDataProvider_StatsElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUTUIDataProvider_StatsRewards : public UUTUIDataProvider_StatsGeneral
{
public:
    //## BEGIN PROPS UTUIDataProvider_StatsRewards
    //## END PROPS UTUIDataProvider_StatsRewards

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_StatsRewards,UUTUIDataProvider_StatsGeneral,0|CLASS_Transient,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_StatsRewards)
};

struct FVehicleStatsRow
{
    FStringNoInit VehicleName;
    FName DrivingTimeName;
    FName VehicleKillsName;

    /** Constructors */
    FVehicleStatsRow() {}
    FVehicleStatsRow(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleStatsRow));
    }
};

class UUTUIDataProvider_StatsVehicles : public UUTUIDataProvider_StatsElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_StatsVehicles
    TArrayNoInit<struct FVehicleStatsRow> Stats;
    //## END PROPS UTUIDataProvider_StatsVehicles

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_StatsVehicles,UUTUIDataProvider_StatsElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct FVehicleWeaponStatsRow
{
    FStringNoInit WeaponName;
    FName KillsName;
    FName DeathsName;
    FName SuicidesName;

    /** Constructors */
    FVehicleWeaponStatsRow() {}
    FVehicleWeaponStatsRow(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleWeaponStatsRow));
    }
};

class UUTUIDataProvider_StatsVehicleWeapons : public UUTUIDataProvider_StatsElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_StatsVehicleWeapons
    TArrayNoInit<struct FVehicleWeaponStatsRow> Stats;
    //## END PROPS UTUIDataProvider_StatsVehicleWeapons

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_StatsVehicleWeapons,UUTUIDataProvider_StatsElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct FWeaponStatsRow
{
    FStringNoInit WeaponName;
    FName KillsName;
    FName DeathsName;
    FName SuicidesName;

    /** Constructors */
    FWeaponStatsRow() {}
    FWeaponStatsRow(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponStatsRow));
    }
};

class UUTUIDataProvider_StatsWeapons : public UUTUIDataProvider_StatsElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_StatsWeapons
    TArrayNoInit<struct FWeaponStatsRow> Stats;
    //## END PROPS UTUIDataProvider_StatsWeapons

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_StatsWeapons,UUTUIDataProvider_StatsElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUTUIDataProvider_StringArray : public UUTUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_StringArray
    TArrayNoInit<FString> Strings;
    //## END PROPS UTUIDataProvider_StringArray

    virtual INT GetElementCount();
    DECLARE_CLASS(UUTUIDataProvider_StringArray,UUTUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UTGame)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUTUICollectionCheckBox : public UUICheckbox
{
public:
    //## BEGIN PROPS UTUICollectionCheckBox
    TScriptInterface<class IUIListElementProvider> DataProvider;
    //## END PROPS UTUICollectionCheckBox

    virtual void SetValue(UBOOL bShouldBeChecked,INT PlayerIndex=-1);
    DECLARE_CLASS(UUTUICollectionCheckBox,UUICheckbox,0|CLASS_Config,UTGame)
public:
	/**
	 * Resolves DataSource into the list element provider that it references.
	 */
	void ResolveListElementProvider();

protected:
	/** @return Returns the number of possible values for the field we are bound to. */
	INT GetNumValues();

	/**
	 * @param ListIndex		List index to get the value of.
	 * @param OutValue	Storage string for the list value
	 *
	 * @return Returns TRUE if we were able to get a value, FALSE otherwise
	 */
	UBOOL GetListValue(INT ListIndex, FString &OutValue);

	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);

	/**
	 * Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.
	 *
	 * @param	out_BoundDataStores	contains the array of data stores that widgets have saved values to.  Each widget that
	 *								implements this method should add its resolved data store to this array after data values have been
	 *								published.  Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called
	 *								on all data stores in this array.
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);

	/**
	 * Handler for the UIDataStore.OnDataStoreValueUpdated delegate.  Used by data stores to indicate that some data provided by the data
	 * has changed.  Subscribers should use this function to refresh any data store values being displayed with the updated value.
	 * notify subscribers when they should refresh their values from this data store.
	 *
	 * @param	SourceDataStore		the data store that generated the refresh notification; useful for subscribers with multiple data store
	 *								bindings, to tell which data store sent the notification.
	 * @param	PropertyTag			the tag associated with the data field that was updated; Subscribers can use this tag to determine whether
	 *								there is any need to refresh their data values.
	 * @param	SourceProvider		for data stores which contain nested providers, the provider that contains the data which changed.
	 * @param	ArrayIndex			for collection fields, indicates which element was changed.  value of INDEX_NONE indicates not an array
	 *								or that the entire array was updated.
	 */
	virtual void NotifyDataStoreValueUpdated( class UUIDataStore* SourceDataStore, UBOOL bValuesInvalidated, FName PropertyTag, class UUIDataProvider* SourceProvider, INT ArrayIndex );
};

class UUTUIButtonBarButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UTUIButtonBarButton
    //## END PROPS UTUIButtonBarButton

    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    DECLARE_CLASS(UUTUIButtonBarButton,UUILabelButton,0|CLASS_Config,UTGame)
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

class UUTUIComboBox : public UUIComboBox
{
public:
    //## BEGIN PROPS UTUIComboBox
    FName ToggleButtonStyleName;
    FName ToggleButtonCheckedStyleName;
    FName EditboxBGStyleName;
    FName ListBackgroundStyleName;
    //## END PROPS UTUIComboBox

    virtual void SetupChildStyles();
    DECLARE_FUNCTION(execSetupChildStyles)
    {
        P_FINISH;
        SetupChildStyles();
    }
    DECLARE_CLASS(UUTUIComboBox,UUIComboBox,0|CLASS_Config,UTGame)
	/* === UUIComboBox interface === */
	/**
	 * Called whenever the selected item is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/* === UUIScreenObject interface === */
	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged()
	{
		Super::NotifyActiveSkinChanged();

		// reapply the styles to the combobox
		SetupChildStyles();
	}

	/**
	 * Sets the data store binding for this object to the text specified.
	 *
	 * @param	MarkupText			a markup string which resolves to data exposed by a data store.  The expected format is:
	 *								<DataStoreTag:DataFieldTag>
	 * @param	BindingIndex		indicates which data store binding should be modified.  Valid values and their meanings are:
	 *									0:	list data source
	 *									1:	caption data source
	 */
	virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=INDEX_NONE);
	/**
	 * Retrieves the markup string corresponding to the data store that this object is bound to.
	 *
	 * @param	BindingIndex		indicates which data store binding should be modified.  Valid values and their meanings are:
	 *									0:	list data source
	 *									1:	caption data source
	 *
	 * @return	a datastore markup string which resolves to the datastore field that this object is bound to, in the format:
	 *			<DataStoreTag:DataFieldTag>
	 */
	virtual FString GetDataStoreBinding(INT BindingIndex=INDEX_NONE) const;
	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @param	BindingIndex		indicates which data store binding should be modified.  Valid values and their meanings are:
	 *									-1:	all data sources
	 *									0:	list data source
	 *									1:	caption data source
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);
	/**
	 * Retrieves the list of data stores bound by this subscriber.
	 *
	 * @param	out_BoundDataStores		receives the array of data stores that subscriber is bound to.
	 */
	virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
	/**
	 * Notifies this subscriber to unbind itself from all bound data stores
	 */
	virtual void ClearBoundDataStores();

	/**
	 * Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.
	 *
	 * @param	out_BoundDataStores	contains the array of data stores that widgets have saved values to.  Each widget that
	 *								implements this method should add its resolved data store to this array after data values have been
	 *								published.  Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called
	 *								on all data stores in this array.
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	virtual UBOOL SaveSubscriberValue( TArray<class UUIDataStore*>& out_BoundDataStores, INT BindingIndex=INDEX_NONE );
};

struct UTTabPage_eventOnTick_Parms
{
    FLOAT DeltaTime;
    UTTabPage_eventOnTick_Parms(EEventParm)
    {
    }
};
class UUTTabPage : public UUITabPage
{
public:
    //## BEGIN PROPS UTTabPage
    BITFIELD bRequiresTick:1;
    FScriptDelegate __OnTick__Delegate;
    //## END PROPS UTTabPage

    void delegateOnTick(FLOAT DeltaTime)
    {
        UTTabPage_eventOnTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessDelegate(UTGAME_OnTick,&__OnTick__Delegate,&Parms);
    }
    DECLARE_CLASS(UUTTabPage,UUITabPage,0|CLASS_Config,UTGame)
	virtual void Tick_Widget(FLOAT DeltaTime);


	/* === UUIScreenObject interface === */

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

#define UCONST_STATS_VIEW_DM_WEAPONS_RANKED_ALLTIME 8
#define UCONST_STATS_VIEW_DM_VEHICLEWEAPONS_RANKED_ALLTIME 7
#define UCONST_STATS_VIEW_DM_VEHICLES_RANKED_ALLTIME 6
#define UCONST_STATS_VIEW_DM_VEHICLEWEAPONS_ALLTIME 5
#define UCONST_STATS_VIEW_DM_VEHICLES_ALLTIME 4
#define UCONST_STATS_VIEW_DM_WEAPONS_ALLTIME 3
#define UCONST_STATS_VIEW_DM_RANKED_ALLTIME 2
#define UCONST_STATS_VIEW_DM_PLAYER_ALLTIME 1
#define UCONST_QUERY_CAMPAIGN 6
#define UCONST_QUERY_DUEL 5
#define UCONST_QUERY_WAR 4
#define UCONST_QUERY_VCTF 3
#define UCONST_QUERY_CTF 2
#define UCONST_QUERY_TDM 1
#define UCONST_QUERY_DM 0
#define UCONST_PROPERTY_CUSTOMMUTATORS 0x40000004
#define UCONST_PROPERTY_SERVERDESCRIPTION 0x40000003
#define UCONST_PROPERTY_CUSTOMGAMEMODE 0x40000002
#define UCONST_PROPERTY_CUSTOMMAPNAME 0x40000001
#define UCONST_PROPERTY_EPICMUTATORS 0x10000105
#define UCONST_PROPERTY_LEADERBOARDRATING 0x20000004
#define UCONST_PROPERTY_TIMELIMIT 0x100000F9
#define UCONST_PROPERTY_GOALSCORE 0x100000F8
#define UCONST_PROPERTY_NUMBOTS 0x100000F7
#define UCONST_CONTEXT_VSBOTS_4_TO_1 6
#define UCONST_CONTEXT_VSBOTS_3_TO_1 5
#define UCONST_CONTEXT_VSBOTS_2_TO_1 4
#define UCONST_CONTEXT_VSBOTS_3_TO_2 3
#define UCONST_CONTEXT_VSBOTS_1_TO_1 2
#define UCONST_CONTEXT_VSBOTS_1_TO_2 1
#define UCONST_CONTEXT_VSBOTS_NONE 0
#define UCONST_CONTEXT_DEDICATEDSERVER_YES 1
#define UCONST_CONTEXT_DEDICATEDSERVER_NO 0
#define UCONST_CONTEXT_EMPTYSERVER_YES 1
#define UCONST_CONTEXT_EMPTYSERVER_NO 0
#define UCONST_CONTEXT_FULLSERVER_YES 1
#define UCONST_CONTEXT_FULLSERVER_NO 0
#define UCONST_CONTEXT_ALLOWKEYBOARD_ANY 2
#define UCONST_CONTEXT_ALLOWKEYBOARD_YES 1
#define UCONST_CONTEXT_ALLOWKEYBOARD_NO 0
#define UCONST_CONTEXT_FORCERESPAWN_YES 1
#define UCONST_CONTEXT_FORCERESPAWN_NO 0
#define UCONST_CONTEXT_CAMPAIGN_YES 1
#define UCONST_CONTEXT_CAMPAIGN_NO 0
#define UCONST_CONTEXT_LOCKEDSERVER_YES 1
#define UCONST_CONTEXT_LOCKEDSERVER_NO 0
#define UCONST_CONTEXT_PURESERVER_ANY 2
#define UCONST_CONTEXT_PURESERVER_YES 1
#define UCONST_CONTEXT_PURESERVER_NO 0
#define UCONST_CONTEXT_TIMELIMIT_30 4
#define UCONST_CONTEXT_TIMELIMIT_20 3
#define UCONST_CONTEXT_TIMELIMIT_15 2
#define UCONST_CONTEXT_TIMELIMIT_10 1
#define UCONST_CONTEXT_TIMELIMIT_5 0
#define UCONST_CONTEXT_NUMBOTS_8 8
#define UCONST_CONTEXT_NUMBOTS_7 7
#define UCONST_CONTEXT_NUMBOTS_6 6
#define UCONST_CONTEXT_NUMBOTS_5 5
#define UCONST_CONTEXT_NUMBOTS_4 4
#define UCONST_CONTEXT_NUMBOTS_3 3
#define UCONST_CONTEXT_NUMBOTS_2 2
#define UCONST_CONTEXT_NUMBOTS_1 1
#define UCONST_CONTEXT_NUMBOTS_0 0
#define UCONST_CONTEXT_GOALSCORE_30 4
#define UCONST_CONTEXT_GOALSCORE_20 3
#define UCONST_CONTEXT_GOALSCORE_15 2
#define UCONST_CONTEXT_GOALSCORE_10 1
#define UCONST_CONTEXT_GOALSCORE_5 0
#define UCONST_CONTEXT_BOTSKILL_GODLIKE 8
#define UCONST_CONTEXT_BOTSKILL_INHUMAN 7
#define UCONST_CONTEXT_BOTSKILL_MASTERFUL 6
#define UCONST_CONTEXT_BOTSKILL_ADEPT 5
#define UCONST_CONTEXT_BOTSKILL_SKILLED 4
#define UCONST_CONTEXT_BOTSKILL_EXPERIENCED 3
#define UCONST_CONTEXT_BOTSKILL_AVERAGE 2
#define UCONST_CONTEXT_BOTSKILL_NOVICE 1
#define UCONST_CONTEXT_BOTSKILL_AUTOADJUSTSKILL 0
#define UCONST_CONTEXT_MAPNAME_CUSTOM 0
#define UCONST_CONTEXT_DEDICATEDSERVER 14
#define UCONST_CONTEXT_EMPTYSERVER 13
#define UCONST_CONTEXT_FULLSERVER 12
#define UCONST_CONTEXT_ALLOWKEYBOARD 11
#define UCONST_CONTEXT_FORCERESPAWN 10
#define UCONST_CONTEXT_CAMPAIGN 9
#define UCONST_CONTEXT_VSBOTS 8
#define UCONST_CONTEXT_LOCKEDSERVER 7
#define UCONST_CONTEXT_PURESERVER 6
#define UCONST_CONTEXT_MAPNAME 1
#define UCONST_CONTEXT_BOTSKILL 0
#define UCONST_CONTEXT_GAME_MODE_CAMPAIGN 7
#define UCONST_CONTEXT_GAME_MODE_CUSTOM 6
#define UCONST_CONTEXT_GAME_MODE_DUEL 5
#define UCONST_CONTEXT_GAME_MODE_TDM 4
#define UCONST_CONTEXT_GAME_MODE_VCTF 3
#define UCONST_CONTEXT_GAME_MODE_WAR 2
#define UCONST_CONTEXT_GAME_MODE_CTF 1
#define UCONST_CONTEXT_GAME_MODE_DM 0
#define UCONST_CONTEXT_GAME_MODE 0x0000800B
#define UCONST_CONTEXT_PRESENCE_MENUPRESENCE 0
#define UCONST_GS_CDKEY_PART_MAXLENGTH 4
#define UCONST_GS_EMAIL_MAXLENGTH 50
#define UCONST_GS_MESSAGE_MAXLENGTH 255
#define UCONST_GS_PASSWORD_MAXLENGTH 30
#define UCONST_GS_USERNAME_MAXLENGTH 15

struct UTUIScene_eventOnAnimationFinished_Parms
{
    class UUIObject* AnimTarget;
    FName AnimName;
    FName SeqName;
    UTUIScene_eventOnAnimationFinished_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventIsControllerInput_Parms
{
    FName KeyName;
    UBOOL ReturnValue;
    UTUIScene_eventIsControllerInput_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventOnSceneOpened_Parms
{
    class UUIScene* OpenedScene;
    UBOOL bInitialActivation;
    UTUIScene_eventOnSceneOpened_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventOnHideAnimationEnded_Parms
{
    UTUIScene_eventOnHideAnimationEnded_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventOnShowAnimationEnded_Parms
{
    UTUIScene_eventOnShowAnimationEnded_Parms(EEventParm)
    {
    }
};
class UUTUIScene : public UUIScene
{
public:
    //## BEGIN PROPS UTUIScene
    BITFIELD bEditorRealTimePreview:1;
    BITFIELD bIgnoreAxisInput:1;
    BITFIELD bShowingScene:1;
    BITFIELD bHidingScene:1;
    BITFIELD bSkipPendingCloseSceneNotify:1;
    class UUIScene* MessageBoxScene;
    class UUIScene* InputBoxScene;
    class UUIScene* PlayerCardScene;
    class UUIScene* OnlineToastScene;
    class UUIScene* PendingOpenScene;
    class UUIScene* PendingCloseScene;
    FScriptDelegate __OnShowAnimationEnded__Delegate;
    FScriptDelegate __OnHideAnimationEnded__Delegate;
    FScriptDelegate __OnSceneOpened__Delegate;
    //## END PROPS UTUIScene

    virtual void SetScreenResolution(INT ResX,INT ResY,UBOOL bFullscreen);
    virtual class AUTPlayerController* GetUTPlayerOwner(INT PlayerIndex=-1);
    virtual class APawn* GetPawnOwner();
    virtual class AUTPlayerReplicationInfo* GetPRIOwner();
    virtual UBOOL IsGame();
    virtual void StartDedicatedServer(const FString& TravelURL);
    virtual void GetPossibleScreenResolutions(TArray<FString>& OutResults);
    virtual void GetPossibleAudioDevices(TArray<FString>& OutResults);
    virtual FString GetCurrentAudioDevice();
    UBOOL IsBelowMinSpecs() const;
    virtual void SetAudioDeviceToUse(const FString& InAudioDevice);
    virtual UBOOL TryCharacterUnlock(const FString& UnlockCode);
    virtual void ActivateLevelEvent(FName EventName);
    virtual void UpdateSplitscreenPlayers(UBOOL bCreatePlayers);
    virtual void ViewportProject(class ULocalPlayer* LocalPlayerOwner,FVector WorldLocation,FVector& OutScreenLocation);
    virtual void ViewportDeProject(class ULocalPlayer* LocalPlayerOwner,FVector ScreenLocation,FVector& OutLocation,FVector& OutDirection);
    virtual void DeleteDemo(const FString& DemoName);
    DECLARE_FUNCTION(execSetScreenResolution)
    {
        P_GET_INT(ResX);
        P_GET_INT(ResY);
        P_GET_UBOOL(bFullscreen);
        P_FINISH;
        SetScreenResolution(ResX,ResY,bFullscreen);
    }
    DECLARE_FUNCTION(execGetUTPlayerOwner)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class AUTPlayerController**)Result=GetUTPlayerOwner(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetPawnOwner)
    {
        P_FINISH;
        *(class APawn**)Result=GetPawnOwner();
    }
    DECLARE_FUNCTION(execGetPRIOwner)
    {
        P_FINISH;
        *(class AUTPlayerReplicationInfo**)Result=GetPRIOwner();
    }
    DECLARE_FUNCTION(execIsGame)
    {
        P_FINISH;
        *(UBOOL*)Result=IsGame();
    }
    DECLARE_FUNCTION(execStartDedicatedServer)
    {
        P_GET_STR(TravelURL);
        P_FINISH;
        StartDedicatedServer(TravelURL);
    }
    DECLARE_FUNCTION(execGetPossibleScreenResolutions)
    {
        P_GET_TARRAY_REF(FString,OutResults);
        P_FINISH;
        GetPossibleScreenResolutions(OutResults);
    }
    DECLARE_FUNCTION(execGetPossibleAudioDevices)
    {
        P_GET_TARRAY_REF(FString,OutResults);
        P_FINISH;
        GetPossibleAudioDevices(OutResults);
    }
    DECLARE_FUNCTION(execGetCurrentAudioDevice)
    {
        P_FINISH;
        *(FString*)Result=GetCurrentAudioDevice();
    }
    DECLARE_FUNCTION(execIsBelowMinSpecs)
    {
        P_FINISH;
        *(UBOOL*)Result=IsBelowMinSpecs();
    }
    DECLARE_FUNCTION(execSetAudioDeviceToUse)
    {
        P_GET_STR(InAudioDevice);
        P_FINISH;
        SetAudioDeviceToUse(InAudioDevice);
    }
    DECLARE_FUNCTION(execTryCharacterUnlock)
    {
        P_GET_STR(UnlockCode);
        P_FINISH;
        *(UBOOL*)Result=TryCharacterUnlock(UnlockCode);
    }
    DECLARE_FUNCTION(execActivateLevelEvent)
    {
        P_GET_NAME(EventName);
        P_FINISH;
        ActivateLevelEvent(EventName);
    }
    DECLARE_FUNCTION(execUpdateSplitscreenPlayers)
    {
        P_GET_UBOOL(bCreatePlayers);
        P_FINISH;
        UpdateSplitscreenPlayers(bCreatePlayers);
    }
    DECLARE_FUNCTION(execViewportProject)
    {
        P_GET_OBJECT(ULocalPlayer,LocalPlayerOwner);
        P_GET_STRUCT(FVector,WorldLocation);
        P_GET_STRUCT_REF(FVector,OutScreenLocation);
        P_FINISH;
        ViewportProject(LocalPlayerOwner,WorldLocation,OutScreenLocation);
    }
    DECLARE_FUNCTION(execViewportDeProject)
    {
        P_GET_OBJECT(ULocalPlayer,LocalPlayerOwner);
        P_GET_STRUCT(FVector,ScreenLocation);
        P_GET_STRUCT_REF(FVector,OutLocation);
        P_GET_STRUCT_REF(FVector,OutDirection);
        P_FINISH;
        ViewportDeProject(LocalPlayerOwner,ScreenLocation,OutLocation,OutDirection);
    }
    DECLARE_FUNCTION(execDeleteDemo)
    {
        P_GET_STR(DemoName);
        P_FINISH;
        DeleteDemo(DemoName);
    }
    void eventOnAnimationFinished(class UUIObject* AnimTarget,FName AnimName,FName SeqName)
    {
        UTUIScene_eventOnAnimationFinished_Parms Parms(EC_EventParm);
        Parms.AnimTarget=AnimTarget;
        Parms.AnimName=AnimName;
        Parms.SeqName=SeqName;
        ProcessEvent(FindFunctionChecked(UTGAME_OnAnimationFinished),&Parms);
    }
    UBOOL eventIsControllerInput(FName KeyName)
    {
        UTUIScene_eventIsControllerInput_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.KeyName=KeyName;
        ProcessEvent(FindFunctionChecked(UTGAME_IsControllerInput),&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnSceneOpened(class UUIScene* OpenedScene,UBOOL bInitialActivation)
    {
        UTUIScene_eventOnSceneOpened_Parms Parms(EC_EventParm);
        Parms.OpenedScene=OpenedScene;
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(UTGAME_OnSceneOpened,&__OnSceneOpened__Delegate,&Parms);
    }
    void delegateOnHideAnimationEnded()
    {
        ProcessDelegate(UTGAME_OnHideAnimationEnded,&__OnHideAnimationEnded__Delegate,NULL);
    }
    void delegateOnShowAnimationEnded()
    {
        ProcessDelegate(UTGAME_OnShowAnimationEnded,&__OnShowAnimationEnded__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUTUIScene,UUIScene,0|CLASS_Config,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick( FLOAT DeltaTime );
	virtual void TickChildren(UUIScreenObject* ParentObject, FLOAT DeltaTime);
	virtual void PreRender(FCanvas* Canvas);

	virtual UBOOL PreChildrenInputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE) { return false; }

	static void AutoPlaceChildren(UUIScreenObject *const BaseObject);

	/**
	 * Appends any command-line switches that should be carried over to the new process when starting a dedicated server instance.
	 */
	static void AppendPersistentSwitches( FString& ExtraSwitches );
};

class UUTUIScene_DemoSell : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_DemoSell
    class UUIButton* SellButton;
    class UUIButton* ExitButton;
    //## END PROPS UTUIScene_DemoSell

    virtual void Sell();
    DECLARE_FUNCTION(execSell)
    {
        P_FINISH;
        Sell();
    }
    DECLARE_CLASS(UUTUIScene_DemoSell,UUTUIScene,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_DemoSell)
};

class UUTUIScene_Hud : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_Hud
    //## END PROPS UTUIScene_Hud

    virtual class AUTHUD* GetPlayerHud();
    DECLARE_FUNCTION(execGetPlayerHud)
    {
        P_FINISH;
        *(class AUTHUD**)Result=GetPlayerHud();
    }
    DECLARE_CLASS(UUTUIScene_Hud,UUTUIScene,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_Hud)
};

class UUTUIScene_MapVote : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_MapVote
    class UUTDrawMapVotePanel* MapList;
    class UUILabel* TimeRemaining;
    class AUTVoteReplicationInfo* VoteRI;
    //## END PROPS UTUIScene_MapVote

    DECLARE_CLASS(UUTUIScene_MapVote,UUTUIScene_Hud,0|CLASS_Config,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

struct FPotentialOptionKeys
{
    TArrayNoInit<FName> Keys;

    /** Constructors */
    FPotentialOptionKeys() {}
    FPotentialOptionKeys(EEventParm)
    {
        appMemzero(this, sizeof(FPotentialOptionKeys));
    }
};

#define UCONST_CANCEL_BUTTON_MARKUP_STRING TEXT("<Strings:UTGameUI.Generic.Cancel>")
#define UCONST_MESSAGEBOX_MAX_POSSIBLE_OPTIONS 4

struct UTUIScene_MessageBox_eventOnHideComplete_Parms
{
    UTUIScene_MessageBox_eventOnHideComplete_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnShowComplete_Parms
{
    UTUIScene_MessageBox_eventOnShowComplete_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnMBInputKey_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UTUIScene_MessageBox_eventOnMBInputKey_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnClosed_Parms
{
    UTUIScene_MessageBox_eventOnClosed_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnSelection_Parms
{
    class UUTUIScene_MessageBox* MessageBox;
    INT SelectedOption;
    INT PlayerIndex;
    UTUIScene_MessageBox_eventOnSelection_Parms(EEventParm)
    {
    }
};
class UUTUIScene_MessageBox : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_MessageBox
    BITFIELD bRepositionMessageToCenter:1;
    BITFIELD bFullyVisible:1;
    BITFIELD bHideOnNextTick:1;
    class UUILabel* MessageLabel;
    class UUILabel* TitleLabel;
    class UUIObject* BackgroundImage;
    class UUIObject* ScrollWindow;
    class UUTUIButtonBar* ButtonBar;
    TArrayNoInit<FString> PotentialOptions;
    TArrayNoInit<struct FPotentialOptionKeys> PotentialOptionKeyMappings;
    INT PreviouslySelectedOption;
    INT SelectingPlayer;
    INT DefaultOptionIdx;
    FLOAT DisplayTime;
    FLOAT MinimumDisplayTime;
    FLOAT FadeDuration;
    INT FadeDirection;
    FLOAT FadeStartTime;
    FScriptDelegate __OnSelection__Delegate;
    FScriptDelegate __OnClosed__Delegate;
    FScriptDelegate __OnMBInputKey__Delegate;
    //## END PROPS UTUIScene_MessageBox

    virtual void BeginShow();
    virtual void BeginHide();
    DECLARE_FUNCTION(execBeginShow)
    {
        P_FINISH;
        BeginShow();
    }
    DECLARE_FUNCTION(execBeginHide)
    {
        P_FINISH;
        BeginHide();
    }
    void eventOnHideComplete()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_OnHideComplete),NULL);
    }
    void eventOnShowComplete()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_OnShowComplete),NULL);
    }
    UBOOL delegateOnMBInputKey(const struct FInputEventParameters& EventParms)
    {
        UTUIScene_MessageBox_eventOnMBInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventParms=EventParms;
        ProcessDelegate(UTGAME_OnMBInputKey,&__OnMBInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnClosed()
    {
        ProcessDelegate(UTGAME_OnClosed,&__OnClosed__Delegate,NULL);
    }
    void delegateOnSelection(class UUTUIScene_MessageBox* MessageBox,INT SelectedOption,INT PlayerIndex)
    {
        UTUIScene_MessageBox_eventOnSelection_Parms Parms(EC_EventParm);
        Parms.MessageBox=MessageBox;
        Parms.SelectedOption=SelectedOption;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(UTGAME_OnSelection,&__OnSelection__Delegate,&Parms);
    }
    DECLARE_CLASS(UUTUIScene_MessageBox,UUTUIScene,0|CLASS_Config,UTGame)
	/** Encapsulates logic for determining whether this message box is interpolating opacity */
	UBOOL IsFading() const { return FadeDirection != 0; }
	UBOOL IsFadingIn() const { return FadeDirection > 0; }
	UBOOL IsFadingOut() const { return FadeDirection < 0; }

	/**
	 * Provides scenes with a way to alter the amount of transparency to use when rendering parent scenes.
	 *
	 * @param	AlphaModulationPercent	the value that will be used for modulating the alpha when rendering the scene below this one.
	 *
	 * @return	TRUE if alpha modulation should be applied when rendering the scene below this one.
	 */
	virtual UBOOL ShouldModulateBackgroundAlpha( FLOAT& AlphaModulationPercent );

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreInitialSceneUpdate();
};

class UUTUIScene_InputBox : public UUTUIScene_MessageBox
{
public:
    //## BEGIN PROPS UTUIScene_InputBox
    class UUIEditBox* InputEditbox;
    BITFIELD bIsPasswordKeyboard:1;
    //## END PROPS UTUIScene_InputBox

    void LayoutScene();
    DECLARE_FUNCTION(execLayoutScene)
    {
        P_FINISH;
        LayoutScene();
    }
    DECLARE_CLASS(UUTUIScene_InputBox,UUTUIScene_MessageBox,0|CLASS_Config,UTGame)
	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreInitialSceneUpdate();
};

struct UTUIScene_MidGameMenu_eventEndLoading_Parms
{
    UTUIScene_MidGameMenu_eventEndLoading_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MidGameMenu_eventBeginLoading_Parms
{
    UTUIScene_MidGameMenu_eventBeginLoading_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MidGameMenu_eventUpdateVote_Parms
{
    class AUTGameReplicationInfo* GRI;
    UTUIScene_MidGameMenu_eventUpdateVote_Parms(EEventParm)
    {
    }
};
class UUTUIScene_MidGameMenu : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_MidGameMenu
    class UUTUIButtonBar* ButtonBar;
    class UUTUITabControl* TabControl;
    class UUILabel* MapVoteClock;
    class UUIPanel* LoadingPanel;
    class UUIImage* LoadingRotator;
    BITFIELD bInitial:1;
    BITFIELD bNeedsProfileSave:1;
    BITFIELD bOkToAutoClose:1;
    BITFIELD bLoading:1;
    BITFIELD bWaitingForReady:1;
    BITFIELD bReturningToMainMenu:1;
    class UUTUITabPage_InGame* InGamePage;
    class UUTUIScene_MessageBox* MBScene;
    //## END PROPS UTUIScene_MidGameMenu

    void eventEndLoading()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_EndLoading),NULL);
    }
    void eventBeginLoading()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_BeginLoading),NULL);
    }
    void eventUpdateVote(class AUTGameReplicationInfo* GRI)
    {
        UTUIScene_MidGameMenu_eventUpdateVote_Parms Parms(EC_EventParm);
        Parms.GRI=GRI;
        ProcessEvent(FindFunctionChecked(UTGAME_UpdateVote),&Parms);
    }
    DECLARE_CLASS(UUTUIScene_MidGameMenu,UUTUIScene_Hud,0|CLASS_Config,UTGame)
	virtual void Tick( FLOAT DeltaTime );
	virtual UBOOL PreChildrenInputKey( INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed,UBOOL bGamepad);
};

struct UTUIScene_MOTD_eventFinish_Parms
{
    UTUIScene_MOTD_eventFinish_Parms(EEventParm)
    {
    }
};
class UUTUIScene_MOTD : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_MOTD
    BITFIELD bFadingOut:1;
    class UUISafeRegionPanel* Panel;
    class UUTDrawPanel* DrawPanel;
    //## END PROPS UTUIScene_MOTD

    void eventFinish()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_Finish),NULL);
    }
    DECLARE_CLASS(UUTUIScene_MOTD,UUTUIScene_Hud,0|CLASS_Config,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

struct UTUIScene_Scoreboard_eventTickScene_Parms
{
    FLOAT DeltaTime;
    UTUIScene_Scoreboard_eventTickScene_Parms(EEventParm)
    {
    }
};
class UUTUIScene_Scoreboard : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_Scoreboard
    class AUTPlayerController* Host;
    //## END PROPS UTUIScene_Scoreboard

    void eventTickScene(FLOAT DeltaTime)
    {
        UTUIScene_Scoreboard_eventTickScene_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UTGAME_TickScene),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUTUIScene_Scoreboard,UUTUIScene_Hud,0|CLASS_Config,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

struct UTUIScene_OnlineToast_eventFinishToast_Parms
{
    UTUIScene_OnlineToast_eventFinishToast_Parms(EEventParm)
    {
    }
};
class UUTUIScene_OnlineToast : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_OnlineToast
    class UUILabel* MessageLabel;
    FLOAT ShowStartTime;
    BITFIELD bFullyVisible:1;
    FLOAT ToastDuration;
    //## END PROPS UTUIScene_OnlineToast

    void eventFinishToast()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_FinishToast),NULL);
    }
    DECLARE_CLASS(UUTUIScene_OnlineToast,UUTUIScene,0|CLASS_Config,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

struct UTUIScene_SaveProfile_eventShutDown_Parms
{
    UTUIScene_SaveProfile_eventShutDown_Parms(EEventParm)
    {
    }
};
struct UTUIScene_SaveProfile_eventPerformSave_Parms
{
    UTUIScene_SaveProfile_eventPerformSave_Parms(EEventParm)
    {
    }
};
struct UTUIScene_SaveProfile_eventOnSaveFinished_Parms
{
    UTUIScene_SaveProfile_eventOnSaveFinished_Parms(EEventParm)
    {
    }
};
class UUTUIScene_SaveProfile : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_SaveProfile
    FLOAT OnScreenTime;
    INT PlayerIndexToSave;
    BITFIELD bProfileSaved:1;
    BITFIELD bShutdown:1;
    BITFIELD bUseTimedClose:1;
    FLOAT MinOnScreenTime;
    FScriptDelegate __OnSaveFinished__Delegate;
    //## END PROPS UTUIScene_SaveProfile

    void eventShutDown()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_ShutDown),NULL);
    }
    void eventPerformSave()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_PerformSave),NULL);
    }
    void delegateOnSaveFinished()
    {
        ProcessDelegate(UTGAME_OnSaveFinished,&__OnSaveFinished__Delegate,NULL);
    }
    DECLARE_CLASS(UUTUIScene_SaveProfile,UUTUIScene,0|CLASS_Config,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

class UUTUITabPage_MyContent : public UUTTabPage
{
public:
    //## BEGIN PROPS UTUITabPage_MyContent
    class UUIList* ContentList;
    class UUTUIScene_MessageBox* MessageBoxReference;
    //## END PROPS UTUITabPage_MyContent

    virtual void PerformDeleteContent(const FString& ContentName);
    virtual void ReloadContent();
    DECLARE_FUNCTION(execPerformDeleteContent)
    {
        P_GET_STR(ContentName);
        P_FINISH;
        PerformDeleteContent(ContentName);
    }
    DECLARE_FUNCTION(execReloadContent)
    {
        P_FINISH;
        ReloadContent();
    }
    DECLARE_CLASS(UUTUITabPage_MyContent,UUTTabPage,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUITabPage_MyContent)
};

class UUTUINumericEditBox : public UUINumericEditBox
{
public:
    //## BEGIN PROPS UTUINumericEditBox
    //## END PROPS UTUINumericEditBox

    DECLARE_CLASS(UUTUINumericEditBox,UUINumericEditBox,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUINumericEditBox)
};

class UUTUIEditBox : public UUIEditBox
{
public:
    //## BEGIN PROPS UTUIEditBox
    //## END PROPS UTUIEditBox

    DECLARE_CLASS(UUTUIEditBox,UUIEditBox,0|CLASS_Config,UTGame)
	/**
	* Perform all initialization for this widget. Called on all widgets when a scene is opened,
	* once the scene has been completely initialized.
	* For widgets added at runtime, called after the widget has been inserted into its parent's
	* list of children.
	*
	* @param	inOwnerScene	the scene to add this widget to.
	* @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	*							is being added to the scene's list of children.
	*/
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/** Saves the value for this subscriber. */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);
};

class UUTUIList : public UUIList
{
public:
    //## BEGIN PROPS UTUIList
    BITFIELD bAllowSaving:1;
    //## END PROPS UTUIList

    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_CLASS(UUTUIList,UUIList,0|CLASS_Config,UTGame)
	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Render this widget.  This version routes the render call to the draw components, if applicable.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUTUIMeshWidget : public UUIMeshWidget
{
public:
    //## BEGIN PROPS UTUIMeshWidget
    FVector RotationRate;
    class USkeletalMeshComponent* SkeletalMeshComp;
    class ULightComponent* DefaultLight;
    FVector LightDirection;
    class ULightComponent* DefaultLight2;
    FVector LightDirection2;
    FLOAT BaseHeight;
    //## END PROPS UTUIMeshWidget

    DECLARE_CLASS(UUTUIMeshWidget,UUIMeshWidget,0|CLASS_Config,UTGame)
	/* === UUIObject interface === */
	/**
	 * Updates 3D primitives for this widget.
	 *
	 * @param	CanvasScene		the scene to use for updating any 3D primitives
	 */
	virtual void UpdateWidgetPrimitives( FCanvasScene* CanvasScene );

	/* === UUIScreenObject interface === */
	/**
	 * Attach and initialize any 3D primitives for this widget and its children.
	 *
	 * @param	CanvasScene		the scene to use for attaching 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );
};

class UUTUISlider : public UUISlider
{
public:
    //## BEGIN PROPS UTUISlider
    //## END PROPS UTUISlider

    virtual void UpdateCaption();
    DECLARE_FUNCTION(execUpdateCaption)
    {
        P_FINISH;
        UpdateCaption();
    }
    DECLARE_CLASS(UUTUISlider,UUISlider,0|CLASS_Config,UTGame)
public:
	/**
	 * Initializes the button and creates the bar image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Render this slider.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called whenever the value of the slider is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @param	BindingIndex		indicates which data store binding should be modified.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);
};

class UUTUITabControl : public UUITabControl
{
public:
    //## BEGIN PROPS UTUITabControl
    FName DefaultTabWidgetTag;
    FName CalloutLabelStyleName;
    class UUILabel* PrevPageCalloutLabel;
    class UUILabel* NextPageCalloutLabel;
    //## END PROPS UTUITabControl

    DECLARE_CLASS(UUTUITabControl,UUITabControl,0|CLASS_Config,UTGame)
protected:
	/**
	 * Set up the docking links between the tab control, buttons, and pages, based on the TabDockFace.
	 */
	virtual void SetupDockingRelationships();

public:
	/**
	 * Sets focus to the child widget that is next in the specified direction in the navigation network within this widget.
	 *
	 * This version doesn't let forced navigation start targetting mode.
	 *
	 * @param	Sender		Control that called NavigateFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	Direction 		the direction to navigate focus.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player to set focus for.
	 * @param	bFocusChanged	TRUE if the focus was changed
	 *
	 * @return	TRUE if the navigation event was handled successfully.
	 */
	UBOOL NavigateFocus( UUIScreenObject* Sender, BYTE Direction, INT PlayerIndex=0, BYTE* bFocusChanged=NULL );
};

class UUTUI_Widget : public UUIObject
{
public:
    //## BEGIN PROPS UTUI_Widget
    BITFIELD bRequiresTick:1;
    class UUTUIScene* UTSceneOwner;
    //## END PROPS UTUI_Widget

    DECLARE_ABSTRACT_CLASS(UUTUI_Widget,UUIObject,0|CLASS_Config,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick_Widget(FLOAT DeltaTime){};
	virtual void PreRender_Widget(FCanvas* Canvas){};

	/**
	  * WARNING: This function does not check the destination and assumes it is valid.
	  *
	  * LookupProperty - Finds a property of a source actor and returns it's value.
	  *
	  * @param		SourceActor			The actor to search
	  * @param		SourceProperty		The property to look up
	  * @out param 	DestPtr				A Point to the storgage of the value
	  *
	  * @Returns true if the look up succeeded
	  */
	virtual UBOOL LookupProperty(AActor* SourceActor, FName SourceProperty, BYTE* DestPtr);

};

struct UTDrawPanel_eventDrawPanel_Parms
{
    UTDrawPanel_eventDrawPanel_Parms(EEventParm)
    {
    }
};
struct UTDrawPanel_eventDrawDelegate_Parms
{
    class UCanvas* C;
    UBOOL ReturnValue;
    UTDrawPanel_eventDrawDelegate_Parms(EEventParm)
    {
    }
};
class UUTDrawPanel : public UUTUI_Widget
{
public:
    //## BEGIN PROPS UTDrawPanel
    BITFIELD bUseFullViewport:1;
    class UCanvas* Canvas;
    FLOAT pLeft;
    FLOAT pTop;
    FLOAT pWidth;
    FLOAT pHeight;
    FLOAT ResolutionScale;
    FScriptDelegate __DrawDelegate__Delegate;
    //## END PROPS UTDrawPanel

    void Draw2DLine(INT X1,INT Y1,INT X2,INT Y2,FColor LineColor);
    DECLARE_FUNCTION(execDraw2DLine)
    {
        P_GET_INT(X1);
        P_GET_INT(Y1);
        P_GET_INT(X2);
        P_GET_INT(Y2);
        P_GET_STRUCT(FColor,LineColor);
        P_FINISH;
        Draw2DLine(X1,Y1,X2,Y2,LineColor);
    }
    void eventDrawPanel()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_DrawPanel),NULL);
    }
    UBOOL delegateDrawDelegate(class UCanvas* C)
    {
        UTDrawPanel_eventDrawDelegate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.C=C;
        ProcessDelegate(UTGAME_DrawDelegate,&__DrawDelegate__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTDrawPanel,UUTUI_Widget,0|CLASS_Config,UTGame)
	void PostRender_Widget(FCanvas* Canvas);
};

struct UTDrawPlayerListPanel_eventTick_Widget_Parms
{
    FLOAT DeltaTime;
    UTDrawPlayerListPanel_eventTick_Widget_Parms(EEventParm)
    {
    }
};
class UUTDrawPlayerListPanel : public UUTDrawPanel
{
public:
    //## BEGIN PROPS UTDrawPlayerListPanel
    class UFont* CaptionFont;
    class UFont* TextFont;
    BITFIELD bTeamMode:1;
    FColor TeamCaptionColors[2];
    FColor TeamTextColors[2];
    FLOAT FullHeight;
    FStringNoInit TeamCaptions[2];
    FStringNoInit Opponents;
    //## END PROPS UTDrawPlayerListPanel

    void eventTick_Widget(FLOAT DeltaTime)
    {
        UTDrawPlayerListPanel_eventTick_Widget_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UTGAME_Tick_Widget),&Parms);
    }
    DECLARE_CLASS(UUTDrawPlayerListPanel,UUTDrawPanel,0|CLASS_Config,UTGame)
	virtual void Tick_Widget(FLOAT DeltaTime);
};

struct FSimpleImageListData
{
    FName Tag;
    INT Count;
    INT ImageIndex;
    struct FTextureCoordinates UVs;
    FLOAT CurMultiplier;
    FLOAT Multipliers[2];
    FLOAT TransitionTime;
    FLOAT TransitionAlpha;
    FLOAT Bounds[4];
    BITFIELD bWasRendered:1;

    /** Constructors */
    FSimpleImageListData() {}
    FSimpleImageListData(EEventParm)
    {
        appMemzero(this, sizeof(FSimpleImageListData));
    }
};

struct UTSimpleImageList_eventOnSelectionChange_Parms
{
    class UUTSimpleImageList* SourceList;
    INT NewSelectedIndex;
    UTSimpleImageList_eventOnSelectionChange_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventOnItemChosen_Parms
{
    class UUTSimpleImageList* SourceList;
    INT SelectedIndex;
    INT PlayerIndex;
    UTSimpleImageList_eventOnItemChosen_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventOnDrawItem_Parms
{
    class UUTSimpleImageList* SimpleList;
    INT ItemIndex;
    FLOAT XPos;
    FLOAT YPos;
    UBOOL ReturnValue;
    UTSimpleImageList_eventOnDrawItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventGetItemScale_Parms
{
    INT ItemIdx;
    FLOAT SelectionPos;
    FLOAT ReturnValue;
    UTSimpleImageList_eventGetItemScale_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventSizeList_Parms
{
    UTSimpleImageList_eventSizeList_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventSelectItem_Parms
{
    INT NewSelection;
    UTSimpleImageList_eventSelectItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventEmpty_Parms
{
    UTSimpleImageList_eventEmpty_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventRemoveItem_Parms
{
    INT IndexToRemove;
    UTSimpleImageList_eventRemoveItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleImageList_eventAddItem_Parms
{
    FName NewTag;
    INT Count;
    INT NewImageIndex;
    struct FTextureCoordinates NewUVs;
    UTSimpleImageList_eventAddItem_Parms(EEventParm)
    {
    }
};
class UUTSimpleImageList : public UUTDrawPanel
{
public:
    //## BEGIN PROPS UTSimpleImageList
    TArrayNoInit<class UTexture2D*> ImageList;
    INT ItemCount;
    INT Selection;
    INT OldSelection;
    FLOAT DefaultCellWidth;
    FLOAT DefaultCellHeight;
    FLOAT Padding;
    FLOAT TransitionTime;
    FLOAT ResScale;
    TArrayNoInit<struct FSimpleImageListData> List;
    FLOAT WindowWidth;
    FLOAT ListWidthInPixel;
    INT BubbleRadius;
    BITFIELD bInvalidated:1;
    BITFIELD bTransitioning:1;
    FLOAT ListWidthInPixels;
    FLOAT LastMouseUpdate;
    FLOAT WindowLeft;
    FLOAT PaddingThisFrame;
    FLOAT SelectionModifier;
    FLOAT StartSelectionTime;
    FLOAT LastRenderTime;
    FLOAT SelectionAlpha;
    FLOAT WindowScaling;
    FScriptDelegate __OnDrawItem__Delegate;
    FScriptDelegate __OnItemChosen__Delegate;
    FScriptDelegate __OnSelectionChange__Delegate;
    //## END PROPS UTSimpleImageList

    virtual void UpdateAnimation(FLOAT DeltaTime);
    DECLARE_FUNCTION(execUpdateAnimation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateAnimation(DeltaTime);
    }
    void delegateOnSelectionChange(class UUTSimpleImageList* SourceList,INT NewSelectedIndex)
    {
        UTSimpleImageList_eventOnSelectionChange_Parms Parms(EC_EventParm);
        Parms.SourceList=SourceList;
        Parms.NewSelectedIndex=NewSelectedIndex;
        ProcessDelegate(UTGAME_OnSelectionChange,&__OnSelectionChange__Delegate,&Parms);
    }
    void delegateOnItemChosen(class UUTSimpleImageList* SourceList,INT SelectedIndex,INT PlayerIndex)
    {
        UTSimpleImageList_eventOnItemChosen_Parms Parms(EC_EventParm);
        Parms.SourceList=SourceList;
        Parms.SelectedIndex=SelectedIndex;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(UTGAME_OnItemChosen,&__OnItemChosen__Delegate,&Parms);
    }
    UBOOL delegateOnDrawItem(class UUTSimpleImageList* SimpleList,INT ItemIndex,FLOAT XPos,FLOAT& YPos)
    {
        UTSimpleImageList_eventOnDrawItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SimpleList=SimpleList;
        Parms.ItemIndex=ItemIndex;
        Parms.XPos=XPos;
        Parms.YPos=YPos;
        ProcessDelegate(UTGAME_OnDrawItem,&__OnDrawItem__Delegate,&Parms);
        YPos=Parms.YPos;
        return Parms.ReturnValue;
    }
    FLOAT eventGetItemScale(INT ItemIdx,FLOAT SelectionPos)
    {
        UTSimpleImageList_eventGetItemScale_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ItemIdx=ItemIdx;
        Parms.SelectionPos=SelectionPos;
        ProcessEvent(FindFunctionChecked(UTGAME_GetItemScale),&Parms);
        return Parms.ReturnValue;
    }
    void eventSizeList()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_SizeList),NULL);
    }
    void eventSelectItem(INT NewSelection)
    {
        UTSimpleImageList_eventSelectItem_Parms Parms(EC_EventParm);
        Parms.NewSelection=NewSelection;
        ProcessEvent(FindFunctionChecked(UTGAME_SelectItem),&Parms);
    }
    void eventEmpty()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_Empty),NULL);
    }
    void eventRemoveItem(INT IndexToRemove)
    {
        UTSimpleImageList_eventRemoveItem_Parms Parms(EC_EventParm);
        Parms.IndexToRemove=IndexToRemove;
        ProcessEvent(FindFunctionChecked(UTGAME_RemoveItem),&Parms);
    }
    void eventAddItem(FName NewTag,INT Count,INT NewImageIndex,struct FTextureCoordinates NewUVs)
    {
        UTSimpleImageList_eventAddItem_Parms Parms(EC_EventParm);
        Parms.NewTag=NewTag;
        Parms.Count=Count;
        Parms.NewImageIndex=NewImageIndex;
        Parms.NewUVs=NewUVs;
        ProcessEvent(FindFunctionChecked(UTGAME_AddItem),&Parms);
    }
    DECLARE_CLASS(UUTSimpleImageList,UUTDrawPanel,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTSimpleImageList)
};

struct FSimpleListData
{
    FStringNoInit Text;
    INT Tag;
    FLOAT CurHeightMultiplier;
    FLOAT TransitionAlpha;
    BITFIELD bWasRendered:1;

    /** Constructors */
    FSimpleListData() {}
    FSimpleListData(EEventParm)
    {
        appMemzero(this, sizeof(FSimpleListData));
    }
};

struct UTSimpleList_eventOnSelectionChange_Parms
{
    class UUTSimpleList* SourceList;
    INT NewSelectedIndex;
    UTSimpleList_eventOnSelectionChange_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventOnItemChosen_Parms
{
    class UUTSimpleList* SourceList;
    INT SelectedIndex;
    INT PlayerIndex;
    UTSimpleList_eventOnItemChosen_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventOnPostDrawSelectionBar_Parms
{
    class UUTSimpleList* SimpleList;
    FLOAT YPos;
    FLOAT Width;
    FLOAT Height;
    UBOOL ReturnValue;
    UTSimpleList_eventOnPostDrawSelectionBar_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventOnDrawSelectionBar_Parms
{
    class UUTSimpleList* SimpleList;
    FLOAT YPos;
    UBOOL ReturnValue;
    UTSimpleList_eventOnDrawSelectionBar_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventOnDrawItem_Parms
{
    class UUTSimpleList* SimpleList;
    INT ItemIndex;
    FLOAT XPos;
    FLOAT YPos;
    UBOOL ReturnValue;
    UTSimpleList_eventOnDrawItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventGetItemScale_Parms
{
    INT ItemIdx;
    FLOAT SelectionPosValue;
    FLOAT Alpha;
    FLOAT ReturnValue;
    UTSimpleList_eventGetItemScale_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventSizeList_Parms
{
    UTSimpleList_eventSizeList_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventSetItemSelectionIndex_Parms
{
    FLOAT SelectionIndex;
    UTSimpleList_eventSetItemSelectionIndex_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventRefreshBarPosition_Parms
{
    UTSimpleList_eventRefreshBarPosition_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventSelectItem_Parms
{
    INT NewSelection;
    UTSimpleList_eventSelectItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventEmpty_Parms
{
    UTSimpleList_eventEmpty_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventRemoveString_Parms
{
    FString TextToRemove;
    UTSimpleList_eventRemoveString_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventRemoveItem_Parms
{
    INT IndexToRemove;
    UTSimpleList_eventRemoveItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventInsertItem_Parms
{
    INT Index;
    FString Text;
    INT Tag;
    UTSimpleList_eventInsertItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventAddItem_Parms
{
    FString Text;
    INT Tag;
    UTSimpleList_eventAddItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventImportStringList_Parms
{
    TArray<FString> StringList;
    UTSimpleList_eventImportStringList_Parms(EEventParm)
    {
    }
};
class UUTSimpleList : public UUTDrawPanel
{
public:
    //## BEGIN PROPS UTSimpleList
    class UFont* TextFont;
    FColor NormalColor;
    FColor AboveBelowColor;
    FColor SelectedColor;
    FColor SelectionBarColor;
    FColor ArrowColor;
    class UTexture2D* SelectionImage;
    FLOAT SelectionImageIconBGU;
    FLOAT SelectionImageIconBGV;
    FLOAT SelectionImageIconBGUL;
    FLOAT SelectionImageIconBGVL;
    FLOAT SelectionImageBarU;
    FLOAT SelectionImageBarV;
    FLOAT SelectionImageBarUL;
    FLOAT SelectionImageBarVL;
    class UTexture2D* ArrowImage;
    FLOAT DefaultCellHeight;
    FLOAT AboveBelowCellHeightMultiplier;
    FLOAT SelectionCellHeightMultiplier;
    FLOAT TransitionTime;
    FLOAT ScrollWidthRatio;
    BITFIELD bHideScrollArrows:1;
    BITFIELD bHorizontalList:1;
    BITFIELD bWrapList:1;
    BITFIELD bHotTracking:1;
    BITFIELD bInvalidated:1;
    BITFIELD bTransitioning:1;
    BITFIELD bUpArrowPressed:1;
    BITFIELD bDownArrowPressed:1;
    BITFIELD bDragging:1;
    BITFIELD bIsMouseOverMenu:1;
    BITFIELD bIsUsingMouseNavigation:1;
    FVector2D NormalTextPadding;
    FVector2D NormalTextOffset;
    FVector2D SelectedTextPadding;
    FVector2D SelectedTextOffset;
    FLOAT ShadowDist;
    FColor ShadowColor;
    TArrayNoInit<struct FSimpleListData> List;
    INT Top;
    INT Selection;
    FLOAT SelectionPos;
    FLOAT OldSelection;
    INT BubbleRadius;
    FVector2D ResScaling;
    FLOAT LastRenderTime;
    FLOAT WindowTop;
    FLOAT WindowHeight;
    FLOAT ListHeightInPixel;
    FLOAT TargetWindowTop;
    FLOAT WindowTopTransitionTime;
    FLOAT UpArrowBounds[4];
    FLOAT DownArrowBounds[4];
    FLOAT StartSelectionTime;
    FLOAT SelectionAlpha;
    FLOAT OldBarPosition;
    FLOAT BarPosition;
    FLOAT DragAdjustment;
    FLOAT LastMouseUpdate;
    FScriptDelegate __OnDrawItem__Delegate;
    FScriptDelegate __OnDrawSelectionBar__Delegate;
    FScriptDelegate __OnPostDrawSelectionBar__Delegate;
    FScriptDelegate __OnItemChosen__Delegate;
    FScriptDelegate __OnSelectionChange__Delegate;
    //## END PROPS UTSimpleList

    virtual INT Find(const FString& SearchText);
    virtual INT FindTag(INT SearchTag);
    virtual void SortList();
    virtual void UpdateAnimation(FLOAT DeltaTime);
    DECLARE_FUNCTION(execFind)
    {
        P_GET_STR(SearchText);
        P_FINISH;
        *(INT*)Result=Find(SearchText);
    }
    DECLARE_FUNCTION(execFindTag)
    {
        P_GET_INT(SearchTag);
        P_FINISH;
        *(INT*)Result=FindTag(SearchTag);
    }
    DECLARE_FUNCTION(execSortList)
    {
        P_FINISH;
        SortList();
    }
    DECLARE_FUNCTION(execUpdateAnimation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateAnimation(DeltaTime);
    }
    void delegateOnSelectionChange(class UUTSimpleList* SourceList,INT NewSelectedIndex)
    {
        UTSimpleList_eventOnSelectionChange_Parms Parms(EC_EventParm);
        Parms.SourceList=SourceList;
        Parms.NewSelectedIndex=NewSelectedIndex;
        ProcessDelegate(UTGAME_OnSelectionChange,&__OnSelectionChange__Delegate,&Parms);
    }
    void delegateOnItemChosen(class UUTSimpleList* SourceList,INT SelectedIndex,INT PlayerIndex)
    {
        UTSimpleList_eventOnItemChosen_Parms Parms(EC_EventParm);
        Parms.SourceList=SourceList;
        Parms.SelectedIndex=SelectedIndex;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(UTGAME_OnItemChosen,&__OnItemChosen__Delegate,&Parms);
    }
    UBOOL delegateOnPostDrawSelectionBar(class UUTSimpleList* SimpleList,FLOAT YPos,FLOAT Width,FLOAT Height)
    {
        UTSimpleList_eventOnPostDrawSelectionBar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SimpleList=SimpleList;
        Parms.YPos=YPos;
        Parms.Width=Width;
        Parms.Height=Height;
        ProcessDelegate(UTGAME_OnPostDrawSelectionBar,&__OnPostDrawSelectionBar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnDrawSelectionBar(class UUTSimpleList* SimpleList,FLOAT YPos)
    {
        UTSimpleList_eventOnDrawSelectionBar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SimpleList=SimpleList;
        Parms.YPos=YPos;
        ProcessDelegate(UTGAME_OnDrawSelectionBar,&__OnDrawSelectionBar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnDrawItem(class UUTSimpleList* SimpleList,INT ItemIndex,FLOAT XPos,FLOAT& YPos)
    {
        UTSimpleList_eventOnDrawItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SimpleList=SimpleList;
        Parms.ItemIndex=ItemIndex;
        Parms.XPos=XPos;
        Parms.YPos=YPos;
        ProcessDelegate(UTGAME_OnDrawItem,&__OnDrawItem__Delegate,&Parms);
        YPos=Parms.YPos;
        return Parms.ReturnValue;
    }
    FLOAT eventGetItemScale(INT ItemIdx,FLOAT SelectionPosValue,FLOAT* Alpha=NULL)
    {
        UTSimpleList_eventGetItemScale_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ItemIdx=ItemIdx;
        Parms.SelectionPosValue=SelectionPosValue;
        if(Alpha){Parms.Alpha=*Alpha;}
        ProcessEvent(FindFunctionChecked(UTGAME_GetItemScale),&Parms);
        if ( Alpha ) { *Alpha=Parms.Alpha; }
        return Parms.ReturnValue;
    }
    void eventSizeList()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_SizeList),NULL);
    }
    void eventSetItemSelectionIndex(FLOAT SelectionIndex)
    {
        UTSimpleList_eventSetItemSelectionIndex_Parms Parms(EC_EventParm);
        Parms.SelectionIndex=SelectionIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_SetItemSelectionIndex),&Parms);
    }
    void eventRefreshBarPosition()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_RefreshBarPosition),NULL);
    }
    void eventSelectItem(INT NewSelection)
    {
        UTSimpleList_eventSelectItem_Parms Parms(EC_EventParm);
        Parms.NewSelection=NewSelection;
        ProcessEvent(FindFunctionChecked(UTGAME_SelectItem),&Parms);
    }
    void eventEmpty()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_Empty),NULL);
    }
    void eventRemoveString(const FString& TextToRemove)
    {
        UTSimpleList_eventRemoveString_Parms Parms(EC_EventParm);
        Parms.TextToRemove=TextToRemove;
        ProcessEvent(FindFunctionChecked(UTGAME_RemoveString),&Parms);
    }
    void eventRemoveItem(INT IndexToRemove)
    {
        UTSimpleList_eventRemoveItem_Parms Parms(EC_EventParm);
        Parms.IndexToRemove=IndexToRemove;
        ProcessEvent(FindFunctionChecked(UTGAME_RemoveItem),&Parms);
    }
    void eventInsertItem(INT Index,const FString& Text,INT Tag=-1)
    {
        UTSimpleList_eventInsertItem_Parms Parms(EC_EventParm);
        Parms.Index=Index;
        Parms.Text=Text;
        Parms.Tag=Tag;
        ProcessEvent(FindFunctionChecked(UTGAME_InsertItem),&Parms);
    }
    void eventAddItem(const FString& Text,INT Tag=-1)
    {
        UTSimpleList_eventAddItem_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        Parms.Tag=Tag;
        ProcessEvent(FindFunctionChecked(UTGAME_AddItem),&Parms);
    }
    void eventImportStringList(const TArray<FString>& StringList)
    {
        UTSimpleList_eventImportStringList_Parms Parms(EC_EventParm);
        Parms.StringList=StringList;
        ProcessEvent(FindFunctionChecked(UTGAME_ImportStringList),&Parms);
    }
    DECLARE_CLASS(UUTSimpleList,UUTDrawPanel,0|CLASS_Config,UTGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);


	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

};

struct UTUIMenuList_eventOnSubmitSelection_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    UTUIMenuList_eventOnSubmitSelection_Parms(EEventParm)
    {
    }
};
class UUTUIMenuList : public UUTSimpleList, public IUIDataStoreSubscriber
{
public:
    //## BEGIN PROPS UTUIMenuList
    struct FUIDataStoreBinding DataSource;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    struct FUIDataStoreBinding SelectedIndexDataSource;
    TArrayNoInit<INT> MenuListItems;
    BITFIELD bIsRotating:1;
    FLOAT StartRotationTime;
    FScriptDelegate __OnSubmitSelection__Delegate;
    //## END PROPS UTUIMenuList

    virtual void RegenerateOptions();
    UBOOL GetCellFieldValue(class UUIObject* InList,FName InCellTag,INT InListIndex,struct FUIProviderFieldValue& OutValue);
    INT FindCellFieldString(class UUIObject* InObject,FName InCellTag,const FString& FindValue,UBOOL bCaseSensitive=FALSE);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    DECLARE_FUNCTION(execRegenerateOptions)
    {
        P_FINISH;
        RegenerateOptions();
    }
    DECLARE_FUNCTION(execGetCellFieldValue)
    {
        P_GET_OBJECT(UUIObject,InList);
        P_GET_NAME(InCellTag);
        P_GET_INT(InListIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetCellFieldValue(InList,InCellTag,InListIndex,OutValue);
    }
    DECLARE_FUNCTION(execFindCellFieldString)
    {
        P_GET_OBJECT(UUIObject,InObject);
        P_GET_NAME(InCellTag);
        P_GET_STR(FindValue);
        P_GET_UBOOL_OPTX(bCaseSensitive,FALSE);
        P_FINISH;
        *(INT*)Result=FindCellFieldString(InObject,InCellTag,FindValue,bCaseSensitive);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    void delegateOnSubmitSelection(class UUIObject* Sender,INT PlayerIndex=0)
    {
        UTUIMenuList_eventOnSubmitSelection_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(UTGAME_OnSubmitSelection,&__OnSubmitSelection__Delegate,&Parms);
    }
    DECLARE_CLASS(UUTUIMenuList,UUTSimpleList,0|CLASS_Config,UTGame)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );


};

struct FWidgetAnimSequence
{
    FName Tag;
    FLOAT Rate;
    FLOAT StartValue;
    FLOAT EndValue;

    /** Constructors */
    FWidgetAnimSequence() {}
    FWidgetAnimSequence(EEventParm)
    {
        appMemzero(this, sizeof(FWidgetAnimSequence));
    }
};

struct FWidgetAnimation
{
    FName Tag;
    BYTE Property;
    BITFIELD bNotifyWhenFinished:1 GCC_BITFIELD_MAGIC;
    TArrayNoInit<struct FWidgetAnimSequence> Sequences;
    BITFIELD bIsPlaying:1;
    INT SeqIndex;
    FLOAT Time;
    FLOAT Value;

    /** Constructors */
    FWidgetAnimation() {}
    FWidgetAnimation(EEventParm)
    {
        appMemzero(this, sizeof(FWidgetAnimation));
    }
};

struct UTUI_HudWidget_eventPlayerOwnerIsSpectating_Parms
{
    UBOOL ReturnValue;
    UTUI_HudWidget_eventPlayerOwnerIsSpectating_Parms(EEventParm)
    {
    }
};
struct UTUI_HudWidget_eventSetOpacity_Parms
{
    FLOAT NewOpacity;
    UTUI_HudWidget_eventSetOpacity_Parms(EEventParm)
    {
    }
};
struct UTUI_HudWidget_eventWidgetTick_Parms
{
    FLOAT DeltaTime;
    UTUI_HudWidget_eventWidgetTick_Parms(EEventParm)
    {
    }
};
struct UTUI_HudWidget_eventFadeTo_Parms
{
    FLOAT NewOpacity;
    FLOAT NewFadeTime;
    UBOOL bTimeFromExtent;
    UTUI_HudWidget_eventFadeTo_Parms(EEventParm)
    {
    }
};
class UUTUI_HudWidget : public UUTUI_Widget
{
public:
    //## BEGIN PROPS UTUI_HudWidget
    class UUTUIScene_Hud* UTHudSceneOwner;
    FLOAT OpacityTarget;
    FLOAT OpacityTimer;
    BITFIELD bManualVisibility:1;
    BITFIELD bVisibleBeforeMatch:1;
    BITFIELD bVisibleDuringMatch:1;
    BITFIELD bVisibleAfterMatch:1;
    BITFIELD bVisibleWhileSpectating:1;
    TArrayNoInit<struct FWidgetAnimation> Animations;
    //## END PROPS UTUI_HudWidget

    virtual UBOOL PlayAnimation(FName AnimTag,FName SeqTag,UBOOL bForceBeginning=FALSE);
    virtual void StopAnimation(FName AnimTag,UBOOL bForceEnd=FALSE);
    DECLARE_FUNCTION(execPlayAnimation)
    {
        P_GET_NAME(AnimTag);
        P_GET_NAME(SeqTag);
        P_GET_UBOOL_OPTX(bForceBeginning,FALSE);
        P_FINISH;
        *(UBOOL*)Result=PlayAnimation(AnimTag,SeqTag,bForceBeginning);
    }
    DECLARE_FUNCTION(execStopAnimation)
    {
        P_GET_NAME(AnimTag);
        P_GET_UBOOL_OPTX(bForceEnd,FALSE);
        P_FINISH;
        StopAnimation(AnimTag,bForceEnd);
    }
    UBOOL eventPlayerOwnerIsSpectating()
    {
        UTUI_HudWidget_eventPlayerOwnerIsSpectating_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_PlayerOwnerIsSpectating),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetOpacity(FLOAT NewOpacity)
    {
        UTUI_HudWidget_eventSetOpacity_Parms Parms(EC_EventParm);
        Parms.NewOpacity=NewOpacity;
        ProcessEvent(FindFunctionChecked(UTGAME_SetOpacity),&Parms);
    }
    void eventWidgetTick(FLOAT DeltaTime)
    {
        UTUI_HudWidget_eventWidgetTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UTGAME_WidgetTick),&Parms);
    }
    void eventFadeTo(FLOAT NewOpacity,FLOAT NewFadeTime,UBOOL bTimeFromExtent=FALSE)
    {
        UTUI_HudWidget_eventFadeTo_Parms Parms(EC_EventParm);
        Parms.NewOpacity=NewOpacity;
        Parms.NewFadeTime=NewFadeTime;
        Parms.bTimeFromExtent=bTimeFromExtent ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_FadeTo),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUTUI_HudWidget,UUTUI_Widget,0|CLASS_Config,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick_Widget(FLOAT DeltaTime);
	virtual void UpdateAnimations(FLOAT DeltaTime);
};

#define UCONST_UTUIBUTTONBAR_BUTTON_SPACING -20
#define UCONST_UTUIBUTTONBAR_MAX_BUTTONS 6

class UUTUIButtonBar : public UUTUI_Widget
{
public:
    //## BEGIN PROPS UTUIButtonBar
    class UUTUIButtonBarButton* Buttons[6];
    //## END PROPS UTUIButtonBar

    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    DECLARE_CLASS(UUTUIButtonBar,UUTUI_Widget,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIButtonBar)
};

#define UCONST_UIKEY_MoveCursorRight UIKEY_MoveCursorRight
#define UCONST_UIKEY_MoveCursorLeft UIKEY_MoveCursorLeft

struct UTUIOptionButton_eventOnMoveSelectionRight_Parms
{
    INT PlayerIndex;
    UTUIOptionButton_eventOnMoveSelectionRight_Parms(EEventParm)
    {
    }
};
struct UTUIOptionButton_eventOnMoveSelectionLeft_Parms
{
    INT PlayerIndex;
    UTUIOptionButton_eventOnMoveSelectionLeft_Parms(EEventParm)
    {
    }
};
class UUTUIOptionButton : public UUTUI_Widget, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UTUIOptionButton
    class UUIButton* ArrowLeftButton;
    class UUIButton* ArrowRightButton;
    struct FUIStyleReference IncrementStyle;
    struct FUIStyleReference DecrementStyle;
    struct FUIScreenValue ButtonSpacing;
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawString* StringRenderComponent;
    INT CurrentIndex;
    FName IncrementCue;
    FName DecrementCue;
    BITFIELD bWrapOptions:1;
    BITFIELD bCustomPlacement:1;
    struct FUIDataStoreBinding DataSource;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    //## END PROPS UTUIOptionButton

    virtual UBOOL HasPrevValue();
    virtual UBOOL HasNextValue();
    virtual void SetPrevValue();
    virtual void SetNextValue();
    virtual INT GetCurrentIndex();
    virtual void SetCurrentIndex(INT NewIndex);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execHasPrevValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasPrevValue();
    }
    DECLARE_FUNCTION(execHasNextValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasNextValue();
    }
    DECLARE_FUNCTION(execSetPrevValue)
    {
        P_FINISH;
        SetPrevValue();
    }
    DECLARE_FUNCTION(execSetNextValue)
    {
        P_FINISH;
        SetNextValue();
    }
    DECLARE_FUNCTION(execGetCurrentIndex)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentIndex();
    }
    DECLARE_FUNCTION(execSetCurrentIndex)
    {
        P_GET_INT(NewIndex);
        P_FINISH;
        SetCurrentIndex(NewIndex);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    void eventOnMoveSelectionRight(INT PlayerIndex)
    {
        UTUIOptionButton_eventOnMoveSelectionRight_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_OnMoveSelectionRight),&Parms);
    }
    void eventOnMoveSelectionLeft(INT PlayerIndex)
    {
        UTUIOptionButton_eventOnMoveSelectionLeft_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_OnMoveSelectionLeft),&Parms);
    }
    DECLARE_CLASS(UUTUIOptionButton,UUTUI_Widget,0|CLASS_Config,UTGame)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIScreenObject interface === */

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Render this button.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Resolves DataSource into the list element provider that it references.
	 */
	void ResolveListElementProvider();

protected:
	/**
	 * Called when the option button's index has changed.
	 *
	 * @param	PreviousIndex	the list's Index before it was changed
	 * @param	PlayerIndex		the index of the player associated with this index change.
	 */
	void NotifyIndexChanged( INT PreviousIndex, INT PlayerIndex );

	/** @return Returns the number of possible values for the field we are bound to. */
	INT GetNumValues();

	/**
	 * @param ListIndex		List index to get the value of.
	 * @param OutValue	Storage string for the list value
	 *
	 * @return Returns TRUE if we were able to get a value, FALSE otherwise
	 */
	UBOOL GetListValue(INT ListIndex, FString &OutValue);

	/**
	 * Retrieves all values (along with their associated ids) for the collection this option button is bound to.
	 *
	 * @param	out_ValueCollection		receives the list of ids/strings contained in the collection this button is bound to
	 *
	 * @return	TRUE if the output value was successfully filled in (even if it's empty); FALSE if the button isn't bound or the data store
	 *			couldn't be resolved.
	 */
	UBOOL GetCollectionValues( TMap<INT,FString>& out_ValueCollection );

	/** Updates the string value using the current index. */
	void UpdateCurrentStringValue();

	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Handles input events for this button.
	 *
	 * @param	InState		State class to activate.
	 * @param	Arrow		Which arrow to activate the state for, LEFT is 0, RIGHT is 1.
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	void ActivateArrowState( UClass* InState, EOptionButtonArrow Arrow );

	/**
	 * Returns the current arrow state(Enabled or disabled) depending on whether or not the widget can shift left or right.
	 */
	UClass* GetArrowEnabledState(EOptionButtonArrow Arrow);

	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );
};

struct UTGameUISceneClient_eventFinishToast_Parms
{
    UTGameUISceneClient_eventFinishToast_Parms(EEventParm)
    {
    }
};
class UUTGameUISceneClient : public UGameUISceneClient
{
public:
    //## BEGIN PROPS UTGameUISceneClient
    BITFIELD bShowRenderTimes:1;
    BITFIELD bFirstFrame:1;
    BITFIELD bToastVisible:1;
    BITFIELD bHidingToast:1;
    BITFIELD bDimScreen:1;
    BITFIELD bPerformedMinSpecCheck:1;
    FLOAT PreRenderTime;
    FLOAT RenderTime;
    FLOAT TickTime;
    FLOAT AnimTime;
    FLOAT AvgTime;
    FLOAT AvgRenderTime;
    FLOAT FrameCount;
    FLOAT StringRenderTime;
    FStringNoInit MissionText;
    class UUTUIScene_SaveProfile* SaveProfileTemplate;
    FStringNoInit ToastMessage;
    FLOAT ShowStartTime;
    FLOAT HideStartTime;
    FLOAT ToastDuration;
    FLOAT ToastTransitionTime;
    class UFont* ToastFont;
    class UTexture2D* ToastImage;
    FLOAT ToastImageU;
    FLOAT ToastImageV;
    FLOAT ToastImageUL;
    FLOAT ToastImageVL;
    FLOAT ToastScale;
    FLinearColor ToastColor;
    FLinearColor ToastTextColor;
    FStringNoInit ScreenWarningMessage;
    FName LastModifierCardUsed;
    //## END PROPS UTGameUISceneClient

    class AWorldInfo* GetWorldInfo();
    virtual UBOOL IsInSeamlessTravel();
    virtual UBOOL IsUIAcceptingInput();
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    DECLARE_FUNCTION(execIsInSeamlessTravel)
    {
        P_FINISH;
        *(UBOOL*)Result=IsInSeamlessTravel();
    }
    DECLARE_FUNCTION(execIsUIAcceptingInput)
    {
        P_FINISH;
        *(UBOOL*)Result=IsUIAcceptingInput();
    }
    void eventFinishToast()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_FinishToast),NULL);
    }
    DECLARE_CLASS(UUTGameUISceneClient,UGameUISceneClient,0|CLASS_Transient|CLASS_Config,UTGame)
	/**
	 * Renders the UI toast.
	 *
	 * @param Canvas	Canvas to draw to.
	 */
	virtual void DrawUIToast(FCanvas* Canvas);

	/**
	 * Renders the screen warning message
	 *
	 * @param Canvas	Canvas to draw to.
	 */
	virtual void DrawScreenWarningMessage( FCanvas* Canvas );

	/**
	 * Render all the active scenes
	 */
	virtual void RenderScenes( FCanvas* Canvas );

	virtual void Render_Scene( FCanvas* Canvas, UUIScene* Scene, EUIPostProcessGroup UIPostProcessGroup );
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * We are going to override this and give UTUIScenes a chance at the input first
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

protected:

	/**
	 * Determines whether the any active scenes process axis input.
	 *
	 * @param	bProcessAxisInput	receives the flags for whether axis input is needed for each player.
	 */
	virtual void CheckAxisInputSupport( UBOOL* bProcessAxisInput[UCONST_MAX_SUPPORTED_GAMEPADS] ) const;
};

class UUTOfficialContent : public UObject
{
public:
    //## BEGIN PROPS UTOfficialContent
    TArrayNoInit<FString> OfficialMaps;
    TArrayNoInit<FString> OfficialPackages;
    //## END PROPS UTOfficialContent

    DECLARE_ABSTRACT_CLASS(UUTOfficialContent,UObject,0|CLASS_Transient,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTOfficialContent)
};

#endif // !INCLUDED_UTGAME_UI_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UUTDataStore_GameSearchBase,-1,execGetEnabledMutators);
AUTOGENERATE_FUNCTION(UUTDrawPanel,-1,execDraw2DLine);
AUTOGENERATE_FUNCTION(UUTGameInteraction,-1,execShouldProcessUIInput);
AUTOGENERATE_FUNCTION(UUTGameUISceneClient,-1,execIsUIAcceptingInput);
AUTOGENERATE_FUNCTION(UUTGameUISceneClient,-1,execIsInSeamlessTravel);
AUTOGENERATE_FUNCTION(UUTGameUISceneClient,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execTranslateBindToFont);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execDrawActorOverlays);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execDisplayWeaponBar);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execLinkToHudScene);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execDrawGlowText);
AUTOGENERATE_FUNCTION(UUTSimpleImageList,-1,execUpdateAnimation);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execUpdateAnimation);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execSortList);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execFindTag);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execFind);
AUTOGENERATE_FUNCTION(UUTUI_HudWidget,-1,execStopAnimation);
AUTOGENERATE_FUNCTION(UUTUI_HudWidget,-1,execPlayAnimation);
AUTOGENERATE_FUNCTION(UUTUIButtonBar,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUTUIButtonBarButton,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUTUICollectionCheckBox,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execSetupChildStyles);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_AvailableContent,-1,execParseContentString);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_AvailableContent,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_Character,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_InstalledContent,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_MapInfo,-1,execIsOfficialMap);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_Mutator,-1,execIsOfficialMutator);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_ServerDetails,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_ServerDetails,-1,execGetSearchResultsProvider);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_SimpleElementProvider,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsElementProvider,-1,execGetColumnName);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsElementProvider,-1,execGetColumnValue);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsGeneral,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsRewards,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsVehicles,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsVehicleWeapons,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StatsWeapons,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_StringArray,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetValueFromProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execFindValueInProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetAllResourceDataProviders);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execIsProviderFiltered);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUTUIDataStore_Options,-1,execGetSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_Options,-1,execAppendToSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_Options,-1,execClearSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasBindingsMap,-1,execClearBoundKeyCache);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasBindingsMap,-1,execAddMappingToBoundKeyCache);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasBindingsMap,-1,execFindMappingInBoundKeyCache);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasBindingsMap,-1,execGetBoundStringWithFieldName);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasBindingsMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execGetList);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execGetStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execFindStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execEmpty);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execRemoveStrByIndex);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execRemoveStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execInsertStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execAddStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execGetFieldIndex);
AUTOGENERATE_FUNCTION(UUTUIList,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execFindCellFieldString);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execGetCellFieldValue);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execRegenerateOptions);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetCurrentIndex);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execGetCurrentIndex);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetNextValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetPrevValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execHasNextValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execHasPrevValue);
AUTOGENERATE_FUNCTION(UUTUIResourceDataProvider,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execDeleteDemo);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execViewportDeProject);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execViewportProject);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execUpdateSplitscreenPlayers);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execActivateLevelEvent);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execTryCharacterUnlock);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execSetAudioDeviceToUse);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execIsBelowMinSpecs);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetCurrentAudioDevice);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPossibleAudioDevices);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPossibleScreenResolutions);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execStartDedicatedServer);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execIsGame);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPRIOwner);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPawnOwner);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetUTPlayerOwner);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execSetScreenResolution);
AUTOGENERATE_FUNCTION(UUTUIScene_DemoSell,-1,execSell);
AUTOGENERATE_FUNCTION(UUTUIScene_Hud,-1,execGetPlayerHud);
AUTOGENERATE_FUNCTION(UUTUIScene_InputBox,-1,execLayoutScene);
AUTOGENERATE_FUNCTION(UUTUIScene_MessageBox,-1,execBeginHide);
AUTOGENERATE_FUNCTION(UUTUIScene_MessageBox,-1,execBeginShow);
AUTOGENERATE_FUNCTION(UUTUISlider,-1,execUpdateCaption);
AUTOGENERATE_FUNCTION(UUTUITabPage_MyContent,-1,execReloadContent);
AUTOGENERATE_FUNCTION(UUTUITabPage_MyContent,-1,execPerformDeleteContent);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UTGAME_UI_NATIVE_DEFS
#define UTGAME_UI_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UTGame,UUIComp_DrawTeamColoredImage);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_UTDrawStateImage);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_UTGlowString);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_UTUIMenuListPresenter);
DECLARE_NATIVE_TYPE(UTGame,UUTDataStore_GameSearchBase);
DECLARE_NATIVE_TYPE(UTGame,UUTDrawPanel);
DECLARE_NATIVE_TYPE(UTGame,UUTDrawPlayerListPanel);
DECLARE_NATIVE_TYPE(UTGame,UUTGameInteraction);
DECLARE_NATIVE_TYPE(UTGame,UUTGameUISceneClient);
DECLARE_NATIVE_TYPE(UTGame,AUTHUD);
DECLARE_NATIVE_TYPE(UTGame,UUTOfficialContent);
DECLARE_NATIVE_TYPE(UTGame,UUTSimpleImageList);
DECLARE_NATIVE_TYPE(UTGame,UUTSimpleList);
DECLARE_NATIVE_TYPE(UTGame,UUTTabPage);
DECLARE_NATIVE_TYPE(UTGame,UUTUI_HudWidget);
DECLARE_NATIVE_TYPE(UTGame,UUTUI_Widget);
DECLARE_NATIVE_TYPE(UTGame,UUTUIButtonBar);
DECLARE_NATIVE_TYPE(UTGame,UUTUIButtonBarButton);
DECLARE_NATIVE_TYPE(UTGame,UUTUICollectionCheckBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIComboBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_AvailableContent);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_Character);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_CharacterFaction);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_CommunityMenuItem);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_DemoFile);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_GameModeInfo);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_InstalledContent);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_KeyBinding);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MainMenuItems);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MapInfo);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MenuOption);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MultiplayerMenuItem);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_Mutator);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_OnlineFriendMessages);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_OnlineFriends);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SearchResult);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_ServerDetails);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SettingsMenuItem);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SimpleElementProvider);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SimpleMenu);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StatsElementProvider);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StatsGeneral);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StatsRewards);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StatsVehicles);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StatsVehicleWeapons);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StatsWeapons);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_StringArray);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_Weapon);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_MenuItems);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_Options);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_StringAliasBindingsMap);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_StringAliasMap);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_StringList);
DECLARE_NATIVE_TYPE(UTGame,UUTUIEditBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIList);
DECLARE_NATIVE_TYPE(UTGame,UUTUIMenuList);
DECLARE_NATIVE_TYPE(UTGame,UUTUIMeshWidget);
DECLARE_NATIVE_TYPE(UTGame,UUTUINumericEditBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIOptionButton);
DECLARE_NATIVE_TYPE(UTGame,UUTUIResourceDataProvider);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_DemoSell);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_Hud);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_InputBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MapVote);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MessageBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MidGameMenu);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MOTD);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_OnlineToast);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_SaveProfile);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_Scoreboard);
DECLARE_NATIVE_TYPE(UTGame,UUTUISlider);
DECLARE_NATIVE_TYPE(UTGame,UUTUITabControl);
DECLARE_NATIVE_TYPE(UTGame,UUTUITabPage_MyContent);

#define AUTO_INITIALIZE_REGISTRANTS_UTGAME_UI \
	UUIComp_DrawTeamColoredImage::StaticClass(); \
	UUIComp_UTDrawStateImage::StaticClass(); \
	UUIComp_UTGlowString::StaticClass(); \
	UUIComp_UTUIMenuListPresenter::StaticClass(); \
	UUTDataStore_GameSearchBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTDataStore_GameSearchBaseNative; \
	UUTDrawPanel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTDrawPanelNative; \
	UUTDrawPlayerListPanel::StaticClass(); \
	UUTGameInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTGameInteractionNative; \
	UUTGameUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTGameUISceneClientNative; \
	AUTHUD::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameAUTHUDNative; \
	UUTOfficialContent::StaticClass(); \
	UUTSimpleImageList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTSimpleImageListNative; \
	UUTSimpleList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTSimpleListNative; \
	UUTTabPage::StaticClass(); \
	UUTUI_HudWidget::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUI_HudWidgetNative; \
	UUTUI_Widget::StaticClass(); \
	UUTUIButtonBar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIButtonBarNative; \
	UUTUIButtonBarButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIButtonBarButtonNative; \
	UUTUICollectionCheckBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUICollectionCheckBoxNative; \
	UUTUIComboBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIComboBoxNative; \
	UUTUIDataProvider_AvailableContent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_AvailableContentNative; \
	UUTUIDataProvider_Character::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_CharacterNative; \
	UUTUIDataProvider_CharacterFaction::StaticClass(); \
	UUTUIDataProvider_CommunityMenuItem::StaticClass(); \
	UUTUIDataProvider_DemoFile::StaticClass(); \
	UUTUIDataProvider_GameModeInfo::StaticClass(); \
	UUTUIDataProvider_InstalledContent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_InstalledContentNative; \
	UUTUIDataProvider_KeyBinding::StaticClass(); \
	UUTUIDataProvider_MainMenuItems::StaticClass(); \
	UUTUIDataProvider_MapInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_MapInfoNative; \
	UUTUIDataProvider_MenuOption::StaticClass(); \
	UUTUIDataProvider_MultiplayerMenuItem::StaticClass(); \
	UUTUIDataProvider_Mutator::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_MutatorNative; \
	UUTUIDataProvider_OnlineFriendMessages::StaticClass(); \
	UUTUIDataProvider_OnlineFriends::StaticClass(); \
	UUTUIDataProvider_SearchResult::StaticClass(); \
	UUTUIDataProvider_ServerDetails::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_ServerDetailsNative; \
	UUTUIDataProvider_SettingsMenuItem::StaticClass(); \
	UUTUIDataProvider_SimpleElementProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_SimpleElementProviderNative; \
	UUTUIDataProvider_SimpleMenu::StaticClass(); \
	UUTUIDataProvider_StatsElementProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StatsElementProviderNative; \
	UUTUIDataProvider_StatsGeneral::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StatsGeneralNative; \
	UUTUIDataProvider_StatsRewards::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StatsRewardsNative; \
	UUTUIDataProvider_StatsVehicles::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StatsVehiclesNative; \
	UUTUIDataProvider_StatsVehicleWeapons::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StatsVehicleWeaponsNative; \
	UUTUIDataProvider_StatsWeapons::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StatsWeaponsNative; \
	UUTUIDataProvider_StringArray::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_StringArrayNative; \
	UUTUIDataProvider_Weapon::StaticClass(); \
	UUTUIDataStore_MenuItems::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_MenuItemsNative; \
	UUTUIDataStore_Options::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_OptionsNative; \
	UUTUIDataStore_StringAliasBindingsMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_StringAliasBindingsMapNative; \
	UUTUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_StringAliasMapNative; \
	UUTUIDataStore_StringList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_StringListNative; \
	UUTUIEditBox::StaticClass(); \
	UUTUIList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIListNative; \
	UUTUIMenuList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIMenuListNative; \
	UUTUIMeshWidget::StaticClass(); \
	UUTUINumericEditBox::StaticClass(); \
	UUTUIOptionButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIOptionButtonNative; \
	UUTUIResourceDataProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIResourceDataProviderNative; \
	UUTUIScene::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUISceneNative; \
	UUTUIScene_DemoSell::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_DemoSellNative; \
	UUTUIScene_Hud::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_HudNative; \
	UUTUIScene_InputBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_InputBoxNative; \
	UUTUIScene_MapVote::StaticClass(); \
	UUTUIScene_MessageBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_MessageBoxNative; \
	UUTUIScene_MidGameMenu::StaticClass(); \
	UUTUIScene_MOTD::StaticClass(); \
	UUTUIScene_OnlineToast::StaticClass(); \
	UUTUIScene_SaveProfile::StaticClass(); \
	UUTUIScene_Scoreboard::StaticClass(); \
	UUTUISlider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUISliderNative; \
	UUTUITabControl::StaticClass(); \
	UUTUITabPage_MyContent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUITabPage_MyContentNative; \

#endif // UTGAME_UI_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UUTDataStore_GameSearchBase) GUTGameUUTDataStore_GameSearchBaseNatives[] = 
{ 
	MAP_NATIVE(UUTDataStore_GameSearchBase,execGetEnabledMutators)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTDataStore_GameSearchBase);

NATIVE_INFO(UUTDrawPanel) GUTGameUUTDrawPanelNatives[] = 
{ 
	MAP_NATIVE(UUTDrawPanel,execDraw2DLine)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTDrawPanel);

NATIVE_INFO(UUTGameInteraction) GUTGameUUTGameInteractionNatives[] = 
{ 
	MAP_NATIVE(UUTGameInteraction,execShouldProcessUIInput)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTGameInteraction);

NATIVE_INFO(UUTGameUISceneClient) GUTGameUUTGameUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UUTGameUISceneClient,execIsUIAcceptingInput)
	MAP_NATIVE(UUTGameUISceneClient,execIsInSeamlessTravel)
	MAP_NATIVE(UUTGameUISceneClient,execGetWorldInfo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTGameUISceneClient);

NATIVE_INFO(AUTHUD) GUTGameAUTHUDNatives[] = 
{ 
	MAP_NATIVE(AUTHUD,execTranslateBindToFont)
	MAP_NATIVE(AUTHUD,execDrawActorOverlays)
	MAP_NATIVE(AUTHUD,execDisplayWeaponBar)
	MAP_NATIVE(AUTHUD,execLinkToHudScene)
	MAP_NATIVE(AUTHUD,execDrawGlowText)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,AUTHUD);

NATIVE_INFO(UUTSimpleImageList) GUTGameUUTSimpleImageListNatives[] = 
{ 
	MAP_NATIVE(UUTSimpleImageList,execUpdateAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTSimpleImageList);

NATIVE_INFO(UUTSimpleList) GUTGameUUTSimpleListNatives[] = 
{ 
	MAP_NATIVE(UUTSimpleList,execUpdateAnimation)
	MAP_NATIVE(UUTSimpleList,execSortList)
	MAP_NATIVE(UUTSimpleList,execFindTag)
	MAP_NATIVE(UUTSimpleList,execFind)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTSimpleList);

NATIVE_INFO(UUTUI_HudWidget) GUTGameUUTUI_HudWidgetNatives[] = 
{ 
	MAP_NATIVE(UUTUI_HudWidget,execStopAnimation)
	MAP_NATIVE(UUTUI_HudWidget,execPlayAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUI_HudWidget);

NATIVE_INFO(UUTUIButtonBar) GUTGameUUTUIButtonBarNatives[] = 
{ 
	MAP_NATIVE(UUTUIButtonBar,execCanAcceptFocus)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIButtonBar);

NATIVE_INFO(UUTUIButtonBarButton) GUTGameUUTUIButtonBarButtonNatives[] = 
{ 
	MAP_NATIVE(UUTUIButtonBarButton,execCanAcceptFocus)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIButtonBarButton);

NATIVE_INFO(UUTUICollectionCheckBox) GUTGameUUTUICollectionCheckBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUICollectionCheckBox,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUICollectionCheckBox);

NATIVE_INFO(UUTUIComboBox) GUTGameUUTUIComboBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUIComboBox,execSetupChildStyles)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIComboBox);

NATIVE_INFO(UUTUIDataProvider_AvailableContent) GUTGameUUTUIDataProvider_AvailableContentNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_AvailableContent,execParseContentString)
	MAP_NATIVE(UUTUIDataProvider_AvailableContent,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_AvailableContent);

NATIVE_INFO(UUTUIDataProvider_Character) GUTGameUUTUIDataProvider_CharacterNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_Character,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_Character);

NATIVE_INFO(UUTUIDataProvider_InstalledContent) GUTGameUUTUIDataProvider_InstalledContentNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_InstalledContent,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_InstalledContent);

NATIVE_INFO(UUTUIDataProvider_MapInfo) GUTGameUUTUIDataProvider_MapInfoNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_MapInfo,execIsOfficialMap)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_MapInfo);

NATIVE_INFO(UUTUIDataProvider_Mutator) GUTGameUUTUIDataProvider_MutatorNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_Mutator,execIsOfficialMutator)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_Mutator);

NATIVE_INFO(UUTUIDataProvider_ServerDetails) GUTGameUUTUIDataProvider_ServerDetailsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_ServerDetails,execGetElementCount)
	MAP_NATIVE(UUTUIDataProvider_ServerDetails,execGetSearchResultsProvider)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_ServerDetails);

NATIVE_INFO(UUTUIDataProvider_SimpleElementProvider) GUTGameUUTUIDataProvider_SimpleElementProviderNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_SimpleElementProvider,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_SimpleElementProvider);

NATIVE_INFO(UUTUIDataProvider_StatsElementProvider) GUTGameUUTUIDataProvider_StatsElementProviderNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StatsElementProvider,execGetColumnName)
	MAP_NATIVE(UUTUIDataProvider_StatsElementProvider,execGetColumnValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StatsElementProvider);

NATIVE_INFO(UUTUIDataProvider_StatsGeneral) GUTGameUUTUIDataProvider_StatsGeneralNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StatsGeneral,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StatsGeneral);

NATIVE_INFO(UUTUIDataProvider_StatsRewards) GUTGameUUTUIDataProvider_StatsRewardsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StatsRewards,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StatsRewards);

NATIVE_INFO(UUTUIDataProvider_StatsVehicles) GUTGameUUTUIDataProvider_StatsVehiclesNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StatsVehicles,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StatsVehicles);

NATIVE_INFO(UUTUIDataProvider_StatsVehicleWeapons) GUTGameUUTUIDataProvider_StatsVehicleWeaponsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StatsVehicleWeapons,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StatsVehicleWeapons);

NATIVE_INFO(UUTUIDataProvider_StatsWeapons) GUTGameUUTUIDataProvider_StatsWeaponsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StatsWeapons,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StatsWeapons);

NATIVE_INFO(UUTUIDataProvider_StringArray) GUTGameUUTUIDataProvider_StringArrayNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_StringArray,execGetElementCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_StringArray);

NATIVE_INFO(UUTUIDataStore_MenuItems) GUTGameUUTUIDataStore_MenuItemsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetProviderSet)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetValueFromProviderSet)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execFindValueInProviderSet)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetAllResourceDataProviders)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execIsProviderFiltered)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetProviderCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_MenuItems);

NATIVE_INFO(UUTUIDataStore_Options) GUTGameUUTUIDataStore_OptionsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_Options,execGetSet)
	MAP_NATIVE(UUTUIDataStore_Options,execAppendToSet)
	MAP_NATIVE(UUTUIDataStore_Options,execClearSet)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_Options);

NATIVE_INFO(UUTUIDataStore_StringAliasBindingsMap) GUTGameUUTUIDataStore_StringAliasBindingsMapNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_StringAliasBindingsMap,execClearBoundKeyCache)
	MAP_NATIVE(UUTUIDataStore_StringAliasBindingsMap,execAddMappingToBoundKeyCache)
	MAP_NATIVE(UUTUIDataStore_StringAliasBindingsMap,execFindMappingInBoundKeyCache)
	MAP_NATIVE(UUTUIDataStore_StringAliasBindingsMap,execGetBoundStringWithFieldName)
	MAP_NATIVE(UUTUIDataStore_StringAliasBindingsMap,execGetStringWithFieldName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_StringAliasBindingsMap);

NATIVE_INFO(UUTUIDataStore_StringAliasMap) GUTGameUUTUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_StringAliasMap,execGetStringWithFieldName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_StringAliasMap);

NATIVE_INFO(UUTUIDataStore_StringList) GUTGameUUTUIDataStore_StringListNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_StringList,execGetList)
	MAP_NATIVE(UUTUIDataStore_StringList,execGetStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execFindStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execEmpty)
	MAP_NATIVE(UUTUIDataStore_StringList,execRemoveStrByIndex)
	MAP_NATIVE(UUTUIDataStore_StringList,execRemoveStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execInsertStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execAddStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execGetFieldIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_StringList);

NATIVE_INFO(UUTUIList) GUTGameUUTUIListNatives[] = 
{ 
	MAP_NATIVE(UUTUIList,execSaveSubscriberValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIList);

NATIVE_INFO(UUTUIMenuList) GUTGameUUTUIMenuListNatives[] = 
{ 
	MAP_NATIVE(UUTUIMenuList,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUTUIMenuList,execClearBoundDataStores)
	MAP_NATIVE(UUTUIMenuList,execGetBoundDataStores)
	MAP_NATIVE(UUTUIMenuList,execRefreshSubscriberValue)
	MAP_NATIVE(UUTUIMenuList,execGetDataStoreBinding)
	MAP_NATIVE(UUTUIMenuList,execSetDataStoreBinding)
	MAP_NATIVE(UUTUIMenuList,execFindCellFieldString)
	MAP_NATIVE(UUTUIMenuList,execGetCellFieldValue)
	MAP_NATIVE(UUTUIMenuList,execRegenerateOptions)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIMenuList);

NATIVE_INFO(UUTUIOptionButton) GUTGameUUTUIOptionButtonNatives[] = 
{ 
	MAP_NATIVE(UUTUIOptionButton,execSaveSubscriberValue)
	MAP_NATIVE(UUTUIOptionButton,execClearBoundDataStores)
	MAP_NATIVE(UUTUIOptionButton,execGetBoundDataStores)
	MAP_NATIVE(UUTUIOptionButton,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUTUIOptionButton,execRefreshSubscriberValue)
	MAP_NATIVE(UUTUIOptionButton,execGetDataStoreBinding)
	MAP_NATIVE(UUTUIOptionButton,execSetDataStoreBinding)
	MAP_NATIVE(UUTUIOptionButton,execSetCurrentIndex)
	MAP_NATIVE(UUTUIOptionButton,execGetCurrentIndex)
	MAP_NATIVE(UUTUIOptionButton,execSetNextValue)
	MAP_NATIVE(UUTUIOptionButton,execSetPrevValue)
	MAP_NATIVE(UUTUIOptionButton,execHasNextValue)
	MAP_NATIVE(UUTUIOptionButton,execHasPrevValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIOptionButton);

NATIVE_INFO(UUTUIResourceDataProvider) GUTGameUUTUIResourceDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUTUIResourceDataProvider,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIResourceDataProvider);

NATIVE_INFO(UUTUIScene) GUTGameUUTUISceneNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene,execDeleteDemo)
	MAP_NATIVE(UUTUIScene,execViewportDeProject)
	MAP_NATIVE(UUTUIScene,execViewportProject)
	MAP_NATIVE(UUTUIScene,execUpdateSplitscreenPlayers)
	MAP_NATIVE(UUTUIScene,execActivateLevelEvent)
	MAP_NATIVE(UUTUIScene,execTryCharacterUnlock)
	MAP_NATIVE(UUTUIScene,execSetAudioDeviceToUse)
	MAP_NATIVE(UUTUIScene,execIsBelowMinSpecs)
	MAP_NATIVE(UUTUIScene,execGetCurrentAudioDevice)
	MAP_NATIVE(UUTUIScene,execGetPossibleAudioDevices)
	MAP_NATIVE(UUTUIScene,execGetPossibleScreenResolutions)
	MAP_NATIVE(UUTUIScene,execStartDedicatedServer)
	MAP_NATIVE(UUTUIScene,execIsGame)
	MAP_NATIVE(UUTUIScene,execGetPRIOwner)
	MAP_NATIVE(UUTUIScene,execGetPawnOwner)
	MAP_NATIVE(UUTUIScene,execGetUTPlayerOwner)
	MAP_NATIVE(UUTUIScene,execSetScreenResolution)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene);

NATIVE_INFO(UUTUIScene_DemoSell) GUTGameUUTUIScene_DemoSellNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_DemoSell,execSell)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_DemoSell);

NATIVE_INFO(UUTUIScene_Hud) GUTGameUUTUIScene_HudNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_Hud,execGetPlayerHud)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_Hud);

NATIVE_INFO(UUTUIScene_InputBox) GUTGameUUTUIScene_InputBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_InputBox,execLayoutScene)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_InputBox);

NATIVE_INFO(UUTUIScene_MessageBox) GUTGameUUTUIScene_MessageBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_MessageBox,execBeginHide)
	MAP_NATIVE(UUTUIScene_MessageBox,execBeginShow)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_MessageBox);

NATIVE_INFO(UUTUISlider) GUTGameUUTUISliderNatives[] = 
{ 
	MAP_NATIVE(UUTUISlider,execUpdateCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUISlider);

NATIVE_INFO(UUTUITabPage_MyContent) GUTGameUUTUITabPage_MyContentNatives[] = 
{ 
	MAP_NATIVE(UUTUITabPage_MyContent,execReloadContent)
	MAP_NATIVE(UUTUITabPage_MyContent,execPerformDeleteContent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUITabPage_MyContent);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawTeamColoredImage,TeamColors)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawTeamColoredImage,EditorTeamIndex)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawTeamColoredImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTDrawStateImage,ImageState)
VERIFY_CLASS_SIZE_NODIE(UUIComp_UTDrawStateImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTGlowString,GlowStyle)
VERIFY_CLASS_SIZE_NODIE(UUIComp_UTGlowString)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTUIMenuListPresenter,SelectedItemHeight)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTUIMenuListPresenter,InstancedPrefabs)
VERIFY_CLASS_SIZE_NODIE(UUIComp_UTUIMenuListPresenter)
VERIFY_CLASS_OFFSET_NODIE(U,UTDataStore_GameSearchBase,ServerDetailsProvider)
VERIFY_CLASS_SIZE_NODIE(UUTDataStore_GameSearchBase)
VERIFY_CLASS_OFFSET_NODIE(U,UTDrawPanel,Canvas)
VERIFY_CLASS_OFFSET_NODIE(U,UTDrawPanel,__DrawDelegate__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTDrawPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UTDrawPlayerListPanel,CaptionFont)
VERIFY_CLASS_OFFSET_NODIE(U,UTDrawPlayerListPanel,Opponents)
VERIFY_CLASS_SIZE_NODIE(UUTDrawPlayerListPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UTGameInteraction,BlockUIInputSemaphore)
VERIFY_CLASS_SIZE_NODIE(UUTGameInteraction)
VERIFY_CLASS_OFFSET_NODIE(U,UTGameUISceneClient,PreRenderTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTGameUISceneClient,LastModifierCardUsed)
VERIFY_CLASS_SIZE_NODIE(UUTGameUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(A,UTHUD,WeaponSwitchMessage)
VERIFY_CLASS_OFFSET_NODIE(A,UTHUD,BkgTexColor)
VERIFY_CLASS_SIZE_NODIE(AUTHUD)
VERIFY_CLASS_OFFSET_NODIE(U,UTOfficialContent,OfficialMaps)
VERIFY_CLASS_OFFSET_NODIE(U,UTOfficialContent,OfficialPackages)
VERIFY_CLASS_SIZE_NODIE(UUTOfficialContent)
VERIFY_CLASS_OFFSET_NODIE(U,UTSimpleImageList,ImageList)
VERIFY_CLASS_OFFSET_NODIE(U,UTSimpleImageList,__OnSelectionChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTSimpleImageList)
VERIFY_CLASS_OFFSET_NODIE(U,UTSimpleList,TextFont)
VERIFY_CLASS_OFFSET_NODIE(U,UTSimpleList,__OnSelectionChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTSimpleList)
VERIFY_CLASS_OFFSET_NODIE(U,UTTabPage,__OnTick__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTTabPage)
VERIFY_CLASS_OFFSET_NODIE(U,UTUI_HudWidget,UTHudSceneOwner)
VERIFY_CLASS_OFFSET_NODIE(U,UTUI_HudWidget,Animations)
VERIFY_CLASS_SIZE_NODIE(UUTUI_HudWidget)
VERIFY_CLASS_OFFSET_NODIE(U,UTUI_Widget,UTSceneOwner)
VERIFY_CLASS_SIZE_NODIE(UUTUI_Widget)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIButtonBar,Buttons)
VERIFY_CLASS_SIZE_NODIE(UUTUIButtonBar)
VERIFY_CLASS_SIZE_NODIE(UUTUIButtonBarButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUICollectionCheckBox,DataProvider)
VERIFY_CLASS_SIZE_NODIE(UUTUICollectionCheckBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIComboBox,ToggleButtonStyleName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIComboBox,ListBackgroundStyleName)
VERIFY_CLASS_SIZE_NODIE(UUTUIComboBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_AvailableContent,Packages)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_AvailableContent)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Character,CustomData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_Character)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CharacterFaction,CustomData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_CharacterFaction)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CommunityMenuItem,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CommunityMenuItem,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_CommunityMenuItem)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_DemoFile,Filename)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_DemoFile)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_GameModeInfo,GameMode)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_GameModeInfo,IconVL)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_GameModeInfo)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_InstalledContent)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_KeyBinding,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_KeyBinding,Command)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_KeyBinding)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MainMenuItems,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MainMenuItems,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MainMenuItems)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MapInfo,MapId)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MapInfo,PreviewImageMarkup)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MapInfo)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MenuOption,OptionType)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MenuOption,RangeData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MenuOption)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MultiplayerMenuItem,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MultiplayerMenuItem,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MultiplayerMenuItem)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Mutator,ClassName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Mutator,SupportedGameTypes)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_Mutator)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_OnlineFriendMessages)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_OnlineFriends)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SearchResult,PlayerRatioTag)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SearchResult,IconFontPathName)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SearchResult)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_ServerDetails,SearchResultsRow)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_ServerDetails)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SettingsMenuItem,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SettingsMenuItem,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SettingsMenuItem)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SimpleElementProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SimpleMenu,FieldName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SimpleMenu,Options)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SimpleMenu)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_StatsElementProvider,ReadObject)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StatsElementProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_StatsGeneral,Stats)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StatsGeneral)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StatsRewards)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_StatsVehicles,Stats)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StatsVehicles)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_StatsVehicleWeapons,Stats)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StatsVehicleWeapons)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_StatsWeapons,Stats)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StatsWeapons)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_StringArray,Strings)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_StringArray)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Weapon,ClassName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Weapon,MeshReference)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_Weapon)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_MenuItems,EnabledMutators)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_MenuItems,GameModeFilter)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_MenuItems)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_Options,OptionProviders)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_Options,DynamicProviders)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_Options)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_StringAliasBindingsMap,FakePlatform)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_StringAliasBindingsMap,ControllerMapArray)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_StringAliasBindingsMap)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_StringAliasMap,FakePlatform)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_StringAliasMap)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_StringList,StringData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_StringList)
VERIFY_CLASS_SIZE_NODIE(UUTUIEditBox)
VERIFY_CLASS_SIZE_NODIE(UUTUIList)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIMenuList,DataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIMenuList,__OnSubmitSelection__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIMenuList)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIMeshWidget,RotationRate)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIMeshWidget,BaseHeight)
VERIFY_CLASS_SIZE_NODIE(UUTUIMeshWidget)
VERIFY_CLASS_SIZE_NODIE(UUTUINumericEditBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIOptionButton,ArrowLeftButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIOptionButton,DataProvider)
VERIFY_CLASS_SIZE_NODIE(UUTUIOptionButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIResourceDataProvider,IniName)
VERIFY_CLASS_SIZE_NODIE(UUTUIResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene,MessageBoxScene)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene,__OnSceneOpened__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_DemoSell,SellButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_DemoSell,ExitButton)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_DemoSell)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_Hud)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_InputBox,InputEditbox)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_InputBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MapVote,MapList)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MapVote,VoteRI)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MapVote)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MessageBox,MessageLabel)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MessageBox,__OnMBInputKey__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MessageBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MidGameMenu,ButtonBar)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MidGameMenu,MBScene)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MidGameMenu)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MOTD,Panel)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MOTD,DrawPanel)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MOTD)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_OnlineToast,MessageLabel)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_OnlineToast,ToastDuration)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_OnlineToast)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_SaveProfile,OnScreenTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_SaveProfile,__OnSaveFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_SaveProfile)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_Scoreboard,Host)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_Scoreboard)
VERIFY_CLASS_SIZE_NODIE(UUTUISlider)
VERIFY_CLASS_OFFSET_NODIE(U,UTUITabControl,DefaultTabWidgetTag)
VERIFY_CLASS_OFFSET_NODIE(U,UTUITabControl,NextPageCalloutLabel)
VERIFY_CLASS_SIZE_NODIE(UUTUITabControl)
VERIFY_CLASS_OFFSET_NODIE(U,UTUITabPage_MyContent,ContentList)
VERIFY_CLASS_OFFSET_NODIE(U,UTUITabPage_MyContent,MessageBoxReference)
VERIFY_CLASS_SIZE_NODIE(UUTUITabPage_MyContent)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
