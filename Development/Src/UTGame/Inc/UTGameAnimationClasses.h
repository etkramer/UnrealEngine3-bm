/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UTGAME_ANIMATION_ENUMS
#define INCLUDED_UTGAME_ANIMATION_ENUMS 1

enum EBlendFallTypes
{
    FBT_Up                  =0,
    FBT_Down                =1,
    FBT_PreLand             =2,
    FBT_Land                =3,
    FBT_DblJumpUp           =4,
    FBT_DblJumpDown         =5,
    FBT_DblJumpPreLand      =6,
    FBT_DblJumpLand         =7,
    FBT_None                =8,
    FBT_MAX                 =9,
};
enum EFlyingState
{
    Flying_NotFlying        =0,
    Flying_OpeningWings     =1,
    Flying_Flying           =2,
    Flying_ClosingWings     =3,
    Flying_MAX              =4,
};

#endif // !INCLUDED_UTGAME_ANIMATION_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UTGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AnimStopFire)
AUTOGENERATE_NAME(BreakApart)
AUTOGENERATE_NAME(BreakApartOnDeath)
AUTOGENERATE_NAME(EntireBeamVelocity)
AUTOGENERATE_NAME(PhysicsVolumeChanged)
AUTOGENERATE_NAME(RestorePart)

#ifndef NAMES_ONLY

#ifndef INCLUDED_UTGAME_ANIMATION_CLASSES
#define INCLUDED_UTGAME_ANIMATION_CLASSES 1

class UUTAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
    //## BEGIN PROPS UTAnimNodeJumpLeanOffset
    FLOAT JumpLeanStrength;
    FLOAT MaxLeanChangeSpeed;
    BITFIELD bMultiplyByZVelocity:1;
    BITFIELD bDodging:1;
    BITFIELD bOldDodging:1;
    BITFIELD bDoubleJumping:1;
    BITFIELD bOldDoubleJumping:1;
    class UAnimNodeAimOffset* CachedAimNode;
    FName OldAimProfileName;
    FVector2D PreBlendAim;
    FLOAT LeanWeight;
    FLOAT LeanWeightTarget;
    FLOAT BlendTimeToGo;
    //## END PROPS UTAnimNodeJumpLeanOffset

    void SetLeanWeight(FLOAT WeightTarget,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetLeanWeight)
    {
        P_GET_FLOAT(WeightTarget);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        SetLeanWeight(WeightTarget,BlendTime);
    }
    DECLARE_CLASS(UUTAnimNodeJumpLeanOffset,UAnimNodeAimOffset,0,UTGame)
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );	
};

class UUTAnimBlendBySlotActive : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendBySlotActive
    class UAnimNodeSlot* ChildSlot;
    //## END PROPS UTAnimBlendBySlotActive

    DECLARE_CLASS(UUTAnimBlendBySlotActive,UAnimNodeBlendPerBone,0,UTGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

struct UTAnimBlendByWeapon_eventAnimStopFire_Parms
{
    FLOAT SpecialBlendTime;
    UTAnimBlendByWeapon_eventAnimStopFire_Parms(EEventParm)
    {
    }
};
class UUTAnimBlendByWeapon : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendByWeapon
    BITFIELD bLooping:1;
    FName LoopingAnim;
    FLOAT BlendTime;
    //## END PROPS UTAnimBlendByWeapon

    void eventAnimStopFire(FLOAT SpecialBlendTime=0)
    {
        UTAnimBlendByWeapon_eventAnimStopFire_Parms Parms(EC_EventParm);
        Parms.SpecialBlendTime=SpecialBlendTime;
        ProcessEvent(FindFunctionChecked(UTGAME_AnimStopFire),&Parms);
    }
    DECLARE_CLASS(UUTAnimBlendByWeapon,UAnimNodeBlendPerBone,0,UTGame)
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUTAnimBlendByWeapType : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendByWeapType
    //## END PROPS UTAnimBlendByWeapType

    DECLARE_CLASS(UUTAnimBlendByWeapType,UAnimNodeBlendPerBone,0,UTGame)
	void WeapTypeChanged(FName NewAimProfileName);
};

class UUTAnimBlendByDriving : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS UTAnimBlendByDriving
    //## END PROPS UTAnimBlendByDriving

    virtual void UpdateDrivingState();
    DECLARE_FUNCTION(execUpdateDrivingState)
    {
        P_FINISH;
        UpdateDrivingState();
    }
    DECLARE_CLASS(UUTAnimBlendByDriving,UAnimNodeBlend,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendBySpeed : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS UTAnimBlendBySpeed
    FLOAT MinSpeed;
    FLOAT MaxSpeed;
    //## END PROPS UTAnimBlendBySpeed

    DECLARE_CLASS(UUTAnimBlendBySpeed,UAnimNodeBlend,0,UTGame)
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UUTAnimBlendBase : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS UTAnimBlendBase
    FLOAT BlendTime;
    TArrayNoInit<FLOAT> ChildBlendTimes;
    //## END PROPS UTAnimBlendBase

    FLOAT GetBlendTime(INT ChildIndex,UBOOL bGetDefault=FALSE);
    FLOAT GetAnimDuration(INT ChildIndex);
    DECLARE_FUNCTION(execGetBlendTime)
    {
        P_GET_INT(ChildIndex);
        P_GET_UBOOL_OPTX(bGetDefault,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetBlendTime(ChildIndex,bGetDefault);
    }
    DECLARE_FUNCTION(execGetAnimDuration)
    {
        P_GET_INT(ChildIndex);
        P_FINISH;
        *(FLOAT*)Result=GetAnimDuration(ChildIndex);
    }
    DECLARE_CLASS(UUTAnimBlendBase,UAnimNodeBlendList,0,UTGame)
	// AnimTree editor interface
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
};

class UUTAnimBlendByFall : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByFall
    BITFIELD bIgnoreDoubleJumps:1;
    BITFIELD bDidDoubleJump:1;
    BITFIELD bDodgeFall:1;
    FLOAT PreLandTime;
    FLOAT PreLandStartUprightTime;
    FLOAT ToDblJumpUprightTime;
    BYTE FallState;
    FLOAT LastFallingVelocity;
    class UUTAnimNodeJumpLeanOffset* CachedLeanNode;
    //## END PROPS UTAnimBlendByFall

    DECLARE_CLASS(UUTAnimBlendByFall,UUTAnimBlendBase,0,UTGame)
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
	virtual void ChangeFallState(EBlendFallTypes NewState);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void RenameChildConnectors();
};

class UUTAnimBlendByHoverJump : public UUTAnimBlendByFall
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverJump
    class APawn* OwnerP;
    class AUTHoverVehicle* OwnerHV;
    //## END PROPS UTAnimBlendByHoverJump

    DECLARE_CLASS(UUTAnimBlendByHoverJump,UUTAnimBlendByFall,0,UTGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendByFlying : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByFlying
    BYTE FlyingState;
    class AUTPawn* Pawn;
    class UUTAnimBlendBase* FlyingMode;
    class UAnimNodeAimOffset* FlyingDir;
    FName StartingAnimName;
    BITFIELD bHasStartingAnim:1;
    BITFIELD bHasEndingAnim:1;
    FName EndingAnimName;
    //## END PROPS UTAnimBlendByFlying

    virtual void UpdateFlyingState();
    DECLARE_FUNCTION(execUpdateFlyingState)
    {
        P_FINISH;
        UpdateFlyingState();
    }
    DECLARE_CLASS(UUTAnimBlendByFlying,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	
	void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent );

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
	
	void TestBlend();
};

class UUTAnimBlendByHoverboarding : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverboarding
    INT LastActiveChildIndex;
    FLOAT BoardLeanAmount;
    FLOAT FallTimeBeforeAnim;
    //## END PROPS UTAnimBlendByHoverboarding

    DECLARE_CLASS(UUTAnimBlendByHoverboarding,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
};

class UUTAnimBlendByIdle : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByIdle
    //## END PROPS UTAnimBlendByIdle

    DECLARE_CLASS(UUTAnimBlendByIdle,UUTAnimBlendBase,0,UTGame)
	// AnimNode interface
	virtual	void TickAnim( float DeltaSeconds, FLOAT TotalWeight  );
};

class UUTAnimBlendByPhysics : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByPhysics
    INT PhysicsMap[12];
    INT LastPhysics;
    FLOAT LandBlendDelay;
    INT PendingChildIndex;
    FLOAT PendingTimeToGo;
    //## END PROPS UTAnimBlendByPhysics

    DECLARE_CLASS(UUTAnimBlendByPhysics,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight  );
};

struct FPhysicsVolumeParams
{
    INT ChildIndex;
    BITFIELD bWaterVolume:1;
    BITFIELD bCheckGravity:1;
    FLOAT MinGravity;
    FLOAT MaxGravity;

    /** Constructors */
    FPhysicsVolumeParams() {}
    FPhysicsVolumeParams(EEventParm)
    {
        appMemzero(this, sizeof(FPhysicsVolumeParams));
    }
};

struct UTAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms
{
    class APhysicsVolume* NewVolume;
    UTAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms(EEventParm)
    {
    }
};
class UUTAnimBlendByPhysicsVolume : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByPhysicsVolume
    TArrayNoInit<struct FPhysicsVolumeParams> PhysicsParamList;
    class APhysicsVolume* LastPhysicsVolume;
    //## END PROPS UTAnimBlendByPhysicsVolume

    void eventPhysicsVolumeChanged(class APhysicsVolume* NewVolume)
    {
        UTAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms Parms(EC_EventParm);
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(UTGAME_PhysicsVolumeChanged),&Parms);
    }
    DECLARE_CLASS(UUTAnimBlendByPhysicsVolume,UUTAnimBlendBase,0,UTGame)
	virtual void RenameChildConnectors();
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UUTAnimBlendByPosture : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByPosture
    //## END PROPS UTAnimBlendByPosture

    DECLARE_CLASS(UUTAnimBlendByPosture,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight  );
};

class UUTAnimBlendByTurnInPlace : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByTurnInPlace
    FLOAT RootYawSpeedThresh;
    FLOAT TurnInPlaceBlendSpeed;
    class AUTPawn* OwnerUTP;
    //## END PROPS UTAnimBlendByTurnInPlace

    DECLARE_CLASS(UUTAnimBlendByTurnInPlace,UUTAnimBlendBase,0,UTGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim( float DeltaSeconds, FLOAT TotalWeight  );
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUTAnimBlendByVehicle : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByVehicle
    BITFIELD bLastPawnDriving:1;
    class AVehicle* LastVehicle;
    //## END PROPS UTAnimBlendByVehicle

    virtual void UpdateVehicleState();
    DECLARE_FUNCTION(execUpdateVehicleState)
    {
        P_FINISH;
        UpdateVehicleState();
    }
    DECLARE_CLASS(UUTAnimBlendByVehicle,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendByHoverboardTilt : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverboardTilt
    FVector UpVector;
    FLOAT TiltScale;
    FLOAT TiltDeadZone;
    FLOAT TiltYScale;
    FName UpperBodyName;
    //## END PROPS UTAnimBlendByHoverboardTilt

    DECLARE_CLASS(UUTAnimBlendByHoverboardTilt,UAnimNodeBlendBase,0,UTGame)
	// AnimNode interface
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	virtual INT GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UUTAnimBlendByHoverboardTurn : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverboardTurn
    FLOAT TurnScale;
    FLOAT MaxBlendPerSec;
    FLOAT CurrentAnimWeight;
    //## END PROPS UTAnimBlendByHoverboardTurn

    DECLARE_CLASS(UUTAnimBlendByHoverboardTurn,UAnimNodeBlendBase,0,UTGame)
	// AnimNode interface
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

struct FBoneCopyInfo
{
    FName SrcBoneName;
    FName DstBoneName;
    INT SrcBoneIndex;
    INT DstBoneIndex;

    /** Constructors */
    FBoneCopyInfo() {}
    FBoneCopyInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBoneCopyInfo));
    }
};

class UUTAnimNodeCopyBoneTranslation : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UTAnimNodeCopyBoneTranslation
    class UAnimNodeAimOffset* CachedAimNode;
    FName OldAimProfileName;
    TArrayNoInit<struct FBoneCopyInfo> DefaultBoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> DualWieldBoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> ActiveBoneCopyArray;
    TArrayNoInit<BYTE> RequiredBones;
    TArrayNoInit<class UUTAnimNodeSeqWeap*> SeqWeaps;
    TArrayNoInit<class UUTAnimBlendByWeapType*> WeapTypeBlends;
    //## END PROPS UTAnimNodeCopyBoneTranslation

    DECLARE_CLASS(UUTAnimNodeCopyBoneTranslation,UAnimNodeBlendBase,0,UTGame)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** Update cached list of required bones, use to transform skeleton from parent space to component space. */
	void UpdateListOfRequiredBones(FName AimProfileName);

	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
};

class UUTAnimNodeFramePlayer : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS UTAnimNodeFramePlayer
    //## END PROPS UTAnimNodeFramePlayer

    virtual void SetAnimation(FName Sequence,FLOAT RateScale);
    virtual void SetAnimPosition(FLOAT Perc);
    DECLARE_FUNCTION(execSetAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(RateScale);
        P_FINISH;
        SetAnimation(Sequence,RateScale);
    }
    DECLARE_FUNCTION(execSetAnimPosition)
    {
        P_GET_FLOAT(Perc);
        P_FINISH;
        SetAnimPosition(Perc);
    }
    DECLARE_CLASS(UUTAnimNodeFramePlayer,UAnimNodeSequence,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTAnimNodeFramePlayer)
};

class UUTAnimNodeSequence : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS UTAnimNodeSequence
    BITFIELD bAutoStart:1 GCC_BITFIELD_MAGIC;
    BITFIELD bLoopLastSequence:1;
    TArrayNoInit<FName> SeqStack;
    //## END PROPS UTAnimNodeSequence

    virtual void PlayAnimation(FName Sequence,FLOAT SeqRate,UBOOL bSeqLoop);
    virtual void PlayAnimationSet(const TArray<FName>& Sequences,FLOAT SeqRate,UBOOL bLoopLast);
    DECLARE_FUNCTION(execPlayAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bSeqLoop);
        P_FINISH;
        PlayAnimation(Sequence,SeqRate,bSeqLoop);
    }
    DECLARE_FUNCTION(execPlayAnimationSet)
    {
        P_GET_TARRAY(FName,Sequences);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bLoopLast);
        P_FINISH;
        PlayAnimationSet(Sequences,SeqRate,bLoopLast);
    }
    DECLARE_CLASS(UUTAnimNodeSequence,UAnimNodeSequence,0,UTGame)
	virtual void OnAnimEnd(FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUTAnimNodeSeqWeap : public UUTAnimNodeSequence
{
public:
    //## BEGIN PROPS UTAnimNodeSeqWeap
    FName DefaultAnim;
    FName DualPistolAnim;
    FName SinglePistolAnim;
    FName ShoulderRocketAnim;
    FName StingerAnim;
    //## END PROPS UTAnimNodeSeqWeap

    DECLARE_CLASS(UUTAnimNodeSeqWeap,UUTAnimNodeSequence,0,UTGame)
	virtual FString GetNodeTitle();

	void WeapTypeChanged(FName NewAimProfileName);
};

struct UTSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms
{
    FVector ReturnValue;
    UTSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms(EEventParm)
    {
    }
};
class UUTSkelControl_CantileverBeam : public USkelControlLookAt
{
public:
    //## BEGIN PROPS UTSkelControl_CantileverBeam
    FVector WorldSpaceGoal;
    FVector InitialWorldSpaceGoalOffset;
    FVector Velocity;
    FLOAT SpringStiffness;
    FLOAT SpringDamping;
    FLOAT PercentBeamVelocityTransfer;
    FScriptDelegate __EntireBeamVelocity__Delegate;
    //## END PROPS UTSkelControl_CantileverBeam

    FVector delegateEntireBeamVelocity()
    {
        UTSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessDelegate(UTGAME_EntireBeamVelocity,&__EntireBeamVelocity__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTSkelControl_CantileverBeam,USkelControlLookAt,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_LookAt : public USkelControlLookAt
{
public:
    //## BEGIN PROPS UTSkelControl_LookAt
    BITFIELD bLimitYaw:1;
    BITFIELD bLimitPitch:1;
    BITFIELD bLimitRoll:1;
    BITFIELD bShowPerAxisLimits:1;
    FLOAT YawLimit;
    FLOAT PitchLimit;
    FLOAT RollLimit;
    //## END PROPS UTSkelControl_LookAt

    DECLARE_CLASS(UUTSkelControl_LookAt,USkelControlLookAt,0,UTGame)
protected:
	virtual UBOOL	ApplyLookDirectionLimits(FVector& DesiredLookDir, const FVector &CurrentLookDir, INT BoneIndex, USkeletalMeshComponent* SkelComp);
public:
	virtual void	TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void	DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

class UUTSkelControl_CicadaEngine : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_CicadaEngine
    FLOAT ForwardPitch;
    FLOAT BackPitch;
    FLOAT PitchRate;
    FLOAT MaxVelocity;
    FLOAT MinVelocity;
    FLOAT MaxVelocityPitchRateMultiplier;
    FLOAT PitchTime;
    FLOAT LastThrust;
    INT DesiredPitch;
    //## END PROPS UTSkelControl_CicadaEngine

    DECLARE_CLASS(UUTSkelControl_CicadaEngine,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct UTSkelControl_Damage_eventRestorePart_Parms
{
    FLOAT ReturnValue;
    UTSkelControl_Damage_eventRestorePart_Parms(EEventParm)
    {
    }
};
struct UTSkelControl_Damage_eventBreakApartOnDeath_Parms
{
    FVector PartLocation;
    UBOOL bIsVisible;
    UTSkelControl_Damage_eventBreakApartOnDeath_Parms(EEventParm)
    {
    }
};
struct UTSkelControl_Damage_eventBreakApart_Parms
{
    FVector PartLocation;
    UBOOL bIsVisible;
    UTSkelControl_Damage_eventBreakApart_Parms(EEventParm)
    {
    }
};
class UUTSkelControl_Damage : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_Damage
    BITFIELD bInitialized:1;
    BITFIELD bOnDamageActive:1;
    BITFIELD bControlStrFollowsHealth:1;
    BITFIELD bIsBroken:1;
    BITFIELD bIsBreaking:1;
    BITFIELD bOnDeathActive:1;
    BITFIELD bOnDeathUseForSecondaryExplosion:1;
    class AUTVehicle* OwnerVehicle;
    FLOAT HealthPerc;
    FLOAT DamageBoneScale;
    INT DamageMax;
    FLOAT ActivationThreshold;
    class UStaticMesh* BreakMesh;
    FLOAT BreakThreshold;
    FLOAT BreakTime;
    FVector DefaultBreakDir;
    FVector DamageScale;
    class UParticleSystem* PS_DamageOnBreak;
    class UParticleSystem* PS_DamageTrail;
    FName BrokenBone;
    FLOAT BreakTimer;
    FLOAT OwnerVehicleMaxHealth;
    FVector BreakSpeed;
    FLOAT DeathPercentToActuallySpawn;
    FLOAT DeathBoneScale;
    class UStaticMesh* DeathStaticMesh;
    FVector DeathImpulseDir;
    FVector DeathScale;
    class UParticleSystem* PS_DeathOnBreak;
    class UParticleSystem* PS_DeathTrail;
    //## END PROPS UTSkelControl_Damage

    FLOAT eventRestorePart()
    {
        UTSkelControl_Damage_eventRestorePart_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(UTGAME_RestorePart),&Parms);
        return Parms.ReturnValue;
    }
    void eventBreakApartOnDeath(FVector PartLocation,UBOOL bIsVisible)
    {
        UTSkelControl_Damage_eventBreakApartOnDeath_Parms Parms(EC_EventParm);
        Parms.PartLocation=PartLocation;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_BreakApartOnDeath),&Parms);
    }
    void eventBreakApart(FVector PartLocation,UBOOL bIsVisible)
    {
        UTSkelControl_Damage_eventBreakApart_Parms Parms(EC_EventParm);
        Parms.PartLocation=PartLocation;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UTGAME_BreakApart),&Parms);
    }
    DECLARE_CLASS(UUTSkelControl_Damage,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp);
	virtual UBOOL InitializeControl(USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_DamageHinge : public UUTSkelControl_Damage
{
public:
    //## BEGIN PROPS UTSkelControl_DamageHinge
    FLOAT MaxAngle;
    BYTE PivotAxis;
    FLOAT AVModifier;
    FLOAT CurrentAngle;
    FLOAT SpringStiffness;
    //## END PROPS UTSkelControl_DamageHinge

    DECLARE_CLASS(UUTSkelControl_DamageHinge,UUTSkelControl_Damage,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_DamageSpring : public UUTSkelControl_Damage
{
public:
    //## BEGIN PROPS UTSkelControl_DamageSpring
    FRotator MaxAngle;
    FRotator MinAngle;
    FLOAT Falloff;
    FLOAT SpringStiffness;
    FLOAT AVModifier;
    FRotator CurrentAngle;
    FLOAT RandomPortion;
    FVector LastHitMomentum;
    FLOAT LastHitTime;
    FLOAT MomentumPortion;
    //## END PROPS UTSkelControl_DamageSpring

    DECLARE_CLASS(UUTSkelControl_DamageSpring,UUTSkelControl_Damage,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual INT CalcAxis(INT &InAngle, FLOAT CurVelocity, FLOAT MinAngle, FLOAT MaxAngle);
	virtual UBOOL InitializeControl(USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_HoverboardSuspension : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HoverboardSuspension
    FLOAT TransIgnore;
    FLOAT TransScale;
    FLOAT TransOffset;
    FLOAT MaxTrans;
    FLOAT MinTrans;
    FLOAT RotScale;
    FLOAT MaxRot;
    FLOAT MaxRotRate;
    FLOAT CurrentRot;
    //## END PROPS UTSkelControl_HoverboardSuspension

    DECLARE_CLASS(UUTSkelControl_HoverboardSuspension,USkelControlSingleBone,0,UTGame)
	// SkelControl interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_HoverboardSwing : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HoverboardSwing
    INT SwingHistoryWindow;
    INT SwingHistorySlot;
    TArrayNoInit<FLOAT> SwingHistory;
    FLOAT SwingScale;
    FLOAT MaxSwing;
    FLOAT MaxUseVel;
    FLOAT CurrentSwing;
    //## END PROPS UTSkelControl_HoverboardSwing

    DECLARE_CLASS(UUTSkelControl_HoverboardSwing,USkelControlSingleBone,0,UTGame)
	// SkelControlWheel interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_HoverboardVibration : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HoverboardVibration
    FLOAT VibFrequency;
    FLOAT VibSpeedAmpScale;
    FLOAT VibTurnAmpScale;
    FLOAT VibMaxAmplitude;
    FLOAT VibInput;
    //## END PROPS UTSkelControl_HoverboardVibration

    DECLARE_CLASS(UUTSkelControl_HoverboardVibration,USkelControlSingleBone,0,UTGame)
	// SkelControlWheel interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_HugGround : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HugGround
    FLOAT DesiredGroundDist;
    FLOAT MaxDist;
    FName ParentBone;
    BITFIELD bOppositeFromParent:1;
    FLOAT XYDistFromParentBone;
    FLOAT ZDistFromParentBone;
    FLOAT MaxTranslationPerSec;
    FLOAT LastUpdateTime;
    //## END PROPS UTSkelControl_HugGround

    DECLARE_CLASS(UUTSkelControl_HugGround,USkelControlSingleBone,0,UTGame)
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_JetThruster : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_JetThruster
    FLOAT MaxForwardVelocity;
    FLOAT BlendRate;
    FLOAT DesiredStrength;
    //## END PROPS UTSkelControl_JetThruster

    DECLARE_CLASS(UUTSkelControl_JetThruster,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_MantaBlade : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_MantaBlade
    FLOAT MaxRotationsPerSecond;
    FLOAT SpinUpTime;
    BITFIELD bCounterClockwise:1;
    FLOAT RotationsPerSecond;
    FLOAT DesiredRotationsPerSecond;
    //## END PROPS UTSkelControl_MantaBlade

    DECLARE_CLASS(UUTSkelControl_MantaBlade,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_MantaFlaps : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_MantaFlaps
    FLOAT maxPitch;
    FLOAT OldZPitch;
    FLOAT MaxPitchTime;
    FLOAT MaxPitchChange;
    FName RightFlapControl;
    FName LeftFlapControl;
    //## END PROPS UTSkelControl_MantaFlaps

    DECLARE_CLASS(UUTSkelControl_MantaFlaps,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_Oscillate : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_Oscillate
    FVector MaxDelta;
    FLOAT Period;
    FLOAT CurrentTime;
    BITFIELD bReverseDirection:1;
    //## END PROPS UTSkelControl_Oscillate

    DECLARE_CLASS(UUTSkelControl_Oscillate,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_Rotate : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_Rotate
    FRotator DesiredBoneRotation;
    FRotator DesiredBoneRotationRate;
    //## END PROPS UTSkelControl_Rotate

    DECLARE_CLASS(UUTSkelControl_Rotate,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_SpinControl : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_SpinControl
    FLOAT DegreesPerSecond;
    FVector Axis;
    //## END PROPS UTSkelControl_SpinControl

    DECLARE_CLASS(UUTSkelControl_SpinControl,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_LockRotation : public USkelControlBase
{
public:
    //## BEGIN PROPS UTSkelControl_LockRotation
    BITFIELD bLockPitch:1;
    BITFIELD bLockYaw:1;
    BITFIELD bLockRoll:1;
    FRotator LockRotation;
    FRotator MaxDelta;
    BYTE LockRotationSpace;
    FName RotationSpaceBoneName;
    //## END PROPS UTSkelControl_LockRotation

    DECLARE_CLASS(UUTSkelControl_LockRotation,USkelControlBase,0,UTGame)
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_MassBoneScaling : public USkelControlBase
{
public:
    //## BEGIN PROPS UTSkelControl_MassBoneScaling
    TArrayNoInit<FLOAT> BoneScales;
    //## END PROPS UTSkelControl_MassBoneScaling

    void SetBoneScale(FName BoneName,FLOAT Scale);
    FLOAT GetBoneScale(FName BoneName);
    DECLARE_FUNCTION(execSetBoneScale)
    {
        P_GET_NAME(BoneName);
        P_GET_FLOAT(Scale);
        P_FINISH;
        SetBoneScale(BoneName,Scale);
    }
    DECLARE_FUNCTION(execGetBoneScale)
    {
        P_GET_NAME(BoneName);
        P_FINISH;
        *(FLOAT*)Result=GetBoneScale(BoneName);
    }
    DECLARE_CLASS(UUTSkelControl_MassBoneScaling,USkelControlBase,0,UTGame)
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp);
};

#endif // !INCLUDED_UTGAME_ANIMATION_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UUTAnimBlendBase,-1,execGetAnimDuration);
AUTOGENERATE_FUNCTION(UUTAnimBlendBase,-1,execGetBlendTime);
AUTOGENERATE_FUNCTION(UUTAnimBlendByDriving,-1,execUpdateDrivingState);
AUTOGENERATE_FUNCTION(UUTAnimBlendByFlying,-1,execUpdateFlyingState);
AUTOGENERATE_FUNCTION(UUTAnimBlendByVehicle,-1,execUpdateVehicleState);
AUTOGENERATE_FUNCTION(UUTAnimNodeFramePlayer,-1,execSetAnimPosition);
AUTOGENERATE_FUNCTION(UUTAnimNodeFramePlayer,-1,execSetAnimation);
AUTOGENERATE_FUNCTION(UUTAnimNodeJumpLeanOffset,-1,execSetLeanWeight);
AUTOGENERATE_FUNCTION(UUTAnimNodeSequence,-1,execPlayAnimationSet);
AUTOGENERATE_FUNCTION(UUTAnimNodeSequence,-1,execPlayAnimation);
AUTOGENERATE_FUNCTION(UUTSkelControl_MassBoneScaling,-1,execGetBoneScale);
AUTOGENERATE_FUNCTION(UUTSkelControl_MassBoneScaling,-1,execSetBoneScale);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UTGAME_ANIMATION_NATIVE_DEFS
#define UTGAME_ANIMATION_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendBase);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByDriving);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByFall);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByFlying);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverboarding);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverboardTilt);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverboardTurn);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverJump);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByIdle);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByPhysics);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByPhysicsVolume);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByPosture);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendBySlotActive);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendBySpeed);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByTurnInPlace);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByVehicle);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByWeapon);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByWeapType);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeCopyBoneTranslation);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeFramePlayer);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeJumpLeanOffset);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeSequence);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeSeqWeap);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_CantileverBeam);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_CicadaEngine);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_Damage);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_DamageHinge);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_DamageSpring);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HoverboardSuspension);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HoverboardSwing);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HoverboardVibration);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HugGround);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_JetThruster);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_LockRotation);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_LookAt);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_MantaBlade);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_MantaFlaps);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_MassBoneScaling);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_Oscillate);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_Rotate);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_SpinControl);

#define AUTO_INITIALIZE_REGISTRANTS_UTGAME_ANIMATION \
	UUTAnimBlendBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimBlendBaseNative; \
	UUTAnimBlendByDriving::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimBlendByDrivingNative; \
	UUTAnimBlendByFall::StaticClass(); \
	UUTAnimBlendByFlying::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimBlendByFlyingNative; \
	UUTAnimBlendByHoverboarding::StaticClass(); \
	UUTAnimBlendByHoverboardTilt::StaticClass(); \
	UUTAnimBlendByHoverboardTurn::StaticClass(); \
	UUTAnimBlendByHoverJump::StaticClass(); \
	UUTAnimBlendByIdle::StaticClass(); \
	UUTAnimBlendByPhysics::StaticClass(); \
	UUTAnimBlendByPhysicsVolume::StaticClass(); \
	UUTAnimBlendByPosture::StaticClass(); \
	UUTAnimBlendBySlotActive::StaticClass(); \
	UUTAnimBlendBySpeed::StaticClass(); \
	UUTAnimBlendByTurnInPlace::StaticClass(); \
	UUTAnimBlendByVehicle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimBlendByVehicleNative; \
	UUTAnimBlendByWeapon::StaticClass(); \
	UUTAnimBlendByWeapType::StaticClass(); \
	UUTAnimNodeCopyBoneTranslation::StaticClass(); \
	UUTAnimNodeFramePlayer::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimNodeFramePlayerNative; \
	UUTAnimNodeJumpLeanOffset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimNodeJumpLeanOffsetNative; \
	UUTAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimNodeSequenceNative; \
	UUTAnimNodeSeqWeap::StaticClass(); \
	UUTSkelControl_CantileverBeam::StaticClass(); \
	UUTSkelControl_CicadaEngine::StaticClass(); \
	UUTSkelControl_Damage::StaticClass(); \
	UUTSkelControl_DamageHinge::StaticClass(); \
	UUTSkelControl_DamageSpring::StaticClass(); \
	UUTSkelControl_HoverboardSuspension::StaticClass(); \
	UUTSkelControl_HoverboardSwing::StaticClass(); \
	UUTSkelControl_HoverboardVibration::StaticClass(); \
	UUTSkelControl_HugGround::StaticClass(); \
	UUTSkelControl_JetThruster::StaticClass(); \
	UUTSkelControl_LockRotation::StaticClass(); \
	UUTSkelControl_LookAt::StaticClass(); \
	UUTSkelControl_MantaBlade::StaticClass(); \
	UUTSkelControl_MantaFlaps::StaticClass(); \
	UUTSkelControl_MassBoneScaling::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTSkelControl_MassBoneScalingNative; \
	UUTSkelControl_Oscillate::StaticClass(); \
	UUTSkelControl_Rotate::StaticClass(); \
	UUTSkelControl_SpinControl::StaticClass(); \

#endif // UTGAME_ANIMATION_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UUTAnimBlendBase) GUTGameUUTAnimBlendBaseNatives[] = 
{ 
	MAP_NATIVE(UUTAnimBlendBase,execGetAnimDuration)
	MAP_NATIVE(UUTAnimBlendBase,execGetBlendTime)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimBlendBase);

NATIVE_INFO(UUTAnimBlendByDriving) GUTGameUUTAnimBlendByDrivingNatives[] = 
{ 
	MAP_NATIVE(UUTAnimBlendByDriving,execUpdateDrivingState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimBlendByDriving);

NATIVE_INFO(UUTAnimBlendByFlying) GUTGameUUTAnimBlendByFlyingNatives[] = 
{ 
	MAP_NATIVE(UUTAnimBlendByFlying,execUpdateFlyingState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimBlendByFlying);

NATIVE_INFO(UUTAnimBlendByVehicle) GUTGameUUTAnimBlendByVehicleNatives[] = 
{ 
	MAP_NATIVE(UUTAnimBlendByVehicle,execUpdateVehicleState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimBlendByVehicle);

NATIVE_INFO(UUTAnimNodeFramePlayer) GUTGameUUTAnimNodeFramePlayerNatives[] = 
{ 
	MAP_NATIVE(UUTAnimNodeFramePlayer,execSetAnimPosition)
	MAP_NATIVE(UUTAnimNodeFramePlayer,execSetAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimNodeFramePlayer);

NATIVE_INFO(UUTAnimNodeJumpLeanOffset) GUTGameUUTAnimNodeJumpLeanOffsetNatives[] = 
{ 
	MAP_NATIVE(UUTAnimNodeJumpLeanOffset,execSetLeanWeight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimNodeJumpLeanOffset);

NATIVE_INFO(UUTAnimNodeSequence) GUTGameUUTAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UUTAnimNodeSequence,execPlayAnimationSet)
	MAP_NATIVE(UUTAnimNodeSequence,execPlayAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimNodeSequence);

NATIVE_INFO(UUTSkelControl_MassBoneScaling) GUTGameUUTSkelControl_MassBoneScalingNatives[] = 
{ 
	MAP_NATIVE(UUTSkelControl_MassBoneScaling,execGetBoneScale)
	MAP_NATIVE(UUTSkelControl_MassBoneScaling,execSetBoneScale)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTSkelControl_MassBoneScaling);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBase,BlendTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBase,ChildBlendTimes)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendBase)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByDriving)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByFall,PreLandTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByFall,CachedLeanNode)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByFall)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByFlying,FlyingState)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByFlying,EndingAnimName)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByFlying)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboarding,LastActiveChildIndex)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboarding,FallTimeBeforeAnim)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverboarding)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTilt,UpVector)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTilt,UpperBodyName)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverboardTilt)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTurn,TurnScale)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTurn,CurrentAnimWeight)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverboardTurn)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverJump,OwnerP)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverJump,OwnerHV)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverJump)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByIdle)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysics,PhysicsMap)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysics,PendingTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByPhysics)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysicsVolume,PhysicsParamList)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysicsVolume,LastPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByPosture)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBySlotActive,ChildSlot)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendBySlotActive)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBySpeed,MinSpeed)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBySpeed,MaxSpeed)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendBySpeed)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByTurnInPlace,RootYawSpeedThresh)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByTurnInPlace,OwnerUTP)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByTurnInPlace)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByVehicle,LastVehicle)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByVehicle)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByWeapon,LoopingAnim)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByWeapon,BlendTime)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByWeapon)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByWeapType)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeCopyBoneTranslation,CachedAimNode)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeCopyBoneTranslation,WeapTypeBlends)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeCopyBoneTranslation)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeFramePlayer)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeJumpLeanOffset,JumpLeanStrength)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeJumpLeanOffset,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeJumpLeanOffset)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeSequence,SeqStack)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeSequence)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeSeqWeap,DefaultAnim)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeSeqWeap,StingerAnim)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeSeqWeap)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CantileverBeam,WorldSpaceGoal)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CantileverBeam,__EntireBeamVelocity__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_CantileverBeam)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CicadaEngine,ForwardPitch)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CicadaEngine,DesiredPitch)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_CicadaEngine)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Damage,OwnerVehicle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Damage,PS_DeathTrail)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_Damage)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageHinge,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageHinge,SpringStiffness)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_DamageHinge)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageSpring,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageSpring,MomentumPortion)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_DamageSpring)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSuspension,TransIgnore)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSuspension,CurrentRot)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HoverboardSuspension)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSwing,SwingHistoryWindow)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSwing,CurrentSwing)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HoverboardSwing)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardVibration,VibFrequency)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardVibration,VibInput)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HoverboardVibration)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HugGround,DesiredGroundDist)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HugGround,LastUpdateTime)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HugGround)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_JetThruster,MaxForwardVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_JetThruster,DesiredStrength)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_JetThruster)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LockRotation,LockRotation)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LockRotation,RotationSpaceBoneName)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_LockRotation)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LookAt,YawLimit)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LookAt,RollLimit)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_LookAt)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaBlade,MaxRotationsPerSecond)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaBlade,DesiredRotationsPerSecond)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_MantaBlade)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaFlaps,maxPitch)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaFlaps,LeftFlapControl)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_MantaFlaps)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MassBoneScaling,BoneScales)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_MassBoneScaling)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Oscillate,MaxDelta)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Oscillate,CurrentTime)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_Oscillate)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Rotate,DesiredBoneRotation)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Rotate,DesiredBoneRotationRate)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_Rotate)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_SpinControl,DegreesPerSecond)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_SpinControl,Axis)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_SpinControl)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
