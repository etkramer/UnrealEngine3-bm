/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_ANIM_ENUMS
#define INCLUDED_ENGINE_ANIM_ENUMS 1

enum EAgentMoveState
{
    EAMS_Move               =0,
    EAMS_Idle               =1,
    EAMS_MAX                =2,
};
enum ECrowdAttractorMode
{
    ECAM_MoveTarget         =0,
    ECAM_Repulsor           =1,
    ECAM_MAX                =2,
};
enum AnimBlendType
{
    ABT_Linear              =0,
    ABT_Cubic               =1,
    ABT_Sinusoidal          =2,
    ABT_EaseInOutExponent2  =3,
    ABT_EaseInOutExponent3  =4,
    ABT_EaseInOutExponent4  =5,
    ABT_EaseInOutExponent5  =6,
    ABT_MAX                 =7,
};
enum ESliderType
{
    ST_1D                   =0,
    ST_2D                   =1,
    ST_MAX                  =2,
};
enum EAimID
{
    EAID_LeftUp             =0,
    EAID_LeftDown           =1,
    EAID_RightUp            =2,
    EAID_RightDown          =3,
    EAID_ZeroUp             =4,
    EAID_ZeroDown           =5,
    EAID_ZeroLeft           =6,
    EAID_ZeroRight          =7,
    EAID_CellLU             =8,
    EAID_CellCU             =9,
    EAID_CellRU             =10,
    EAID_CellLC             =11,
    EAID_CellCC             =12,
    EAID_CellRC             =13,
    EAID_CellLD             =14,
    EAID_CellCD             =15,
    EAID_CellRD             =16,
    EAID_MAX                =17,
};
enum EAnimAimDir
{
    ANIMAIM_LEFTUP          =0,
    ANIMAIM_CENTERUP        =1,
    ANIMAIM_RIGHTUP         =2,
    ANIMAIM_LEFTCENTER      =3,
    ANIMAIM_CENTERCENTER    =4,
    ANIMAIM_RIGHTCENTER     =5,
    ANIMAIM_LEFTDOWN        =6,
    ANIMAIM_CENTERDOWN      =7,
    ANIMAIM_RIGHTDOWN       =8,
    ANIMAIM_MAX             =9,
};
enum ERootRotationOption
{
    RRO_Default             =0,
    RRO_Discard             =1,
    RRO_Extract             =2,
    RRO_MAX                 =3,
};
enum ERootBoneAxis
{
    RBA_Default             =0,
    RBA_Discard             =1,
    RBA_Translate           =2,
    RBA_MAX                 =3,
};
enum EBaseBlendType
{
    BBT_ByActorTag          =0,
    BBT_ByActorClass        =1,
    BBT_MAX                 =2,
};
enum EBoneControlSpace
{
    BCS_WorldSpace          =0,
    BCS_ActorSpace          =1,
    BCS_ComponentSpace      =2,
    BCS_ParentBoneSpace     =3,
    BCS_BoneSpace           =4,
    BCS_OtherBoneSpace      =5,
    BCS_MAX                 =6,
};
enum ESplineControlRotMode
{
    SCR_NoChange            =0,
    SCR_AlongSpline         =1,
    SCR_Interpolate         =2,
    SCR_MAX                 =3,
};
enum AnimationKeyFormat
{
    AKF_ConstantKeyLerp     =0,
    AKF_VariableKeyLerp     =1,
    AKF_MAX                 =2,
};
enum AnimationCompressionFormat
{
    ACF_None                =0,
    ACF_Float96NoW          =1,
    ACF_Fixed48NoW          =2,
    ACF_IntervalFixed32NoW  =3,
    ACF_Fixed32NoW          =4,
    ACF_Float32NoW          =5,
    ACF_Fixed48Max          =6,
    ACF_MAX                 =7,
};

#endif // !INCLUDED_ENGINE_ANIM_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Notify)
AUTOGENERATE_NAME(OnBecomeRelevant)
AUTOGENERATE_NAME(OnCeaseRelevant)
AUTOGENERATE_NAME(OnInit)
AUTOGENERATE_NAME(OnSetSkelControlTarget)
AUTOGENERATE_NAME(OnSetSkeletalMesh)
AUTOGENERATE_NAME(OnUpdatePhysBonesFromAnim)
AUTOGENERATE_NAME(OverlappedActorEvent)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_ANIM_CLASSES
#define INCLUDED_ENGINE_ANIM_CLASSES 1

struct CrowdAgent_eventOverlappedActorEvent_Parms
{
    class AActor* A;
    CrowdAgent_eventOverlappedActorEvent_Parms(EEventParm)
    {
    }
};
class ACrowdAgent : public AActor
{
public:
    //## BEGIN PROPS CrowdAgent
    class USeqAct_CrowdSpawner* Spawner;
    BYTE AgentState;
    FLOAT EndActionTime;
    FLOAT NextActionTime;
    FLOAT VelDamping;
    FRotator ToTargetRot;
    BITFIELD bRotateToTargetRot:1;
    BITFIELD bHadNearbyTarget:1;
    BITFIELD bTargetZPosInitialized:1;
    FVector CurrentMoveTargetPos;
    FVector ExternalForce;
    FLOAT InterpZTranslation;
    class USkeletalMeshComponent* SkeletalMeshComponent;
    class UAnimNodeBlend* SpeedBlendNode;
    class UAnimNodeBlend* ActionBlendNode;
    class UAnimNodeSequence* ActionSeqNode;
    class UAnimNodeSequence* WalkSeqNode;
    class UAnimNodeSequence* RunSeqNode;
    class UAnimTree* AgentTree;
    INT Health;
    class ULightEnvironmentComponent* LightEnvironment;
    INT ConformTraceFrameCount;
    INT AwareUpdateFrameCount;
    TArrayNoInit<class ACrowdAgent*> NearbyAgents;
    TArrayNoInit<class ACrowdAttractor*> RelevantAttractors;
    class UReachSpec* NearestPath;
    //## END PROPS CrowdAgent

    virtual void PlayDeath();
    DECLARE_FUNCTION(execPlayDeath)
    {
        P_FINISH;
        PlayDeath();
    }
    void eventOverlappedActorEvent(class AActor* A)
    {
        CrowdAgent_eventOverlappedActorEvent_Parms Parms(EC_EventParm);
        Parms.A=A;
        ProcessEvent(FindFunctionChecked(ENGINE_OverlappedActorEvent),&Parms);
    }
    DECLARE_CLASS(ACrowdAgent,AActor,0,Engine)
	virtual void PreBeginPlay();
	virtual void PostScriptDestroyed();
	virtual void GetActorReferences(TArray<FActorReference*>& ActorRefs, UBOOL bIsRemovingLevel);

	virtual void performPhysics(FLOAT DeltaTime);
	void SetAgentMoveState(BYTE NewState);
	void DoAction(UBOOL bAtTarget, const FVector& TargetLoc);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);

	/** Fired when an agent does his 'action' at a target, if 'bSpawnEffects' is TRUE */
	virtual void SpawnActionEffect(const FVector& ActionTarget) {}
};

class ACrowdAttractor : public AActor
{
public:
    //## BEGIN PROPS CrowdAttractor
    FLOAT Attraction;
    BITFIELD bAttractorEnabled:1;
    BITFIELD bAttractionFalloff:1;
    BITFIELD bActionAtThisAttractor:1;
    BITFIELD bKillWhenReached:1;
    FLOAT ActionRadiusScale;
    class UCylinderComponent* CylinderComponent;
    FLOAT AttractionRadius;
    FLOAT AttractionHeight;
    FOctreeElementId OctreeId;
    FLOAT KillDist;
    class AActor* ActionTarget;
    BYTE Mode;
    //## END PROPS CrowdAttractor

    DECLARE_CLASS(ACrowdAttractor,AActor,0,Engine)
	// AActor interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
	virtual void PreSave();
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate=FALSE);
	virtual void ClearComponents();
};

struct FSkelMeshActorControlTarget
{
    FName ControlName;
    class AActor* TargetActor;

    /** Constructors */
    FSkelMeshActorControlTarget() {}
    FSkelMeshActorControlTarget(EEventParm)
    {
        appMemzero(this, sizeof(FSkelMeshActorControlTarget));
    }
};

struct SkeletalMeshActor_eventOnSetSkelControlTarget_Parms
{
    class USeqAct_SetSkelControlTarget* Action;
    SkeletalMeshActor_eventOnSetSkelControlTarget_Parms(EEventParm)
    {
    }
};
struct SkeletalMeshActor_eventOnUpdatePhysBonesFromAnim_Parms
{
    class USeqAct_UpdatePhysBonesFromAnim* Action;
    SkeletalMeshActor_eventOnUpdatePhysBonesFromAnim_Parms(EEventParm)
    {
    }
};
struct SkeletalMeshActor_eventOnSetSkeletalMesh_Parms
{
    class USeqAct_SetSkeletalMesh* Action;
    SkeletalMeshActor_eventOnSetSkeletalMesh_Parms(EEventParm)
    {
    }
};
class ASkeletalMeshActor : public AActor
{
public:
    //## BEGIN PROPS SkeletalMeshActor
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bCheckpointSaveRotation:1;
    BITFIELD bShouldDoAnimNotifies:1;
    class USkeletalMeshComponent* SkeletalMeshComponent;
    class ULightEnvironmentComponent* LightEnvironment;
    class UAudioComponent* FacialAudioComp;
    class UAudioComponent* ImpactSoundComponent;
    class UAudioComponent* ImpactSoundComponent2;
    FLOAT LastImpactTime;
    class UPrimitiveComponent* ImpactForceComponent;
    class USkeletalMesh* ReplicatedMesh;
    class UMaterialInterface* ReplicatedMaterial;
    TArrayNoInit<struct FSkelMeshActorControlTarget> ControlTargets;
    class AActor* LookAtTarget;
    FLOAT LookAtWeight;
    class USkeletalMeshComponent* HeadMesh;
    //## END PROPS SkeletalMeshActor

    void eventOnSetSkelControlTarget(class USeqAct_SetSkelControlTarget* Action)
    {
        SkeletalMeshActor_eventOnSetSkelControlTarget_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_OnSetSkelControlTarget),&Parms);
    }
    void eventOnUpdatePhysBonesFromAnim(class USeqAct_UpdatePhysBonesFromAnim* Action)
    {
        SkeletalMeshActor_eventOnUpdatePhysBonesFromAnim_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_OnUpdatePhysBonesFromAnim),&Parms);
    }
    void eventOnSetSkeletalMesh(class USeqAct_SetSkeletalMesh* Action)
    {
        SkeletalMeshActor_eventOnSetSkeletalMesh_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_OnSetSkeletalMesh),&Parms);
    }
    DECLARE_CLASS(ASkeletalMeshActor,AActor,0,Engine)
	// UObject interface
	virtual void CheckForErrors();

	// AActor interface
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual void ForceUpdateComponents(UBOOL bCollisionUpdate,UBOOL bTransformOnly);
	virtual UBOOL InStasis();
	virtual void PreviewBeginAnimControl(TArray<class UAnimSet*>& InAnimSets);
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping);
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);
	virtual void PreviewFinishAnimControl();
	virtual void PreviewUpdateFaceFX(UBOOL bForceAnim, const FString& GroupName, const FString& SeqName, FLOAT InPosition);
	virtual void PreviewActorPlayFaceFX(const FString& GroupName, const FString& SeqName, USoundCue* InSoundCue);
	virtual void PreviewActorStopFaceFX();
	virtual UAudioComponent* PreviewGetFaceFXAudioComponent();
	virtual class UFaceFXAsset* PreviewGetActorFaceFXAsset();

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );

protected:
/**
     * This function actually does the work for the GetDetailInfo and is virtual.
     * It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
     **/
	virtual FString GetDetailedInfoInternal() const;
};

struct FSkelMaterialSetterDatum
{
    INT MaterialIndex;
    class UMaterialInterface* TheMaterial;

    /** Constructors */
    FSkelMaterialSetterDatum() {}
    FSkelMaterialSetterDatum(EEventParm)
    {
        appMemzero(this, sizeof(FSkelMaterialSetterDatum));
    }
};

class ASkeletalMeshActorBasedOnExtremeContent : public ASkeletalMeshActor
{
public:
    //## BEGIN PROPS SkeletalMeshActorBasedOnExtremeContent
    TArrayNoInit<struct FSkelMaterialSetterDatum> ExtremeContent;
    TArrayNoInit<struct FSkelMaterialSetterDatum> NonExtremeContent;
    //## END PROPS SkeletalMeshActorBasedOnExtremeContent

    DECLARE_CLASS(ASkeletalMeshActorBasedOnExtremeContent,ASkeletalMeshActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASkeletalMeshActorBasedOnExtremeContent)
};

class ASkeletalMeshActorMAT : public ASkeletalMeshActor
{
public:
    //## BEGIN PROPS SkeletalMeshActorMAT
    TArrayNoInit<class UAnimNodeSlot*> SlotNodes;
    //## END PROPS SkeletalMeshActorMAT

    virtual void MAT_BeginAnimControl(const TArray<class UAnimSet*>& InAnimSets);
    virtual void MAT_SetAnimPosition(FName SlotName,INT ChannelIndex,FName InAnimSeqName,FLOAT InPosition,UBOOL bFireNotifies,UBOOL bLooping);
    virtual void MAT_SetAnimWeights(const TArray<struct FAnimSlotInfo>& SlotInfos);
    virtual void MAT_FinishAnimControl();
    virtual void MAT_SetMorphWeight(FName MorphNodeName,FLOAT MorphWeight);
    virtual void MAT_SetSkelControlScale(FName SkelControlName,FLOAT Scale);
    DECLARE_FUNCTION(execMAT_BeginAnimControl)
    {
        P_GET_TARRAY(class UAnimSet*,InAnimSets);
        P_FINISH;
        MAT_BeginAnimControl(InAnimSets);
    }
    DECLARE_FUNCTION(execMAT_SetAnimPosition)
    {
        P_GET_NAME(SlotName);
        P_GET_INT(ChannelIndex);
        P_GET_NAME(InAnimSeqName);
        P_GET_FLOAT(InPosition);
        P_GET_UBOOL(bFireNotifies);
        P_GET_UBOOL(bLooping);
        P_FINISH;
        MAT_SetAnimPosition(SlotName,ChannelIndex,InAnimSeqName,InPosition,bFireNotifies,bLooping);
    }
    DECLARE_FUNCTION(execMAT_SetAnimWeights)
    {
        P_GET_TARRAY(struct FAnimSlotInfo,SlotInfos);
        P_FINISH;
        MAT_SetAnimWeights(SlotInfos);
    }
    DECLARE_FUNCTION(execMAT_FinishAnimControl)
    {
        P_FINISH;
        MAT_FinishAnimControl();
    }
    DECLARE_FUNCTION(execMAT_SetMorphWeight)
    {
        P_GET_NAME(MorphNodeName);
        P_GET_FLOAT(MorphWeight);
        P_FINISH;
        MAT_SetMorphWeight(MorphNodeName,MorphWeight);
    }
    DECLARE_FUNCTION(execMAT_SetSkelControlScale)
    {
        P_GET_NAME(SkelControlName);
        P_GET_FLOAT(Scale);
        P_FINISH;
        MAT_SetSkelControlScale(SkelControlName,Scale);
    }
    DECLARE_CLASS(ASkeletalMeshActorMAT,ASkeletalMeshActor,0,Engine)
	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs);
	virtual void PreviewBeginAnimControl(TArray<class UAnimSet*>& InAnimSets);
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping);
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);
	virtual void PreviewFinishAnimControl();
	virtual void PreviewSetMorphWeight(FName MorphNodeName, FLOAT MorphWeight);
	virtual void PreviewSetSkelControlScale(FName SkelControlName, FLOAT Scale);

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );
};

class UAnimationCompressionAlgorithm : public UObject
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm
    FStringNoInit Description;
    BITFIELD bNeedsSkeleton:1;
    BYTE TranslationCompressionFormat GCC_BITFIELD_MAGIC;
    BYTE RotationCompressionFormat;
    //## END PROPS AnimationCompressionAlgorithm

    DECLARE_ABSTRACT_CLASS(UAnimationCompressionAlgorithm,UObject,0,Engine)
public:
	/**
	 * Reduce the number of keyframes and bitwise compress the specified sequence.
	 *
	 * @param	AnimSeq		The animation sequence to compress.
	 * @param	SkelMesh	The skeletal mesh against which to compress the animation.  Not needed by all compression schemes.
	 * @param	bOutput		If FALSE don't generate output or compute memory savings.
	 * @return				FALSE if a skeleton was needed by the algorithm but not provided.
	 */
	UBOOL Reduce(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, UBOOL bOutput);

	/**
	 * Reduce the number of keyframes and bitwise compress all sequences in the specified animation set.
	 *
	 * @param	AnimSet		The animation set to compress.
	 * @param	SkelMesh	The skeletal mesh against which to compress the animation.  Not needed by all compression schemes.
	 * @param	bOutput		If FALSE don't generate output or compute memory savings.
	 * @return				FALSE if a skeleton was needed by the algorithm but not provided.
	 */
	UBOOL Reduce(class UAnimSet* AnimSet, class USkeletalMesh* SkelMesh, UBOOL bOutput);

protected:
	/**
	 * Implemented by child classes, this function reduces the number of keyframes in
	 * the specified sequence, given the specified skeleton (if needed).
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData) PURE_VIRTUAL(UAnimationCompressionAlgorithm::DoReduction,);

	/**
	 * Common compression utility to remove 'redundant' position keys based on the provided delta threshold
	 *
	 * @param	InputTracks		Array of position track elements to reduce
	 * @param	MaxPosDelta		Maximum local-space threshold for stationary motion
	 */
	static void FilterTrivialPositionKeys(
		TArray<struct FTranslationTrack>& InputTracks, 
		FLOAT MaxPosDelta);
	
	/**
	 * Common compression utility to remove 'redundant' rotation keys based on the provided delta threshold
	 *
	 * @param	InputTracks		Array of rotation track elements to reduce
	 * @param	MaxRotDelta		Maximum angle threshold to consider stationary motion
	 */
	static void FilterTrivialRotationKeys(
		TArray<struct FRotationTrack>& InputTracks, 
		FLOAT MaxRotDelta);

	/**
	 * Common compression utility to remove 'redundant' keys based on the provided delta thresholds
	 *
	 * @param	PositionTracks	Array of position track elements to reduce
	 * @param	RotationTracks	Array of rotation track elements to reduce
	 * @param	MaxPosDelta		Maximum local-space threshold for stationary motion
	 * @param	MaxRotDelta		Maximum angle threshold to consider stationary motion
	 */
	static void FilterTrivialKeys(
		TArray<struct FTranslationTrack>& PositionTracks,
		TArray<struct FRotationTrack>& RotationTracks, 
		FLOAT MaxPosDelta,
		FLOAT MaxRotDelta);
	
	/**
	 * Common compression utility to retain only intermittent position keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	PositionTracks	Array of position track elements to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentPositionKeys(
		TArray<struct FTranslationTrack>& PositionTracks, 
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to retain only intermittent rotation keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	RotationTracks	Array of rotation track elements to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentRotationKeys(
		TArray<struct FRotationTrack>& RotationTracks, 
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to retain only intermittent animation keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	PositionTracks	Array of position track elements to reduce
	 * @param	RotationTracks	Array of rotation track elements to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentKeys(
		TArray<struct FTranslationTrack>& PositionTracks, 
		TArray<struct FRotationTrack>& RotationTracks, 
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to populate individual rotation and translation track
	 * arrays from a set of raw animation tracks. Used as a precurser to animation compression.
	 *
	 * @param	RawAnimData			Array of raw animation tracks
	 * @param	SequenceLength		The duration of the animation in seconds
	 * @param	OutTranslationData	Translation tracks to fill
	 * @param	OutRotationData		Rotation tracks to fill
	 */
	static void SeparateRawDataIntoTracks(
		const TArray<struct FRawAnimSequenceTrack>& RawAnimData,
		FLOAT SequenceLength,
		TArray<struct FTranslationTrack>& OutTranslationData,
		TArray<struct FRotationTrack>& OutRotationData);
	
	/**
	 * Common compression utility to walk an array of rotation tracks and enforce
	 * that all adjacent rotation keys are represented by shortest-arc quaternion pairs.
	 *
	 * @param	RotationData	Array of rotation track elements to reduce.
	 */
	static void PrecalculateShortestQuaternionRoutes(TArray<struct FRotationTrack>& RotationData);

public:

	/**
	 * Encodes individual key arrays into an AnimSequence using the desired bit packing formats.
	 *
	 * @param	Seq							Pointer to an Animation Sequence which will contain the bit-packed data .
	 * @param	TargetTranslationFormat		The format to use when encoding translation keys.
	 * @param	TargetRotationFormat		The format to use when encoding rotation keys.
	 * @param	TranslationData				Translation Tracks to bit-pack into the Animation Sequence.
	 * @param	RotationData				Rotation Tracks to bit-pack into the Animation Sequence.
	 * @param	IncludeKeyTable				TRUE if the compressed data should also contain a table of frame indices for each key. (required by some codecs)
	 */
	static void BitwiseCompressAnimationTracks(
		class UAnimSequence* Seq, 
		AnimationCompressionFormat TargetTranslationFormat, 
		AnimationCompressionFormat TargetRotationFormat,
		const TArray<struct FTranslationTrack>& TranslationData,
		const TArray<struct FRotationTrack>& RotationData,
		UBOOL IncludeKeyTable = FALSE);
	
};

class UAnimationCompressionAlgorithm_BitwiseCompressOnly : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_BitwiseCompressOnly
    //## END PROPS AnimationCompressionAlgorithm_BitwiseCompressOnly

    DECLARE_CLASS(UAnimationCompressionAlgorithm_BitwiseCompressOnly,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Bitwise animation compression only; performs no key reduction.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_RemoveEverySecondKey : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RemoveEverySecondKey
    INT MinKeys;
    BITFIELD bStartAtSecondKey:1;
    //## END PROPS AnimationCompressionAlgorithm_RemoveEverySecondKey

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RemoveEverySecondKey,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Keyframe reduction algorithm that simply removes every second key.
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_RemoveLinearKeys : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RemoveLinearKeys
    FLOAT MaxPosDiff;
    FLOAT MaxAngleDiff;
    FLOAT MaxEffectorDiff;
    FLOAT MinEffectorDiff;
    FLOAT ParentKeyScale;
    BITFIELD bRetarget:1;
    //## END PROPS AnimationCompressionAlgorithm_RemoveLinearKeys

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RemoveLinearKeys,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Keyframe reduction algorithm that simply removes every second key.
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);

	/**
	 * Locates spans of keys within the position and rotation tracks provided which can be estimated
	 * through linear interpolation of the surrounding keys. The remaining key values are bit packed into
	 * the animation sequence provided
	 *
	 * @param	AnimSeq		The animation sequence being compressed
	 * @param	SkelMesh	The skeletal mesh to use to guide the compressor
	 * @param	BoneData	BoneData array describing the hierarchy of the animated skeleton
	 * @param	TranslationCompressionFormat	The format to use when encoding translation keys.
	 * @param	RotationCompressionFormat		The format to use when encoding rotation keys.
	 * @param	TranslationData		Translation Tracks to compress and bit-pack into the Animation Sequence.
	 * @param	RotationData		Rotation Tracks to compress and bit-pack into the Animation Sequence.
	 * @return				None.
	 */
	void ProcessAnimationTracks(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh, 
		const TArray<FBoneData>& BoneData, 
		AnimationCompressionFormat TranslationCompressionFormat,
		AnimationCompressionFormat RotationCompressionFormat,
		TArray<FTranslationTrack>& PositionTracks,
		TArray<FRotationTrack>& RotationTracks);
};

class UAnimationCompressionAlgorithm_RemoveTrivialKeys : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RemoveTrivialKeys
    FLOAT MaxPosDiff;
    FLOAT MaxAngleDiff;
    //## END PROPS AnimationCompressionAlgorithm_RemoveTrivialKeys

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RemoveTrivialKeys,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Removes trivial frames -- frames of tracks when position or orientation is constant
	 * over the entire animation -- from the raw animation data.  If both position and rotation
	 * go down to a single frame, the time is stripped out as well.
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_RevertToRaw : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RevertToRaw
    //## END PROPS AnimationCompressionAlgorithm_RevertToRaw

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RevertToRaw,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Reverts any animation compression, restoring the animation to the raw data.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

struct FNotifierInfo
{
    class USkeletalMeshComponent* SkelComponent;
    BITFIELD AnimMirrored:1;

    /** Constructors */
    FNotifierInfo() {}
    FNotifierInfo(EEventParm)
    {
        appMemzero(this, sizeof(FNotifierInfo));
    }
};

class UAnimNotify : public UObject
{
public:
    //## BEGIN PROPS AnimNotify
    //## END PROPS AnimNotify

    DECLARE_ABSTRACT_CLASS(UAnimNotify,UObject,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent ) {};
};

class UAnimNotify_CameraEffect : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_CameraEffect
    class UClass* CameraLensEffect;
    //## END PROPS AnimNotify_CameraEffect

    DECLARE_CLASS(UAnimNotify_CameraEffect,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

class UAnimNotify_Footstep : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Footstep
    INT FootDown;
    //## END PROPS AnimNotify_Footstep

    DECLARE_CLASS(UAnimNotify_Footstep,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

class UAnimNotify_PlayParticleEffect : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_PlayParticleEffect
    class UParticleSystem* PSTemplate;
    BITFIELD bIsExtremeContent:1;
    BITFIELD bAttach:1;
    FName SocketName;
    FName BoneName;
    //## END PROPS AnimNotify_PlayParticleEffect

    DECLARE_CLASS(UAnimNotify_PlayParticleEffect,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

class UAnimNotify_Rumble : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Rumble
    class UClass* PredefinedWaveForm;
    class UForceFeedbackWaveform* WaveForm;
    //## END PROPS AnimNotify_Rumble

    DECLARE_CLASS(UAnimNotify_Rumble,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

class UAnimNotify_Script : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Script
    FName NotifyName;
    //## END PROPS AnimNotify_Script

    DECLARE_CLASS(UAnimNotify_Script,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

struct AnimNotify_Scripted_eventNotify_Parms
{
    class AActor* Owner;
    class USkeletalMeshComponent* AnimSeqInstigator;
    AnimNotify_Scripted_eventNotify_Parms(EEventParm)
    {
    }
};
class UAnimNotify_Scripted : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Scripted
    //## END PROPS AnimNotify_Scripted

    void eventNotify(class AActor* Owner,class USkeletalMeshComponent* AnimSeqInstigator)
    {
        AnimNotify_Scripted_eventNotify_Parms Parms(EC_EventParm);
        Parms.Owner=Owner;
        Parms.AnimSeqInstigator=AnimSeqInstigator;
        ProcessEvent(FindFunctionChecked(ENGINE_Notify),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UAnimNotify_Scripted,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

class UAnimNotify_Sound : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Sound
    class USoundCue* SoundCue;
    BITFIELD bFollowActor:1;
    BITFIELD bIgnoreIfActorHidden:1;
    FName BoneName;
    //## END PROPS AnimNotify_Sound

    DECLARE_CLASS(UAnimNotify_Sound,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class USkeletalMeshComponent* SkelComponent );
};

class UAnimObject : public UObject
{
public:
    //## BEGIN PROPS AnimObject
    INT DrawWidth;
    INT DrawHeight;
    INT NodePosX;
    INT NodePosY;
    INT OutDrawY;
    FStringNoInit CategoryDesc;
    class USkeletalMeshComponent* SkelComponent;
    //## END PROPS AnimObject

    DECLARE_ABSTRACT_CLASS(UAnimObject,UObject,0,Engine)
	virtual UAnimNode * GetAnimNode() { return NULL;}
	virtual UMorphNodeBase * GetMorphNodeBase() { return NULL;}
	virtual USkelControlBase * GetSkelControlBase() { return NULL; }

	virtual void DrawNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bShowWeight, UBOOL bCurves) {}
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste() {};
};

struct AnimNode_eventOnCeaseRelevant_Parms
{
    AnimNode_eventOnCeaseRelevant_Parms(EEventParm)
    {
    }
};
struct AnimNode_eventOnBecomeRelevant_Parms
{
    AnimNode_eventOnBecomeRelevant_Parms(EEventParm)
    {
    }
};
struct AnimNode_eventOnInit_Parms
{
    AnimNode_eventOnInit_Parms(EEventParm)
    {
    }
};
class UAnimNode : public UAnimObject
{
public:
    //## BEGIN PROPS AnimNode
    BITFIELD bRelevant:1;
    BITFIELD bJustBecameRelevant:1;
    BITFIELD bSkipTickWhenZeroWeight:1;
    BITFIELD bTickDuringPausedAnims:1;
    INT NodeTickTag;
    INT NodeCachedAtomsTag;
    FLOAT NodeTotalWeight;
    FLOAT TotalWeightAccumulator;
    TArrayNoInit<class UAnimNodeBlendBase*> ParentNodes;
    FName NodeName;
    TArrayNoInit<FBoneAtom> CachedBoneAtoms;
    FBoneAtom CachedRootMotionDelta;
    INT bCachedHasRootMotion;
    INT InstanceVersionNumber;
protected:
    INT SearchTag;
public:
    //## END PROPS AnimNode

    class UAnimNode* FindAnimNode(FName InNodeName);
    virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT Rate=1.000000,FLOAT StartTime=0.000000);
    virtual void StopAnim();
    DECLARE_FUNCTION(execFindAnimNode)
    {
        P_GET_NAME(InNodeName);
        P_FINISH;
        *(class UAnimNode**)Result=FindAnimNode(InNodeName);
    }
    DECLARE_FUNCTION(execPlayAnim)
    {
        P_GET_UBOOL_OPTX(bLoop,FALSE);
        P_GET_FLOAT_OPTX(Rate,1.000000);
        P_GET_FLOAT_OPTX(StartTime,0.000000);
        P_FINISH;
        PlayAnim(bLoop,Rate,StartTime);
    }
    DECLARE_FUNCTION(execStopAnim)
    {
        P_FINISH;
        StopAnim();
    }
    void eventOnCeaseRelevant()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnCeaseRelevant),NULL);
    }
    void eventOnBecomeRelevant()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnBecomeRelevant),NULL);
    }
    void eventOnInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnInit),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UAnimNode,UAnimObject,0,Engine)
	// UAnimNode interface

	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );

	/** AnimSets have been updated, update all animations */
	virtual void AnimSetsUpdated() {}

	/** 
	 *	Called just after a node has been copied from its AnimTreeTemplate version. 
	 *	This is called on the copy, and SourceNode is the node within the AnimTreeTemplate.
	 */
	virtual void PostAnimNodeInstance(UAnimNode* SourceNode) {}

	/**
	 *	Update this node, then call TickAnim on all children.
	 *	@param DeltaSeconds		Amount of time to advance this node.
	 *	@param TotalWeight		The eventual weight that this node will have in the final blend. This is the multiplication of weights of all nodes above this one.
	 */
	virtual	void	TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight ) {}

	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom() { return TRUE; }

	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL	CanBlendTo() { return TRUE; }

	/** Add this node and all children to array. Node are added so a parent is always before its children in the array. */
	void GetNodes(TArray<UAnimNode*>& Nodes);

	/** Add this node and all children of the specified class to array. Node are added so a parent is always before its children in the array. */
	void GetNodesByClass(TArray<class UAnimNode*>& Nodes, class UClass* BaseClass);

	/** Return an array with all UAnimNodeSequence childs, including this node. */
	void GetAnimSeqNodes(TArray<UAnimNodeSequence*>& Nodes, FName InSynchGroupName=NAME_None);

	/** Used for building array of AnimNodes in 'tick' order - that is, all parents of a node are added to array before it. */
	virtual void BuildTickArray(TArray<UAnimNode*>& OutTickArray) {}

	/**
	 *	Get the local transform for each bone. If a blend, will recursively ask children and blend etc.
	 *	DesiredBones should be in strictly increasing order.
	 */
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	/**
	 *	Will copy the cached results into the OutAtoms array if they are up to date and return TRUE
	 *	If cache is not up to date, does nothing and retuns FALSE.
	 */
	virtual UBOOL GetCachedResults(FBoneAtomArray& OutAtoms, FBoneAtom& OutRootMotionDelta, INT& bOutHasRootMotion);

	/** Save the supplied array of BoneAtoms in the CachedBoneAtoms. */
    virtual UBOOL ShouldSaveCachedResults();
	void SaveCachedResults(const FBoneAtomArray& NewAtoms, const FBoneAtom& NewRootMotionDelta, INT bNewHasRootMotion);

	/** Get notification that this node has become relevant for the final blend. ie TotalWeight is now > 0 */
	virtual void OnBecomeRelevant();

	/** Get notification that this node is no longer relevant for the final blend. ie TotalWeight is now == 0 */
	virtual void OnCeaseRelevant();

	/** Utility for counting the number of parents of this node that have been ticked. */
	INT CountNumParentsTicked();

	/** Returns TRUE if this node is a child of Node */
	UBOOL IsChildOf(UAnimNode* Node);

	/** Optimisation way to see if this is a UAnimTree */
	virtual UAnimTree* GetAnimTree() { return NULL; }

	virtual void SetAnim( FName SequenceName ) {}
	virtual void SetPosition( FLOAT NewTime, UBOOL bFireNotifies ) {}

	/// ANIMTREE EDITOR

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	bSelected		TRUE if this node is selected.
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 * @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bShowWeight, UBOOL bCurves) {}

	/** Return title to display for this Node in the AnimTree editor. */
	virtual FString GetNodeTitle() { return TEXT(""); }

	/** For editor use. */
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	/** Return the number of sliders */
	virtual INT GetNumSliders() const { return 0; }

	/** Return the slider type of slider Index */
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_1D; }

	/** Return current position of slider for this node in the AnimTreeEditor. Return value should be within 0.0 to 1.0 range. */
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex) { return 0.f; }

	/** Called when slider is moved in the AnimTreeEditor. NewSliderValue is in range 0.0 to 1.0. */
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue) {}

	/** Get the number to draw under the slider to show the current value being previewed. */
	virtual FString GetSliderDrawValue(INT SliderIndex) { return FString(TEXT("")); }

	/** internal code for GetNodes(); should only be called from GetNodes() or from the GetNodesInternal() of this node's parent */
	virtual void GetNodesInternal(TArray<UAnimNode*>& Nodes);

	// STATIC ANIMTREE UTILS

	/** flag to prevent calling GetNodesInternal() from anywhere besides GetNodes() or another GetNodesInternal(), since
	 * we can't make it private/protected because UAnimNodeBlendBase needs to be able to call it on its children
	 */
	static UBOOL bNodeSearching;
	/** current tag value used for SearchTag on nodes being iterated over. Incremented every time a new search is started */
	static INT CurrentSearchTag;

	/**
	 * Fills the Atoms array with the specified skeletal mesh reference pose.
	 *
	 * @param Atoms				[out] Output array of relative bone transforms. Must be the same length as RefSkel when calling function.
	 * @param DesiredBones		Indices of bones we want to modify. Parents must occur before children.
	 * @param RefSkel			Input reference skeleton to create atoms from.
	 */
	static void FillWithRefPose(TArray<FBoneAtom>& Atoms, const TArray<BYTE>& DesiredBones, const TArray<struct FMeshBone>& RefSkel);
	static void FillWithRefPose(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, const TArray<struct FMeshBone>& RefSkel);

	/** Utility for taking an array of bone indices and ensuring that all parents are present (ie. all bones between those in the array and the root are present). */
	static void EnsureParentsPresent( TArray<BYTE>& BoneIndices, USkeletalMesh* SkelMesh );
};

struct FAnimBlendChild
{
    FName Name;
    class UAnimNode* Anim;
    FLOAT Weight;
    FLOAT TotalWeight;
    FLOAT BlendWeight;
    INT bHasRootMotion;
    FBoneAtom RootMotion;
    BITFIELD bMirrorSkeleton:1;
    BITFIELD bIsAdditive:1;
    INT DrawY;

    /** Constructors */
    FAnimBlendChild() {}
    FAnimBlendChild(EEventParm)
    {
        appMemzero(this, sizeof(FAnimBlendChild));
    }
};

class UAnimNodeBlendBase : public UAnimNode
{
public:
    //## BEGIN PROPS AnimNodeBlendBase
    TArrayNoInit<struct FAnimBlendChild> Children;
    BITFIELD bFixNumChildren:1;
    BYTE BlendType GCC_BITFIELD_MAGIC;
    //## END PROPS AnimNodeBlendBase

    virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT Rate=1.000000,FLOAT StartTime=0.000000);
    virtual void StopAnim();
    DECLARE_ABSTRACT_CLASS(UAnimNodeBlendBase,UAnimNode,0,Engine)
	// UAnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );

	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	virtual void BuildTickArray(TArray<UAnimNode*>& OutTickArray);

	FORCEINLINE FLOAT	GetBlendWeight(FLOAT ChildWeight);
	FORCEINLINE void	SetBlendTypeWeights();
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	/**
	 * Get mirrored bone atoms from desired child index.
	 * Bones are mirrored using the SkelMirrorTable.
	 */
	void GetMirroredBoneAtoms(FBoneAtomArray& Atoms, INT ChildIndex, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	bSelected		TRUE if this node is selected.
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 * @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bShowWeight, UBOOL bCurves);
	virtual FString GetNodeTitle();

	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	// UAnimNodeBlendBase interface
	/** Calculates total weight of children */
	virtual void SetChildrenTotalWeightAccumulator(const INT Index);
	/** Get notification that this node is no longer relevant for the final blend. ie TotalWeight is now == 0 */
	virtual void OnCeaseRelevant();

	/** For debugging. Return the sum of the weights of all children nodes. Should always be 1.0. */
	FLOAT GetChildWeightTotal();

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);

	/** A child connector has been added */
	virtual void	OnAddChild(INT ChildNum);
	/** A child connector has been removed */
	virtual void	OnRemoveChild(INT ChildNum);

	/** Rename all child nodes upon Add/Remove, so they match their position in the array. */
	virtual void	RenameChildConnectors();

	/** internal code for GetNodes(); should only be called from GetNodes() or from the GetNodesInternal() of this node's parent */
	virtual void GetNodesInternal(TArray<UAnimNode*>& Nodes);
};

struct FAimTransform
{
    FQuat Quaternion;
    FVector Translation;

    /** Constructors */
    FAimTransform() {}
    FAimTransform(EEventParm)
    {
        appMemzero(this, sizeof(FAimTransform));
    }
};

struct FAimComponent
{
    FName BoneName;
    struct FAimTransform LU;
    struct FAimTransform LC;
    struct FAimTransform LD;
    struct FAimTransform CU;
    struct FAimTransform CC;
    struct FAimTransform CD;
    struct FAimTransform RU;
    struct FAimTransform RC;
    struct FAimTransform RD;

    /** Constructors */
    FAimComponent() {}
    FAimComponent(EEventParm)
    {
        appMemzero(this, sizeof(FAimComponent));
    }
};

struct FAimOffsetProfile
{
    FName ProfileName;
    FVector2D HorizontalRange;
    FVector2D VerticalRange;
    TArrayNoInit<struct FAimComponent> AimComponents;
    FName AnimName_LU;
    FName AnimName_LC;
    FName AnimName_LD;
    FName AnimName_CU;
    FName AnimName_CC;
    FName AnimName_CD;
    FName AnimName_RU;
    FName AnimName_RC;
    FName AnimName_RD;

    /** Constructors */
    FAimOffsetProfile() {}
    FAimOffsetProfile(EEventParm)
    {
        appMemzero(this, sizeof(FAimOffsetProfile));
    }
};

class UAnimNodeAimOffset : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeAimOffset
    FVector2D Aim;
    FVector2D AngleOffset;
    BITFIELD bForceAimDir:1;
    BITFIELD bBakeFromAnimations:1;
    BITFIELD bPassThroughWhenNotRendered:1;
    INT PassThroughAtOrAboveLOD;
    BYTE ForcedAimDir;
    TArrayNoInit<BYTE> RequiredBones;
    TArrayNoInit<INT> BoneToAimCpnt;
    class UAnimNodeAimOffset* TemplateNode;
    TArrayNoInit<struct FAimOffsetProfile> Profiles;
    INT CurrentProfileIndex;
    //## END PROPS AnimNodeAimOffset

    virtual void SetActiveProfileByName(FName ProfileName);
    virtual void SetActiveProfileByIndex(INT ProfileIndex);
    DECLARE_FUNCTION(execSetActiveProfileByName)
    {
        P_GET_NAME(ProfileName);
        P_FINISH;
        SetActiveProfileByName(ProfileName);
    }
    DECLARE_FUNCTION(execSetActiveProfileByIndex)
    {
        P_GET_INT(ProfileIndex);
        P_FINISH;
        SetActiveProfileByIndex(ProfileIndex);
    }
    DECLARE_CLASS(UAnimNodeAimOffset,UAnimNodeBlendBase,0,Engine)
	// UObject interface
	virtual void		PostEditChange(UProperty* PropertyThatChanged);

	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void		InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);

	/** Used to save pointer to AimOffset node in package, to avoid duplicating profile data. */
	virtual void		PostAnimNodeInstance(UAnimNode* SourceNode);

	/** returns current aim. Override this to pull information from somewhere else, like Pawn actor for example. */
	virtual FVector2D	GetAim() { return Aim; }

	virtual void		GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	/** 
	 * Function called after Aim has been extracted and processed (offsets, range, clamping...).
	 * Gives a chance to PostProcess it before being used by the AimOffset Node.
	 * Note that X,Y range should remain [-1,+1].
	 */
	virtual void		PostAimProcessing(FVector2D &AimOffsetPct) {}

	/** Util for getting the current AimOffsetProfile. */
	FAimOffsetProfile*	GetCurrentProfile();

	/** Update cached list of required bones, use to transform skeleton from parent space to component space. */
	void				UpdateListOfRequiredBones();

	/** Returns TRUE if AimComponents contains specified bone */
	UBOOL				ContainsBone(const FName &BoneName);

	/** Util for grabbing the quaternion on a specific bone in a specific direction. */
	FQuat				GetBoneAimQuaternion(INT CompIndex, EAnimAimDir InAimDir);
	/** Util for grabbing the translation on a specific bone in a specific direction. */
	FVector				GetBoneAimTranslation(INT CompIndex, EAnimAimDir InAimDir);

	/** Util for setting the quaternion on a specific bone in a specific direction. */
	void				SetBoneAimQuaternion(INT CompIndex, EAnimAimDir InAimDir, FQuat InQuat);
	/** Util for setting the translation on a specific bone in a specific direction. */
	void				SetBoneAimTranslation(INT CompIndex, EAnimAimDir InAimDir, FVector InTrans);

	/** Bake in Offsets from supplied Animations. */
	void				BakeOffsetsFromAnimations();
	void				ExtractOffsets(TArray<FBoneAtom>& RefBoneAtoms, TArray<FBoneAtom>& BoneAtoms, EAnimAimDir InAimDir);
	INT					GetComponentIdxFromBoneIdx(const INT BoneIndex, UBOOL bCreateIfNotFound=0);
	/**
	 * Extract Parent Space Bone Atoms from Animation Data specified by Name.
	 * Returns TRUE if successful.
	 */
	UBOOL				ExtractAnimationData(UAnimNodeSequence *SeqNode, FName AnimationName, TArray<FBoneAtom>& BoneAtoms);

	// For slider support
	virtual INT			GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT		GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void		HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString		GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodeBlend : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlend
    FLOAT Child2Weight;
    FLOAT Child2WeightTarget;
    FLOAT BlendTimeToGo;
    BITFIELD bSkipBlendWhenNotRendered:1;
    //## END PROPS AnimNodeBlend

    void SetBlendTarget(FLOAT BlendTarget,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetBlendTarget)
    {
        P_GET_FLOAT(BlendTarget);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        SetBlendTarget(BlendTarget,BlendTime);
    }
    DECLARE_CLASS(UAnimNodeBlend,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodeAdditiveBlending : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodeAdditiveBlending
    BITFIELD bPassThroughWhenNotRendered:1 GCC_BITFIELD_MAGIC;
    //## END PROPS AnimNodeAdditiveBlending

    DECLARE_CLASS(UAnimNodeAdditiveBlending,UAnimNodeBlend,0,Engine)
	void GetChildAtoms(INT ChildIndex, FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
	virtual void SetChildrenTotalWeightAccumulator(const INT Index);
};

class UAnimNodeBlendPerBone : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodeBlendPerBone
    BITFIELD bForceLocalSpaceBlend:1 GCC_BITFIELD_MAGIC;
    TArrayNoInit<FName> BranchStartBoneName;
    TArrayNoInit<FLOAT> Child2PerBoneWeight;
    TArrayNoInit<BYTE> LocalToCompReqBones;
    //## END PROPS AnimNodeBlendPerBone

    DECLARE_CLASS(UAnimNodeBlendPerBone,UAnimNodeBlend,0,Engine)
	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);

	// AnimNode interface
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
	virtual void SetChildrenTotalWeightAccumulator(const INT Index);

	virtual void PostEditChange(UProperty* PropertyThatChanged);
	void BuildWeightList();
};

class UAnimNodeCrossfader : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodeCrossfader
    FName DefaultAnimSeqName;
    BITFIELD bDontBlendOutOneShot:1;
    FLOAT PendingBlendOutTimeOneShot;
    //## END PROPS AnimNodeCrossfader

    FName GetAnimName();
    class UAnimNodeSequence* GetActiveChild();
    DECLARE_FUNCTION(execPlayOneShotAnim);
    DECLARE_FUNCTION(execBlendToLoopingAnim);
    DECLARE_FUNCTION(execGetAnimName)
    {
        P_FINISH;
        *(FName*)Result=GetAnimName();
    }
    DECLARE_FUNCTION(execGetActiveChild)
    {
        P_FINISH;
        *(class UAnimNodeSequence**)Result=GetActiveChild();
    }
    DECLARE_CLASS(UAnimNodeCrossfader,UAnimNodeBlend,0,Engine)
	// UAnimNode interface
	virtual	void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UAnimNodeSequence : public UAnimNode
{
public:
    //## BEGIN PROPS AnimNodeSequence
    FName AnimSeqName;
    FLOAT Rate;
    BITFIELD bPlaying:1;
    BITFIELD bLooping:1;
    BITFIELD bCauseActorAnimEnd:1;
    BITFIELD bCauseActorAnimPlay:1;
    BITFIELD bZeroRootRotation:1;
    BITFIELD bZeroRootTranslation:1;
    BITFIELD bDisableWarningWhenAnimNotFound:1;
    BITFIELD bNoNotifies:1;
    BITFIELD bForceRefposeWhenNotPlaying:1;
    BITFIELD bIsIssuingNotifies:1;
    BITFIELD bForceAlwaysSlave:1;
    BITFIELD bSynchronize:1;
    BITFIELD bShowTimeLineSlider:1;
    BITFIELD bLoopCameraAnim:1;
    BITFIELD bRandomizeCameraAnimLoopStartTime:1;
    BITFIELD bEditorOnlyAddRefPoseToAdditiveAnimation:1;
    FLOAT CurrentTime;
    FLOAT PreviousTime;
    class UAnimSequence* AnimSeq;
    INT AnimLinkupIndex;
    FLOAT NotifyWeightThreshold;
    FName SynchGroupName;
    FLOAT SynchPosOffset;
    class UTexture2D* DebugTrack;
    class UTexture2D* DebugCarat;
    class UCameraAnim* CameraAnim;
    class UCameraAnimInst* ActiveCameraAnimInstance;
    FLOAT CameraAnimScale;
    FLOAT CameraAnimPlayRate;
    BYTE RootBoneOption[3];
    BYTE RootRotationOption[3];
    //## END PROPS AnimNodeSequence

    virtual void SetAnim(FName Sequence);
    virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT InRate=1.000000,FLOAT StartTime=0.000000);
    virtual void StopAnim();
    virtual void SetPosition(FLOAT NewTime,UBOOL bFireNotifies);
    virtual FLOAT GetNormalizedPosition();
    virtual FLOAT FindNormalizedPositionFromGroupRelativePosition(FLOAT GroupRelativePosition);
    virtual FLOAT GetGlobalPlayRate();
    virtual FLOAT GetAnimPlaybackLength();
    virtual FLOAT GetTimeLeft();
    DECLARE_FUNCTION(execSetAnim)
    {
        P_GET_NAME(Sequence);
        P_FINISH;
        SetAnim(Sequence);
    }
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewTime);
        P_GET_UBOOL(bFireNotifies);
        P_FINISH;
        SetPosition(NewTime,bFireNotifies);
    }
    DECLARE_FUNCTION(execGetNormalizedPosition)
    {
        P_FINISH;
        *(FLOAT*)Result=GetNormalizedPosition();
    }
    DECLARE_FUNCTION(execFindNormalizedPositionFromGroupRelativePosition)
    {
        P_GET_FLOAT(GroupRelativePosition);
        P_FINISH;
        *(FLOAT*)Result=FindNormalizedPositionFromGroupRelativePosition(GroupRelativePosition);
    }
    DECLARE_FUNCTION(execGetGlobalPlayRate)
    {
        P_FINISH;
        *(FLOAT*)Result=GetGlobalPlayRate();
    }
    DECLARE_FUNCTION(execGetAnimPlaybackLength)
    {
        P_FINISH;
        *(FLOAT*)Result=GetAnimPlaybackLength();
    }
    DECLARE_FUNCTION(execGetTimeLeft)
    {
        P_FINISH;
        *(FLOAT*)Result=GetTimeLeft();
    }
    DECLARE_CLASS(UAnimNodeSequence,UAnimNode,0,Engine)
protected:
	// Internal
	/** Returns the camera associated with the skelmesh's owner, if any. */
	AAnimatedCamera* GetPlayerCamera() const;

public:
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void BeginDestroy();

	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
    virtual UBOOL GetCachedResults(FBoneAtomArray& OutAtoms, FBoneAtom& OutRootMotionDelta, INT& bOutHasRootMotion);
    virtual UBOOL ShouldSaveCachedResults();
	UBOOL ShouldSkipWhenMeshNotRendered();
	void ConditionalClearCachedData();

	/** AnimSets have been updated, update all animations */
	virtual void AnimSetsUpdated();

	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );	 // Progress the animation state, issue AnimEnd notifies.
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	RI				The rendering interface to use.
	 * @param	bSelected		TRUE if this node is selected.
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 * @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bShowWeight, UBOOL bCurves);
	virtual FString GetNodeTitle();

	// AnimNodeSequence interface
	void GetAnimationPose(UAnimSequence* InAnimSeq, INT& InAnimLinkupIndex, FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
	// Extract root motion fro animation.
	void ExtractRootMotion(UAnimSequence* InAnimSeq, const INT &TrackIndex, FBoneAtom& RootBoneAtom, FBoneAtom& RootBoneAtomDeltaMotion, INT& bHasRootMotion);

	/** Advance animation time. Take care of issuing notifies, looping and so on */
	void AdvanceBy(FLOAT MoveDelta, FLOAT DeltaSeconds, UBOOL bFireNotifies);

	/** Issue any notifies tha are passed when moving from the current position to DeltaSeconds in the future. Called from TickAnim. */
	void IssueNotifies(FLOAT DeltaSeconds);

	/**
	 * notification that current animation finished playing.
	 * @param	PlayedTime	Time in seconds of animation played. (play rate independant).
	 * @param	ExcessTime	Time in seconds beyond end of animation. (play rate independant).
	 */
	virtual void OnAnimEnd(FLOAT PlayedTime, FLOAT ExcessTime);

	// AnimTree editor interface
	virtual INT GetNumSliders() const { return bShowTimeLineSlider ? 1 : 0; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);

	/** Starts playing any camera anim we want to play in conjunction with this anim. */
	void StartCameraAnim();
	/** Stops playing any active camera anim playing in conjunction with this anim. */
	void StopCameraAnim();
};

struct FAnimInfo
{
    FName AnimSeqName;
    class UAnimSequence* AnimSeq;
    INT AnimLinkupIndex;

    /** Constructors */
    FAnimInfo() {}
    FAnimInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnimInfo));
    }
};

struct FAnimBlendInfo
{
    FName AnimName;
    struct FAnimInfo AnimInfo;
    FLOAT Weight;

    /** Constructors */
    FAnimBlendInfo() {}
    FAnimBlendInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnimBlendInfo));
    }
};

class UAnimNodeSequenceBlendBase : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS AnimNodeSequenceBlendBase
    TArrayNoInit<struct FAnimBlendInfo> Anims;
    //## END PROPS AnimNodeSequenceBlendBase

    DECLARE_ABSTRACT_CLASS(UAnimNodeSequenceBlendBase,UAnimNodeSequence,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);

	/** AnimSets have been updated, update all animations */
	virtual void AnimSetsUpdated();

	/** make sure animations are up date */
	virtual void CheckAnimsUpToDate();

	/** Lookup animation data for a given animation name */
	void SetAnimInfo(FName InSequenceName, FAnimInfo& InAnimInfo);
	
	/** Extract animations and do the blend. */
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
};

class UAnimNodeSequenceBlendByAim : public UAnimNodeSequenceBlendBase
{
public:
    //## BEGIN PROPS AnimNodeSequenceBlendByAim
    FVector2D Aim;
    FVector2D PreviousAim;
    FVector2D HorizontalRange;
    FVector2D VerticalRange;
    FVector2D AngleOffset;
    FName AnimName_LU;
    FName AnimName_LC;
    FName AnimName_LD;
    FName AnimName_CU;
    FName AnimName_CC;
    FName AnimName_CD;
    FName AnimName_RU;
    FName AnimName_RC;
    FName AnimName_RD;
    //## END PROPS AnimNodeSequenceBlendByAim

    void CheckAnimsUpToDate();
    DECLARE_FUNCTION(execCheckAnimsUpToDate)
    {
        P_FINISH;
        CheckAnimsUpToDate();
    }
    DECLARE_CLASS(UAnimNodeSequenceBlendByAim,UAnimNodeSequenceBlendBase,0,Engine)
	/** Override this function in a subclass, and return normalized Aim from Pawn. */
	virtual FVector2D GetAim();

	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	// For slider support	
	virtual INT GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodePlayCustomAnim : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodePlayCustomAnim
    BITFIELD bIsPlayingCustomAnim:1 GCC_BITFIELD_MAGIC;
    FLOAT CustomPendingBlendOutTime;
    //## END PROPS AnimNodePlayCustomAnim

    FLOAT PlayCustomAnim(FName AnimName,FLOAT Rate,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=FALSE);
    void PlayCustomAnimByDuration(FName AnimName,FLOAT Duration,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=FALSE);
    void StopCustomAnim(FLOAT BlendOutTime);
    DECLARE_FUNCTION(execPlayCustomAnim)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Rate);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,FALSE);
        P_FINISH;
        *(FLOAT*)Result=PlayCustomAnim(AnimName,Rate,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execPlayCustomAnimByDuration)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Duration);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,FALSE);
        P_FINISH;
        PlayCustomAnimByDuration(AnimName,Duration,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execStopCustomAnim)
    {
        P_GET_FLOAT(BlendOutTime);
        P_FINISH;
        StopCustomAnim(BlendOutTime);
    }
    DECLARE_CLASS(UAnimNodePlayCustomAnim,UAnimNodeBlend,0,Engine)
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	virtual INT GetNumSliders() const { return 0; }
};

class UAnimNodeBlendDirectional : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlendDirectional
    FLOAT DirDegreesPerSecond;
    FLOAT DirAngle;
    INT SingleAnimAtOrAboveLOD;
    //## END PROPS AnimNodeBlendDirectional

    DECLARE_CLASS(UAnimNodeBlendDirectional,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodeBlendList : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlendList
    TArrayNoInit<FLOAT> TargetWeight;
    FLOAT BlendTimeToGo;
    INT ActiveChildIndex;
    BITFIELD bPlayActiveChild:1;
    BITFIELD bForceChildFullWeightWhenBecomingRelevant:1;
    BITFIELD bSkipBlendWhenNotRendered:1;
    FLOAT SliderPosition;
    //## END PROPS AnimNodeBlendList

    virtual void SetActiveChild(INT ChildIndex,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetActiveChild)
    {
        P_GET_INT(ChildIndex);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        SetActiveChild(ChildIndex,BlendTime);
    }
    DECLARE_CLASS(UAnimNodeBlendList,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	// AnimTree editor interface
	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);

	// AnimNodeBlendBase interface
	virtual void OnAddChild(INT ChildNum);
	virtual void OnRemoveChild(INT ChildNum);

	// AnimNodeBlendList interface
};

class UAnimNodeBlendByBase : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByBase
    BYTE Type;
    FName ActorTag;
    class UClass* ActorClass;
    FLOAT BlendTime;
    class AActor* CachedBase;
    //## END PROPS AnimNodeBlendByBase

    DECLARE_CLASS(UAnimNodeBlendByBase,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByPhysics
    //## END PROPS AnimNodeBlendByPhysics

    DECLARE_CLASS(UAnimNodeBlendByPhysics,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UAnimNodeBlendByPosture : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByPosture
    //## END PROPS AnimNodeBlendByPosture

    DECLARE_CLASS(UAnimNodeBlendByPosture,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UAnimNodeBlendBySpeed : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendBySpeed
    FLOAT Speed;
    INT LastChannel;
    FLOAT BlendUpTime;
    FLOAT BlendDownTime;
    FLOAT BlendDownPerc;
    TArrayNoInit<FLOAT> Constraints;
    BITFIELD bUseAcceleration:1;
    //## END PROPS AnimNodeBlendBySpeed

    DECLARE_CLASS(UAnimNodeBlendBySpeed,UAnimNodeBlendList,0,Engine)
	// AnimNode interface
	
	/**
	 * Blend animations based on an Owner's velocity.
	 *
	 * @param DeltaSeconds	Time since last tick in seconds.
	 */
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	/**
	 * Resets the last channel on becoming active.	
	 */
	virtual void OnBecomeRelevant();

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
	
	// AnimNodeBlendBySpeed interface

	/** 
	 *	Function called to calculate the speed that should be used for this node. 
	 *	Allows subclasses to easily modify the speed used.
	 */
	 virtual FLOAT CalcSpeed();
};

struct FRandomAnimInfo
{
    FLOAT Chance;
    BYTE LoopCountMin;
    BYTE LoopCountMax;
    FLOAT BlendInTime;
    FVector2D PlayRateRange;
    BITFIELD bStillFrame:1;
    BYTE LoopCount GCC_BITFIELD_MAGIC;

    /** Constructors */
    FRandomAnimInfo() {}
    FRandomAnimInfo(EEventParm)
    {
        appMemzero(this, sizeof(FRandomAnimInfo));
    }
};

class UAnimNodeRandom : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeRandom
    TArrayNoInit<struct FRandomAnimInfo> RandomInfo;
    class UAnimNodeSequence* PlayingSeqNode;
    INT PendingChildIndex;
    //## END PROPS AnimNodeRandom

    DECLARE_CLASS(UAnimNodeRandom,UAnimNodeBlendList,0,Engine)
	virtual void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	/** A child has been added, update RandomInfo accordingly */
	virtual void OnAddChild(INT ChildNum);
	/** A child has been removed, update RandomInfo accordingly */
	virtual void OnRemoveChild(INT ChildNum);

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);

	/** Notification when node becomes relevant. */
	virtual void OnBecomeRelevant();

	INT		PickNextAnimIndex();
	void	PlayPendingAnimation(FLOAT BlendTime=0.f, FLOAT StartTime=0.f);
};

struct FChildBoneBlendInfo
{
    TArrayNoInit<FLOAT> TargetPerBoneWeight;
    FName InitTargetStartBone;
    FLOAT InitPerBoneIncrease;
    FName OldStartBone;
    FLOAT OldBoneIncrease;
    TArrayNoInit<BYTE> TargetRequiredBones;

    /** Constructors */
    FChildBoneBlendInfo() {}
    FChildBoneBlendInfo(EEventParm)
    {
        appMemzero(this, sizeof(FChildBoneBlendInfo));
    }
};

class UAnimNodeBlendMultiBone : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlendMultiBone
    TArrayNoInit<struct FChildBoneBlendInfo> BlendTargetList;
    TArrayNoInit<BYTE> SourceRequiredBones;
    //## END PROPS AnimNodeBlendMultiBone

    DECLARE_FUNCTION(execSetTargetStartBone);
    DECLARE_CLASS(UAnimNodeBlendMultiBone,UAnimNodeBlendBase,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	// AnimNodeBlendPerBone interface
	/** 
	 * Calculates total weight of children. 
	 * Set a full weight on source, because it's potentially always feeding animations into the final blend.
	 */
	virtual void SetChildrenTotalWeightAccumulator(const INT Index);

	/** Utility for creating the TargetPerBoneWeight array. Starting from the named bone, walk down the heirarchy increasing the weight by PerBoneIncrease each step. */
	virtual void SetTargetStartBone( INT TargetIdx, FName StartBoneName, FLOAT PerBoneIncrease = 1.f );
};

class UAnimNodeMirror : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeMirror
    BITFIELD bEnableMirroring:1 GCC_BITFIELD_MAGIC;
    //## END PROPS AnimNodeMirror

    DECLARE_CLASS(UAnimNodeMirror,UAnimNodeBlendBase,0,Engine)
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
};

class UAnimNodeScalePlayRate : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeScalePlayRate
    FLOAT ScaleByValue;
    //## END PROPS AnimNodeScalePlayRate

    DECLARE_CLASS(UAnimNodeScalePlayRate,UAnimNodeBlendBase,0,Engine)
	virtual void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	virtual FLOAT	GetScaleValue();
};

class UAnimNodeScaleRateBySpeed : public UAnimNodeScalePlayRate
{
public:
    //## BEGIN PROPS AnimNodeScaleRateBySpeed
    FLOAT BaseSpeed;
    //## END PROPS AnimNodeScaleRateBySpeed

    DECLARE_CLASS(UAnimNodeScaleRateBySpeed,UAnimNodeScalePlayRate,0,Engine)
	virtual FLOAT	GetScaleValue();
};

class UAnimNodeSlot : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeSlot
    BITFIELD bIsPlayingCustomAnim:1 GCC_BITFIELD_MAGIC;
    BITFIELD bEarlyAnimEndNotify:1;
    BITFIELD bSkipBlendWhenNotRendered:1;
    FLOAT PendingBlendOutTime;
    INT CustomChildIndex;
    INT TargetChildIndex;
    TArrayNoInit<FLOAT> TargetWeight;
    FLOAT BlendTimeToGo;
    class UAnimNodeSynch* SynchNode;
    //## END PROPS AnimNodeSlot

    FLOAT PlayCustomAnim(FName AnimName,FLOAT Rate,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=FALSE);
    void PlayCustomAnimByDuration(FName AnimName,FLOAT Duration,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=TRUE);
    FName GetPlayedAnimation();
    void StopCustomAnim(FLOAT BlendOutTime);
    void SetCustomAnim(FName AnimName);
    void SetActorAnimEndNotification(UBOOL bNewStatus);
    class UAnimNodeSequence* GetCustomAnimNodeSeq();
    void SetRootBoneAxisOption(BYTE AxisX=0,BYTE AxisY=0,BYTE AxisZ=0);
    void AddToSynchGroup(FName GroupName);
    DECLARE_FUNCTION(execPlayCustomAnim)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Rate);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,FALSE);
        P_FINISH;
        *(FLOAT*)Result=PlayCustomAnim(AnimName,Rate,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execPlayCustomAnimByDuration)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Duration);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,TRUE);
        P_FINISH;
        PlayCustomAnimByDuration(AnimName,Duration,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execGetPlayedAnimation)
    {
        P_FINISH;
        *(FName*)Result=GetPlayedAnimation();
    }
    DECLARE_FUNCTION(execStopCustomAnim)
    {
        P_GET_FLOAT(BlendOutTime);
        P_FINISH;
        StopCustomAnim(BlendOutTime);
    }
    DECLARE_FUNCTION(execSetCustomAnim)
    {
        P_GET_NAME(AnimName);
        P_FINISH;
        SetCustomAnim(AnimName);
    }
    DECLARE_FUNCTION(execSetActorAnimEndNotification)
    {
        P_GET_UBOOL(bNewStatus);
        P_FINISH;
        SetActorAnimEndNotification(bNewStatus);
    }
    DECLARE_FUNCTION(execGetCustomAnimNodeSeq)
    {
        P_FINISH;
        *(class UAnimNodeSequence**)Result=GetCustomAnimNodeSeq();
    }
    DECLARE_FUNCTION(execSetRootBoneAxisOption)
    {
        P_GET_BYTE_OPTX(AxisX,0);
        P_GET_BYTE_OPTX(AxisY,0);
        P_GET_BYTE_OPTX(AxisZ,0);
        P_FINISH;
        SetRootBoneAxisOption(AxisX,AxisY,AxisZ);
    }
    DECLARE_FUNCTION(execAddToSynchGroup)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        AddToSynchGroup(GroupName);
    }
    DECLARE_CLASS(UAnimNodeSlot,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);

	/** Update position of given channel */
	virtual void MAT_SetAnimPosition(INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bFireNotifies, UBOOL bLooping);
	/** Update weight of channels */
	virtual void MAT_SetAnimWeights(const FAnimSlotInfo& SlotInfo);
	/** Rename all child nodes upon Add/Remove, so they match their position in the array. */
	virtual void RenameChildConnectors();

	// AnimNode interface
	virtual	void	TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void	GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	// AnimNodeBlendBase interface
	virtual void	OnAddChild(INT ChildNum);
	virtual void	OnRemoveChild(INT ChildNum);

	virtual INT		GetNumSliders() const { return 0; }

	/**
	 * When requested to play a new animation, we need to find a new child.
	 * We'd like to find one that is unused for smooth blending, 
	 * but that may be a luxury that is not available.
	 */
	INT		FindBestChildToPlayAnim(FName AnimToPlay);

	void	SetActiveChild(INT ChildIndex, FLOAT BlendTime);
	void	UpdateWeightsForAdditiveAnimations();
};

struct FSynchGroup
{
    TArrayNoInit<class UAnimNodeSequence*> SeqNodes;
    class UAnimNodeSequence* MasterNode;
    FName GroupName;
    BITFIELD bFireSlaveNotifies:1;
    FLOAT RateScale;

    /** Constructors */
    FSynchGroup() {}
    FSynchGroup(EEventParm)
    {
        appMemzero(this, sizeof(FSynchGroup));
    }
};

class UAnimNodeSynch : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeSynch
    TArrayNoInit<struct FSynchGroup> Groups;
    //## END PROPS AnimNodeSynch

    void AddNodeToGroup(class UAnimNodeSequence* SeqNode,FName GroupName);
    void RemoveNodeFromGroup(class UAnimNodeSequence* SeqNode,FName GroupName);
    class UAnimNodeSequence* GetMasterNodeOfGroup(FName GroupName);
    void ForceRelativePosition(FName GroupName,FLOAT RelativePosition);
    FLOAT GetRelativePosition(FName GroupName);
    void SetGroupRateScale(FName GroupName,FLOAT NewRateScale);
    DECLARE_FUNCTION(execAddNodeToGroup)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_NAME(GroupName);
        P_FINISH;
        AddNodeToGroup(SeqNode,GroupName);
    }
    DECLARE_FUNCTION(execRemoveNodeFromGroup)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_NAME(GroupName);
        P_FINISH;
        RemoveNodeFromGroup(SeqNode,GroupName);
    }
    DECLARE_FUNCTION(execGetMasterNodeOfGroup)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=GetMasterNodeOfGroup(GroupName);
    }
    DECLARE_FUNCTION(execForceRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(RelativePosition);
        P_FINISH;
        ForceRelativePosition(GroupName,RelativePosition);
    }
    DECLARE_FUNCTION(execGetRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(FLOAT*)Result=GetRelativePosition(GroupName);
    }
    DECLARE_FUNCTION(execSetGroupRateScale)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(NewRateScale);
        P_FINISH;
        SetGroupRateScale(GroupName,NewRateScale);
    }
    DECLARE_CLASS(UAnimNodeSynch,UAnimNodeBlendBase,0,Engine)
	virtual void	PostLoad();
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void	TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);

	void			UpdateMasterNodeForGroup(FSynchGroup& SynchGroup);
	void			RepopulateGroups();
};

struct FAnimGroup
{
    TArrayNoInit<class UAnimNodeSequence*> SeqNodes;
    class UAnimNodeSequence* SynchMaster;
    class UAnimNodeSequence* NotifyMaster;
    FName GroupName;
    FLOAT RateScale;
    FLOAT SynchPctPosition;

    /** Constructors */
    FAnimGroup() {}
    FAnimGroup(EEventParm)
    {
        appMemzero(this, sizeof(FAnimGroup));
    }
};

struct FSkelControlListHead
{
    FName BoneName;
    class USkelControlBase* ControlHead;
    INT DrawY;

    /** Constructors */
    FSkelControlListHead() {}
    FSkelControlListHead(EEventParm)
    {
        appMemzero(this, sizeof(FSkelControlListHead));
    }
};

class UAnimTree : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimTree
    TArrayNoInit<struct FAnimGroup> AnimGroups;
    TArrayNoInit<FName> PrioritizedSkelBranches;
    TArrayNoInit<BYTE> PriorityList;
    TArrayNoInit<class UMorphNodeBase*> RootMorphNodes;
    TArrayNoInit<struct FSkelControlListHead> SkelControlLists;
    TArrayNoInit<FBoneAtom> SavedPose;
    BITFIELD bUseSavedPose:1;
    BITFIELD bBeingEdited:1;
    INT MorphConnDrawY;
    FLOAT PreviewPlayRate;
    class USkeletalMesh* PreviewSkelMesh;
    class USkeletalMesh* SocketSkelMesh;
    class UStaticMesh* SocketStaticMesh;
    FName SocketName;
    TArrayNoInit<class UAnimSet*> PreviewAnimSets;
    TArrayNoInit<class UMorphTargetSet*> PreviewMorphSets;
    FVector PreviewCamPos;
    FRotator PreviewCamRot;
    FVector PreviewFloorPos;
    INT PreviewFloorYaw;
    //## END PROPS AnimTree

    class USkelControlBase* FindSkelControl(FName InControlName);
    class UMorphNodeBase* FindMorphNode(FName InNodeName);
    void SetUseSavedPose(UBOOL bUseSaved);
    UBOOL SetAnimGroupForNode(class UAnimNodeSequence* SeqNode,FName GroupName,UBOOL bCreateIfNotFound=FALSE);
    class UAnimNodeSequence* GetGroupSynchMaster(FName GroupName);
    class UAnimNodeSequence* GetGroupNotifyMaster(FName GroupName);
    void ForceGroupRelativePosition(FName GroupName,FLOAT RelativePosition);
    FLOAT GetGroupRelativePosition(FName GroupName);
    void SetGroupRateScale(FName GroupName,FLOAT NewRateScale);
    FLOAT GetGroupRateScale(FName GroupName);
    INT GetGroupIndex(FName GroupName);
    DECLARE_FUNCTION(execFindSkelControl)
    {
        P_GET_NAME(InControlName);
        P_FINISH;
        *(class USkelControlBase**)Result=FindSkelControl(InControlName);
    }
    DECLARE_FUNCTION(execFindMorphNode)
    {
        P_GET_NAME(InNodeName);
        P_FINISH;
        *(class UMorphNodeBase**)Result=FindMorphNode(InNodeName);
    }
    DECLARE_FUNCTION(execSetUseSavedPose)
    {
        P_GET_UBOOL(bUseSaved);
        P_FINISH;
        SetUseSavedPose(bUseSaved);
    }
    DECLARE_FUNCTION(execSetAnimGroupForNode)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_NAME(GroupName);
        P_GET_UBOOL_OPTX(bCreateIfNotFound,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetAnimGroupForNode(SeqNode,GroupName,bCreateIfNotFound);
    }
    DECLARE_FUNCTION(execGetGroupSynchMaster)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=GetGroupSynchMaster(GroupName);
    }
    DECLARE_FUNCTION(execGetGroupNotifyMaster)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=GetGroupNotifyMaster(GroupName);
    }
    DECLARE_FUNCTION(execForceGroupRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(RelativePosition);
        P_FINISH;
        ForceGroupRelativePosition(GroupName,RelativePosition);
    }
    DECLARE_FUNCTION(execGetGroupRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(FLOAT*)Result=GetGroupRelativePosition(GroupName);
    }
    DECLARE_FUNCTION(execSetGroupRateScale)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(NewRateScale);
        P_FINISH;
        SetGroupRateScale(GroupName,NewRateScale);
    }
    DECLARE_FUNCTION(execGetGroupRateScale)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(FLOAT*)Result=GetGroupRateScale(GroupName);
    }
    DECLARE_FUNCTION(execGetGroupIndex)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(INT*)Result=GetGroupIndex(GroupName);
    }
    DECLARE_CLASS(UAnimTree,UAnimNodeBlendBase,0,Engine)
	virtual void	InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual void	GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);

	/** Optimisation way to see if this is a UAnimTree */
	virtual UAnimTree* GetAnimTree() { return this; }


	void			UpdateAnimNodeSeqGroups(FLOAT DeltaSeconds);
	void			UpdateMasterNodesForGroup(FAnimGroup& AnimGroup);
	void			RepopulateAnimGroups();

	void			PostEditChange(UProperty* PropertyThatChanged);

	/** Get all SkelControls within this AnimTree. */
	void			GetSkelControls(TArray<USkelControlBase*>& OutControls);

	/** Get all MorphNodes within this AnimTree. */
	void			GetMorphNodes(TArray<class UMorphNodeBase*>& OutNodes);

	/** Call InitMorph on all morph nodes attached to the tree. */
	void			InitTreeMorphNodes(USkeletalMeshComponent* InSkelComp);

	/** Calls GetActiveMorphs on each element of the RootMorphNodes array. */
	void			GetTreeActiveMorphs(TArray<FActiveMorph>& OutMorphs);

	/** Make a copy of entire tree, including all AnimNodes and SkelControls. */
	UAnimTree*		CopyAnimTree(UObject* NewTreeOuter);

	/** Utility function for copying a selection of nodes, maintaining any references between them, but leaving any external references. */
	static void		CopyAnimNodes(const TArray<class UAnimNode*>& SrcNodes, UObject* NewOuter, TArray<class UAnimNode*>& DestNodes, TMap<class UAnimNode*,class UAnimNode*>& SrcToDestNodeMap);

	/** Utility function for copying a selection of controls, maintaining any references between them, but leaving any external references. */
	static void		CopySkelControls(const TArray<class USkelControlBase*>& SrcControls, UObject* NewOuter, TArray<class USkelControlBase*>& DestControls, TMap<class USkelControlBase*,class USkelControlBase*>& SrcToDestControlMap);

	/** Utility function for copying a selection of morph nodes, maintaining any references between them, but leaving any external references. */
	static void		CopyMorphNodes(const TArray<class UMorphNodeBase*>& SrcNodes, UObject* NewOuter, TArray<class UMorphNodeBase*>& DestNodes, TMap<class UMorphNodeBase*,class UMorphNodeBase*>& SrcToDestNodeMap);


	// UAnimNode interface
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	/** 
	* Draws this node in the AnimTreeEditor.
	*
	* @param	Canvas			The canvas to use.
	* @param	bSelected		TRUE if this node is selected.
	* @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	* @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	*/
	virtual void DrawAnimNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bShowWeight, UBOOL bCurves);
};

class UMorphNodeBase : public UAnimObject
{
public:
    //## BEGIN PROPS MorphNodeBase
    FName NodeName;
    BITFIELD bDrawSlider:1;
    //## END PROPS MorphNodeBase

    DECLARE_ABSTRACT_CLASS(UMorphNodeBase,UAnimObject,0,Engine)
	/** Add to array all the active morphs below this one, including their weight. */
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs) {}
	
	/** Do any initialisation necessary for this MorphNode. */
	virtual void InitMorphNode(USkeletalMeshComponent* InSkelComp);

	/** Add all nodes at or below this one to the output array. */
	virtual void GetNodes(TArray<UMorphNodeBase*>& OutNodes);

	// EDITOR	
	
	/** 
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	bSelected		TRUE if this node is selected.
	 * @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	 */
	virtual void DrawMorphNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bCurves) {}

	/** Get location of a connection of a particular type. */
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);	
	
	/** Return current position of slider for this node in the AnimTreeEditor. Return value should be within 0.0 to 1.0 range. */
	virtual FLOAT GetSliderPosition() { return 0.f; }

	/** Called when slider is moved in the AnimTreeEditor. NewSliderValue is in range 0.0 to 1.0. */
	virtual void HandleSliderMove(FLOAT NewSliderValue) {}	

	/** Render on 3d viewport when node is selected. */
	virtual void Render(const FSceneView* View, FPrimitiveDrawInterface* PDI) {}
	/** Draw on 3d viewport canvas when node is selected */
	virtual void Draw(FViewport* Viewport, FCanvas* Canvas, const FSceneView* View) {}
};

class UMorphNodePose : public UMorphNodeBase
{
public:
    //## BEGIN PROPS MorphNodePose
    class UMorphTarget* Target;
    FName MorphName;
    FLOAT Weight;
    //## END PROPS MorphNodePose

    void SetMorphTarget(FName MorphTargetName);
    DECLARE_FUNCTION(execSetMorphTarget)
    {
        P_GET_NAME(MorphTargetName);
        P_FINISH;
        SetMorphTarget(MorphTargetName);
    }
    DECLARE_CLASS(UMorphNodePose,UMorphNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// MorphNodeBase interface
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	virtual void InitMorphNode(USkeletalMeshComponent* InSkelComp);

	/** 
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	bSelected		TRUE if this node is selected.
	 * @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	 */	
	virtual void DrawMorphNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bCurves);
};

struct FMorphNodeConn
{
    TArrayNoInit<class UMorphNodeBase*> ChildNodes;
    FName ConnName;
    INT DrawY;

    /** Constructors */
    FMorphNodeConn() {}
    FMorphNodeConn(EEventParm)
    {
        appMemzero(this, sizeof(FMorphNodeConn));
    }
};

class UMorphNodeWeightBase : public UMorphNodeBase
{
public:
    //## BEGIN PROPS MorphNodeWeightBase
    TArrayNoInit<struct FMorphNodeConn> NodeConns;
    //## END PROPS MorphNodeWeightBase

    DECLARE_ABSTRACT_CLASS(UMorphNodeWeightBase,UMorphNodeBase,0,Engine)
	virtual void GetNodes(TArray<UMorphNodeBase*>& OutNodes);

	/** 
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	bSelected		TRUE if this node is selected.
	 * @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	 */	
	virtual void DrawMorphNode(FCanvas* Canvas, UBOOL bSelected, UBOOL bCurves);

	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);
};

class UMorphNodeWeight : public UMorphNodeWeightBase
{
public:
    //## BEGIN PROPS MorphNodeWeight
    FLOAT NodeWeight;
    //## END PROPS MorphNodeWeight

    virtual void SetNodeWeight(FLOAT NewWeight);
    DECLARE_FUNCTION(execSetNodeWeight)
    {
        P_GET_FLOAT(NewWeight);
        P_FINISH;
        SetNodeWeight(NewWeight);
    }
    DECLARE_CLASS(UMorphNodeWeight,UMorphNodeWeightBase,0,Engine)
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	
	virtual FLOAT GetSliderPosition();
	virtual void HandleSliderMove(FLOAT NewSliderValue);
};

class USkelControlBase : public UAnimObject
{
public:
    //## BEGIN PROPS SkelControlBase
    FName ControlName;
    FLOAT ControlStrength;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    BYTE BlendType;
    FLOAT StrengthTarget;
    FLOAT BlendTimeToGo;
    BITFIELD bSetStrengthFromAnimNode:1;
    BITFIELD bInitializedCachedNodeList:1;
    BITFIELD bPropagateSetActive:1;
    BITFIELD bIgnoreWhenNotRendered:1;
    BITFIELD bEnableEaseInOut:1;
    TArrayNoInit<FName> StrengthAnimNodeNameList;
    TArrayNoInit<class UAnimNode*> CachedNodeList;
    FLOAT BoneScale;
    INT ControlTickTag;
    INT IgnoreAtOrAboveLOD;
    class USkelControlBase* NextControl;
    INT ControlPosX;
    INT ControlPosY;
    //## END PROPS SkelControlBase

    void SetSkelControlActive(UBOOL bInActive);
    void SetSkelControlStrength(FLOAT NewStrength,FLOAT InBlendTime);
    DECLARE_FUNCTION(execSetSkelControlActive)
    {
        P_GET_UBOOL(bInActive);
        P_FINISH;
        SetSkelControlActive(bInActive);
    }
    DECLARE_FUNCTION(execSetSkelControlStrength)
    {
        P_GET_FLOAT(NewStrength);
        P_GET_FLOAT(InBlendTime);
        P_FINISH;
        SetSkelControlStrength(NewStrength,InBlendTime);
    }
    DECLARE_ABSTRACT_CLASS(USkelControlBase,UAnimObject,0,Engine)
	/**
	*	Called from the SkeletalMeshComponent Tick function, to allow SkelControls to do any time-based update,
	*	such as adjusting their current blend amount.
	*/
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);

	/**
	*	Get the array of bones that this controller affects. Must be in hierarchy order, that is, parents before children.
	*/
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices) {}

	/**
	*	Calculate the new component-space transforms for the affected bones.
	*	The output array OutBoneTransforms must correspond to the OutBoneIndices array returned above (be in the same order etc).
	*/
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms) {}

	/**
	*	Allows you to modify the scaling of all affected bones.
	*	The output array OutBoneScales must correspond to the OutBoneIndices array returned above (be in the same order etc).
	*/
	virtual void CalculateNewBoneScales(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FLOAT>& OutBoneScales) {}

	/** Allows you to modify the scaling of the controller bone. */
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp) { return BoneScale; }

	// UObject functions
	virtual void PostLoad();

	// UTILS

	/** Utility function for turning axis indicator enum into direction vector, possibly inverted. */
	static FVector GetAxisDirVector(BYTE InAxis, UBOOL bInvert);

	/**
	*	Create a matrix given two arbitrary rows of it.
	*	We generate the missing row using another cross product, but we have to get the order right to avoid changing handedness.
	*/
	static FMatrix BuildMatrixFromVectors(BYTE Vec1Axis, const FVector& Vec1, BYTE Vec2Axis, const FVector& Vec2);

	/** Given two unit direction vectors, find the axis and angle between them. */
	static void FindAxisAndAngle(const FVector& A, const FVector& B, FVector& OutAxis, FLOAT& OutAngle);

	// ANIMTREE EDITOR SUPPORT

	/**
	* Draw this SkelControl in the AnimTreeEditor.
	*
	* @param	Canvas			The canvas to use.
	* @param	bSelected		TRUE if this node is selected.
	* @param	bCurves			If TRUE, render links as splines; if FALSE, render links as straight lines.
	*/
	virtual void DrawSkelControl(FCanvas* Canvas, UBOOL bSelected, UBOOL bCurves);

	/** For editor use. */
	FIntPoint GetConnectionLocation(INT ConnType);

	/** If we should draw manipulation widget in 3D viewport. */
	virtual INT GetWidgetCount() { return 0; }

	/** The transform to use when drawing the widget, in world space. */
	virtual FMatrix GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex) { return FMatrix::Identity; }

	/** Update properties of this controller based on the widget being manipulated in the 3D viewport. */
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec) {}

	/** Extra function for drawing special debug info in the 3D viewport if desired. */
	virtual void DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex) {}

	/** Called when slider is moved in the AnimTreeEditor. NewSliderValue is in range 0.0 to 1.0. */
	void HandleControlSliderMove(FLOAT NewSliderValue);

	/**
	* Get Alpha for this control. By default it is ControlStrength.
	* 0.f means no effect, 1.f means full effect.
	* ControlStrength controls whether or not CalculateNewBoneTransforms() is called.
	* By modifying GetControlAlpha() you can still get CalculateNewBoneTransforms() called
	* but not have the controller's effect applied on the mesh.
	* This is useful for cases where you need to have the skeleton built in mesh space
	* for testing, which is not available in TickSkelControl().
	*/
	virtual FLOAT	GetControlAlpha();

	/* Returns Final Blend Control Alpha based on Blend Type*/
	FORCEINLINE FLOAT GetBlendControlAlpha(FLOAT ControlAlpha);

	/** Used by high level systems to assign a 'target' for a generic control. One example is the ControlTargets array in SkeletalMeshActor. */
	virtual void SetControlTargetLocation(const FVector& TargetLocation) {}
};

class USkelControlLimb : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlLimb
    FVector EffectorLocation;
    BYTE EffectorLocationSpace;
    BYTE JointTargetLocationSpace;
    BYTE BoneAxis;
    BYTE JointAxis;
    FName EffectorSpaceBoneName;
    FVector JointTargetLocation;
    FName JointTargetSpaceBoneName;
    BITFIELD bInvertBoneAxis:1;
    BITFIELD bInvertJointAxis:1;
    BITFIELD bMaintainEffectorRelRot:1;
    BITFIELD bTakeRotationFromEffectorSpace:1;
    BITFIELD bAllowStretching:1;
    FVector2D StretchLimits;
    FName StretchRollBoneName;
    //## END PROPS SkelControlLimb

    DECLARE_CLASS(USkelControlLimb,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	

	virtual INT GetWidgetCount();
	virtual FMatrix GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
	virtual void DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

class USkelControlFootPlacement : public USkelControlLimb
{
public:
    //## BEGIN PROPS SkelControlFootPlacement
    FLOAT FootOffset;
    BYTE FootUpAxis;
    FRotator FootRotOffset;
    BITFIELD bInvertFootUpAxis:1;
    BITFIELD bOrientFootToGround:1;
    BITFIELD bOnlyEnableForUpAdjustment:1;
    FLOAT MaxUpAdjustment;
    FLOAT MaxDownAdjustment;
    FLOAT MaxFootOrientAdjust;
    //## END PROPS SkelControlFootPlacement

    DECLARE_CLASS(USkelControlFootPlacement,USkelControlLimb,0,Engine)
	// USkelControlBase interface
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
};

class USkelControlLookAt : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlLookAt
    FVector TargetLocation;
    BYTE TargetLocationSpace;
    BYTE LookAtAxis;
    BYTE UpAxis;
    BYTE AllowRotationSpace;
    FName TargetSpaceBoneName;
    BITFIELD bInvertLookAtAxis:1;
    BITFIELD bDefineUpAxis:1;
    BITFIELD bInvertUpAxis:1;
    BITFIELD bEnableLimit:1;
    BITFIELD bLimitBasedOnRefPose:1;
    BITFIELD bDisableBeyondLimit:1;
    BITFIELD bNotifyBeyondLimit:1;
    BITFIELD bShowLimit:1;
    BITFIELD bAllowRotationX:1;
    BITFIELD bAllowRotationY:1;
    BITFIELD bAllowRotationZ:1;
    FLOAT TargetLocationInterpSpeed;
    FVector DesiredTargetLocation;
    FLOAT MaxAngle;
    FLOAT OuterMaxAngle;
    FLOAT DeadZoneAngle;
    FName AllowRotationOtherBoneName;
    FLOAT LookAtAlpha;
    FLOAT LookAtAlphaTarget;
    FLOAT LookAtAlphaBlendTimeToGo;
    FVector LimitLookDir;
    FVector BaseLookDir;
    FVector BaseBonePos;
    FLOAT LastCalcTime;
    //## END PROPS SkelControlLookAt

    void SetTargetLocation(FVector NewTargetLocation);
    void InterpolateTargetLocation(FLOAT DeltaTime);
    void SetLookAtAlpha(FLOAT DesiredAlpha,FLOAT DesiredBlendTime);
    UBOOL CanLookAtPoint(FVector PointLoc,UBOOL bDrawDebugInfo=FALSE,UBOOL bDebugUsePersistentLines=FALSE,UBOOL bDebugFlushLinesFirst=FALSE);
    DECLARE_FUNCTION(execSetTargetLocation)
    {
        P_GET_STRUCT(FVector,NewTargetLocation);
        P_FINISH;
        SetTargetLocation(NewTargetLocation);
    }
    DECLARE_FUNCTION(execInterpolateTargetLocation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        InterpolateTargetLocation(DeltaTime);
    }
    DECLARE_FUNCTION(execSetLookAtAlpha)
    {
        P_GET_FLOAT(DesiredAlpha);
        P_GET_FLOAT(DesiredBlendTime);
        P_FINISH;
        SetLookAtAlpha(DesiredAlpha,DesiredBlendTime);
    }
    DECLARE_FUNCTION(execCanLookAtPoint)
    {
        P_GET_STRUCT(FVector,PointLoc);
        P_GET_UBOOL_OPTX(bDrawDebugInfo,FALSE);
        P_GET_UBOOL_OPTX(bDebugUsePersistentLines,FALSE);
        P_GET_UBOOL_OPTX(bDebugFlushLinesFirst,FALSE);
        P_FINISH;
        *(UBOOL*)Result=CanLookAtPoint(PointLoc,bDrawDebugInfo,bDebugUsePersistentLines,bDebugFlushLinesFirst);
    }
    DECLARE_CLASS(USkelControlLookAt,USkelControlBase,0,Engine)
	// USkelControlBase interface
	/** LookAtAlpha allows to cancel head look when going beyond boundaries */
	virtual	FLOAT	GetControlAlpha();
	virtual void	TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void	GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void	CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
	
	virtual INT		GetWidgetCount() { return 1; }
	virtual FMatrix GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void	HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
	virtual void	DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);

	virtual void SetControlTargetLocation(const FVector& InTargetLocation);

protected:
	virtual UBOOL	ApplyLookDirectionLimits(FVector& DesiredLookDir, const FVector &CurrentLookDir, INT BoneIndex, USkeletalMeshComponent* SkelComp);

public:
};

class USkelControlSingleBone : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlSingleBone
    BITFIELD bApplyTranslation:1;
    BITFIELD bAddTranslation:1;
    BITFIELD bApplyRotation:1;
    BITFIELD bAddRotation:1;
    FVector BoneTranslation;
    BYTE BoneTranslationSpace;
    BYTE BoneRotationSpace;
    FName TranslationSpaceBoneName;
    FRotator BoneRotation;
    FName RotationSpaceBoneName;
    //## END PROPS SkelControlSingleBone

    DECLARE_CLASS(USkelControlSingleBone,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	

	virtual INT GetWidgetCount();
	virtual FMatrix GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
};

class USkelControlWheel : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS SkelControlWheel
    FLOAT WheelDisplacement;
    FLOAT WheelMaxRenderDisplacement;
    FLOAT WheelRoll;
    BYTE WheelRollAxis;
    BYTE WheelSteeringAxis;
    FLOAT WheelSteering;
    BITFIELD bInvertWheelRoll:1;
    BITFIELD bInvertWheelSteering:1;
    //## END PROPS SkelControlWheel

    DECLARE_CLASS(USkelControlWheel,USkelControlSingleBone,0,Engine)
	// SkelControlWheel interface
	void UpdateWheelControl( FLOAT InDisplacement, FLOAT InRoll, FLOAT InSteering );
	void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class USkelControlSpline : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlSpline
    INT SplineLength;
    BYTE SplineBoneAxis;
    BYTE BoneRotMode;
    BITFIELD bInvertSplineBoneAxis:1 GCC_BITFIELD_MAGIC;
    FLOAT EndSplineTension;
    FLOAT StartSplineTension;
    //## END PROPS SkelControlSpline

    DECLARE_CLASS(USkelControlSpline,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
};

class USkelControlTrail : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlTrail
    INT ChainLength;
    BYTE ChainBoneAxis;
    BITFIELD bInvertChainBoneAxis:1 GCC_BITFIELD_MAGIC;
    BITFIELD bLimitStretch:1;
    BITFIELD bActorSpaceFakeVel:1;
    BITFIELD bHadValidStrength:1;
    FLOAT TrailRelaxation;
    FLOAT StretchLimit;
    FVector FakeVelocity;
    FLOAT ThisTimstep;
    TArrayNoInit<FVector> TrailBoneLocations;
    FMatrix OldLocalToWorld;
    //## END PROPS SkelControlTrail

    DECLARE_CLASS(USkelControlTrail,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);	
};

struct FAnimNotifyEvent
{
    FLOAT Time;
    class UAnimNotify* Notify;
    FName Comment;

    /** Constructors */
    FAnimNotifyEvent() {}
    FAnimNotifyEvent(EEventParm)
    {
        appMemzero(this, sizeof(FAnimNotifyEvent));
    }
};

struct FRawAnimSequenceTrack
{
    TArrayNoInit<FVector> PosKeys;
    TArrayNoInit<FQuat> RotKeys;
    TArrayNoInit<FLOAT> KeyTimes;

    /** Constructors */
    FRawAnimSequenceTrack() {}
    FRawAnimSequenceTrack(EEventParm)
    {
        appMemzero(this, sizeof(FRawAnimSequenceTrack));
    }
};

struct FTranslationTrack
{
    TArrayNoInit<FVector> PosKeys;
    TArrayNoInit<FLOAT> Times;

    /** Constructors */
    FTranslationTrack() {}
    FTranslationTrack(EEventParm)
    {
        appMemzero(this, sizeof(FTranslationTrack));
    }
};

struct FRotationTrack
{
    TArrayNoInit<FQuat> RotKeys;
    TArrayNoInit<FLOAT> Times;

    /** Constructors */
    FRotationTrack() {}
    FRotationTrack(EEventParm)
    {
        appMemzero(this, sizeof(FRotationTrack));
    }
};

struct FCompressedTrack
{
    TArrayNoInit<BYTE> ByteStream;
    TArrayNoInit<FLOAT> Times;
    FLOAT Mins[3];
    FLOAT Ranges[3];

    /** Constructors */
    FCompressedTrack() {}
    FCompressedTrack(EEventParm)
    {
        appMemzero(this, sizeof(FCompressedTrack));
    }
};

class UAnimSequence : public UObject
{
public:
    //## BEGIN PROPS AnimSequence
    FName SequenceName;
    TArrayNoInit<struct FAnimNotifyEvent> Notifies;
    FLOAT SequenceLength;
    INT NumFrames;
    FLOAT RateScale;
    BITFIELD bNoLoopingInterpolation:1;
    BITFIELD bIsAdditive:1;
    BITFIELD bDoNotOverrideCompression:1;
    TArrayNoInit<struct FRawAnimSequenceTrack> RawAnimData;
    TArrayNoInit<struct FTranslationTrack> TranslationData;
    TArrayNoInit<struct FRotationTrack> RotationData;
    class UAnimationCompressionAlgorithm* CompressionScheme;
    BYTE TranslationCompressionFormat;
    BYTE RotationCompressionFormat;
    BYTE KeyEncodingFormat;
    TArrayNoInit<INT> CompressedTrackOffsets;
    TArrayNoInit<BYTE> CompressedByteStream;
    FPointer TranslationCodec;
    FPointer RotationCodec;
    TArrayNoInit<FBoneAtom> AdditiveRefPose;
    FName AdditiveRefName;
    INT EncodingPkgVersion;
    //## END PROPS AnimSequence

    DECLARE_CLASS(UAnimSequence,UObject,0,Engine)
	// UObject interface

	virtual void Serialize(FArchive& Ar);
	virtual void PreSave();
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void BeginDestroy();

	/**
	 * Used by various commandlets to purge Editor only data from the object.
	 * 
	 * @param TargetPlatform Platform the object will be saved for (ie PC vs console cooking, etc)
	 */
	virtual void StripData(UE3::EPlatformType TargetPlatform);

	// AnimSequence interface

	/**
	 * Reconstructs a bone atom from key-reduced tracks.
	 */
	static void ReconstructBoneAtom(FBoneAtom& OutAtom,
									const FTranslationTrack& TranslationTrack,
									const FRotationTrack& RotationTrack,
									FLOAT SequenceLength,
									FLOAT Time,
									UBOOL bLooping);

	/**
	 * Reconstructs a bone atom from compressed tracks.
	 */
	static void ReconstructBoneAtom(FBoneAtom& OutAtom,
									const FCompressedTrack& TranslationTrack,
									const FCompressedTrack& RotationTrack,
									AnimationCompressionFormat TranslationCompressionFormat,
									AnimationCompressionFormat RotationCompressionFormat,
									FLOAT SequenceLength,
									FLOAT Time,
									UBOOL bLooping);

	/**
	 * Reconstructs a bone atom from compressed tracks.
	 */
	static void ReconstructBoneAtom(FBoneAtom& OutAtom,
									const BYTE* TransStream,
									INT NumTransKeys,
									const BYTE* RotStream,
									INT NumRotKeys,
									AnimationCompressionFormat TranslationCompressionFormat,
									AnimationCompressionFormat RotationCompressionFormat,
									FLOAT SequenceLength,
									FLOAT Time,
									UBOOL bLooping);

	/**
	 * Decompresses a translation key from the specified compressed translation track.
	 */
	static void ReconstructTranslation(class FVector& Out, const BYTE* Stream, INT KeyIndex, AnimationCompressionFormat TranslationCompressionFormat);

	/**
	 * Decompresses a rotation key from the specified compressed rotation track.
	 */
	static void ReconstructRotation(class FQuat& Out, const BYTE* Stream, INT KeyIndex, AnimationCompressionFormat RotationCompressionFormat, const FLOAT *Mins, const FLOAT *Ranges);

	/**
	 * Decompresses a translation key from the specified compressed translation track.
	 */
	static void ReconstructTranslation(class FVector& Out, const BYTE* Stream, INT KeyIndex);

	/**
	 * Decompresses a rotation key from the specified compressed rotation track.
	 */
	static void ReconstructRotation(class FQuat& Out, const BYTE* Stream, INT KeyIndex, UBOOL bTrackHasCompressionInfo, AnimationCompressionFormat RotationCompressionFormat);

	/**
	 * Populates the key reduced arrays from raw animation data.
	 */
	static void SeparateRawDataToTracks(const TArray<FRawAnimSequenceTrack>& RawAnimData,
										FLOAT SequenceLength,
										TArray<FTranslationTrack>& OutTranslationData,
										TArray<FRotationTrack>& OutRotationData);

	/**
	 * Interpolate keyframes in this sequence to find the bone transform (relative to parent).
	 * 
	 * @param	OutAtom			[out] Output bone transform.
	 * @param	TrackIndex		Index of track to interpolate.
	 * @param	Time			Time on track to interpolate to.
	 * @param	bLooping		TRUE if the animation is looping.
	 * @param	bUseRawData		If TRUE, use raw animation data instead of compressed data.
	 */
	void GetBoneAtom(FBoneAtom& OutAtom, INT TrackIndex, FLOAT Time, UBOOL bLooping, UBOOL bUseRawData) const;

	/** Sort the Notifies array by time, earliest first. */
	void SortNotifies();

	/**
	 * @return		A reference to the AnimSet this sequence belongs to.
	 */
	UAnimSet* GetAnimSet() const;

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	/**
	 * @return		The approximate size of raw animation data.
	 */
	INT GetApproxRawSize() const;

	/**
	 * @return		The approximate size of key-reduced animation data.
	 */
	INT GetApproxReducedSize() const;

	/**
	 * @return		The approximate size of compressed animation data.
	 */
	INT GetApproxCompressedSize() const;
	
	/**
	 * Crops the raw anim data either from Start to CurrentTime or CurrentTime to End depending on 
	 * value of bFromStart.  Can't be called against cooked data.
	 *
	 * @param	CurrentTime		marker for cropping (either beginning or end)
	 * @param	bFromStart		whether marker is begin or end marker
	 * @return					TRUE if the operation was successful.
	 */
	UBOOL CropRawAnimData( FLOAT CurrentTime, UBOOL bFromStart );

	/** Clears any data in the AnimSequence, so it can be recycled when importing a new animation with same name over it. */
	void RecycleAnimSequence();
};

struct FAnimSetMeshLinkup
{
    FGuid SkelMeshLinkupGUID;
    TArrayNoInit<INT> BoneToTrackTable;
    TArrayNoInit<BYTE> BoneUseAnimTranslation;
    TArrayNoInit<BYTE> ForceUseMeshTranslation;

		/** Reset this linkup and re-create between the provided skeletal mesh and anim set. */
		void BuildLinkup(USkeletalMesh* InSkelMesh, UAnimSet* InAnimSet);
	
};

class UAnimSet : public UObject
{
public:
    //## BEGIN PROPS AnimSet
    BITFIELD bAnimRotationOnly:1;
    TArrayNoInit<FName> TrackBoneNames;
    TArrayNoInit<class UAnimSequence*> Sequences;
    TArrayNoInit<struct FAnimSetMeshLinkup> LinkupCache;
    TArrayNoInit<FName> UseTranslationBoneNames;
    TArrayNoInit<FName> ForceMeshTranslationBoneNames;
    FName PreviewSkelMeshName;
    class USkeletalMesh* PreviewSkelMesh;
    FName SkeletonName;
    //## END PROPS AnimSet

    DECLARE_CLASS(UAnimSet,UObject,0,Engine)
	/**
	 * Serialize code for calculating memory usage
	 */
	virtual void Serialize( FArchive& Ar );

	// UObject interface
	virtual void PostLoad();

	// UAnimSet interface

	/**
	 * See if we can play sequences from this AnimSet on the provided SkeletalMesh.
	 * Returns true if there is a bone in SkelMesh for every track in the AnimSet,
	 * or there is a track of animation for every bone of the SkelMesh.
	 * 
	 * @param	SkelMesh	SkeletalMesh to compare the AnimSet against.
	 * @return				TRUE if animation set can play on supplied SkeletalMesh, FALSE if not.
	 */
	UBOOL CanPlayOnSkeletalMesh(USkeletalMesh* SkelMesh) const;

	/** Get Ratio of how much that mesh fits that animation set */
	FLOAT GetSkeletalMeshMatchRatio(USkeletalMesh* SkelMesh) const;

	/**
	 * Returns the AnimSequence with the specified name in this set.
	 * 
	 * @param		SequenceName	Name of sequence to find.
	 * @return						Pointer to AnimSequence with desired name, or NULL if sequence was not found.
	 */
	UAnimSequence* FindAnimSequence(FName SequenceName) const;

	/** 
	 * Find a mesh linkup table (mapping of sequence tracks to bone indices) for a particular SkeletalMesh
	 * If one does not already exist, create it now.
	 */
	INT GetMeshLinkupIndex(USkeletalMesh* SkelMesh);

	/**
	 * @return		The track index for the bone with the supplied name, or INDEX_NONE if no track exists for that bone.
	 */
	INT FindTrackWithName(FName BoneName) const
	{
		return TrackBoneNames.FindItemIndex( BoneName );
	}

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();

	/**
	 * Clears all sequences and resets the TrackBoneNames table.
	 */
	void ResetAnimSet();

	/** Util that find all AnimSets and flushes their LinkupCache, then calls InitAnimTree on all SkeletalMeshComponents. */
	static void ClearAllAnimSetLinkupCaches();
};

class UMorphTargetSet : public UObject
{
public:
    //## BEGIN PROPS MorphTargetSet
    TArrayNoInit<class UMorphTarget*> Targets;
    class USkeletalMesh* BaseSkelMesh;
    //## END PROPS MorphTargetSet

    class UMorphTarget* FindMorphTarget(FName MorphTargetName);
    DECLARE_FUNCTION(execFindMorphTarget)
    {
        P_GET_NAME(MorphTargetName);
        P_FINISH;
        *(class UMorphTarget**)Result=FindMorphTarget(MorphTargetName);
    }
    DECLARE_CLASS(UMorphTargetSet,UObject,0,Engine)
	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();
};

class UMorphWeightSequence : public UObject
{
public:
    //## BEGIN PROPS MorphWeightSequence
    //## END PROPS MorphWeightSequence

    DECLARE_CLASS(UMorphWeightSequence,UObject,0,Engine)
	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();
};

#endif // !INCLUDED_ENGINE_ANIM_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UAnimNode,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNode,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNode,-1,execFindAnimNode);
AUTOGENERATE_FUNCTION(UAnimNodeAimOffset,-1,execSetActiveProfileByIndex);
AUTOGENERATE_FUNCTION(UAnimNodeAimOffset,-1,execSetActiveProfileByName);
AUTOGENERATE_FUNCTION(UAnimNodeBlend,-1,execSetBlendTarget);
AUTOGENERATE_FUNCTION(UAnimNodeBlendBase,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNodeBlendBase,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNodeBlendList,-1,execSetActiveChild);
AUTOGENERATE_FUNCTION(UAnimNodeBlendMultiBone,-1,execSetTargetStartBone);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execGetActiveChild);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execGetAnimName);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execBlendToLoopingAnim);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execPlayOneShotAnim);
AUTOGENERATE_FUNCTION(UAnimNodePlayCustomAnim,-1,execStopCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodePlayCustomAnim,-1,execPlayCustomAnimByDuration);
AUTOGENERATE_FUNCTION(UAnimNodePlayCustomAnim,-1,execPlayCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetTimeLeft);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetAnimPlaybackLength);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetGlobalPlayRate);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execFindNormalizedPositionFromGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetNormalizedPosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetPosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequenceBlendByAim,-1,execCheckAnimsUpToDate);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execAddToSynchGroup);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetRootBoneAxisOption);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execGetCustomAnimNodeSeq);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetActorAnimEndNotification);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execStopCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execGetPlayedAnimation);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execPlayCustomAnimByDuration);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execPlayCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execSetGroupRateScale);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execGetRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execForceRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execGetMasterNodeOfGroup);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execRemoveNodeFromGroup);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execAddNodeToGroup);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupIndex);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupRateScale);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execSetGroupRateScale);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execForceGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupNotifyMaster);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupSynchMaster);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execSetAnimGroupForNode);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execSetUseSavedPose);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execFindMorphNode);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execFindSkelControl);
AUTOGENERATE_FUNCTION(ACrowdAgent,-1,execPlayDeath);
AUTOGENERATE_FUNCTION(UMorphNodePose,-1,execSetMorphTarget);
AUTOGENERATE_FUNCTION(UMorphNodeWeight,-1,execSetNodeWeight);
AUTOGENERATE_FUNCTION(UMorphTargetSet,-1,execFindMorphTarget);
AUTOGENERATE_FUNCTION(USkelControlBase,-1,execSetSkelControlStrength);
AUTOGENERATE_FUNCTION(USkelControlBase,-1,execSetSkelControlActive);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execCanLookAtPoint);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execSetLookAtAlpha);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execInterpolateTargetLocation);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execSetTargetLocation);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetSkelControlScale);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetMorphWeight);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_FinishAnimControl);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetAnimWeights);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetAnimPosition);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_BeginAnimControl);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_ANIM_NATIVE_DEFS
#define ENGINE_ANIM_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UAnimationCompressionAlgorithm);
DECLARE_NATIVE_TYPE(Engine,UAnimationCompressionAlgorithm_BitwiseCompressOnly);
DECLARE_NATIVE_TYPE(Engine,UAnimationCompressionAlgorithm_RemoveEverySecondKey);
DECLARE_NATIVE_TYPE(Engine,UAnimationCompressionAlgorithm_RemoveLinearKeys);
DECLARE_NATIVE_TYPE(Engine,UAnimationCompressionAlgorithm_RemoveTrivialKeys);
DECLARE_NATIVE_TYPE(Engine,UAnimationCompressionAlgorithm_RevertToRaw);
DECLARE_NATIVE_TYPE(Engine,UAnimNode);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeAdditiveBlending);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeAimOffset);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlend);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendBase);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendByBase);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendByPhysics);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendByPosture);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendBySpeed);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendDirectional);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendList);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendMultiBone);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendPerBone);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeCrossfader);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeMirror);
DECLARE_NATIVE_TYPE(Engine,UAnimNodePlayCustomAnim);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeRandom);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeScalePlayRate);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeScaleRateBySpeed);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeSequence);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeSequenceBlendBase);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeSequenceBlendByAim);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeSlot);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeSynch);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_CameraEffect);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_Footstep);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_PlayParticleEffect);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_Rumble);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_Script);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_Scripted);
DECLARE_NATIVE_TYPE(Engine,UAnimNotify_Sound);
DECLARE_NATIVE_TYPE(Engine,UAnimObject);
DECLARE_NATIVE_TYPE(Engine,UAnimSequence);
DECLARE_NATIVE_TYPE(Engine,UAnimSet);
DECLARE_NATIVE_TYPE(Engine,UAnimTree);
DECLARE_NATIVE_TYPE(Engine,ACrowdAgent);
DECLARE_NATIVE_TYPE(Engine,ACrowdAttractor);
DECLARE_NATIVE_TYPE(Engine,UMorphNodeBase);
DECLARE_NATIVE_TYPE(Engine,UMorphNodePose);
DECLARE_NATIVE_TYPE(Engine,UMorphNodeWeight);
DECLARE_NATIVE_TYPE(Engine,UMorphNodeWeightBase);
DECLARE_NATIVE_TYPE(Engine,UMorphTargetSet);
DECLARE_NATIVE_TYPE(Engine,UMorphWeightSequence);
DECLARE_NATIVE_TYPE(Engine,USkelControlBase);
DECLARE_NATIVE_TYPE(Engine,USkelControlFootPlacement);
DECLARE_NATIVE_TYPE(Engine,USkelControlLimb);
DECLARE_NATIVE_TYPE(Engine,USkelControlLookAt);
DECLARE_NATIVE_TYPE(Engine,USkelControlSingleBone);
DECLARE_NATIVE_TYPE(Engine,USkelControlSpline);
DECLARE_NATIVE_TYPE(Engine,USkelControlTrail);
DECLARE_NATIVE_TYPE(Engine,USkelControlWheel);
DECLARE_NATIVE_TYPE(Engine,ASkeletalMeshActor);
DECLARE_NATIVE_TYPE(Engine,ASkeletalMeshActorBasedOnExtremeContent);
DECLARE_NATIVE_TYPE(Engine,ASkeletalMeshActorMAT);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_ANIM \
	UAnimationCompressionAlgorithm::StaticClass(); \
	UAnimationCompressionAlgorithm_BitwiseCompressOnly::StaticClass(); \
	UAnimationCompressionAlgorithm_RemoveEverySecondKey::StaticClass(); \
	UAnimationCompressionAlgorithm_RemoveLinearKeys::StaticClass(); \
	UAnimationCompressionAlgorithm_RemoveTrivialKeys::StaticClass(); \
	UAnimationCompressionAlgorithm_RevertToRaw::StaticClass(); \
	UAnimNode::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeNative; \
	UAnimNodeAdditiveBlending::StaticClass(); \
	UAnimNodeAimOffset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeAimOffsetNative; \
	UAnimNodeBlend::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendNative; \
	UAnimNodeBlendBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendBaseNative; \
	UAnimNodeBlendByBase::StaticClass(); \
	UAnimNodeBlendByPhysics::StaticClass(); \
	UAnimNodeBlendByPosture::StaticClass(); \
	UAnimNodeBlendBySpeed::StaticClass(); \
	UAnimNodeBlendDirectional::StaticClass(); \
	UAnimNodeBlendList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendListNative; \
	UAnimNodeBlendMultiBone::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendMultiBoneNative; \
	UAnimNodeBlendPerBone::StaticClass(); \
	UAnimNodeCrossfader::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeCrossfaderNative; \
	UAnimNodeMirror::StaticClass(); \
	UAnimNodePlayCustomAnim::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodePlayCustomAnimNative; \
	UAnimNodeRandom::StaticClass(); \
	UAnimNodeScalePlayRate::StaticClass(); \
	UAnimNodeScaleRateBySpeed::StaticClass(); \
	UAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeSequenceNative; \
	UAnimNodeSequenceBlendBase::StaticClass(); \
	UAnimNodeSequenceBlendByAim::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeSequenceBlendByAimNative; \
	UAnimNodeSlot::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeSlotNative; \
	UAnimNodeSynch::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeSynchNative; \
	UAnimNotify::StaticClass(); \
	UAnimNotify_CameraEffect::StaticClass(); \
	UAnimNotify_Footstep::StaticClass(); \
	UAnimNotify_PlayParticleEffect::StaticClass(); \
	UAnimNotify_Rumble::StaticClass(); \
	UAnimNotify_Script::StaticClass(); \
	UAnimNotify_Scripted::StaticClass(); \
	UAnimNotify_Sound::StaticClass(); \
	UAnimObject::StaticClass(); \
	UAnimSequence::StaticClass(); \
	UAnimSet::StaticClass(); \
	UAnimTree::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimTreeNative; \
	ACrowdAgent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineACrowdAgentNative; \
	ACrowdAttractor::StaticClass(); \
	UMorphNodeBase::StaticClass(); \
	UMorphNodePose::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMorphNodePoseNative; \
	UMorphNodeWeight::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMorphNodeWeightNative; \
	UMorphNodeWeightBase::StaticClass(); \
	UMorphTarget::StaticClass(); \
	UMorphTargetSet::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMorphTargetSetNative; \
	UMorphWeightSequence::StaticClass(); \
	USkelControlBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSkelControlBaseNative; \
	USkelControlFootPlacement::StaticClass(); \
	USkelControlLimb::StaticClass(); \
	USkelControlLookAt::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSkelControlLookAtNative; \
	USkelControlSingleBone::StaticClass(); \
	USkelControlSpline::StaticClass(); \
	USkelControlTrail::StaticClass(); \
	USkelControlWheel::StaticClass(); \
	ASkeletalMeshActor::StaticClass(); \
	ASkeletalMeshActorBasedOnExtremeContent::StaticClass(); \
	ASkeletalMeshActorMAT::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineASkeletalMeshActorMATNative; \

#endif // ENGINE_ANIM_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UAnimNode) GEngineUAnimNodeNatives[] = 
{ 
	MAP_NATIVE(UAnimNode,execStopAnim)
	MAP_NATIVE(UAnimNode,execPlayAnim)
	MAP_NATIVE(UAnimNode,execFindAnimNode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNode);

NATIVE_INFO(UAnimNodeAimOffset) GEngineUAnimNodeAimOffsetNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeAimOffset,execSetActiveProfileByIndex)
	MAP_NATIVE(UAnimNodeAimOffset,execSetActiveProfileByName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeAimOffset);

NATIVE_INFO(UAnimNodeBlend) GEngineUAnimNodeBlendNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlend,execSetBlendTarget)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlend);

NATIVE_INFO(UAnimNodeBlendBase) GEngineUAnimNodeBlendBaseNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendBase,execStopAnim)
	MAP_NATIVE(UAnimNodeBlendBase,execPlayAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlendBase);

NATIVE_INFO(UAnimNodeBlendList) GEngineUAnimNodeBlendListNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendList,execSetActiveChild)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlendList);

NATIVE_INFO(UAnimNodeBlendMultiBone) GEngineUAnimNodeBlendMultiBoneNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendMultiBone,execSetTargetStartBone)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlendMultiBone);

NATIVE_INFO(UAnimNodeCrossfader) GEngineUAnimNodeCrossfaderNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeCrossfader,execGetActiveChild)
	MAP_NATIVE(UAnimNodeCrossfader,execGetAnimName)
	MAP_NATIVE(UAnimNodeCrossfader,execBlendToLoopingAnim)
	MAP_NATIVE(UAnimNodeCrossfader,execPlayOneShotAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeCrossfader);

NATIVE_INFO(UAnimNodePlayCustomAnim) GEngineUAnimNodePlayCustomAnimNatives[] = 
{ 
	MAP_NATIVE(UAnimNodePlayCustomAnim,execStopCustomAnim)
	MAP_NATIVE(UAnimNodePlayCustomAnim,execPlayCustomAnimByDuration)
	MAP_NATIVE(UAnimNodePlayCustomAnim,execPlayCustomAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodePlayCustomAnim);

NATIVE_INFO(UAnimNodeSequence) GEngineUAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSequence,execGetTimeLeft)
	MAP_NATIVE(UAnimNodeSequence,execGetAnimPlaybackLength)
	MAP_NATIVE(UAnimNodeSequence,execGetGlobalPlayRate)
	MAP_NATIVE(UAnimNodeSequence,execFindNormalizedPositionFromGroupRelativePosition)
	MAP_NATIVE(UAnimNodeSequence,execGetNormalizedPosition)
	MAP_NATIVE(UAnimNodeSequence,execSetPosition)
	MAP_NATIVE(UAnimNodeSequence,execStopAnim)
	MAP_NATIVE(UAnimNodeSequence,execPlayAnim)
	MAP_NATIVE(UAnimNodeSequence,execSetAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeSequence);

NATIVE_INFO(UAnimNodeSequenceBlendByAim) GEngineUAnimNodeSequenceBlendByAimNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSequenceBlendByAim,execCheckAnimsUpToDate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeSequenceBlendByAim);

NATIVE_INFO(UAnimNodeSlot) GEngineUAnimNodeSlotNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSlot,execAddToSynchGroup)
	MAP_NATIVE(UAnimNodeSlot,execSetRootBoneAxisOption)
	MAP_NATIVE(UAnimNodeSlot,execGetCustomAnimNodeSeq)
	MAP_NATIVE(UAnimNodeSlot,execSetActorAnimEndNotification)
	MAP_NATIVE(UAnimNodeSlot,execSetCustomAnim)
	MAP_NATIVE(UAnimNodeSlot,execStopCustomAnim)
	MAP_NATIVE(UAnimNodeSlot,execGetPlayedAnimation)
	MAP_NATIVE(UAnimNodeSlot,execPlayCustomAnimByDuration)
	MAP_NATIVE(UAnimNodeSlot,execPlayCustomAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeSlot);

NATIVE_INFO(UAnimNodeSynch) GEngineUAnimNodeSynchNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSynch,execSetGroupRateScale)
	MAP_NATIVE(UAnimNodeSynch,execGetRelativePosition)
	MAP_NATIVE(UAnimNodeSynch,execForceRelativePosition)
	MAP_NATIVE(UAnimNodeSynch,execGetMasterNodeOfGroup)
	MAP_NATIVE(UAnimNodeSynch,execRemoveNodeFromGroup)
	MAP_NATIVE(UAnimNodeSynch,execAddNodeToGroup)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeSynch);

NATIVE_INFO(UAnimTree) GEngineUAnimTreeNatives[] = 
{ 
	MAP_NATIVE(UAnimTree,execGetGroupIndex)
	MAP_NATIVE(UAnimTree,execGetGroupRateScale)
	MAP_NATIVE(UAnimTree,execSetGroupRateScale)
	MAP_NATIVE(UAnimTree,execGetGroupRelativePosition)
	MAP_NATIVE(UAnimTree,execForceGroupRelativePosition)
	MAP_NATIVE(UAnimTree,execGetGroupNotifyMaster)
	MAP_NATIVE(UAnimTree,execGetGroupSynchMaster)
	MAP_NATIVE(UAnimTree,execSetAnimGroupForNode)
	MAP_NATIVE(UAnimTree,execSetUseSavedPose)
	MAP_NATIVE(UAnimTree,execFindMorphNode)
	MAP_NATIVE(UAnimTree,execFindSkelControl)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimTree);

NATIVE_INFO(ACrowdAgent) GEngineACrowdAgentNatives[] = 
{ 
	MAP_NATIVE(ACrowdAgent,execPlayDeath)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ACrowdAgent);

NATIVE_INFO(UMorphNodePose) GEngineUMorphNodePoseNatives[] = 
{ 
	MAP_NATIVE(UMorphNodePose,execSetMorphTarget)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMorphNodePose);

NATIVE_INFO(UMorphNodeWeight) GEngineUMorphNodeWeightNatives[] = 
{ 
	MAP_NATIVE(UMorphNodeWeight,execSetNodeWeight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMorphNodeWeight);

NATIVE_INFO(UMorphTargetSet) GEngineUMorphTargetSetNatives[] = 
{ 
	MAP_NATIVE(UMorphTargetSet,execFindMorphTarget)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMorphTargetSet);

NATIVE_INFO(USkelControlBase) GEngineUSkelControlBaseNatives[] = 
{ 
	MAP_NATIVE(USkelControlBase,execSetSkelControlStrength)
	MAP_NATIVE(USkelControlBase,execSetSkelControlActive)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USkelControlBase);

NATIVE_INFO(USkelControlLookAt) GEngineUSkelControlLookAtNatives[] = 
{ 
	MAP_NATIVE(USkelControlLookAt,execCanLookAtPoint)
	MAP_NATIVE(USkelControlLookAt,execSetLookAtAlpha)
	MAP_NATIVE(USkelControlLookAt,execInterpolateTargetLocation)
	MAP_NATIVE(USkelControlLookAt,execSetTargetLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USkelControlLookAt);

NATIVE_INFO(ASkeletalMeshActorMAT) GEngineASkeletalMeshActorMATNatives[] = 
{ 
	MAP_NATIVE(ASkeletalMeshActorMAT,execMAT_SetSkelControlScale)
	MAP_NATIVE(ASkeletalMeshActorMAT,execMAT_SetMorphWeight)
	MAP_NATIVE(ASkeletalMeshActorMAT,execMAT_FinishAnimControl)
	MAP_NATIVE(ASkeletalMeshActorMAT,execMAT_SetAnimWeights)
	MAP_NATIVE(ASkeletalMeshActorMAT,execMAT_SetAnimPosition)
	MAP_NATIVE(ASkeletalMeshActorMAT,execMAT_BeginAnimControl)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ASkeletalMeshActorMAT);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm,Description)
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm,RotationCompressionFormat)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_BitwiseCompressOnly)
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm_RemoveEverySecondKey,MinKeys)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RemoveEverySecondKey)
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm_RemoveLinearKeys,MaxPosDiff)
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm_RemoveLinearKeys,ParentKeyScale)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RemoveLinearKeys)
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm_RemoveTrivialKeys,MaxPosDiff)
VERIFY_CLASS_OFFSET_NODIE(U,AnimationCompressionAlgorithm_RemoveTrivialKeys,MaxAngleDiff)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RemoveTrivialKeys)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RevertToRaw)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNode,NodeTickTag)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNode,SearchTag)
VERIFY_CLASS_SIZE_NODIE(UAnimNode)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeAdditiveBlending)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeAimOffset,Aim)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeAimOffset,CurrentProfileIndex)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeAimOffset)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlend,Child2Weight)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlend,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlend)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendBase,Children)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendBase,BlendType)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendBase)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendByBase,Type)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendByBase,CachedBase)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByBase)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByPhysics)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByPosture)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendBySpeed,Speed)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendBySpeed,Constraints)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendBySpeed)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendDirectional,DirDegreesPerSecond)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendDirectional,SingleAnimAtOrAboveLOD)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendDirectional)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendList,TargetWeight)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendList,SliderPosition)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendList)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendMultiBone,BlendTargetList)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendMultiBone,SourceRequiredBones)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendMultiBone)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendPerBone,BranchStartBoneName)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeBlendPerBone,LocalToCompReqBones)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendPerBone)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeCrossfader,DefaultAnimSeqName)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeCrossfader,PendingBlendOutTimeOneShot)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeCrossfader)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeMirror)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodePlayCustomAnim,CustomPendingBlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UAnimNodePlayCustomAnim)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeRandom,RandomInfo)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeRandom,PendingChildIndex)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeRandom)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeScalePlayRate,ScaleByValue)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeScalePlayRate)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeScaleRateBySpeed,BaseSpeed)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeScaleRateBySpeed)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSequence,AnimSeqName)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSequence,RootRotationOption)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequence)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSequenceBlendBase,Anims)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequenceBlendBase)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSequenceBlendByAim,Aim)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSequenceBlendByAim,AnimName_RD)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequenceBlendByAim)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSlot,PendingBlendOutTime)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSlot,SynchNode)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSlot)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeSynch,Groups)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSynch)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_CameraEffect,CameraLensEffect)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_CameraEffect)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_Footstep,FootDown)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Footstep)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_PlayParticleEffect,PSTemplate)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_PlayParticleEffect,BoneName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_PlayParticleEffect)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_Rumble,PredefinedWaveForm)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_Rumble,WaveForm)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Rumble)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_Script,NotifyName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Script)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Scripted)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_Sound,SoundCue)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNotify_Sound,BoneName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Sound)
VERIFY_CLASS_OFFSET_NODIE(U,AnimObject,DrawWidth)
VERIFY_CLASS_OFFSET_NODIE(U,AnimObject,SkelComponent)
VERIFY_CLASS_SIZE_NODIE(UAnimObject)
VERIFY_CLASS_OFFSET_NODIE(U,AnimSequence,SequenceName)
VERIFY_CLASS_OFFSET_NODIE(U,AnimSequence,EncodingPkgVersion)
VERIFY_CLASS_SIZE_NODIE(UAnimSequence)
VERIFY_CLASS_OFFSET_NODIE(U,AnimSet,TrackBoneNames)
VERIFY_CLASS_OFFSET_NODIE(U,AnimSet,SkeletonName)
VERIFY_CLASS_SIZE_NODIE(UAnimSet)
VERIFY_CLASS_OFFSET_NODIE(U,AnimTree,AnimGroups)
VERIFY_CLASS_OFFSET_NODIE(U,AnimTree,PreviewFloorYaw)
VERIFY_CLASS_SIZE_NODIE(UAnimTree)
VERIFY_CLASS_OFFSET_NODIE(A,CrowdAgent,Spawner)
VERIFY_CLASS_OFFSET_NODIE(A,CrowdAgent,NearestPath)
VERIFY_CLASS_SIZE_NODIE(ACrowdAgent)
VERIFY_CLASS_OFFSET_NODIE(A,CrowdAttractor,Attraction)
VERIFY_CLASS_OFFSET_NODIE(A,CrowdAttractor,Mode)
VERIFY_CLASS_SIZE_NODIE(ACrowdAttractor)
VERIFY_CLASS_OFFSET_NODIE(U,MorphNodeBase,NodeName)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeBase)
VERIFY_CLASS_OFFSET_NODIE(U,MorphNodePose,Target)
VERIFY_CLASS_OFFSET_NODIE(U,MorphNodePose,Weight)
VERIFY_CLASS_SIZE_NODIE(UMorphNodePose)
VERIFY_CLASS_OFFSET_NODIE(U,MorphNodeWeight,NodeWeight)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeWeight)
VERIFY_CLASS_OFFSET_NODIE(U,MorphNodeWeightBase,NodeConns)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeWeightBase)
VERIFY_CLASS_OFFSET_NODIE(U,MorphTarget,MorphLODModels)
VERIFY_CLASS_SIZE_NODIE(UMorphTarget)
VERIFY_CLASS_OFFSET_NODIE(U,MorphTargetSet,Targets)
VERIFY_CLASS_OFFSET_NODIE(U,MorphTargetSet,BaseSkelMesh)
VERIFY_CLASS_SIZE_NODIE(UMorphTargetSet)
VERIFY_CLASS_SIZE_NODIE(UMorphWeightSequence)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlBase,ControlName)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlBase,ControlPosY)
VERIFY_CLASS_SIZE_NODIE(USkelControlBase)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlFootPlacement,FootOffset)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlFootPlacement,MaxFootOrientAdjust)
VERIFY_CLASS_SIZE_NODIE(USkelControlFootPlacement)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlLimb,EffectorLocation)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlLimb,StretchRollBoneName)
VERIFY_CLASS_SIZE_NODIE(USkelControlLimb)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlLookAt,TargetLocation)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlLookAt,LastCalcTime)
VERIFY_CLASS_SIZE_NODIE(USkelControlLookAt)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlSingleBone,BoneTranslation)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlSingleBone,RotationSpaceBoneName)
VERIFY_CLASS_SIZE_NODIE(USkelControlSingleBone)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlSpline,SplineLength)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlSpline,StartSplineTension)
VERIFY_CLASS_SIZE_NODIE(USkelControlSpline)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlTrail,ChainLength)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlTrail,OldLocalToWorld)
VERIFY_CLASS_SIZE_NODIE(USkelControlTrail)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlWheel,WheelDisplacement)
VERIFY_CLASS_OFFSET_NODIE(U,SkelControlWheel,WheelSteering)
VERIFY_CLASS_SIZE_NODIE(USkelControlWheel)
VERIFY_CLASS_OFFSET_NODIE(A,SkeletalMeshActor,SkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,SkeletalMeshActor,HeadMesh)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActor)
VERIFY_CLASS_OFFSET_NODIE(A,SkeletalMeshActorBasedOnExtremeContent,ExtremeContent)
VERIFY_CLASS_OFFSET_NODIE(A,SkeletalMeshActorBasedOnExtremeContent,NonExtremeContent)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActorBasedOnExtremeContent)
VERIFY_CLASS_OFFSET_NODIE(A,SkeletalMeshActorMAT,SlotNodes)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActorMAT)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
