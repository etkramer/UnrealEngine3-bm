/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_AI_ENUMS
#define INCLUDED_ENGINE_AI_ENUMS 1


#endif // !INCLUDED_ENGINE_AI_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(GetDumpString)
AUTOGENERATE_NAME(Recycle)
AUTOGENERATE_NAME(SetTeam)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_AI_CLASSES
#define INCLUDED_ENGINE_AI_CLASSES 1

struct AIController_eventSetTeam_Parms
{
    INT inTeamIdx;
    AIController_eventSetTeam_Parms(EEventParm)
    {
    }
};
class AAIController : public AController
{
public:
    //## BEGIN PROPS AIController
    BITFIELD bHunting:1;
    BITFIELD bAdjustFromWalls:1;
    BITFIELD bReverseScriptedRoute:1;
    FLOAT Skill;
    class AActor* ScriptedMoveTarget;
    class ARoute* ScriptedRoute;
    INT ScriptedRouteIndex;
    class AActor* ScriptedFocus;
    //## END PROPS AIController

    void eventSetTeam(INT inTeamIdx)
    {
        AIController_eventSetTeam_Parms Parms(EC_EventParm);
        Parms.inTeamIdx=inTeamIdx;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTeam),&Parms);
    }
    DECLARE_CLASS(AAIController,AController,0,Engine)
	INT AcceptNearbyPath(AActor *goal);
	void AdjustFromWall(FVector HitNormal, AActor* HitActor);
	virtual void SetAdjustLocation(FVector NewLoc,UBOOL bAdjust,UBOOL bOffsetFromBase=FALSE);
	virtual FVector DesiredDirection();
};

class UCoverGroupRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS CoverGroupRenderingComponent
    //## END PROPS CoverGroupRenderingComponent

    DECLARE_CLASS(UCoverGroupRenderingComponent,UPrimitiveComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;
};

struct FCoverMeshes
{
    class UStaticMesh* Base;
    class UStaticMesh* LeanLeft;
    class UStaticMesh* LeanRight;
    class UStaticMesh* Climb;
    class UStaticMesh* Mantle;
    class UStaticMesh* SlipLeft;
    class UStaticMesh* SlipRight;
    class UStaticMesh* SwatLeft;
    class UStaticMesh* SwatRight;
    class UStaticMesh* PopUp;
    class UStaticMesh* PlayerOnly;

    /** Constructors */
    FCoverMeshes() {}
    FCoverMeshes(EEventParm)
    {
        appMemzero(this, sizeof(FCoverMeshes));
    }
};

class UCoverMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS CoverMeshComponent
    TArrayNoInit<struct FCoverMeshes> Meshes;
    FVector LocationOffset;
    class UStaticMesh* AutoAdjustOn;
    class UStaticMesh* AutoAdjustOff;
    class UStaticMesh* Disabled;
    //## END PROPS CoverMeshComponent

    DECLARE_CLASS(UCoverMeshComponent,UStaticMeshComponent,0,Engine)
	void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;
	virtual void UpdateMeshes() {};
};

class UPathRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS PathRenderingComponent
    //## END PROPS PathRenderingComponent

    DECLARE_CLASS(UPathRenderingComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Creates a new scene proxy for the path rendering component.
	 * @return	Pointer to the FPathRenderingSceneProxy
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	virtual void UpdateBounds();
};

class URouteRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RouteRenderingComponent
    //## END PROPS RouteRenderingComponent

    DECLARE_CLASS(URouteRenderingComponent,UPrimitiveComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
};

struct PathConstraint_eventGetDumpString_Parms
{
    FString ReturnValue;
    PathConstraint_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct PathConstraint_eventRecycle_Parms
{
    PathConstraint_eventRecycle_Parms(EEventParm)
    {
    }
};
class UPathConstraint : public UObject
{
public:
    //## BEGIN PROPS PathConstraint
    INT CacheIdx;
    class UPathConstraint* NextConstraint;
    //## END PROPS PathConstraint

    FString eventGetDumpString()
    {
        PathConstraint_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventRecycle()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Recycle),NULL);
    }
    DECLARE_CLASS(UPathConstraint,UObject,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_AlongLine : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_AlongLine
    FVector Direction;
    //## END PROPS Path_AlongLine

    DECLARE_CLASS(UPath_AlongLine,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_AvoidInEscapableNodes : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_AvoidInEscapableNodes
    INT Radius;
    INT Height;
    INT MaxFallSpeed;
    INT MoveFlags;
    //## END PROPS Path_AvoidInEscapableNodes

    virtual void CachePawnReacFlags(class APawn* P);
    DECLARE_FUNCTION(execCachePawnReacFlags)
    {
        P_GET_OBJECT(APawn,P);
        P_FINISH;
        CachePawnReacFlags(P);
    }
    DECLARE_CLASS(UPath_AvoidInEscapableNodes,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_MinDistBetweenSpecsOfType : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_MinDistBetweenSpecsOfType
    FLOAT MinDistBetweenSpecTypes;
    FVector InitLocation;
    class UClass* ReachSpecClass;
    //## END PROPS Path_MinDistBetweenSpecsOfType

    DECLARE_CLASS(UPath_MinDistBetweenSpecsOfType,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
	UBOOL IsNodeWithinMinDistOfSpecInPath(ANavigationPoint* Node);
};

class UPath_TowardGoal : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_TowardGoal
    class AActor* GoalActor;
    //## END PROPS Path_TowardGoal

    DECLARE_CLASS(UPath_TowardGoal,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_TowardPoint : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_TowardPoint
    FVector GoalPoint;
    //## END PROPS Path_TowardPoint

    DECLARE_CLASS(UPath_TowardPoint,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_WithinDistanceEnvelope : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_WithinDistanceEnvelope
    FLOAT MaxDistance;
    FLOAT MinDistance;
    BITFIELD bSoft:1;
    BITFIELD bOnlyThrowOutNodesThatLeaveEnvelope:1;
    FLOAT SoftStartPenalty;
    FVector EnvelopeTestPoint;
    //## END PROPS Path_WithinDistanceEnvelope

    DECLARE_CLASS(UPath_WithinDistanceEnvelope,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_WithinTraversalDist : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_WithinTraversalDist
    FLOAT MaxTraversalDist;
    BITFIELD bSoft:1;
    FLOAT SoftStartPenalty;
    //## END PROPS Path_WithinTraversalDist

    DECLARE_CLASS(UPath_WithinTraversalDist,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

struct PathGoalEvaluator_eventGetDumpString_Parms
{
    FString ReturnValue;
    PathGoalEvaluator_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct PathGoalEvaluator_eventRecycle_Parms
{
    PathGoalEvaluator_eventRecycle_Parms(EEventParm)
    {
    }
};
class UPathGoalEvaluator : public UObject
{
public:
    //## BEGIN PROPS PathGoalEvaluator
    class UPathGoalEvaluator* NextEvaluator;
    class ANavigationPoint* GeneratedGoal;
    INT MaxPathVisits;
    INT CacheIdx;
    //## END PROPS PathGoalEvaluator

    FString eventGetDumpString()
    {
        PathGoalEvaluator_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventRecycle()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Recycle),NULL);
    }
    DECLARE_CLASS(UPathGoalEvaluator,UObject,0,Engine)
	// Interface
	virtual UBOOL InitialAbortCheck( ANavigationPoint* Start, APawn* Pawn );
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal( ANavigationPoint*& out_GoalNav );
	virtual void  NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess );
};

class UGoal_AtActor : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_AtActor
    class AActor* GoalActor;
    FLOAT GoalDist;
    BITFIELD bKeepPartial:1;
    //## END PROPS Goal_AtActor

    DECLARE_CLASS(UGoal_AtActor,UPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL InitialAbortCheck( ANavigationPoint* Start, APawn* Pawn );
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual void  NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess );
};

class UGoal_Null : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_Null
    //## END PROPS Goal_Null

    DECLARE_CLASS(UGoal_Null,UPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual void NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess ){/*don't care about best guess.. just ignore this*/}
};

#endif // !INCLUDED_ENGINE_AI_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UPath_AvoidInEscapableNodes,-1,execCachePawnReacFlags);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_AI_NATIVE_DEFS
#define ENGINE_AI_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,AAIController);
DECLARE_NATIVE_TYPE(Engine,UCoverGroupRenderingComponent);
DECLARE_NATIVE_TYPE(Engine,UCoverMeshComponent);
DECLARE_NATIVE_TYPE(Engine,UGoal_AtActor);
DECLARE_NATIVE_TYPE(Engine,UGoal_Null);
DECLARE_NATIVE_TYPE(Engine,UPath_AlongLine);
DECLARE_NATIVE_TYPE(Engine,UPath_AvoidInEscapableNodes);
DECLARE_NATIVE_TYPE(Engine,UPath_MinDistBetweenSpecsOfType);
DECLARE_NATIVE_TYPE(Engine,UPath_TowardGoal);
DECLARE_NATIVE_TYPE(Engine,UPath_TowardPoint);
DECLARE_NATIVE_TYPE(Engine,UPath_WithinDistanceEnvelope);
DECLARE_NATIVE_TYPE(Engine,UPath_WithinTraversalDist);
DECLARE_NATIVE_TYPE(Engine,UPathConstraint);
DECLARE_NATIVE_TYPE(Engine,UPathGoalEvaluator);
DECLARE_NATIVE_TYPE(Engine,UPathRenderingComponent);
DECLARE_NATIVE_TYPE(Engine,URouteRenderingComponent);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_AI \
	AAIController::StaticClass(); \
	UCoverGroupRenderingComponent::StaticClass(); \
	UCoverMeshComponent::StaticClass(); \
	UGoal_AtActor::StaticClass(); \
	UGoal_Null::StaticClass(); \
	UPath_AlongLine::StaticClass(); \
	UPath_AvoidInEscapableNodes::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPath_AvoidInEscapableNodesNative; \
	UPath_MinDistBetweenSpecsOfType::StaticClass(); \
	UPath_TowardGoal::StaticClass(); \
	UPath_TowardPoint::StaticClass(); \
	UPath_WithinDistanceEnvelope::StaticClass(); \
	UPath_WithinTraversalDist::StaticClass(); \
	UPathConstraint::StaticClass(); \
	UPathGoalEvaluator::StaticClass(); \
	UPathRenderingComponent::StaticClass(); \
	URouteRenderingComponent::StaticClass(); \

#endif // ENGINE_AI_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UPath_AvoidInEscapableNodes) GEngineUPath_AvoidInEscapableNodesNatives[] = 
{ 
	MAP_NATIVE(UPath_AvoidInEscapableNodes,execCachePawnReacFlags)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPath_AvoidInEscapableNodes);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,AIController,Skill)
VERIFY_CLASS_OFFSET_NODIE(A,AIController,ScriptedFocus)
VERIFY_CLASS_SIZE_NODIE(AAIController)
VERIFY_CLASS_SIZE_NODIE(UCoverGroupRenderingComponent)
VERIFY_CLASS_OFFSET_NODIE(U,CoverMeshComponent,Meshes)
VERIFY_CLASS_OFFSET_NODIE(U,CoverMeshComponent,Disabled)
VERIFY_CLASS_SIZE_NODIE(UCoverMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_AtActor,GoalActor)
VERIFY_CLASS_OFFSET_NODIE(U,Goal_AtActor,GoalDist)
VERIFY_CLASS_SIZE_NODIE(UGoal_AtActor)
VERIFY_CLASS_SIZE_NODIE(UGoal_Null)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AlongLine,Direction)
VERIFY_CLASS_SIZE_NODIE(UPath_AlongLine)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AvoidInEscapableNodes,Radius)
VERIFY_CLASS_OFFSET_NODIE(U,Path_AvoidInEscapableNodes,MoveFlags)
VERIFY_CLASS_SIZE_NODIE(UPath_AvoidInEscapableNodes)
VERIFY_CLASS_OFFSET_NODIE(U,Path_MinDistBetweenSpecsOfType,MinDistBetweenSpecTypes)
VERIFY_CLASS_OFFSET_NODIE(U,Path_MinDistBetweenSpecsOfType,ReachSpecClass)
VERIFY_CLASS_SIZE_NODIE(UPath_MinDistBetweenSpecsOfType)
VERIFY_CLASS_OFFSET_NODIE(U,Path_TowardGoal,GoalActor)
VERIFY_CLASS_SIZE_NODIE(UPath_TowardGoal)
VERIFY_CLASS_OFFSET_NODIE(U,Path_TowardPoint,GoalPoint)
VERIFY_CLASS_SIZE_NODIE(UPath_TowardPoint)
VERIFY_CLASS_OFFSET_NODIE(U,Path_WithinDistanceEnvelope,MaxDistance)
VERIFY_CLASS_OFFSET_NODIE(U,Path_WithinDistanceEnvelope,EnvelopeTestPoint)
VERIFY_CLASS_SIZE_NODIE(UPath_WithinDistanceEnvelope)
VERIFY_CLASS_OFFSET_NODIE(U,Path_WithinTraversalDist,MaxTraversalDist)
VERIFY_CLASS_OFFSET_NODIE(U,Path_WithinTraversalDist,SoftStartPenalty)
VERIFY_CLASS_SIZE_NODIE(UPath_WithinTraversalDist)
VERIFY_CLASS_OFFSET_NODIE(U,PathConstraint,CacheIdx)
VERIFY_CLASS_OFFSET_NODIE(U,PathConstraint,NextConstraint)
VERIFY_CLASS_SIZE_NODIE(UPathConstraint)
VERIFY_CLASS_OFFSET_NODIE(U,PathGoalEvaluator,NextEvaluator)
VERIFY_CLASS_OFFSET_NODIE(U,PathGoalEvaluator,CacheIdx)
VERIFY_CLASS_SIZE_NODIE(UPathGoalEvaluator)
VERIFY_CLASS_SIZE_NODIE(UPathRenderingComponent)
VERIFY_CLASS_SIZE_NODIE(URouteRenderingComponent)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
