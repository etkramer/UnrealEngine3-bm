/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PHYSICS_ENUMS
#define INCLUDED_ENGINE_PHYSICS_ENUMS 1

enum EWheelSide
{
    SIDE_None               =0,
    SIDE_Left               =1,
    SIDE_Right              =2,
    SIDE_MAX                =3,
};
enum ESleepFamily
{
    SF_Normal               =0,
    SF_Sensitive            =1,
    SF_MAX                  =2,
};
enum EPhysEffectType
{
    EPMET_Impact            =0,
    EPMET_Slide             =1,
    EPMET_MAX               =2,
};

#endif // !INCLUDED_ENGINE_PHYSICS_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(SuspensionHeavyShift)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PHYSICS_CLASSES
#define INCLUDED_ENGINE_PHYSICS_CLASSES 1

class AKActor : public ADynamicSMActor
{
public:
    //## BEGIN PROPS KActor
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bWakeOnLevelStart:1;
    BITFIELD bCurrentSlide:1;
    BITFIELD bSlideActive:1;
    BITFIELD bEnableStayUprightSpring:1;
    BITFIELD bLimitMaxPhysicsVelocity:1;
    BITFIELD bNeedsRBStateReplication:1;
    BITFIELD bDisableClientSidePawnInteractions:1;
    class UParticleSystemComponent* ImpactEffectComponent;
    class UAudioComponent* ImpactSoundComponent;
    class UAudioComponent* ImpactSoundComponent2;
    FLOAT LastImpactTime;
    struct FPhysEffectInfo ImpactEffectInfo;
    class UParticleSystemComponent* SlideEffectComponent;
    class UAudioComponent* SlideSoundComponent;
    FLOAT LastSlideTime;
    struct FPhysEffectInfo SlideEffectInfo;
    FLOAT StayUprightTorqueFactor;
    FLOAT StayUprightMaxTorque;
    FLOAT MaxPhysicsVelocity;
    FRigidBodyState RBState;
    FLOAT AngErrorAccumulator;
    FVector ReplicatedDrawScale3D;
    FVector InitialLocation;
    FRotator InitialRotation;
    //## END PROPS KActor

    class UPhysicalMaterial* GetKActorPhysMaterial();
    void ResolveRBState();
    DECLARE_FUNCTION(execGetKActorPhysMaterial)
    {
        P_FINISH;
        *(class UPhysicalMaterial**)Result=GetKActorPhysMaterial();
    }
    DECLARE_FUNCTION(execResolveRBState)
    {
        P_FINISH;
        ResolveRBState();
    }
    DECLARE_CLASS(AKActor,ADynamicSMActor,0|CLASS_NativeReplication,Engine)
	// UObject interface
	virtual void PostLoad();

	// AActor interface
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();

	virtual void TickSpecial(FLOAT DeltaSeconds);
};

class AKActorSpawnable : public AKActor
{
public:
    //## BEGIN PROPS KActorSpawnable
    BITFIELD bRecycleScaleToZero:1;
    BITFIELD bScalingToZero:1;
    //## END PROPS KActorSpawnable

    virtual void ResetComponents();
    DECLARE_FUNCTION(execResetComponents)
    {
        P_FINISH;
        ResetComponents();
    }
    DECLARE_CLASS(AKActorSpawnable,AKActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AKActorSpawnable)
};

class AKAsset : public AActor
{
public:
    //## BEGIN PROPS KAsset
    class USkeletalMeshComponent* SkeletalMeshComponent;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bWakeOnLevelStart:1;
    BITFIELD bBlockPawns:1;
    class USkeletalMesh* ReplicatedMesh;
    class UPhysicsAsset* ReplicatedPhysAsset;
    //## END PROPS KAsset

    DECLARE_CLASS(AKAsset,AActor,0|CLASS_NativeReplication,Engine)
public:
	// UObject interface
	virtual void PostLoad();

	// AActor interface.
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

	/**
	* Function that gets called from within Map_Check to allow this actor to check itself
	* for any potential errors and register them with map check dialog.
	*/
	virtual void CheckForErrors();

	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
	UBOOL IgnoreBlockingBy(const AActor* Other);
};

struct FVehicleState
{
    FRigidBodyState RBState;
    BYTE ServerBrake;
    BYTE ServerGas;
    BYTE ServerSteering;
    BYTE ServerRise;
    BITFIELD bServerHandbrake:1 GCC_BITFIELD_MAGIC;
    INT ServerView;

    /** Constructors */
    FVehicleState() {}
    FVehicleState(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleState));
    }
};

struct SVehicle_eventSuspensionHeavyShift_Parms
{
    FLOAT Delta;
    SVehicle_eventSuspensionHeavyShift_Parms(EEventParm)
    {
    }
};
class ASVehicle : public AVehicle
{
public:
    //## BEGIN PROPS SVehicle
    class USVehicleSimBase* SimObj;
    TArrayNoInit<class USVehicleWheel*> Wheels;
    FVector COMOffset;
    FVector InertiaTensorMultiplier;
    BITFIELD bStayUpright:1;
    BITFIELD bUseSuspensionAxis:1;
    BITFIELD bUpdateWheelShapes:1;
    BITFIELD bVehicleOnGround:1;
    BITFIELD bVehicleOnWater:1;
    BITFIELD bIsInverted:1;
    BITFIELD bChassisTouchingGround:1;
    BITFIELD bWasChassisTouchingGroundLastTick:1;
    BITFIELD bCanFlip:1;
    BITFIELD bFlipRight:1;
    BITFIELD bIsUprighting:1;
    BITFIELD bOutputHandbrake:1;
    BITFIELD bHoldingDownHandbrake:1;
    FLOAT StayUprightRollResistAngle;
    FLOAT StayUprightPitchResistAngle;
    FLOAT StayUprightStiffness;
    FLOAT StayUprightDamping;
    class URB_StayUprightSetup* StayUprightConstraintSetup;
    class URB_ConstraintInstance* StayUprightConstraintInstance;
    FLOAT HeavySuspensionShiftPercent;
    FLOAT MaxSpeed;
    FLOAT MaxAngularVelocity;
    FLOAT TimeOffGround;
    FLOAT UprightLiftStrength;
    FLOAT UprightTorqueStrength;
    FLOAT UprightTime;
    FLOAT UprightStartTime;
    class UAudioComponent* EngineSound;
    class UAudioComponent* SquealSound;
    class USoundCue* CollisionSound;
    class USoundCue* EnterVehicleSound;
    class USoundCue* ExitVehicleSound;
    FLOAT CollisionIntervalSecs;
    FLOAT SquealThreshold;
    FLOAT SquealLatThreshold;
    FLOAT LatAngleVolumeMult;
    FLOAT EngineStartOffsetSecs;
    FLOAT EngineStopOffsetSecs;
    FLOAT LastCollisionSoundTime;
    FLOAT OutputBrake;
    FLOAT OutputGas;
    FLOAT OutputSteering;
    FLOAT OutputRise;
    FLOAT ForwardVel;
    INT NumPoweredWheels;
    FVector BaseOffset;
    FLOAT CamDist;
    INT DriverViewPitch;
    INT DriverViewYaw;
    struct FVehicleState VState;
    FLOAT AngErrorAccumulator;
    FLOAT RadialImpulseScaling;
    //## END PROPS SVehicle

    void SetWheelCollision(INT WheelNum,UBOOL bCollision);
    virtual void InitVehicleRagdoll(class USkeletalMesh* RagdollMesh,class UPhysicsAsset* RagdollPhysAsset,FVector ActorMove,UBOOL bClearAnimTree);
    virtual UBOOL HasWheelsOnGround();
    DECLARE_FUNCTION(execSetWheelCollision)
    {
        P_GET_INT(WheelNum);
        P_GET_UBOOL(bCollision);
        P_FINISH;
        SetWheelCollision(WheelNum,bCollision);
    }
    DECLARE_FUNCTION(execInitVehicleRagdoll)
    {
        P_GET_OBJECT(USkeletalMesh,RagdollMesh);
        P_GET_OBJECT(UPhysicsAsset,RagdollPhysAsset);
        P_GET_STRUCT(FVector,ActorMove);
        P_GET_UBOOL(bClearAnimTree);
        P_FINISH;
        InitVehicleRagdoll(RagdollMesh,RagdollPhysAsset,ActorMove,bClearAnimTree);
    }
    DECLARE_FUNCTION(execHasWheelsOnGround)
    {
        P_FINISH;
        *(UBOOL*)Result=HasWheelsOnGround();
    }
    void eventSuspensionHeavyShift(FLOAT Delta)
    {
        SVehicle_eventSuspensionHeavyShift_Parms Parms(EC_EventParm);
        Parms.Delta=Delta;
        ProcessEvent(FindFunctionChecked(ENGINE_SuspensionHeavyShift),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(ASVehicle,AVehicle,0|CLASS_Config|CLASS_NativeReplication,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// Actor interface.
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual void PostNetReceiveLocation();
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );

	// SVehicle interface.
	virtual void VehiclePackRBState();
	virtual void VehicleUnpackRBState();
	virtual FVector GetDampingForce(const FVector& InForce);

	// Physics interface
	virtual void AddForce(FVector Force);
	virtual void AddImpulse(FVector Impulse);
	virtual void AddTorque(FVector Torque);
	virtual UBOOL IsSleeping();

#if WITH_NOVODEX

    virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc,UPrimitiveComponent* PrimComp, const class NxGroupsMask& GroupsMask, UINT MatIndex);
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp);
	virtual void PreTermRigidBody(NxActor* nActor);
	virtual void TermRBPhys(FRBPhysScene* Scene);
#endif

	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime) {}

	/** Set any params on wheel particle effect */
	virtual void SetWheelEffectParams(USVehicleWheel* VW, FLOAT SlipVel);
};

class ARB_ConstraintActor : public AActor
{
public:
    //## BEGIN PROPS RB_ConstraintActor
    class AActor* ConstraintActor1;
    class AActor* ConstraintActor2;
    class URB_ConstraintSetup* ConstraintSetup;
    class URB_ConstraintInstance* ConstraintInstance;
    BITFIELD bDisableCollision:1;
    BITFIELD bUpdateActor1RefFrame:1;
    BITFIELD bUpdateActor2RefFrame:1;
    class AActor* PulleyPivotActor1;
    class AActor* PulleyPivotActor2;
    //## END PROPS RB_ConstraintActor

    void SetDisableCollision(UBOOL NewDisableCollision);
    void InitConstraint(class AActor* Actor1,class AActor* Actor2,FName Actor1Bone=NAME_None,FName Actor2Bone=NAME_None,FLOAT BreakThreshold=0);
    void TermConstraint();
    DECLARE_FUNCTION(execSetDisableCollision)
    {
        P_GET_UBOOL(NewDisableCollision);
        P_FINISH;
        SetDisableCollision(NewDisableCollision);
    }
    DECLARE_FUNCTION(execInitConstraint)
    {
        P_GET_OBJECT(AActor,Actor1);
        P_GET_OBJECT(AActor,Actor2);
        P_GET_NAME_OPTX(Actor1Bone,NAME_None);
        P_GET_NAME_OPTX(Actor2Bone,NAME_None);
        P_GET_FLOAT_OPTX(BreakThreshold,0);
        P_FINISH;
        InitConstraint(Actor1,Actor2,Actor1Bone,Actor2Bone,BreakThreshold);
    }
    DECLARE_FUNCTION(execTermConstraint)
    {
        P_FINISH;
        TermConstraint();
    }
    DECLARE_ABSTRACT_CLASS(ARB_ConstraintActor,AActor,0,Engine)
	virtual void physRigidBody(FLOAT DeltaTime) {};
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void CheckForErrors(); // used for checking that this constraint is valid buring map build

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	void UpdateConstraintFramesFromActor();
};

class ARB_LineImpulseActor : public AActor
{
public:
    //## BEGIN PROPS RB_LineImpulseActor
    FLOAT ImpulseStrength;
    FLOAT ImpulseRange;
    BITFIELD bVelChange:1;
    BITFIELD bStopAtFirstHit:1;
    BITFIELD bCauseFracture:1;
    class UArrowComponent* Arrow;
    BYTE ImpulseCount;
    //## END PROPS RB_LineImpulseActor

    void FireLineImpulse();
    DECLARE_FUNCTION(execFireLineImpulse)
    {
        P_FINISH;
        FireLineImpulse();
    }
    DECLARE_CLASS(ARB_LineImpulseActor,AActor,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class ARB_RadialImpulseActor : public AActor
{
public:
    //## BEGIN PROPS RB_RadialImpulseActor
    class UDrawSphereComponent* RenderComponent;
    class URB_RadialImpulseComponent* ImpulseComponent;
    BYTE ImpulseCount;
    //## END PROPS RB_RadialImpulseActor

    DECLARE_CLASS(ARB_RadialImpulseActor,AActor,0,Engine)
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class ARB_Thruster : public AActor
{
public:
    //## BEGIN PROPS RB_Thruster
    BITFIELD bThrustEnabled:1;
    FLOAT ThrustStrength;
    //## END PROPS RB_Thruster

    DECLARE_CLASS(ARB_Thruster,AActor,0,Engine)
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
};

class URB_ConstraintDrawComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RB_ConstraintDrawComponent
    class UMaterialInterface* LimitMaterial;
    //## END PROPS RB_ConstraintDrawComponent

    DECLARE_CLASS(URB_ConstraintDrawComponent,UPrimitiveComponent,0,Engine)
	// Primitive Component interface
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class URB_RadialImpulseComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RB_RadialImpulseComponent
    BYTE ImpulseFalloff;
    FLOAT ImpulseStrength;
    FLOAT ImpulseRadius;
    BITFIELD bVelChange:1;
    BITFIELD bCauseFracture:1;
    class UDrawSphereComponent* PreviewSphere;
    //## END PROPS RB_RadialImpulseComponent

    virtual void FireImpulse(FVector Origin);
    DECLARE_FUNCTION(execFireImpulse)
    {
        P_GET_STRUCT(FVector,Origin);
        P_FINISH;
        FireImpulse(Origin);
    }
    DECLARE_CLASS(URB_RadialImpulseComponent,UPrimitiveComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
public:
};

class URB_Handle : public UActorComponent
{
public:
    //## BEGIN PROPS RB_Handle
    class UPrimitiveComponent* GrabbedComponent;
    FName GrabbedBoneName;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bRotationConstrained:1;
    BITFIELD bInterpolating:1;
    class NxJoint* HandleData;
    class NxActor* KinActorData;
    FLOAT LinearDamping;
    FLOAT LinearStiffness;
    FLOAT AngularDamping;
    FLOAT AngularStiffness;
    FVector Destination;
    FVector StepSize;
    FVector Location;
    //## END PROPS RB_Handle

    virtual void GrabComponent(class UPrimitiveComponent* Component,FName InBoneName,FVector GrabLocation,UBOOL bConstrainRotation);
    virtual void ReleaseComponent();
    virtual void SetLocation(FVector NewLocation);
    virtual void SetSmoothLocation(FVector NewLocation,FLOAT MoveTime);
    virtual void UpdateSmoothLocation(const FVector& NewLocation);
    virtual void SetOrientation(FQuat NewOrientation);
    virtual FQuat GetOrientation();
    DECLARE_FUNCTION(execGrabComponent)
    {
        P_GET_OBJECT(UPrimitiveComponent,Component);
        P_GET_NAME(InBoneName);
        P_GET_STRUCT(FVector,GrabLocation);
        P_GET_UBOOL(bConstrainRotation);
        P_FINISH;
        GrabComponent(Component,InBoneName,GrabLocation,bConstrainRotation);
    }
    DECLARE_FUNCTION(execReleaseComponent)
    {
        P_FINISH;
        ReleaseComponent();
    }
    DECLARE_FUNCTION(execSetLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        SetLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetSmoothLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_GET_FLOAT(MoveTime);
        P_FINISH;
        SetSmoothLocation(NewLocation,MoveTime);
    }
    DECLARE_FUNCTION(execUpdateSmoothLocation)
    {
        P_GET_STRUCT_REF(FVector,NewLocation);
        P_FINISH;
        UpdateSmoothLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetOrientation)
    {
        P_GET_STRUCT(FQuat,NewOrientation);
        P_FINISH;
        SetOrientation(NewOrientation);
    }
    DECLARE_FUNCTION(execGetOrientation)
    {
        P_FINISH;
        *(FQuat*)Result=GetOrientation();
    }
    DECLARE_CLASS(URB_Handle,UActorComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	virtual void Tick(FLOAT DeltaTime);
public:
	virtual void TermComponentRBPhys(FRBPhysScene* InScene);

	// URB_Handle interface
};

class URB_Spring : public UActorComponent
{
public:
    //## BEGIN PROPS RB_Spring
    class UPrimitiveComponent* Component1;
    FName BoneName1;
    class UPrimitiveComponent* Component2;
    FName BoneName2;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bEnableForceMassRatio:1;
    FPointer SpringData;
    FLOAT TimeSinceActivation;
    FLOAT MinBodyMass;
    FLOAT SpringSaturateDist;
    FLOAT SpringMaxForce;
    FLOAT MaxForceMassRatio;
    FInterpCurveFloat SpringMaxForceTimeScale;
    FLOAT DampSaturateVel;
    FLOAT DampMaxForce;
    //## END PROPS RB_Spring

    virtual void SetComponents(class UPrimitiveComponent* InComponent1,FName InBoneName1,FVector Position1,class UPrimitiveComponent* InComponent2,FName InBoneName2,FVector Position2);
    virtual void Clear();
    DECLARE_FUNCTION(execSetComponents)
    {
        P_GET_OBJECT(UPrimitiveComponent,InComponent1);
        P_GET_NAME(InBoneName1);
        P_GET_STRUCT(FVector,Position1);
        P_GET_OBJECT(UPrimitiveComponent,InComponent2);
        P_GET_NAME(InBoneName2);
        P_GET_STRUCT(FVector,Position2);
        P_FINISH;
        SetComponents(InComponent1,InBoneName1,Position1,InComponent2,InBoneName2,Position2);
    }
    DECLARE_FUNCTION(execClear)
    {
        P_FINISH;
        Clear();
    }
    DECLARE_CLASS(URB_Spring,UActorComponent,0,Engine)
	// ActorComponent interface

	virtual void Tick(FLOAT DeltaTime);
	virtual void TermComponentRBPhys(FRBPhysScene* InScene);
};

class USVehicleSimBase : public UActorComponent
{
public:
    //## BEGIN PROPS SVehicleSimBase
    FLOAT WheelSuspensionStiffness;
    FLOAT WheelSuspensionDamping;
    FLOAT WheelSuspensionBias;
    FLOAT WheelLongExtremumSlip;
    FLOAT WheelLongExtremumValue;
    FLOAT WheelLongAsymptoteSlip;
    FLOAT WheelLongAsymptoteValue;
    FLOAT WheelLatExtremumSlip;
    FLOAT WheelLatExtremumValue;
    FLOAT WheelLatAsymptoteSlip;
    FLOAT WheelLatAsymptoteValue;
    FLOAT WheelInertia;
    BITFIELD bWheelSpeedOverride:1;
    BITFIELD bClampedFrictionModel:1;
    BITFIELD bAutoDrive:1;
    FLOAT AutoDriveSteer;
    //## END PROPS SVehicleSimBase

    DECLARE_CLASS(USVehicleSimBase,UActorComponent,0,Engine)
	virtual void ProcessCarInput(ASVehicle* Vehicle) {}
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime) {}

#if WITH_NOVODEX
	virtual void SetNxWheelShapeParams(class NxWheelShape* WheelShape, USVehicleWheel* VW, FLOAT LongGripScale=1.f, FLOAT LatGripScale=1.f);
	virtual void SetNxWheelShapeTireForceFunctions(class NxWheelShape* WheelShape, USVehicleWheel* VW, FLOAT LongGripScale=1.f, FLOAT LatGripScale=1.f);
#endif

	/** Returns a float representative of the vehcile's engine output. */
	virtual FLOAT GetEngineOutput(ASVehicle* Vehicle) { return 0.0f; }
};

class USVehicleSimCar : public USVehicleSimBase
{
public:
    //## BEGIN PROPS SVehicleSimCar
    FLOAT ChassisTorqueScale;
    FInterpCurveFloat MaxSteerAngleCurve;
    FLOAT SteerSpeed;
    FLOAT ReverseThrottle;
    FLOAT EngineBrakeFactor;
    FLOAT MaxBrakeTorque;
    FLOAT StopThreshold;
    BITFIELD bIsDriving:1;
    FLOAT ActualSteering;
    FLOAT TimeSinceThrottle;
    //## END PROPS SVehicleSimCar

    DECLARE_CLASS(USVehicleSimCar,USVehicleSimBase,0,Engine)
	// SVehicleSimBase interface.
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateHandbrake(ASVehicle* Vehicle);
};

class USVehicleSimTank : public USVehicleSimCar
{
public:
    //## BEGIN PROPS SVehicleSimTank
    FLOAT LeftTrackVel;
    FLOAT RightTrackVel;
    FLOAT LeftTrackTorque;
    FLOAT RightTrackTorque;
    FLOAT MaxEngineTorque;
    FLOAT EngineDamping;
    FLOAT InsideTrackTorqueFactor;
    FLOAT SteeringLatStiffnessFactor;
    FLOAT TurnInPlaceThrottle;
    FLOAT TurnMaxGripReduction;
    FLOAT TurnGripScaleRate;
    BITFIELD bTurnInPlaceOnSteer:1;
    //## END PROPS SVehicleSimTank

    DECLARE_CLASS(USVehicleSimTank,USVehicleSimCar,0,Engine)
	// SVehicleSimBase interface.
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	virtual void ApplyWheels(FLOAT InLeftTrackVel, FLOAT InRightTrackVel, ASVehicle* Vehicle);
};

class USVehicleWheel : public UComponent
{
public:
    //## BEGIN PROPS SVehicleWheel
    FLOAT Steer;
    FLOAT MotorTorque;
    FLOAT BrakeTorque;
    FLOAT ChassisTorque;
    BITFIELD bPoweredWheel:1;
    BITFIELD bHoverWheel:1;
    BITFIELD bCollidesVehicles:1;
    BITFIELD bCollidesPawns:1;
    BITFIELD bIsSquealing:1;
    BITFIELD bWheelOnGround:1;
    FLOAT SteerFactor;
    FName SkelControlName;
    class USkelControlWheel* WheelControl;
    FName BoneName;
    FVector BoneOffset;
    FLOAT WheelRadius;
    FLOAT SuspensionTravel;
    FLOAT SuspensionSpeed;
    class UParticleSystem* WheelParticleSystem;
    BYTE Side;
    FLOAT LongSlipFactor;
    FLOAT LatSlipFactor;
    FLOAT HandbrakeLongSlipFactor;
    FLOAT HandbrakeLatSlipFactor;
    FLOAT ParkedSlipFactor;
    FVector WheelPosition;
    FLOAT SpinVel;
    FLOAT LongSlipRatio;
    FLOAT LatSlipAngle;
    FVector ContactNormal;
    FVector LongDirection;
    FVector LatDirection;
    FLOAT ContactForce;
    FLOAT LongImpulse;
    FLOAT LatImpulse;
    FLOAT DesiredSuspensionPosition;
    FLOAT SuspensionPosition;
    FLOAT CurrentRotation;
    FPointer WheelShape;
    INT WheelMaterialIndex;
    class UClass* WheelPSCClass;
    class UParticleSystemComponent* WheelParticleComp;
    FName SlipParticleParamName;
    //## END PROPS SVehicleWheel

    DECLARE_CLASS(USVehicleWheel,UComponent,0,Engine)
#if WITH_NOVODEX
	class NxWheelShape* GetNxWheelShape()
	{
		return (NxWheelShape*)WheelShape;
	}
#endif

	/** @return whether this wheel wants a particle component attached to it */
	virtual UBOOL WantsParticleComponent();
};

class URB_BodySetup : public UKMeshProps
{
public:
    //## BEGIN PROPS RB_BodySetup
    BYTE SleepFamily;
    FName BoneName;
    BITFIELD bFixed:1;
    BITFIELD bNoCollision:1;
    BITFIELD bBlockZeroExtent:1;
    BITFIELD bBlockNonZeroExtent:1;
    BITFIELD bEnableContinuousCollisionDetection:1;
    BITFIELD bAlwaysFullAnimWeight:1;
    BITFIELD bConsiderForBounds:1;
    class UPhysicalMaterial* PhysMaterial;
    FLOAT MassScale;
    TArrayNoInit<FPointer> CollisionGeom;
    TArrayNoInit<FVector> CollisionGeomScale3D;
    TArrayNoInit<FVector> PreCachedPhysScale;
    TArrayNoInit<FKCachedConvexData> PreCachedPhysData;
    INT PreCachedPhysDataVersion;
    //## END PROPS RB_BodySetup

    DECLARE_CLASS(URB_BodySetup,UKMeshProps,0,Engine)
	// UObject interface.
	virtual void PreSave();
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void FinishDestroy();
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// URB_BodySetup interface.
	void	CopyBodyPropertiesFrom(class URB_BodySetup* fromSetup);
	void	ClearShapeCache();

	/** Pre-cache this mesh at all desired scales. */
	void PreCachePhysicsData();

	/*
	* Create and add a new physics collision representation to this body setup
	* @param Scale3D    - Scale at which this geometry should be created at
	* @param CachedData - Unreal description of the collision geometry to create
	* @param DebugName  - debug name to output
	* returns TRUE if successful
	*/
	UBOOL AddCollisionFromCachedData(const FVector& Scale3D, FKCachedConvexData* CachedData, const FString& DebugName);
};

class UPhysicalMaterial : public UObject
{
public:
    //## BEGIN PROPS PhysicalMaterial
    INT MaterialIndex;
    FLOAT Friction;
    FLOAT Restitution;
    BITFIELD bForceConeFriction:1;
    BITFIELD bEnableAnisotropicFriction:1;
    FVector AnisoFrictionDir;
    FLOAT FrictionV;
    FLOAT Density;
    FLOAT AngularDamping;
    FLOAT LinearDamping;
    FLOAT MagneticResponse;
    FLOAT WindResponse;
    FLOAT ImpactThreshold;
    FLOAT ImpactReFireDelay;
    class UParticleSystem* ImpactEffect;
    class USoundCue* ImpactSound;
    FLOAT SlideThreshold;
    FLOAT SlideReFireDelay;
    class UParticleSystem* SlideEffect;
    class USoundCue* SlideSound;
    class USoundCue* FractureSoundExplosion;
    class USoundCue* FractureSoundSingle;
    class UPhysicalMaterial* Parent;
    class UPhysicalMaterialPropertyBase* PhysicalMaterialProperty;
    //## END PROPS PhysicalMaterial

    virtual struct FPhysEffectInfo FindPhysEffectInfo(BYTE Type);
    DECLARE_FUNCTION(execFindPhysEffectInfo)
    {
        P_GET_BYTE(Type);
        P_FINISH;
        *(struct FPhysEffectInfo*)Result=FindPhysEffectInfo(Type);
    }
    DECLARE_CLASS(UPhysicalMaterial,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void FinishDestroy();

	/**
     * This will fix any old PhysicalMaterials that were created in the PhysMaterial's outer instead
	 * of correctly inside the PhysMaterial.  This will allow "broken" PhysMaterials to be renamed.
	 **/
	virtual UBOOL Rename( const TCHAR* InName, UObject* NewOuter, ERenameFlags Flags );
};

class UPhysicalMaterialPropertyBase : public UObject
{
public:
    //## BEGIN PROPS PhysicalMaterialPropertyBase
    //## END PROPS PhysicalMaterialPropertyBase

    DECLARE_ABSTRACT_CLASS(UPhysicalMaterialPropertyBase,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPhysicalMaterialPropertyBase)
};

class UPhysicsAsset : public UObject
{
public:
    //## BEGIN PROPS PhysicsAsset
    class USkeletalMesh* DefaultSkelMesh;
    TArrayNoInit<class URB_BodySetup*> BodySetup;
    TMap<FName, INT> BodySetupIndexMap;
    TArrayNoInit<INT> BoundsBodies;
    TArrayNoInit<class URB_ConstraintSetup*> ConstraintSetup;
    class UPhysicsAssetInstance* DefaultInstance;
    //## END PROPS PhysicsAsset

    INT FindBodyIndex(FName BodyName);
    DECLARE_FUNCTION(execFindBodyIndex)
    {
        P_GET_NAME(BodyName);
        P_FINISH;
        *(INT*)Result=FindBodyIndex(BodyName);
    }
    DECLARE_CLASS(UPhysicsAsset,UObject,0,Engine)
	// UObject interface
	virtual void PostLoad();

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// Creates a Physics Asset using the supplied Skeletal Mesh as a starting point.
	UBOOL CreateFromSkeletalMesh( class USkeletalMesh* skelMesh, FPhysAssetCreateParams& Params );
	static void CreateCollisionFromBone( URB_BodySetup* bs, class USkeletalMesh* skelMesh, INT BoneIndex, FPhysAssetCreateParams& Params, TArray<struct FBoneVertInfo>& Infos );

	INT						FindControllingBodyIndex(class USkeletalMesh* skelMesh, INT BoneIndex);
	INT						FindConstraintIndex(FName ConstraintName);
	FName					FindConstraintBoneName(INT ConstraintIndex);

	/** Utility for getting indices of all bodies below (and including) the one with the supplied name. */
	void					GetBodyIndicesBelow(TArray<INT>& OutBodyIndices, FName InBoneName, USkeletalMesh* InSkelMesh);

	FBox					CalcAABB(class USkeletalMeshComponent* SkelComp);
	UBOOL					LineCheck(FCheckResult& Result, class USkeletalMeshComponent* SkelComp, const FVector& Start, const FVector& End, const FVector& Extent, UBOOL bOnlyPerPolyShapes);
	FCheckResult*			LineCheckAllInteractions( FMemStack& Mem, class USkeletalMeshComponent* SkelComp, const FVector& Start, const FVector& End, const FVector& Extent, UBOOL bPerPolyShapes );
	UBOOL					PointCheck(FCheckResult& Result, class USkeletalMeshComponent* SkelComp, const FVector& Location, const FVector& Extent);
	void					UpdateMassProps();

	// For PhAT only really...
	INT CreateNewBody(FName InBodyName);
	void DestroyBody(INT BodyIndex);

	INT CreateNewConstraint(FName InConstraintName, URB_ConstraintSetup* InConstraintSetup = NULL);
	void DestroyConstraint(INT ConstraintIndex);

	void BodyFindConstraints(INT BodyIndex, TArray<INT>& Constraints);
	void ClearShapeCaches();

	void UpdateBodyIndices();

	void WeldBodies(INT BaseBodyIndex, INT AddBodyIndex, USkeletalMeshComponent* SkelComp);

	void DrawCollision(class FPrimitiveDrawInterface* PDI, const USkeletalMesh* SkelMesh, const TArray<FMatrix>& SpaceBases, const FMatrix& LocalToWorld, FLOAT Scale);
	void DrawConstraints(class FPrimitiveDrawInterface* PDI, const USkeletalMesh* SkelMesh, const TArray<FMatrix>& SpaceBases, const FMatrix& LocalToWorld, FLOAT Scale);

	void FixOuters();

	/** Update the BoundsBodies array and cache the indices of bodies marked with bConsiderForBounds to BoundsBodies array. */
	void UpdateBoundsBodiesArray();

	/** Update the BodySetup Array Index Map.  */
	void UpdateBodySetupIndexMap();
};

class UPhysicsAssetInstance : public UObject
{
public:
    //## BEGIN PROPS PhysicsAssetInstance
    class AActor* Owner;
    INT RootBodyIndex;
    TArrayNoInit<class URB_BodyInstance*> Bodies;
    TArrayNoInit<class URB_ConstraintInstance*> Constraints;
    TMap<FRigidBodyIndexPair,UBOOL> CollisionDisableTable;
    FLOAT LinearSpringScale;
    FLOAT LinearDampingScale;
    FLOAT LinearForceLimitScale;
    FLOAT AngularSpringScale;
    FLOAT AngularDampingScale;
    FLOAT AngularForceLimitScale;
    BITFIELD bInitBodies:1;
    //## END PROPS PhysicsAssetInstance

    void SetLinearDriveScale(FLOAT InLinearSpringScale,FLOAT InLinearDampingScale,FLOAT InLinearForceLimitScale);
    void SetAngularDriveScale(FLOAT InAngularSpringScale,FLOAT InAngularDampingScale,FLOAT InAngularForceLimitScale);
    FLOAT GetTotalMassBelowBone(FName InBoneName,class UPhysicsAsset* InAsset,class USkeletalMesh* InSkelMesh);
    void SetAllBodiesFixed(UBOOL bNewFixed);
    void SetNamedBodiesFixed(UBOOL bNewFixed,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMesh,UBOOL bSetOtherBodiesToComplement=FALSE,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetAllMotorsAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,class USkeletalMeshComponent* SkelMesh=NULL,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetAllMotorsAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetAllMotorsAngularDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit,class USkeletalMeshComponent* SkelMesh=NULL,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetNamedMotorsAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSetOtherBodiesToComplement=FALSE);
    void SetNamedMotorsAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSetOtherBodiesToComplement=FALSE);
    void SetNamedRBBoneSprings(UBOOL bEnable,const TArray<FName>& BoneNames,FLOAT InBoneLinearSpring,FLOAT InBoneAngularSpring,class USkeletalMeshComponent* SkelMeshComp);
    void SetNamedBodiesBlockRigidBody(UBOOL bNewBlockRigidBody,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMesh);
    void SetFullAnimWeightBlockRigidBody(UBOOL bNewBlockRigidBody,class USkeletalMeshComponent* SkelMesh);
    void SetFullAnimWeightBonesFixed(UBOOL bNewFixed,class USkeletalMeshComponent* SkelMesh);
    class URB_BodyInstance* FindBodyInstance(FName BodyName,class UPhysicsAsset* InAsset);
    class URB_ConstraintInstance* FindConstraintInstance(FName ConName,class UPhysicsAsset* InAsset);
    DECLARE_FUNCTION(execSetLinearDriveScale)
    {
        P_GET_FLOAT(InLinearSpringScale);
        P_GET_FLOAT(InLinearDampingScale);
        P_GET_FLOAT(InLinearForceLimitScale);
        P_FINISH;
        SetLinearDriveScale(InLinearSpringScale,InLinearDampingScale,InLinearForceLimitScale);
    }
    DECLARE_FUNCTION(execSetAngularDriveScale)
    {
        P_GET_FLOAT(InAngularSpringScale);
        P_GET_FLOAT(InAngularDampingScale);
        P_GET_FLOAT(InAngularForceLimitScale);
        P_FINISH;
        SetAngularDriveScale(InAngularSpringScale,InAngularDampingScale,InAngularForceLimitScale);
    }
    DECLARE_FUNCTION(execGetTotalMassBelowBone)
    {
        P_GET_NAME(InBoneName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_GET_OBJECT(USkeletalMesh,InSkelMesh);
        P_FINISH;
        *(FLOAT*)Result=GetTotalMassBelowBone(InBoneName,InAsset,InSkelMesh);
    }
    DECLARE_FUNCTION(execSetAllBodiesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_FINISH;
        SetAllBodiesFixed(bNewFixed);
    }
    DECLARE_FUNCTION(execSetNamedBodiesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        SetNamedBodiesFixed(bNewFixed,BoneNames,SkelMesh,bSetOtherBodiesToComplement,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_OBJECT_OPTX(USkeletalMeshComponent,SkelMesh,NULL);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        SetAllMotorsAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive,SkelMesh,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        SetAllMotorsAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive,SkelMeshComp,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_GET_OBJECT_OPTX(USkeletalMeshComponent,SkelMesh,NULL);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        SetAllMotorsAngularDriveParams(InSpring,InDamping,InForceLimit,SkelMesh,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetNamedMotorsAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_FINISH;
        SetNamedMotorsAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive,BoneNames,SkelMeshComp,bSetOtherBodiesToComplement);
    }
    DECLARE_FUNCTION(execSetNamedMotorsAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_FINISH;
        SetNamedMotorsAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive,BoneNames,SkelMeshComp,bSetOtherBodiesToComplement);
    }
    DECLARE_FUNCTION(execSetNamedRBBoneSprings)
    {
        P_GET_UBOOL(bEnable);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_FLOAT(InBoneLinearSpring);
        P_GET_FLOAT(InBoneAngularSpring);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_FINISH;
        SetNamedRBBoneSprings(bEnable,BoneNames,InBoneLinearSpring,InBoneAngularSpring,SkelMeshComp);
    }
    DECLARE_FUNCTION(execSetNamedBodiesBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        SetNamedBodiesBlockRigidBody(bNewBlockRigidBody,BoneNames,SkelMesh);
    }
    DECLARE_FUNCTION(execSetFullAnimWeightBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        SetFullAnimWeightBlockRigidBody(bNewBlockRigidBody,SkelMesh);
    }
    DECLARE_FUNCTION(execSetFullAnimWeightBonesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        SetFullAnimWeightBonesFixed(bNewFixed,SkelMesh);
    }
    DECLARE_FUNCTION(execFindBodyInstance)
    {
        P_GET_NAME(BodyName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_FINISH;
        *(class URB_BodyInstance**)Result=FindBodyInstance(BodyName,InAsset);
    }
    DECLARE_FUNCTION(execFindConstraintInstance)
    {
        P_GET_NAME(ConName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_FINISH;
        *(class URB_ConstraintInstance**)Result=FindConstraintInstance(ConName,InAsset);
    }
    DECLARE_CLASS(UPhysicsAssetInstance,UObject,0,Engine)
	// UObject interface
	virtual void			Serialize(FArchive& Ar);

	// UPhysicsAssetInstance interface
	void					InitInstance(class USkeletalMeshComponent* SkelComp, class UPhysicsAsset* PhysAsset, UBOOL bFixed, FRBPhysScene* InRBScene);
	UBOOL					TermInstance(FRBPhysScene* Scene);

	/** Terminate physics on all bodies below the named bone */
	void					TermBodiesBelow(FName ParentBoneName, class USkeletalMeshComponent* SkelComp);

	void					DisableCollision(class URB_BodyInstance* BodyA, class URB_BodyInstance* BodyB);
	void					EnableCollision(class URB_BodyInstance* BodyA, class URB_BodyInstance* BodyB);
};

class UPhysicsLODVerticalDestructible : public UObject
{
public:
    //## BEGIN PROPS PhysicsLODVerticalDestructible
    INT MaxDynamicChunkCount;
    FLOAT DebrisLifetime;
    //## END PROPS PhysicsLODVerticalDestructible

    DECLARE_CLASS(UPhysicsLODVerticalDestructible,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UPhysicsLODVerticalDestructible)
};

class UPhysicsLODVerticalEmitter : public UObject
{
public:
    //## BEGIN PROPS PhysicsLODVerticalEmitter
    INT ParticlePercentage;
    //## END PROPS PhysicsLODVerticalEmitter

    DECLARE_CLASS(UPhysicsLODVerticalEmitter,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UPhysicsLODVerticalEmitter)
};

class URB_BodyInstance : public UObject
{
public:
    //## BEGIN PROPS RB_BodyInstance
    class UPrimitiveComponent* OwnerComponent;
    INT BodyIndex;
    FVector Velocity;
    FVector PreviousVelocity;
    INT SceneIndex;
    FPointer BodyData;
    FPointer BoneSpring;
    FPointer BoneSpringKinActor;
    BITFIELD bEnableBoneSpringLinear:1;
    BITFIELD bEnableBoneSpringAngular:1;
    BITFIELD bDisableOnOverextension:1;
    BITFIELD bNotifyOwnerOnOverextension:1;
    BITFIELD bTeleportOnOverextension:1;
    BITFIELD bUseKinActorForBoneSpring:1;
    BITFIELD bMakeSpringToBaseCollisionComponent:1;
    BITFIELD bOnlyCollideWithPawns:1;
    BITFIELD bEnableCollisionResponse:1;
    BITFIELD bPushBody:1;
    FLOAT BoneLinearSpring;
    FLOAT BoneLinearDamping;
    FLOAT BoneAngularSpring;
    FLOAT BoneAngularDamping;
    FLOAT OverextensionThreshold;
    FLOAT CustomGravityFactor;
    FLOAT LastEffectPlayedTime;
    class UPhysicalMaterial* PhysMaterialOverride;
    FLOAT ContactReportForceThreshold;
    //## END PROPS RB_BodyInstance

    void SetFixed(UBOOL bNewFixed);
    UBOOL IsFixed();
    UBOOL IsValidBodyInstance();
    class UPhysicsAssetInstance* GetPhysicsAssetInstance();
    FMatrix GetUnrealWorldTM();
    FVector GetUnrealWorldVelocity();
    FVector GetUnrealWorldAngularVelocity();
    void EnableBoneSpring(UBOOL bInEnableLinear,UBOOL bInEnableAngular,const FMatrix& InBoneTarget);
    void SetBoneSpringParams(FLOAT InLinearSpring,FLOAT InLinearDamping,FLOAT InAngularSpring,FLOAT InAngularDamping);
    void SetBoneSpringTarget(const FMatrix& InBoneTarget,UBOOL bTeleport);
    void SetBlockRigidBody(UBOOL bNewBlockRigidBody);
    void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
    void EnableCollisionResponse(UBOOL bEnableResponse);
    void SetContactReportForceThreshold(FLOAT Threshold);
    DECLARE_FUNCTION(execSetFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_FINISH;
        SetFixed(bNewFixed);
    }
    DECLARE_FUNCTION(execIsFixed)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFixed();
    }
    DECLARE_FUNCTION(execIsValidBodyInstance)
    {
        P_FINISH;
        *(UBOOL*)Result=IsValidBodyInstance();
    }
    DECLARE_FUNCTION(execGetPhysicsAssetInstance)
    {
        P_FINISH;
        *(class UPhysicsAssetInstance**)Result=GetPhysicsAssetInstance();
    }
    DECLARE_FUNCTION(execGetUnrealWorldTM)
    {
        P_FINISH;
        *(FMatrix*)Result=GetUnrealWorldTM();
    }
    DECLARE_FUNCTION(execGetUnrealWorldVelocity)
    {
        P_FINISH;
        *(FVector*)Result=GetUnrealWorldVelocity();
    }
    DECLARE_FUNCTION(execGetUnrealWorldAngularVelocity)
    {
        P_FINISH;
        *(FVector*)Result=GetUnrealWorldAngularVelocity();
    }
    DECLARE_FUNCTION(execEnableBoneSpring)
    {
        P_GET_UBOOL(bInEnableLinear);
        P_GET_UBOOL(bInEnableAngular);
        P_GET_STRUCT_REF(FMatrix,InBoneTarget);
        P_FINISH;
        EnableBoneSpring(bInEnableLinear,bInEnableAngular,InBoneTarget);
    }
    DECLARE_FUNCTION(execSetBoneSpringParams)
    {
        P_GET_FLOAT(InLinearSpring);
        P_GET_FLOAT(InLinearDamping);
        P_GET_FLOAT(InAngularSpring);
        P_GET_FLOAT(InAngularDamping);
        P_FINISH;
        SetBoneSpringParams(InLinearSpring,InLinearDamping,InAngularSpring,InAngularDamping);
    }
    DECLARE_FUNCTION(execSetBoneSpringTarget)
    {
        P_GET_STRUCT_REF(FMatrix,InBoneTarget);
        P_GET_UBOOL(bTeleport);
        P_FINISH;
        SetBoneSpringTarget(InBoneTarget,bTeleport);
    }
    DECLARE_FUNCTION(execSetBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_FINISH;
        SetBlockRigidBody(bNewBlockRigidBody);
    }
    DECLARE_FUNCTION(execSetPhysMaterialOverride)
    {
        P_GET_OBJECT(UPhysicalMaterial,NewPhysMaterial);
        P_FINISH;
        SetPhysMaterialOverride(NewPhysMaterial);
    }
    DECLARE_FUNCTION(execEnableCollisionResponse)
    {
        P_GET_UBOOL(bEnableResponse);
        P_FINISH;
        EnableCollisionResponse(bEnableResponse);
    }
    DECLARE_FUNCTION(execSetContactReportForceThreshold)
    {
        P_GET_FLOAT(Threshold);
        P_FINISH;
        SetContactReportForceThreshold(Threshold);
    }
    DECLARE_CLASS(URB_BodyInstance,UObject,0,Engine)
	// Object interface
	virtual void FinishDestroy();

	// RB_BodyInstance interface
	void InitBody(class URB_BodySetup* setup, const FMatrix& transform, const FVector& Scale3D, UBOOL bFixed, UPrimitiveComponent* PrimComp, FRBPhysScene* InRBScene);
	UBOOL TermBody(FRBPhysScene* Scene);

	FVector GetCOMPosition();
	FLOAT GetBodyMass();
	void DrawCOMPosition( FPrimitiveDrawInterface* PDI, FLOAT COMRenderSize, const FColor& COMRenderColor );

	/** Utility for copying properties from one BodyInstance to another. */
	void CopyBodyInstancePropertiesFrom(URB_BodyInstance* FromInst);

	UPhysicalMaterial* GetPhysicalMaterial();

#if WITH_NOVODEX
	class NxActor* GetNxActor();
	void UpdatePhysMaterialOverride();
#endif
};

class URB_ConstraintInstance : public UObject
{
public:
    //## BEGIN PROPS RB_ConstraintInstance
    class AActor* Owner;
    class UPrimitiveComponent* OwnerComponent;
    INT ConstraintIndex;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bLinearXPositionDrive:1;
    BITFIELD bLinearXVelocityDrive:1;
    BITFIELD bLinearYPositionDrive:1;
    BITFIELD bLinearYVelocityDrive:1;
    BITFIELD bLinearZPositionDrive:1;
    BITFIELD bLinearZVelocityDrive:1;
    BITFIELD bSwingPositionDrive:1;
    BITFIELD bSwingVelocityDrive:1;
    BITFIELD bTwistPositionDrive:1;
    BITFIELD bTwistVelocityDrive:1;
    BITFIELD bAngularSlerpDrive:1;
    BITFIELD bTerminated:1;
    class NxJoint* ConstraintData;
    FVector LinearPositionTarget;
    FVector LinearVelocityTarget;
    FLOAT LinearDriveSpring;
    FLOAT LinearDriveDamping;
    FLOAT LinearDriveForceLimit;
    FQuat AngularPositionTarget;
    FVector AngularVelocityTarget;
    FLOAT AngularDriveSpring;
    FLOAT AngularDriveDamping;
    FLOAT AngularDriveForceLimit;
    FPointer DummyKinActor;
    //## END PROPS RB_ConstraintInstance

    void InitConstraint(class UPrimitiveComponent* PrimComp1,class UPrimitiveComponent* PrimComp2,class URB_ConstraintSetup* Setup,FLOAT Scale,class AActor* InOwner,class UPrimitiveComponent* InPrimComp,UBOOL bMakeKinForBody1);
    class UPhysicsAssetInstance* GetPhysicsAssetInstance();
    FVector GetConstraintLocation();
    void SetLinearPositionDrive(UBOOL bEnableXDrive,UBOOL bEnableYDrive,UBOOL bEnableZDrive);
    void SetLinearVelocityDrive(UBOOL bEnableXDrive,UBOOL bEnableYDrive,UBOOL bEnableZDrive);
    void SetAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetLinearPositionTarget(FVector InPosTarget);
    void SetLinearVelocityTarget(FVector InVelTarget);
    void SetLinearDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetAngularPositionTarget(FQuat InPosTarget);
    void SetAngularVelocityTarget(FVector InVelTarget);
    void SetAngularDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetAngularDOFLimitScale(FLOAT InSwing1LimitScale,FLOAT InSwing2LimitScale,FLOAT InTwistLimitScale,class URB_ConstraintSetup* InSetup);
    void SetLinearLimitSize(FLOAT NewLimitSize);
    void MoveKinActorTransform(FMatrix& NewTM);
    DECLARE_FUNCTION(execInitConstraint)
    {
        P_GET_OBJECT(UPrimitiveComponent,PrimComp1);
        P_GET_OBJECT(UPrimitiveComponent,PrimComp2);
        P_GET_OBJECT(URB_ConstraintSetup,Setup);
        P_GET_FLOAT(Scale);
        P_GET_OBJECT(AActor,InOwner);
        P_GET_OBJECT(UPrimitiveComponent,InPrimComp);
        P_GET_UBOOL(bMakeKinForBody1);
        P_FINISH;
        InitConstraint(PrimComp1,PrimComp2,Setup,Scale,InOwner,InPrimComp,bMakeKinForBody1);
    }
    DECLARE_FUNCTION(execTermConstraint);
    DECLARE_FUNCTION(execGetPhysicsAssetInstance)
    {
        P_FINISH;
        *(class UPhysicsAssetInstance**)Result=GetPhysicsAssetInstance();
    }
    DECLARE_FUNCTION(execGetConstraintLocation)
    {
        P_FINISH;
        *(FVector*)Result=GetConstraintLocation();
    }
    DECLARE_FUNCTION(execSetLinearPositionDrive)
    {
        P_GET_UBOOL(bEnableXDrive);
        P_GET_UBOOL(bEnableYDrive);
        P_GET_UBOOL(bEnableZDrive);
        P_FINISH;
        SetLinearPositionDrive(bEnableXDrive,bEnableYDrive,bEnableZDrive);
    }
    DECLARE_FUNCTION(execSetLinearVelocityDrive)
    {
        P_GET_UBOOL(bEnableXDrive);
        P_GET_UBOOL(bEnableYDrive);
        P_GET_UBOOL(bEnableZDrive);
        P_FINISH;
        SetLinearVelocityDrive(bEnableXDrive,bEnableYDrive,bEnableZDrive);
    }
    DECLARE_FUNCTION(execSetAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        SetAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        SetAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetLinearPositionTarget)
    {
        P_GET_STRUCT(FVector,InPosTarget);
        P_FINISH;
        SetLinearPositionTarget(InPosTarget);
    }
    DECLARE_FUNCTION(execSetLinearVelocityTarget)
    {
        P_GET_STRUCT(FVector,InVelTarget);
        P_FINISH;
        SetLinearVelocityTarget(InVelTarget);
    }
    DECLARE_FUNCTION(execSetLinearDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        SetLinearDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetAngularPositionTarget)
    {
        P_GET_STRUCT(FQuat,InPosTarget);
        P_FINISH;
        SetAngularPositionTarget(InPosTarget);
    }
    DECLARE_FUNCTION(execSetAngularVelocityTarget)
    {
        P_GET_STRUCT(FVector,InVelTarget);
        P_FINISH;
        SetAngularVelocityTarget(InVelTarget);
    }
    DECLARE_FUNCTION(execSetAngularDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        SetAngularDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetAngularDOFLimitScale)
    {
        P_GET_FLOAT(InSwing1LimitScale);
        P_GET_FLOAT(InSwing2LimitScale);
        P_GET_FLOAT(InTwistLimitScale);
        P_GET_OBJECT(URB_ConstraintSetup,InSetup);
        P_FINISH;
        SetAngularDOFLimitScale(InSwing1LimitScale,InSwing2LimitScale,InTwistLimitScale,InSetup);
    }
    DECLARE_FUNCTION(execSetLinearLimitSize)
    {
        P_GET_FLOAT(NewLimitSize);
        P_FINISH;
        SetLinearLimitSize(NewLimitSize);
    }
    DECLARE_FUNCTION(execMoveKinActorTransform)
    {
        P_GET_STRUCT_REF(FMatrix,NewTM);
        P_FINISH;
        MoveKinActorTransform(NewTM);
    }
    DECLARE_CLASS(URB_ConstraintInstance,UObject,0,Engine)
	// Object interface
	virtual void FinishDestroy();

	// RB_ConstraintInstance interface

	UBOOL TermConstraint(FRBPhysScene* Scene, UBOOL bFireBrokenEvent);

	void CopyInstanceParamsFrom(class URB_ConstraintInstance* fromInstance);
};

struct FLinearDOFSetup
{
    BYTE bLimited;
    FLOAT LimitSize;

    /** Constructors */
    FLinearDOFSetup() {}
    FLinearDOFSetup(EEventParm)
    {
        appMemzero(this, sizeof(FLinearDOFSetup));
    }
};

class URB_ConstraintSetup : public UObject
{
public:
    //## BEGIN PROPS RB_ConstraintSetup
    FName JointName;
    FName ConstraintBone1;
    FName ConstraintBone2;
    FVector Pos1;
    FVector PriAxis1;
    FVector SecAxis1;
    FVector Pos2;
    FVector PriAxis2;
    FVector SecAxis2;
    FVector PulleyPivot1;
    FVector PulleyPivot2;
    BITFIELD bEnableProjection:1;
    BITFIELD bLinearLimitSoft:1;
    BITFIELD bLinearBreakable:1;
    BITFIELD bSwingLimited:1;
    BITFIELD bTwistLimited:1;
    BITFIELD bSwingLimitSoft:1;
    BITFIELD bTwistLimitSoft:1;
    BITFIELD bAngularBreakable:1;
    BITFIELD bIsPulley:1;
    BITFIELD bMaintainMinDistance:1;
    struct FLinearDOFSetup LinearXSetup;
    struct FLinearDOFSetup LinearYSetup;
    struct FLinearDOFSetup LinearZSetup;
    FLOAT LinearLimitStiffness;
    FLOAT LinearLimitDamping;
    FLOAT LinearBreakThreshold;
    FLOAT Swing1LimitAngle;
    FLOAT Swing2LimitAngle;
    FLOAT TwistLimitAngle;
    FLOAT SwingLimitStiffness;
    FLOAT SwingLimitDamping;
    FLOAT TwistLimitStiffness;
    FLOAT TwistLimitDamping;
    FLOAT AngularBreakThreshold;
    FLOAT PulleyRatio;
    //## END PROPS RB_ConstraintSetup

    DECLARE_CLASS(URB_ConstraintSetup,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// Get/SetRefFrameMatrix only used in PhAT
	FMatrix GetRefFrameMatrix(INT BodyIndex);
	void SetRefFrameMatrix(INT BodyIndex, const FMatrix& RefFrame);

	void CopyConstraintGeometryFrom(class URB_ConstraintSetup* fromSetup);
	void CopyConstraintParamsFrom(class URB_ConstraintSetup* fromSetup);

	void DrawConstraint(class FPrimitiveDrawInterface* PDI, 
		FLOAT Scale, UBOOL bDrawLimits, UBOOL bDrawSelected, UMaterialInterface* LimitMaterial,
		const FMatrix& Con1Frame, const FMatrix& Con2Frame, UBOOL bDrawAsPoint);
};

class URB_BSJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_BSJointSetup
    //## END PROPS RB_BSJointSetup

    DECLARE_CLASS(URB_BSJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_BSJointSetup)
};

class URB_DistanceJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_DistanceJointSetup
    //## END PROPS RB_DistanceJointSetup

    DECLARE_CLASS(URB_DistanceJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_DistanceJointSetup)
};

class URB_HingeSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_HingeSetup
    //## END PROPS RB_HingeSetup

    DECLARE_CLASS(URB_HingeSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_HingeSetup)
};

class URB_PrismaticSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_PrismaticSetup
    //## END PROPS RB_PrismaticSetup

    DECLARE_CLASS(URB_PrismaticSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_PrismaticSetup)
};

class URB_PulleyJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_PulleyJointSetup
    //## END PROPS RB_PulleyJointSetup

    DECLARE_CLASS(URB_PulleyJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_PulleyJointSetup)
};

class URB_SkelJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_SkelJointSetup
    //## END PROPS RB_SkelJointSetup

    DECLARE_CLASS(URB_SkelJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_SkelJointSetup)
};

class URB_StayUprightSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_StayUprightSetup
    //## END PROPS RB_StayUprightSetup

    DECLARE_CLASS(URB_StayUprightSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_StayUprightSetup)
};

#endif // !INCLUDED_ENGINE_PHYSICS_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AKActor,-1,execResolveRBState);
AUTOGENERATE_FUNCTION(AKActor,-1,execGetKActorPhysMaterial);
AUTOGENERATE_FUNCTION(AKActorSpawnable,-1,execResetComponents);
AUTOGENERATE_FUNCTION(UPhysicalMaterial,-1,execFindPhysEffectInfo);
AUTOGENERATE_FUNCTION(UPhysicsAsset,-1,execFindBodyIndex);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execFindConstraintInstance);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execFindBodyInstance);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetFullAnimWeightBonesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetFullAnimWeightBlockRigidBody);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedBodiesBlockRigidBody);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedRBBoneSprings);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedMotorsAngularVelocityDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedMotorsAngularPositionDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularDriveParams);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularVelocityDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularPositionDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedBodiesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllBodiesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execGetTotalMassBelowBone);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAngularDriveScale);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetLinearDriveScale);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetContactReportForceThreshold);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execEnableCollisionResponse);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetPhysMaterialOverride);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBlockRigidBody);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBoneSpringTarget);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBoneSpringParams);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execEnableBoneSpring);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldAngularVelocity);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldVelocity);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldTM);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetPhysicsAssetInstance);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execIsValidBodyInstance);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execIsFixed);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetFixed);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execTermConstraint);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execInitConstraint);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execSetDisableCollision);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execMoveKinActorTransform);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearLimitSize);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularDOFLimitScale);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularDriveParams);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularVelocityTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularPositionTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearDriveParams);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearVelocityTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearPositionTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularVelocityDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularPositionDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearVelocityDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearPositionDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execGetConstraintLocation);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execGetPhysicsAssetInstance);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execTermConstraint);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execInitConstraint);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execGetOrientation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetOrientation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execUpdateSmoothLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetSmoothLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execReleaseComponent);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execGrabComponent);
AUTOGENERATE_FUNCTION(ARB_LineImpulseActor,-1,execFireLineImpulse);
AUTOGENERATE_FUNCTION(URB_RadialImpulseComponent,-1,execFireImpulse);
AUTOGENERATE_FUNCTION(URB_Spring,-1,execClear);
AUTOGENERATE_FUNCTION(URB_Spring,-1,execSetComponents);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execHasWheelsOnGround);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execInitVehicleRagdoll);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execSetWheelCollision);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PHYSICS_NATIVE_DEFS
#define ENGINE_PHYSICS_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,AKActor);
DECLARE_NATIVE_TYPE(Engine,AKActorSpawnable);
DECLARE_NATIVE_TYPE(Engine,AKAsset);
DECLARE_NATIVE_TYPE(Engine,UPhysicalMaterial);
DECLARE_NATIVE_TYPE(Engine,UPhysicalMaterialPropertyBase);
DECLARE_NATIVE_TYPE(Engine,UPhysicsAsset);
DECLARE_NATIVE_TYPE(Engine,UPhysicsAssetInstance);
DECLARE_NATIVE_TYPE(Engine,UPhysicsLODVerticalDestructible);
DECLARE_NATIVE_TYPE(Engine,UPhysicsLODVerticalEmitter);
DECLARE_NATIVE_TYPE(Engine,URB_BodyInstance);
DECLARE_NATIVE_TYPE(Engine,URB_BodySetup);
DECLARE_NATIVE_TYPE(Engine,URB_BSJointSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_ConstraintActor);
DECLARE_NATIVE_TYPE(Engine,URB_ConstraintDrawComponent);
DECLARE_NATIVE_TYPE(Engine,URB_ConstraintInstance);
DECLARE_NATIVE_TYPE(Engine,URB_ConstraintSetup);
DECLARE_NATIVE_TYPE(Engine,URB_DistanceJointSetup);
DECLARE_NATIVE_TYPE(Engine,URB_Handle);
DECLARE_NATIVE_TYPE(Engine,URB_HingeSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_LineImpulseActor);
DECLARE_NATIVE_TYPE(Engine,URB_PrismaticSetup);
DECLARE_NATIVE_TYPE(Engine,URB_PulleyJointSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_RadialImpulseActor);
DECLARE_NATIVE_TYPE(Engine,URB_RadialImpulseComponent);
DECLARE_NATIVE_TYPE(Engine,URB_SkelJointSetup);
DECLARE_NATIVE_TYPE(Engine,URB_Spring);
DECLARE_NATIVE_TYPE(Engine,URB_StayUprightSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_Thruster);
DECLARE_NATIVE_TYPE(Engine,ASVehicle);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimBase);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimCar);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimTank);
DECLARE_NATIVE_TYPE(Engine,USVehicleWheel);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PHYSICS \
	AKActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAKActorNative; \
	AKActorSpawnable::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAKActorSpawnableNative; \
	AKAsset::StaticClass(); \
	UPhysicalMaterial::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPhysicalMaterialNative; \
	UPhysicalMaterialPropertyBase::StaticClass(); \
	UPhysicsAsset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPhysicsAssetNative; \
	UPhysicsAssetInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPhysicsAssetInstanceNative; \
	UPhysicsLODVerticalDestructible::StaticClass(); \
	UPhysicsLODVerticalEmitter::StaticClass(); \
	URB_BodyInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_BodyInstanceNative; \
	URB_BodySetup::StaticClass(); \
	URB_BSJointSetup::StaticClass(); \
	ARB_ConstraintActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARB_ConstraintActorNative; \
	URB_ConstraintDrawComponent::StaticClass(); \
	URB_ConstraintInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_ConstraintInstanceNative; \
	URB_ConstraintSetup::StaticClass(); \
	URB_DistanceJointSetup::StaticClass(); \
	URB_Handle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_HandleNative; \
	URB_HingeSetup::StaticClass(); \
	ARB_LineImpulseActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARB_LineImpulseActorNative; \
	URB_PrismaticSetup::StaticClass(); \
	URB_PulleyJointSetup::StaticClass(); \
	ARB_RadialImpulseActor::StaticClass(); \
	URB_RadialImpulseComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_RadialImpulseComponentNative; \
	URB_SkelJointSetup::StaticClass(); \
	URB_Spring::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_SpringNative; \
	URB_StayUprightSetup::StaticClass(); \
	ARB_Thruster::StaticClass(); \
	ASVehicle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineASVehicleNative; \
	USVehicleSimBase::StaticClass(); \
	USVehicleSimCar::StaticClass(); \
	USVehicleSimTank::StaticClass(); \
	USVehicleWheel::StaticClass(); \

#endif // ENGINE_PHYSICS_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AKActor) GEngineAKActorNatives[] = 
{ 
	MAP_NATIVE(AKActor,execResolveRBState)
	MAP_NATIVE(AKActor,execGetKActorPhysMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AKActor);

NATIVE_INFO(AKActorSpawnable) GEngineAKActorSpawnableNatives[] = 
{ 
	MAP_NATIVE(AKActorSpawnable,execResetComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AKActorSpawnable);

NATIVE_INFO(UPhysicalMaterial) GEngineUPhysicalMaterialNatives[] = 
{ 
	MAP_NATIVE(UPhysicalMaterial,execFindPhysEffectInfo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPhysicalMaterial);

NATIVE_INFO(UPhysicsAsset) GEngineUPhysicsAssetNatives[] = 
{ 
	MAP_NATIVE(UPhysicsAsset,execFindBodyIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPhysicsAsset);

NATIVE_INFO(UPhysicsAssetInstance) GEngineUPhysicsAssetInstanceNatives[] = 
{ 
	MAP_NATIVE(UPhysicsAssetInstance,execFindConstraintInstance)
	MAP_NATIVE(UPhysicsAssetInstance,execFindBodyInstance)
	MAP_NATIVE(UPhysicsAssetInstance,execSetFullAnimWeightBonesFixed)
	MAP_NATIVE(UPhysicsAssetInstance,execSetFullAnimWeightBlockRigidBody)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedBodiesBlockRigidBody)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedRBBoneSprings)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedMotorsAngularVelocityDrive)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedMotorsAngularPositionDrive)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllMotorsAngularDriveParams)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllMotorsAngularVelocityDrive)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllMotorsAngularPositionDrive)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedBodiesFixed)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllBodiesFixed)
	MAP_NATIVE(UPhysicsAssetInstance,execGetTotalMassBelowBone)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAngularDriveScale)
	MAP_NATIVE(UPhysicsAssetInstance,execSetLinearDriveScale)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPhysicsAssetInstance);

NATIVE_INFO(URB_BodyInstance) GEngineURB_BodyInstanceNatives[] = 
{ 
	MAP_NATIVE(URB_BodyInstance,execSetContactReportForceThreshold)
	MAP_NATIVE(URB_BodyInstance,execEnableCollisionResponse)
	MAP_NATIVE(URB_BodyInstance,execSetPhysMaterialOverride)
	MAP_NATIVE(URB_BodyInstance,execSetBlockRigidBody)
	MAP_NATIVE(URB_BodyInstance,execSetBoneSpringTarget)
	MAP_NATIVE(URB_BodyInstance,execSetBoneSpringParams)
	MAP_NATIVE(URB_BodyInstance,execEnableBoneSpring)
	MAP_NATIVE(URB_BodyInstance,execGetUnrealWorldAngularVelocity)
	MAP_NATIVE(URB_BodyInstance,execGetUnrealWorldVelocity)
	MAP_NATIVE(URB_BodyInstance,execGetUnrealWorldTM)
	MAP_NATIVE(URB_BodyInstance,execGetPhysicsAssetInstance)
	MAP_NATIVE(URB_BodyInstance,execIsValidBodyInstance)
	MAP_NATIVE(URB_BodyInstance,execIsFixed)
	MAP_NATIVE(URB_BodyInstance,execSetFixed)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_BodyInstance);

NATIVE_INFO(ARB_ConstraintActor) GEngineARB_ConstraintActorNatives[] = 
{ 
	MAP_NATIVE(ARB_ConstraintActor,execTermConstraint)
	MAP_NATIVE(ARB_ConstraintActor,execInitConstraint)
	MAP_NATIVE(ARB_ConstraintActor,execSetDisableCollision)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARB_ConstraintActor);

NATIVE_INFO(URB_ConstraintInstance) GEngineURB_ConstraintInstanceNatives[] = 
{ 
	MAP_NATIVE(URB_ConstraintInstance,execMoveKinActorTransform)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearLimitSize)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularDOFLimitScale)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularDriveParams)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularVelocityTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularPositionTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearDriveParams)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearVelocityTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearPositionTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularVelocityDrive)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularPositionDrive)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearVelocityDrive)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearPositionDrive)
	MAP_NATIVE(URB_ConstraintInstance,execGetConstraintLocation)
	MAP_NATIVE(URB_ConstraintInstance,execGetPhysicsAssetInstance)
	MAP_NATIVE(URB_ConstraintInstance,execTermConstraint)
	MAP_NATIVE(URB_ConstraintInstance,execInitConstraint)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_ConstraintInstance);

NATIVE_INFO(URB_Handle) GEngineURB_HandleNatives[] = 
{ 
	MAP_NATIVE(URB_Handle,execGetOrientation)
	MAP_NATIVE(URB_Handle,execSetOrientation)
	MAP_NATIVE(URB_Handle,execUpdateSmoothLocation)
	MAP_NATIVE(URB_Handle,execSetSmoothLocation)
	MAP_NATIVE(URB_Handle,execSetLocation)
	MAP_NATIVE(URB_Handle,execReleaseComponent)
	MAP_NATIVE(URB_Handle,execGrabComponent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_Handle);

NATIVE_INFO(ARB_LineImpulseActor) GEngineARB_LineImpulseActorNatives[] = 
{ 
	MAP_NATIVE(ARB_LineImpulseActor,execFireLineImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARB_LineImpulseActor);

NATIVE_INFO(URB_RadialImpulseComponent) GEngineURB_RadialImpulseComponentNatives[] = 
{ 
	MAP_NATIVE(URB_RadialImpulseComponent,execFireImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_RadialImpulseComponent);

NATIVE_INFO(URB_Spring) GEngineURB_SpringNatives[] = 
{ 
	MAP_NATIVE(URB_Spring,execClear)
	MAP_NATIVE(URB_Spring,execSetComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_Spring);

NATIVE_INFO(ASVehicle) GEngineASVehicleNatives[] = 
{ 
	MAP_NATIVE(ASVehicle,execHasWheelsOnGround)
	MAP_NATIVE(ASVehicle,execInitVehicleRagdoll)
	MAP_NATIVE(ASVehicle,execSetWheelCollision)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ASVehicle);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,KActor,ImpactEffectComponent)
VERIFY_CLASS_OFFSET_NODIE(A,KActor,InitialRotation)
VERIFY_CLASS_SIZE_NODIE(AKActor)
VERIFY_CLASS_SIZE_NODIE(AKActorSpawnable)
VERIFY_CLASS_OFFSET_NODIE(A,KAsset,SkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,KAsset,ReplicatedPhysAsset)
VERIFY_CLASS_SIZE_NODIE(AKAsset)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicalMaterial,MaterialIndex)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicalMaterial,PhysicalMaterialProperty)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterial)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterialPropertyBase)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,DefaultSkelMesh)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,DefaultInstance)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,AngularForceLimitScale)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAssetInstance)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsLODVerticalDestructible,MaxDynamicChunkCount)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsLODVerticalDestructible,DebrisLifetime)
VERIFY_CLASS_SIZE_NODIE(UPhysicsLODVerticalDestructible)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsLODVerticalEmitter,ParticlePercentage)
VERIFY_CLASS_SIZE_NODIE(UPhysicsLODVerticalEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodyInstance,OwnerComponent)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodyInstance,ContactReportForceThreshold)
VERIFY_CLASS_SIZE_NODIE(URB_BodyInstance)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,SleepFamily)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,PreCachedPhysDataVersion)
VERIFY_CLASS_SIZE_NODIE(URB_BodySetup)
VERIFY_CLASS_SIZE_NODIE(URB_BSJointSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_ConstraintActor,ConstraintActor1)
VERIFY_CLASS_OFFSET_NODIE(A,RB_ConstraintActor,PulleyPivotActor2)
VERIFY_CLASS_SIZE_NODIE(ARB_ConstraintActor)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintDrawComponent,LimitMaterial)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintDrawComponent)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintInstance,DummyKinActor)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintInstance)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintSetup,JointName)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintSetup,PulleyRatio)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintSetup)
VERIFY_CLASS_SIZE_NODIE(URB_DistanceJointSetup)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Handle,GrabbedComponent)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Handle,Location)
VERIFY_CLASS_SIZE_NODIE(URB_Handle)
VERIFY_CLASS_SIZE_NODIE(URB_HingeSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_LineImpulseActor,ImpulseStrength)
VERIFY_CLASS_OFFSET_NODIE(A,RB_LineImpulseActor,ImpulseCount)
VERIFY_CLASS_SIZE_NODIE(ARB_LineImpulseActor)
VERIFY_CLASS_SIZE_NODIE(URB_PrismaticSetup)
VERIFY_CLASS_SIZE_NODIE(URB_PulleyJointSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_RadialImpulseActor,RenderComponent)
VERIFY_CLASS_OFFSET_NODIE(A,RB_RadialImpulseActor,ImpulseCount)
VERIFY_CLASS_SIZE_NODIE(ARB_RadialImpulseActor)
VERIFY_CLASS_OFFSET_NODIE(U,RB_RadialImpulseComponent,ImpulseFalloff)
VERIFY_CLASS_OFFSET_NODIE(U,RB_RadialImpulseComponent,PreviewSphere)
VERIFY_CLASS_SIZE_NODIE(URB_RadialImpulseComponent)
VERIFY_CLASS_SIZE_NODIE(URB_SkelJointSetup)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Spring,Component1)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Spring,DampMaxForce)
VERIFY_CLASS_SIZE_NODIE(URB_Spring)
VERIFY_CLASS_SIZE_NODIE(URB_StayUprightSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_Thruster,ThrustStrength)
VERIFY_CLASS_SIZE_NODIE(ARB_Thruster)
VERIFY_CLASS_OFFSET_NODIE(A,SVehicle,SimObj)
VERIFY_CLASS_OFFSET_NODIE(A,SVehicle,RadialImpulseScaling)
VERIFY_CLASS_SIZE_NODIE(ASVehicle)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimBase,WheelSuspensionStiffness)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimBase,AutoDriveSteer)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimBase)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimCar,ChassisTorqueScale)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimCar,TimeSinceThrottle)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimCar)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimTank,LeftTrackVel)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimTank,TurnGripScaleRate)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimTank)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleWheel,Steer)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleWheel,SlipParticleParamName)
VERIFY_CLASS_SIZE_NODIE(USVehicleWheel)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
