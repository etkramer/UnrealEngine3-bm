/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_SEQUENCE_ENUMS
#define INCLUDED_ENGINE_SEQUENCE_ENUMS 1

enum EPointSelection
{
    PS_Normal               =0,
    PS_Random               =1,
    PS_Reverse              =2,
    PS_MAX                  =3,
};
enum EParticleEventOutputType
{
    ePARTICLEOUT_Spawn      =0,
    ePARTICLEOUT_Death      =1,
    ePARTICLEOUT_Collision  =2,
    ePARTICLEOUT_Kismet     =3,
    ePARTICLEOUT_MAX        =4,
};

#endif // !INCLUDED_ENGINE_SEQUENCE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Activated)
AUTOGENERATE_NAME(CheckLogins)
AUTOGENERATE_NAME(Deactivated)
AUTOGENERATE_NAME(GetObjClassVersion)
AUTOGENERATE_NAME(InsertValueEntry)
AUTOGENERATE_NAME(IsFallThruEnabled)
AUTOGENERATE_NAME(IsPastingIntoLevelSequenceAllowed)
AUTOGENERATE_NAME(IsPastingIntoUISequenceAllowed)
AUTOGENERATE_NAME(IsValidLevelSequenceObject)
AUTOGENERATE_NAME(IsValidUISequenceObject)
AUTOGENERATE_NAME(RegisterEvent)
AUTOGENERATE_NAME(RemoveValueEntry)
AUTOGENERATE_NAME(SpawnAgent)
AUTOGENERATE_NAME(Toggled)
AUTOGENERATE_NAME(VerifyDefaultCaseValue)
AUTOGENERATE_NAME(VersionUpdated)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_SEQUENCE_CLASSES
#define INCLUDED_ENGINE_SEQUENCE_CLASSES 1

struct SequenceObject_eventGetObjClassVersion_Parms
{
    INT ReturnValue;
    SequenceObject_eventGetObjClassVersion_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsPastingIntoUISequenceAllowed_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventIsPastingIntoUISequenceAllowed_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsValidUISequenceObject_Parms
{
    class UUIScreenObject* TargetObject;
    UBOOL ReturnValue;
    SequenceObject_eventIsValidUISequenceObject_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsPastingIntoLevelSequenceAllowed_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventIsPastingIntoLevelSequenceAllowed_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsValidLevelSequenceObject_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventIsValidLevelSequenceObject_Parms(EEventParm)
    {
    }
};
class USequenceObject : public UObject
{
public:
    //## BEGIN PROPS SequenceObject
    INT ObjInstanceVersion;
    class USequence* ParentSequence;
    INT ObjPosX;
    INT ObjPosY;
    FStringNoInit ObjName;
    FStringNoInit ObjCategory;
    TArrayNoInit<FString> ObjRemoveInProject;
    FColor ObjColor;
    FStringNoInit ObjComment;
    BITFIELD bDeletable:1;
    BITFIELD bDrawFirst:1;
    BITFIELD bDrawLast:1;
    BITFIELD bOutputObjCommentToScreen:1;
    BITFIELD bSuppressAutoComment:1;
    INT DrawWidth;
    INT DrawHeight;
    //## END PROPS SequenceObject

    void ScriptLog(const FString& LogText,UBOOL bWarning=TRUE);
    class AWorldInfo* GetWorldInfo();
    DECLARE_FUNCTION(execScriptLog)
    {
        P_GET_STR(LogText);
        P_GET_UBOOL_OPTX(bWarning,TRUE);
        P_FINISH;
        ScriptLog(LogText,bWarning);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    INT eventGetObjClassVersion()
    {
        SequenceObject_eventGetObjClassVersion_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetObjClassVersion),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsPastingIntoUISequenceAllowed()
    {
        SequenceObject_eventIsPastingIntoUISequenceAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsPastingIntoUISequenceAllowed),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsValidUISequenceObject(class UUIScreenObject* TargetObject=NULL)
    {
        SequenceObject_eventIsValidUISequenceObject_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.TargetObject=TargetObject;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidUISequenceObject),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsPastingIntoLevelSequenceAllowed()
    {
        SequenceObject_eventIsPastingIntoLevelSequenceAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsPastingIntoLevelSequenceAllowed),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsValidLevelSequenceObject()
    {
        SequenceObject_eventIsValidLevelSequenceObject_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidLevelSequenceObject),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(USequenceObject,UObject,0,Engine)
	virtual void CheckForErrors() {};

	/**
	 * Notification that this object has been connected to another sequence object via a link.  Called immediately after
	 * the designer creates a link between two sequence objects.
	 *
	 * @param	connObj		the object that this op was just connected to.
	 * @param	connIdx		the index of the connection that was created.  Depends on the type of sequence op that is being connected.
	 */
	virtual void OnConnect(USequenceObject *connObj,INT connIdx) {}

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime) {};
	virtual void DrawLogicLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex) {};
	virtual void DrawVariableLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex) {};
	virtual void OnCreated()
	{
		ObjInstanceVersion = eventGetObjClassVersion();
	};
	virtual void OnDelete() {}
	virtual void OnSelected() {};

	virtual void OnExport();
	/**
	 * Called when a copy of this object is made in the editor via cut and paste
	 */
	virtual void OnPasted(){};

	virtual FIntRect GetSeqObjBoundingBox();
	void SnapPosition(INT Gridsize, INT MaxSequenceSize);
	FString GetSeqObjFullName();

	/**
	 * Traverses the ParentSequence chain until a non-sequence object is found, starting with this object.
	 *
	 * @erturn	a pointer to the first object (including this one) in the ParentSequence chain that does
	 *			has a NULL ParentSequence.
	 */
	USequence* GetRootSequence( UBOOL bOuterFallback=FALSE );
	/**
	 * Traverses the ParentSequence chain until a non-sequence object is found, starting with this object.
	 *
	 * @erturn	a pointer to the first object (including this one) in the ParentSequence chain that does
	 *			has a NULL ParentSequence.
	 */
	const USequence* GetRootSequence( UBOOL bOuterFallback=FALSE ) const;
	/**
	 * Traverses the ParentSequence chain until a non-sequence object is found, starting with this object's ParentSequence.
	 *
	 * @erturn	a pointer to the first object (not including this one) in the ParentSequence chain that does
	 *			has a NULL ParentSequence.
	 */
	USequence* GetParentSequenceRoot( UBOOL bOuterFallback=FALSE ) const;

	FIntPoint GetTitleBarSize(FCanvas* Canvas);
	FColor GetBorderColor(UBOOL bSelected, UBOOL bMouseOver);

	/** Gives op a chance to customize the title bar text.  e.g. to include important data.  Returns string to display in the title bar. */
	virtual FString GetDisplayTitle() const;
	virtual void DrawTitleBar(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, const FIntPoint& Pos, const FIntPoint& Size);

	virtual void UpdateObject()
	{
		// set the new instance version to match the class version
		const INT ObjClassVersion = eventGetObjClassVersion();
		const UBOOL bDirty = ObjInstanceVersion != ObjClassVersion;
		ObjInstanceVersion = ObjClassVersion;
		if ( bDirty )
		{
			MarkPackageDirty();
		}
	}

	virtual void DrawKismetRefs( FViewport* Viewport, const FSceneView* View, FCanvas* Canvas ) {}

	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/**
	 * Get the name of the class to use for handling user interaction events (such as mouse-clicks) with this sequence object
	 * in the kismet editor.
	 *
	 * @return	a string containing the path name of a class in an editor package which can handle user input events for this
	 *			sequence object.
	 */
	virtual const FString GetEdHelperClassName() const
	{
		return FString( TEXT("UnrealEd.SequenceObjectHelper") );
	}

	virtual UBOOL IsPendingKill() const;

	/**
	 * Provides a way for non-deletable SequenceObjects (those with bDeletable=false) to be removed programatically.  The
	 * user will not be able to remove this object from the sequence via the UI, but calls to RemoveObject will succeed.
	 */
	virtual UBOOL IsDeletable() const { return bDeletable; }

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return FALSE; }

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp() {}

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for sequence objects would be handled by prefab code, so this version just skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for sequence objects is handled by the prefab code, this version simply routes the call
	 * to the owning prefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for sequence objects is handled by the prefab code, this version simply routes the call
	 * to the owning prefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Determines whether this object is contained within a UPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UPrefab; FALSE if it IS a UPrefab or isn't contained within one.
	 */
	virtual UBOOL IsAPrefabArchetype( class UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is a UPrefabInstance or part of a prefab instance.
	 */
	virtual UBOOL IsInPrefabInstance() const;

	virtual void Initialize() {}
	virtual void PrePathBuild(  AScout* Scout ) {}
	virtual void PostPathBuild( AScout* Scout ) {}
};

class USequenceFrame : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceFrame
    INT SizeX;
    INT SizeY;
    INT BorderWidth;
    BITFIELD bDrawBox:1;
    BITFIELD bFilled:1;
    BITFIELD bTileFill:1;
    FColor BorderColor;
    FColor FillColor;
    class UTexture2D* FillTexture;
    class UMaterial* FillMaterial;
    //## END PROPS SequenceFrame

    DECLARE_CLASS(USequenceFrame,USequenceObject,0,Engine)
	/** Draws the box part of the comment (including handle) */
	void DrawFrameBox(FCanvas* Canvas, UBOOL bSelected);

	// SequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
};

class USequenceFrameWrapped : public USequenceFrame
{
public:
    //## BEGIN PROPS SequenceFrameWrapped
    //## END PROPS SequenceFrameWrapped

    DECLARE_CLASS(USequenceFrameWrapped,USequenceFrame,0,Engine)
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
};

struct FSeqOpInputLink
{
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1;
    INT QueuedActivations;
    BITFIELD bDisabled:1;
    BITFIELD bDisabledPIE:1;
    class USequenceOp* LinkedOp;
    INT DrawY;
    BITFIELD bHidden:1;
    FLOAT ActivateDelay;

     /** Constructors */
    FSeqOpInputLink() {}
    FSeqOpInputLink(EEventParm)
    {
		appMemzero(this, sizeof(FSeqOpInputLink));
    }

	/**
	 * Activates this output link if bDisabled is not true
	 */
	UBOOL ActivateInputLink()
	{
		if ( !bDisabled && !(bDisabledPIE && GIsEditor))
		{
			// if already active then mark in the queue, unless it's a latent op since those are handled uniquely currently
			if (bHasImpulse)
			{
				QueuedActivations++;
			}
			bHasImpulse = TRUE;
			return TRUE;
		}

		return FALSE;
	}

};

struct FSeqOpOutputInputLink
{
    class USequenceOp* LinkedOp;
    INT InputLinkIdx;

		/** Default ctor */
		FSeqOpOutputInputLink() {}
		FSeqOpOutputInputLink(EEventParm) : LinkedOp(NULL), InputLinkIdx(0)
		{
		}
		FSeqOpOutputInputLink( USequenceOp* InOp, INT InLinkIdx=0 ) : LinkedOp(InOp), InputLinkIdx(InLinkIdx)
		{
		}

		/** Operators */
		/** native serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FSeqOpOutputInputLink& OutputInputLink );

		/** Comparison operator */
		UBOOL operator==( const FSeqOpOutputInputLink& Other ) const;
		UBOOL operator!=( const FSeqOpOutputInputLink& Other ) const;
	
};

struct FSeqOpOutputLink
{
    TArrayNoInit<struct FSeqOpOutputInputLink> Links;
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1;
    BITFIELD bDisabled:1;
    BITFIELD bDisabledPIE:1;
    class USequenceOp* LinkedOp;
    FLOAT ActivateDelay;
    INT DrawY;
    BITFIELD bHidden:1;

     /** Constructors */
    FSeqOpOutputLink() {}
    FSeqOpOutputLink(EEventParm)
    {
		appMemzero(this, sizeof(FSeqOpOutputLink));
    }

	/**
	 * Activates this output link if bDisabled is not true
	 */
	UBOOL ActivateOutputLink()
	{
		if ( !bDisabled && !(bDisabledPIE && GIsEditor))
		{
			bHasImpulse = TRUE;
			return TRUE;
		}
		return FALSE;
	}

	UBOOL HasLinkTo(USequenceOp *Op, INT LinkIdx = -1)
	{
		if (Op != NULL)
		{
			for (INT Idx = 0; Idx < Links.Num(); Idx++)
			{
				if (Links(Idx).LinkedOp == Op &&
					(LinkIdx == -1 || Links(Idx).InputLinkIdx == LinkIdx))
				{
					return TRUE;
				}
			}
		}
		return FALSE;
	}

};

struct FSeqVarLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceVariable*> LinkedVariables;
    FStringNoInit LinkDesc;
    FName LinkVar;
    FName PropertyName;
    BITFIELD bWriteable:1;
    BITFIELD bModifiesLinkedObject:1;
    BITFIELD bHidden:1;
    INT MinVars;
    INT MaxVars;
    INT DrawX;
    class UProperty* CachedProperty;

    /** Constructors */
    FSeqVarLink() {}
    FSeqVarLink(EEventParm)
    {
	appMemzero(this, sizeof(FSeqVarLink));
    }

	/**
	 * Determines whether this variable link can be associated with the specified sequence variable class.
	 *
	 * @param	SequenceVariableClass	the class to check for compatibility with this variable link; must be a child of SequenceVariable
	 * @param	bRequireExactClass		if FALSE, child classes of the specified class return a match as well.
	 *
	 * @return	TRUE if this variable link can be linked to the a SequenceVariable of the specified type.
	 */
	UBOOL SupportsVariableType( UClass* SequenceVariableClass, UBOOL bRequireExactClass=TRUE ) const;

};

struct FSeqEventLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceEvent*> LinkedEvents;
    FStringNoInit LinkDesc;
    INT DrawX;
    BITFIELD bHidden:1;

    /** Constructors */
    FSeqEventLink() {}
    FSeqEventLink(EEventParm)
    {
        appMemzero(this, sizeof(FSeqEventLink));
    }
};

struct SequenceOp_eventVersionUpdated_Parms
{
    INT OldVersion;
    INT NewVersion;
    SequenceOp_eventVersionUpdated_Parms(EEventParm)
    {
    }
};
struct SequenceOp_eventDeactivated_Parms
{
    SequenceOp_eventDeactivated_Parms(EEventParm)
    {
    }
};
struct SequenceOp_eventActivated_Parms
{
    SequenceOp_eventActivated_Parms(EEventParm)
    {
    }
};
class USequenceOp : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceOp
    BITFIELD bActive:1;
    BITFIELD bLatentExecution:1;
    BITFIELD bAutoActivateOutputLinks:1;
    TArrayNoInit<struct FSeqOpInputLink> InputLinks;
    TArrayNoInit<struct FSeqOpOutputLink> OutputLinks;
    TArrayNoInit<struct FSeqVarLink> VariableLinks;
    TArrayNoInit<struct FSeqEventLink> EventLinks;
    INT PlayerIndex;
    BYTE GamepadID;
    INT ActivateCount;
protected:
    INT SearchTag;
public:
    //## END PROPS SequenceOp

    UBOOL HasLinkedOps(UBOOL bConsiderInputLinks=FALSE) const;
    void GetLinkedObjects(TArray<class USequenceObject*>& out_Objects,class UClass* ObjectType=NULL,UBOOL bRecurse=FALSE);
    UBOOL ActivateOutputLink(INT OutputIdx);
    UBOOL ActivateNamedOutputLink(const FString& LinkDesc);
    virtual void PopulateLinkedVariableValues();
    virtual void PublishLinkedVariableValues();
    void ForceActivateInput(INT InputIdx);
    DECLARE_FUNCTION(execHasLinkedOps)
    {
        P_GET_UBOOL_OPTX(bConsiderInputLinks,FALSE);
        P_FINISH;
        *(UBOOL*)Result=HasLinkedOps(bConsiderInputLinks);
    }
    DECLARE_FUNCTION(execGetLinkedObjects)
    {
        P_GET_TARRAY_REF(class USequenceObject*,out_Objects);
        P_GET_OBJECT_OPTX(UClass,ObjectType,NULL);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        GetLinkedObjects(out_Objects,ObjectType,bRecurse);
    }
    DECLARE_FUNCTION(execGetObjectVars);
    DECLARE_FUNCTION(execGetInterpDataVars);
    DECLARE_FUNCTION(execGetBoolVars);
    DECLARE_FUNCTION(execLinkedVariables);
    DECLARE_FUNCTION(execActivateOutputLink)
    {
        P_GET_INT(OutputIdx);
        P_FINISH;
        *(UBOOL*)Result=ActivateOutputLink(OutputIdx);
    }
    DECLARE_FUNCTION(execActivateNamedOutputLink)
    {
        P_GET_STR(LinkDesc);
        P_FINISH;
        *(UBOOL*)Result=ActivateNamedOutputLink(LinkDesc);
    }
    DECLARE_FUNCTION(execPopulateLinkedVariableValues)
    {
        P_FINISH;
        PopulateLinkedVariableValues();
    }
    DECLARE_FUNCTION(execPublishLinkedVariableValues)
    {
        P_FINISH;
        PublishLinkedVariableValues();
    }
    DECLARE_FUNCTION(execForceActivateInput)
    {
        P_GET_INT(InputIdx);
        P_FINISH;
        ForceActivateInput(InputIdx);
    }
    void eventVersionUpdated(INT OldVersion,INT NewVersion)
    {
        SequenceOp_eventVersionUpdated_Parms Parms(EC_EventParm);
        Parms.OldVersion=OldVersion;
        Parms.NewVersion=NewVersion;
        ProcessEvent(FindFunctionChecked(ENGINE_VersionUpdated),&Parms);
    }
    void eventDeactivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Deactivated),NULL);
    }
    void eventActivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Activated),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USequenceOp,USequenceObject,0,Engine)
	virtual void CheckForErrors();

	// USequenceOp interface
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();
	/**
	 * Called after all the op has been deactivated and all linked variable values have been propagated to the next op
	 * in the sequence.
	 */
    virtual void PostDeActivated() {};

	/**
	 * Notification that an input link on this sequence op has been given impulse by another op.  Propagates the value of
	 * PlayerIndex from the ActivatorOp to this one.
	 *
	 * @param	ActivatorOp		the sequence op that applied impulse to this op's input link
	 * @param	InputLinkIndex	the index [into this op's InputLinks array] for the input link that was given impulse
	 */
	virtual void OnReceivedImpulse( class USequenceOp* ActivatorOp, INT InputLinkIndex );

	/**
	 * Allows the operation to initialize the values for any VariableLinks that need to be filled prior to executing this
	 * op's logic.  This is a convenient hook for filling VariableLinks that aren't necessarily associated with an actual
	 * member variable of this op, or for VariableLinks that are used in the execution of this ops logic.
	 */
	virtual void InitializeLinkedVariableValues() {}

	// helper functions
	void GetBoolVars(TArray<UBOOL*> &outBools, const TCHAR *inDesc = NULL) const;
	void GetIntVars(TArray<INT*> &outInts, const TCHAR *inDesc = NULL) const;
	void GetByteVars(TArray<BYTE*>& out_Bytes, const TCHAR* inDesc=NULL ) const;
	void GetFloatVars(TArray<FLOAT*> &outFloats, const TCHAR *inDesc = NULL) const;
	void GetVectorVars(TArray<FVector*> &outVectors, const TCHAR *inDesc = NULL) const;
	void GetObjectVars(TArray<UObject**> &outObjects, const TCHAR *inDesc = NULL) const;
	void GetStringVars(TArray<FString*> &outStrings, const TCHAR *inDesc = NULL) const;
	/**
	 * Retrieve a list of FName values connected to this sequence op.
	 *
	 * @param	out_Names	receieves the list of name values
	 * @param	inDesc		if specified, only name values connected via a variable link that this name will be returned.
	 */
	void GetNameVars( TArray<FName*>& out_Names, const TCHAR* inDesc=NULL );
	/** Retrieve list of UInterpData objects connected to this sequence op. */
	void GetInterpDataVars(TArray<class UInterpData*> &outIData, const TCHAR *inDesc = NULL);

	/**
	 * Retrieve a list of UIRangeData values connected to this sequence op.
	 *
	 * @param	out_UIRanges	receieves the list of UIRangeData values
	 * @param	inDesc			if specified, only UIRangeData values connected via a variable link that this name will be returned.
	 */
	void GetUIRangeVars( TArray<struct FUIRangeData*>& out_UIRanges, const TCHAR* inDesc=NULL );

	/**
	 * Retrieve a list of UniqueNetId values connected to this sequence op.
	 *
	 * @param	out_NetIds	receieves the list of UniqueNetId values
	 * @param	inDesc		if specified, only UniqueNetId values connected via a variable link that this name will be returned.
	 */
	void GetUniqueNetIdVars( TArray<struct FUniqueNetId*>& out_NetIds, const TCHAR* inDesc=NULL );

	INT FindConnectorIndex(const FString& ConnName, INT ConnType);
	void CleanupConnections();

	/** Called via PostEditChange(), lets ops create/remove dynamic links based on data. */
	virtual void UpdateDynamicLinks() {}
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntPoint	GetConnectionLocation(INT ConnType, INT ConnIndex);
	virtual FColor		GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );

	FIntPoint GetLogicConnectorsSize(FCanvas* Canvas, INT* InputY=0, INT* OutputY=0);
	FIntPoint GetVariableConnectorsSize(FCanvas* Canvas);
	FColor GetVarConnectorColor(INT LinkIndex);

	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter){}

	void DrawLogicConnectors(FCanvas* Canvas, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex);
	void DrawVariableConnectors(FCanvas* Canvas, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex, INT VarWidth);

	virtual void DrawLogicLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex);
	virtual void DrawVariableLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex);

	void MakeLinkedObjDrawInfo(struct FLinkedObjDrawInfo& ObjInfo, INT MouseOverConnType = -1, INT MouseOverConnIndex = INDEX_NONE);
	INT VisibleIndexToActualIndex(INT ConnType, INT VisibleIndex);

	/**
	 * Handles updating this sequence op when the ObjClassVersion doesn't match the ObjInstanceVersion, indicating that the op's
	 * default values have been changed.
	 */
	virtual void UpdateObject();

	/** Called after the object is loaded */
	virtual void PostLoad();
private:
	static INT CurrentSearchTag;
	void GetLinkedObjectsInternal(TArray<USequenceObject*>& out_Objects, UClass* ObjectType, UBOOL bRecurse);
};

struct FActivateOp
{
    class USequenceOp* ActivatorOp;
    class USequenceOp* Op;
    INT InputIdx;
    FLOAT RemainingDelay;

    /** Constructors */
    FActivateOp() {}
    FActivateOp(EEventParm)
    {
        appMemzero(this, sizeof(FActivateOp));
    }
};

class USequence : public USequenceOp
{
public:
    //## BEGIN PROPS Sequence
    FPointer LogFile;
    TArrayNoInit<class USequenceObject*> SequenceObjects;
    TArrayNoInit<class USequenceOp*> ActiveSequenceOps;
    TArrayNoInit<class USequence*> NestedSequences;
    TArrayNoInit<class USequenceEvent*> UnregisteredEvents;
    TArrayNoInit<struct FActivateOp> DelayedActivatedOps;
private:
    BITFIELD bEnabled:1;
public:
    INT DefaultViewX;
    INT DefaultViewY;
    FLOAT DefaultViewZoom;
    //## END PROPS Sequence

    void SetEnabled(UBOOL bInEnabled);
    DECLARE_FUNCTION(execFindSeqObjectsByClass);
    DECLARE_FUNCTION(execFindSeqObjectsByName);
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bInEnabled);
        P_FINISH;
        SetEnabled(bInEnabled);
    }
    DECLARE_CLASS(USequence,USequenceOp,0,Engine)
#define PREFAB_SEQCONTAINER_NAME	TEXT("Prefabs")

	virtual void PostLoad();

	void CheckForErrors();

	/**
	 * Adds a new SequenceObject to this sequence's list of ops
	 *
	 * @param	NewObj		the sequence object to add.
	 * @param	bRecurse	if TRUE, recursively add any sequence objects attached to this one
	 *
	 * @return	TRUE if the object was successfully added to the sequence.
	 */
	virtual UBOOL AddSequenceObject( USequenceObject* NewObj, UBOOL bRecurse=FALSE );

	/**
	 * Removes the specified object from the SequenceObjects array, severing any links to that object.
	 *
	 * @param	ObjectToRemove	the SequenceObject to remove from this sequence.  All links to the object will be cleared.
	 * @param	ModifiedObjects	a list of objects that have been modified the objects that have been
	 */
	virtual void RemoveObject( USequenceObject* ObjectToRemove );

	/**
	 * Removes the specified objects from this Sequence's SequenceObjects array, severing any links to these objects.
	 *
	 * @param	ObjectsToRemove	the sequence objects to remove from this sequence.  All links to these objects will be cleared,
	 *							and the objects will be removed from all SequenceObject arrays.
	 */
	void RemoveObjects( const TArray<USequenceObject*>& ObjectsToRemove);

	/**
	 * Adds the specified SequenceOp to this sequence's list of ActiveOps.
	 *
	 * @param	NewSequenceOp	the sequence op to add to the list
	 * @param	bPushTop		if TRUE, adds the operation to the top of stack (meaning it will be executed first),
	 *							rather than the bottom
	 *
	 * @return	TRUE if the sequence operation was successfully added to the list.
	 */
	virtual UBOOL QueueSequenceOp( USequenceOp* NewSequenceOp, UBOOL bPushTop=FALSE );

	UBOOL ExecuteActiveOps(FLOAT DeltaTime, INT MaxSteps = 0);
	UBOOL UpdateOp(FLOAT DeltaTime);

	VARARG_DECL(void, void, {}, ScriptLogf, VARARG_NONE, const TCHAR*, VARARG_NONE, VARARG_NONE);
	VARARG_DECL(void, void, {}, ScriptWarnf, VARARG_NONE, const TCHAR*, VARARG_NONE, VARARG_NONE);

	virtual void Activated();

	virtual void UpdateObject()
	{
		// do nothing
	}

	virtual void OnCreated()
	{
		Super::OnCreated();
		// update our connectors
		UpdateConnectors();
	}

	virtual void OnExport()
	{
		Super::OnExport();
		for (INT idx = 0; idx < SequenceObjects.Num(); idx++)
		{
			SequenceObjects(idx)->OnExport();
		}
		// only eliminate external links if this is the topmost sequence
		if (Cast<UPackage>(GetOuter()) != NULL)
		{
			for (INT idx = 0; idx < OutputLinks.Num(); idx++)
			{
				OutputLinks(idx).Links.Empty();
			}
			for (INT idx = 0; idx < VariableLinks.Num(); idx++)
			{
				VariableLinks(idx).LinkedVariables.Empty();
			}
			for (INT idx = 0; idx < EventLinks.Num(); idx++)
			{
				EventLinks(idx).LinkedEvents.Empty();
			}
		}
	}

	virtual void UpdateConnectors();
	void UpdateNamedVarStatus();
	void UpdateInterpActionConnectors();

	/**
	 * Initialize this kismet sequence.
	 *  - Creates the kismet script log (if this sequence has no parent sequence)
	 *  - Registers all events with the objects that they're associated with.
	 *  - Resolves all "named" and "external" variable links contained by this sequence.
	 */
	virtual void InitializeSequence();

	/**
	 * Conditionally creates the log file for this sequence.
	 */
	virtual void CreateKismetLog();

	/**
	 * Called from level startup.  Initializes the sequence and activates any level-startup
	 * events contained within the sequence.
	 */
	virtual void BeginPlay();
	virtual void FinishDestroy();
	/** called when streaming out a level to mark everything in this sequence as pending kill so they will be GC'ed */
	void MarkSequencePendingKill();
	/**
	 * Activates LevelStartup and/or LevelBeginning events in this sequence
	 *
	 * @param bShouldActivateLevelStartupEvents If TRUE, will activate all LevelStartup events
	 * @param bShouldActivateLevelBeginningEvents If TRUE, will activate all LevelBeginning events
	 * @param bShouldActivateLevelLoadedEvents If TRUE, will activate all LevelLoadedAndVisible events
	 */
	virtual void NotifyMatchStarted(UBOOL bShouldActivateLevelStartupEvents=TRUE, UBOOL bShouldActivateLevelBeginningEvents=TRUE, UBOOL bShouldActivateLevelLoadedEvents=FALSE);

	void FindSeqObjectsByClass(UClass* DesiredClass, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindSeqObjectsByName(const FString& Name, UBOOL bCheckComment, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindSeqObjectsByObjectName(FName Name, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindNamedVariables(FName VarName, UBOOL bFindUses, TArray<USequenceVariable*>& OutputVars, UBOOL bRecursive = TRUE) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to any of the specified objects
	 *
	 * @param	SearchObjects	the collection of objects to search for references to
	 * @param	out_Referencers	will be filled in with the sequence objects which reference any objects in the SearchObjects set
	 * @param	bRecursive		TRUE to search subsequences as well
	 *
	 * @return	TRUE if at least one object in the sequence objects array is referencing one of the objects in the set
	 */
	UBOOL FindReferencingSequenceObjects( const TArray<class UObject*>& SearchObjects, TArray<class USequenceObject*>* out_Referencers=NULL, UBOOL bRecursive=TRUE ) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to the specified object
	 *
	 * @param	SearchObject	the object to search for references to
	 * @param	out_Referencers	will be filled in with the sequence objects which reference the specified object
	 * @param	bRecursive		TRUE to search subsequences as well
	 *
	 * @return	TRUE if at least one object in the sequence objects array is referencing the object
	 */
	UBOOL FindReferencingSequenceObjects( UObject* SearchObject, TArray<class USequenceObject*>* out_Referencers=NULL, UBOOL bRecursive=TRUE ) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to the specified sequence object.
	 *
	 * @param	SearchObject		the sequence object to search for link references to
	 * @param	out_Referencers		if specified, receieves the list of sequence objects contained by this sequence
	 *								which are linked to the specified op
	 *
	 * @return	TRUE if at least one object in the sequence objects array is linked to the specified op.
	 */
	virtual UBOOL FindSequenceOpReferencers( USequenceObject* SearchObject, TArray<USequenceObject*>* out_Referencers=NULL );

	/**
	 * Returns a list of output links from this sequence's ops which reference the specified op.
	 *
	 * @param	SeqOp	the sequence object to search for output links to
	 * @param	Links	[out] receives the list of output links which reference the specified op.
	 */
	void FindLinksToSeqOp(USequenceOp* SeqOp, TArray<FSeqOpOutputLink*> &Links);

	/**
	 * Get the sequence which contains all PrefabInstance sequences.
	 *
	 * @param	bCreateIfNecessary		indicates whether the Prefabs sequence should be created if it doesn't exist.
	 *
	 * @return	pointer to the sequence which serves as the parent for all PrefabInstance sequences in the map.
	 */
	USequence* GetPrefabsSequence( UBOOL bCreateIfNecessary=TRUE );

	/**
	 * @return	TRUE if this sequence is the special sequence which serves as the parent for all PrefabInstance sequences in a map.
	 */
	virtual UBOOL IsPrefabSequenceContainer() const { return FALSE; }

	/**
	 * Determine if this sequence (or any of its subsequences) references a certain object.
	 *
	 * @param	InObject	the object to search for references to
	 * @param	pReferencer	if specified, will be set to the SequenceObject that is referencing the search object.
	 *
	 * @return TRUE if this sequence references the specified object.
	 */
	UBOOL ReferencesObject( const UObject* InObject, USequenceObject** pReferencer=NULL ) const;

	/**
	 * Determines whether the specified SequenceObject is contained in the SequenceObjects array of this sequence.
	 *
	 * @param	SearchObject	the sequence object to look for
	 * @param	bRecursive		specify FALSE to limit the search to this sequence only (do not search in sub-sequences as well)
	 *
	 * @return	TRUE if the specified sequence object was found in the SequenceObjects array of this sequence or one of its sub-sequences
	 */
	UBOOL ContainsSequenceObject( USequenceObject* SearchObject, UBOOL bRecursive=TRUE ) const;

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	void ClearNameUsage(FName InName, ERenameFlags RenameFlags=REN_None);

	/** Iterate over all SequenceObjects in this Sequence, making sure that their ParentSequence pointer points back to this Sequence. */
	void CheckParentSequencePointers();

	/** Draws the this sequence. */
	virtual void DrawSequence(FCanvas* Canvas, TArray<USequenceObject*>& SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime, UBOOL bCurves);

	/**
	 * @return		The ULevel this sequence occurs in.
	 */
	ULevel* GetLevel() const;

	UBOOL IsEnabled() const;

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();
};

class UPrefabSequence : public USequence
{
public:
    //## BEGIN PROPS PrefabSequence
protected:
    class APrefabInstance* OwnerPrefab;
public:
    //## END PROPS PrefabSequence

    void SetOwnerPrefab(class APrefabInstance* InOwner);
    class APrefabInstance* GetOwnerPrefab() const;
    DECLARE_FUNCTION(execSetOwnerPrefab)
    {
        P_GET_OBJECT(APrefabInstance,InOwner);
        P_FINISH;
        SetOwnerPrefab(InOwner);
    }
    DECLARE_FUNCTION(execGetOwnerPrefab)
    {
        P_FINISH;
        *(class APrefabInstance**)Result=GetOwnerPrefab();
    }
    DECLARE_CLASS(UPrefabSequence,USequence,0,Engine)
	/* === USequenceObject interface === */
	/**
	 * Provides a way for non-deletable SequenceObjects (those with bDeletable=false) to be removed programatically.  The
	 * user will not be able to remove this object from the sequence via the UI, but calls to RemoveObject will succeed.
	 */
	virtual UBOOL IsDeletable() const { return TRUE; }

	/* === UObject interface === */
	virtual void PostLoad();

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostEditImport();
	/**
	 * Called after this object is renamed; updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostRename();
	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostDuplicate();
};

class UPrefabSequenceContainer : public USequence
{
public:
    //## BEGIN PROPS PrefabSequenceContainer
    //## END PROPS PrefabSequenceContainer

    DECLARE_CLASS(UPrefabSequenceContainer,USequence,0,Engine)
	/* === USequenceObject interface === */
	/**
	 * Provides a way for non-deletable SequenceObjects (those with bDeletable=false) to be removed programatically.  The
	 * user will not be able to remove this object from the sequence via the UI, but calls to RemoveObject will succeed.
	 */
	virtual UBOOL IsDeletable() const { return TRUE; }

	/* === USequence interface === */
	/**
	 * @return	TRUE if this sequence is the special sequence which serves as the parent for all PrefabInstance sequences in a map.
	 */
	virtual UBOOL IsPrefabSequenceContainer() const { return TRUE; }

	/* === UObject interface === */
	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostEditImport();

	/**
	 * Called after this object is renamed; updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostRename();

	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostDuplicate();
};

class USequenceAction : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceAction
    FName HandlerName;
    BITFIELD bCallHandler:1;
    TArrayNoInit<class UObject*> Targets;
    //## END PROPS SequenceAction

    DECLARE_ABSTRACT_CLASS(USequenceAction,USequenceOp,0,Engine)
	virtual void Activated();

	/** Called before the handler function is called on a target actor. */
	virtual void PreActorHandle(AActor *inActor) {}
};

class USeqAct_ActivateRemoteEvent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ActivateRemoteEvent
    class AActor* Instigator;
    FName EventName;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqAct_ActivateRemoteEvent

    DECLARE_CLASS(USeqAct_ActivateRemoteEvent,USequenceAction,0,Engine)
	void Activated();
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
	virtual void UpdateStatus();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_ApplySoundNode : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ApplySoundNode
    class USoundCue* PlaySound;
    class USoundNode* ApplyNode;
    //## END PROPS SeqAct_ApplySoundNode

    DECLARE_CLASS(USeqAct_ApplySoundNode,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_AttachToEvent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_AttachToEvent
    BITFIELD bPreferController:1;
    //## END PROPS SeqAct_AttachToEvent

    DECLARE_CLASS(USeqAct_AttachToEvent,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_CameraFade : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CameraFade
    FColor FadeColor;
    FVector2D FadeAlpha;
    FLOAT FadeTime;
    BITFIELD bPersistFade:1;
    FLOAT FadeTimeRemaining;
    TArrayNoInit<class APlayerController*> CachedPCs;
    //## END PROPS SeqAct_CameraFade

    DECLARE_CLASS(USeqAct_CameraFade,USequenceAction,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_CameraLookAt : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CameraLookAt
    BITFIELD bAffectCamera:1;
    BITFIELD bAlwaysFocus:1;
    BITFIELD bAdjustCamera:1;
    BITFIELD bTurnInPlace:1;
    BITFIELD bIgnoreTrace:1;
    BITFIELD bAffectHead:1;
    BITFIELD bToggleGodMode:1;
    BITFIELD bLeaveCameraRotation:1;
    BITFIELD bDisableInput:1;
    BITFIELD bUsedTimer:1;
    BITFIELD bCheckLineOfSight:1;
    FVector2D InterpSpeedRange;
    FVector2D InFocusFOV;
    FName FocusBoneName;
    FStringNoInit TextDisplay;
    FLOAT TotalTime;
    FLOAT CameraFOV;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_CameraLookAt

    DECLARE_CLASS(USeqAct_CameraLookAt,USequenceAction,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();

	void UpdateObject();
};

class USeqAct_CauseDamage : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CauseDamage
    class UClass* DamageType;
    FLOAT Momentum;
    FLOAT DamageAmount;
    class AActor* Instigator;
    //## END PROPS SeqAct_CauseDamage

    DECLARE_CLASS(USeqAct_CauseDamage,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_CauseDamage)
};

class USeqAct_CauseDamageRadial : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CauseDamageRadial
    class UClass* DamageType;
    FLOAT Momentum;
    FLOAT DamageAmount;
    FLOAT DamageRadius;
    BITFIELD bDamageFalloff:1;
    class AActor* Instigator;
    //## END PROPS SeqAct_CauseDamageRadial

    DECLARE_CLASS(USeqAct_CauseDamageRadial,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_ChangeCollision : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ChangeCollision
    BITFIELD bCollideActors:1;
    BITFIELD bBlockActors:1;
    BITFIELD bIgnoreEncroachers:1;
    BYTE CollisionType GCC_BITFIELD_MAGIC;
    //## END PROPS SeqAct_ChangeCollision

    DECLARE_CLASS(USeqAct_ChangeCollision,USequenceAction,0,Engine)
	void UpdateObject()
	{
		Super::UpdateObject();
		if (bBlockActors)
		{
			CollisionType = COLLIDE_BlockAll;
		}
		else
		if (bCollideActors)
		{
			CollisionType = COLLIDE_TouchAll;
		}
		else
		{
			CollisionType = COLLIDE_NoCollision;
		}
	}
};

class USeqAct_CommitMapChange : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CommitMapChange
    //## END PROPS SeqAct_CommitMapChange

    DECLARE_CLASS(USeqAct_CommitMapChange,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_FinishSequence : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_FinishSequence
    FStringNoInit OutputLabel;
    //## END PROPS SeqAct_FinishSequence

    DECLARE_CLASS(USeqAct_FinishSequence,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void OnCreated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_Gate : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Gate
    BITFIELD bOpen:1;
    INT AutoCloseCount;
    //## END PROPS SeqAct_Gate

    DECLARE_CLASS(USeqAct_Gate,USequenceAction,0,Engine)
	void Activated()
	{
		UBOOL bWasOpen = bOpen;
		// first look for an open/close impulse
		if (InputLinks(1).bHasImpulse)
		{
			// open the gate
			bOpen = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			// close the gate
			bOpen = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			// toggle the gate
			bOpen = !bOpen;
		}
		KISMET_LOG(TEXT("- Gate status: %s (was: %s)"),bOpen?TEXT("Open"):TEXT("Closed"),bWasOpen?TEXT("Open"):TEXT("Closed"));
		// next check for an activation impulse
		if (bOpen && InputLinks(0).bHasImpulse)
		{
			if (!OutputLinks(0).bDisabled && 
				!(OutputLinks(0).bDisabledPIE && GIsEditor))
			{
				OutputLinks(0).bHasImpulse = TRUE;
			}
			if (AutoCloseCount > 0 && ActivateCount >= AutoCloseCount)
			{
				bOpen = FALSE;
			}
		}
	}
};

class USeqAct_GetDistance : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetDistance
    FLOAT Distance;
    //## END PROPS SeqAct_GetDistance

    DECLARE_CLASS(USeqAct_GetDistance,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_GetProperty : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetProperty
    FName PropertyName;
    //## END PROPS SeqAct_GetProperty

    DECLARE_CLASS(USeqAct_GetProperty,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_GetVelocity : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetVelocity
    FLOAT Velocity;
    //## END PROPS SeqAct_GetVelocity

    DECLARE_CLASS(USeqAct_GetVelocity,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_IsInObjectList : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_IsInObjectList
    BITFIELD bCheckForAllObjects:1;
    BITFIELD bObjectFound:1;
    //## END PROPS SeqAct_IsInObjectList

    DECLARE_CLASS(USeqAct_IsInObjectList,USequenceAction,0,Engine)
	/**
	* When a IsInObjectList is Activated() it will look in the referenced
	* list and then determine if the referenced object is in it
	**/
	void Activated();

	/**
	* IsInObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();


private:
	/**
	* Helper functions to determine if objects are in the list for each of the cases
	**/
	UBOOL TestForAllObjectsInList();
	UBOOL TestForAnyObjectsInList();
};

struct SeqAct_Latent_eventUpdate_Parms
{
    FLOAT DeltaTime;
    UBOOL ReturnValue;
    SeqAct_Latent_eventUpdate_Parms(EEventParm)
    {
    }
};
class USeqAct_Latent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Latent
    TArrayNoInit<class AActor*> LatentActors;
    BITFIELD bAborted:1;
    //## END PROPS SeqAct_Latent

    virtual void AbortFor(class AActor* latentActor);
    DECLARE_FUNCTION(execAbortFor)
    {
        P_GET_OBJECT(AActor,latentActor);
        P_FINISH;
        AbortFor(latentActor);
    }
    UBOOL eventUpdate(FLOAT DeltaTime)
    {
        SeqAct_Latent_eventUpdate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Update),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(USeqAct_Latent,USequenceAction,0,Engine)
	virtual void PreActorHandle(AActor *inActor);
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();
};

class USeqAct_ActorFactory : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ActorFactory
    BITFIELD bEnabled:1 GCC_BITFIELD_MAGIC;
    BITFIELD bIsSpawning:1;
    BITFIELD bCheckSpawnCollision:1;
    class UActorFactory* Factory;
    BYTE PointSelection;
    TArrayNoInit<class AActor*> SpawnPoints;
    TArrayNoInit<FVector> SpawnLocations;
    TArrayNoInit<FVector> SpawnOrientations;
    INT SpawnCount;
    FLOAT SpawnDelay;
    INT LastSpawnIdx;
    INT SpawnedCount;
    FLOAT RemainingDelay;
    //## END PROPS SeqAct_ActorFactory

    DECLARE_CLASS(USeqAct_ActorFactory,USeqAct_Latent,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();

	virtual void Spawned(UObject *NewSpawn);

	/**
	 * Checks any of the bEnabled inputs and sets the new value.
	 */
	void CheckToggle()
	{
		if (InputLinks(1).bHasImpulse)
		{
			bEnabled = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			bEnabled = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			bEnabled = !bEnabled;
		}
	}
};

class USeqAct_ActorFactoryEx : public USeqAct_ActorFactory
{
public:
    //## BEGIN PROPS SeqAct_ActorFactoryEx
    //## END PROPS SeqAct_ActorFactoryEx

    DECLARE_CLASS(USeqAct_ActorFactoryEx,USeqAct_ActorFactory,0,Engine)
	virtual void UpdateDynamicLinks();
	virtual void Spawned(UObject *NewSpawn);
};

class USeqAct_AIMoveToActor : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_AIMoveToActor
    BITFIELD bInterruptable:1 GCC_BITFIELD_MAGIC;
    //## END PROPS SeqAct_AIMoveToActor

    DECLARE_CLASS(USeqAct_AIMoveToActor,USeqAct_Latent,0,Engine)
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void  Activated();
};

struct FCrowdTargetActionInfo
{
    FName AnimName;
    BITFIELD bFireEffects:1;

    /** Constructors */
    FCrowdTargetActionInfo() {}
    FCrowdTargetActionInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCrowdTargetActionInfo));
    }
};

struct FCrowdAttachmentInfo
{
    class UStaticMesh* StaticMesh;
    FLOAT Chance;
    FVector Scale3D;

    /** Constructors */
    FCrowdAttachmentInfo() {}
    FCrowdAttachmentInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCrowdAttachmentInfo));
    }
};

struct FCrowdAttachmentList
{
    FName SocketName;
    TArrayNoInit<struct FCrowdAttachmentInfo> List;

    /** Constructors */
    FCrowdAttachmentList() {}
    FCrowdAttachmentList(EEventParm)
    {
        appMemzero(this, sizeof(FCrowdAttachmentList));
    }
};

struct SeqAct_CrowdSpawner_eventSpawnAgent_Parms
{
    class AActor* SpawnLoc;
    class ACrowdAgent* ReturnValue;
    SeqAct_CrowdSpawner_eventSpawnAgent_Parms(EEventParm)
    {
    }
};
class USeqAct_CrowdSpawner : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_CrowdSpawner
    BITFIELD bSpawningActive:1 GCC_BITFIELD_MAGIC;
    BITFIELD bConformToBSP:1;
    BITFIELD bConformToWorld:1;
    BITFIELD bRespawnDeadAgents:1;
    BITFIELD bLineSpawner:1;
    BITFIELD bSpawnAtEdge:1;
    BITFIELD bReduceNumInSplitScreen:1;
    BITFIELD bHasReducedNumberDueToSplitScreen:1;
    BITFIELD bUseOnlyCrowdPaths:1;
    BITFIELD bFlockScaleUniform:1;
    BITFIELD bDrawDebugPathInfo:1;
    BITFIELD bDrawDebugHitBox:1;
    BITFIELD bDrawDebugMoveTarget:1;
    BITFIELD bEnableCrowdLightEnvironment:1;
    FLOAT ConformTraceDist;
    INT ConformTraceInterval;
    FVector CollisionBoxScaling;
    TArrayNoInit<class ACrowdAttractor*> AssignedMoveTargets;
    TArrayNoInit<class AActor*> SpawnLocs;
    TArrayNoInit<class ACrowdAttractor*> AssignedActionTargets;
    FLOAT SpawnRate;
    INT SpawnNum;
    FLOAT Radius;
    FLOAT SplitScreenNumReduction;
    FLOAT Remainder;
    class UClass* AgentClass;
    FLOAT AwareRadius;
    INT AwareUpdateInterval;
    FLOAT AvoidOtherStrength;
    FLOAT AvoidOtherRadius;
    FLOAT MatchVelStrength;
    FLOAT ToPathStrength;
    FLOAT FollowPathStrength;
    FLOAT PathDistance;
    FLOAT ToAttractorStrength;
    FLOAT MinVelDamping;
    FLOAT MaxVelDamping;
    struct FRawDistributionFloat ActionDuration;
    struct FRawDistributionFloat ActionInterval;
    struct FRawDistributionFloat TargetActionInterval;
    TArrayNoInit<FName> ActionAnimNames;
    TArrayNoInit<FName> TargetActionAnimNames;
    TArrayNoInit<struct FCrowdTargetActionInfo> TargetActions;
    FLOAT MaxEffectsPerSecond;
    FLOAT RemaingEffectsThisFrame;
    FName SpawnAnimName;
    TArrayNoInit<FName> DeathAnimNames;
    FLOAT ActionBlendTime;
    FLOAT ReActionDelay;
    FLOAT RotateToTargetSpeed;
    FLOAT SpeedBlendStart;
    FLOAT SpeedBlendEnd;
    FLOAT AnimVelRate;
    FLOAT MaxSpeedBlendChangeSpeed;
    FName MoveSyncGroupName;
    FLOAT MaxYawRate;
    class USkeletalMesh* FlockMesh;
    TArrayNoInit<class USkeletalMesh*> FlockMeshes;
    TArrayNoInit<class UMaterialInterface*> RandomMaterials;
    FVector FlockMeshMinScale3D;
    FVector FlockMeshMaxScale3D;
    TArrayNoInit<class UAnimSet*> FlockAnimSets;
    FName WalkAnimName;
    TArrayNoInit<FName> WalkAnimNames;
    FName RunAnimName;
    TArrayNoInit<FName> RunAnimNames;
    class UAnimTree* FlockAnimTree;
    INT Health;
    class UParticleSystem* ExplosiveDeathEffect;
    class UParticleSystem* ExplosiveDeathEffectNonExtremeContent;
    FLOAT ExplosiveDeathEffectScale;
    TArrayNoInit<class ACrowdAgent*> SpawnedList;
    FLightingChannelContainer FlockLighting;
    TArrayNoInit<struct FCrowdAttachmentList> Attachments;
    TArrayNoInit<class UClass*> ReportOverlapsWithClass;
    class ACrowdReplicationActor* RepActor;
    //## END PROPS SeqAct_CrowdSpawner

    virtual void CacheSpawnerVars();
    virtual void KillAgents();
    virtual void UpdateSpawning(FLOAT DeltaSeconds);
    DECLARE_FUNCTION(execCacheSpawnerVars)
    {
        P_FINISH;
        CacheSpawnerVars();
    }
    DECLARE_FUNCTION(execKillAgents)
    {
        P_FINISH;
        KillAgents();
    }
    DECLARE_FUNCTION(execUpdateSpawning)
    {
        P_GET_FLOAT(DeltaSeconds);
        P_FINISH;
        UpdateSpawning(DeltaSeconds);
    }
    class ACrowdAgent* eventSpawnAgent(class AActor* SpawnLoc)
    {
        SeqAct_CrowdSpawner_eventSpawnAgent_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.SpawnLoc=SpawnLoc;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnAgent),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(USeqAct_CrowdSpawner,USeqAct_Latent,0,Engine)
	virtual void PostLoad();

	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void CleanUp();

	void UpdateAgent(class ACrowdAgent* Agent, FLOAT DeltaTime);
};

class USeqAct_Delay : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_Delay
    BITFIELD bDelayActive:1 GCC_BITFIELD_MAGIC;
    FLOAT DefaultDuration;
    FLOAT Duration;
    FLOAT LastUpdateTime;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_Delay

    DECLARE_CLASS(USeqAct_Delay,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	virtual void PostLoad();

	virtual FString GetDisplayTitle() const;
};

class USeqAct_DelaySwitch : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_DelaySwitch
    INT LinkCount;
    INT CurrentIdx;
    FLOAT SwitchDelay;
    FLOAT NextLinkTime;
    //## END PROPS SeqAct_DelaySwitch

    DECLARE_CLASS(USeqAct_DelaySwitch,USeqAct_Latent,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		Super::PostEditChange(PropertyThatChanged);
	}

	void Activated()
	{
		// reset the link index
		CurrentIdx = 0;
		// figure out the total delay
		TArray<FLOAT*> floatVars;
		GetFloatVars(floatVars,TEXT("Delay"));
		SwitchDelay = 0.f;
		for (INT idx = 0; idx < floatVars.Num(); idx++)
		{
			SwitchDelay += *(floatVars(idx));
		}
		NextLinkTime = SwitchDelay;
	}

	UBOOL UpdateOp(FLOAT deltaTime)
	{
		if (NextLinkTime <= 0.f)
		{
			if( CurrentIdx < OutputLinks.Num() && !OutputLinks(CurrentIdx).bDisabled &&
				!(OutputLinks(CurrentIdx).bDisabledPIE && GIsEditor))
			{
				// activate the new link
				OutputLinks(CurrentIdx).bHasImpulse = 1;
				// fill any variables attached
				TArray<INT*> intVars;
				GetIntVars(intVars,TEXT("Active Link"));
				for (INT idx = 0; idx < intVars.Num(); idx++)
				{
					// offset by 1 for non-programmer friendliness
					*(intVars(idx)) = CurrentIdx + 1;
				}
				// and increment the link index
				CurrentIdx++;
			}
			NextLinkTime = SwitchDelay;
		}
		else
		{
			NextLinkTime -= deltaTime;
		}
		return (CurrentIdx >= OutputLinks.Num());
	}

	void DeActivated()
	{
	}
};

class USeqAct_ForceGarbageCollection : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ForceGarbageCollection
    //## END PROPS SeqAct_ForceGarbageCollection

    DECLARE_CLASS(USeqAct_ForceGarbageCollection,USeqAct_Latent,0,Engine)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_ForceMaterialMipsResident : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ForceMaterialMipsResident
    FLOAT ForceDuration;
    TArrayNoInit<class UMaterialInterface*> ForceMaterials;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_ForceMaterialMipsResident

    DECLARE_CLASS(USeqAct_ForceMaterialMipsResident,USeqAct_Latent,0,Engine)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);

	/** Apply the specified settings to the materials. */
	void ApplySettings( UBOOL bEnable, FLOAT Duration );
};

struct FSavedTransform
{
    FVector Location;
    FRotator Rotation;
    friend FArchive& operator<<(FArchive& Ar,FSavedTransform& MySavedTransform)
    {
        return Ar << MySavedTransform.Location << MySavedTransform.Rotation;
    }

    /** Constructors */
    FSavedTransform() {}
    FSavedTransform(EEventParm)
    {
        appMemzero(this, sizeof(FSavedTransform));
    }
};

struct FCameraCutInfo
{
    FVector Location;
    FLOAT TimeStamp;

    /** Constructors */
    FCameraCutInfo() {}
    FCameraCutInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCameraCutInfo));
    }
};

class USeqAct_Interp : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_Interp
    TMap< AActor*,FSavedTransform > SavedActorTransforms;
    TMap< AActor*,BYTE > SavedActorVisibilities;
    FLOAT PlayRate;
    FLOAT Position;
    FLOAT ForceStartPosition;
    BITFIELD bIsPlaying:1;
    BITFIELD bPaused:1;
    BITFIELD bIsBeingEdited:1;
    BITFIELD bLooping:1;
    BITFIELD bRewindOnPlay:1;
    BITFIELD bNoResetOnRewind:1;
    BITFIELD bRewindIfAlreadyPlaying:1;
    BITFIELD bReversePlayback:1;
    BITFIELD bInterpForPathBuilding:1;
    BITFIELD bForceStartPos:1;
    BITFIELD bClientSideOnly:1;
    BITFIELD bSkipUpdateIfNotVisible:1;
    BITFIELD bIsSkippable:1;
    BITFIELD bShouldShowGore:1;
    TArrayNoInit<class ACoverLink*> LinkedCover;
    class UInterpData* InterpData;
    TArrayNoInit<class UInterpGroupInst*> GroupInst;
    class UClass* ReplicatedActorClass;
    class AMatineeActor* ReplicatedActor;
    INT PreferredSplitScreenNum;
    TArrayNoInit<struct FCameraCutInfo> CameraCuts;
    FLOAT TerminationTime;
    //## END PROPS SeqAct_Interp

    void SetPosition(FLOAT NewPosition,UBOOL bJump=FALSE);
    void Stop();
    void AddPlayerToDirectorTracks(class APlayerController* PC);
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewPosition);
        P_GET_UBOOL_OPTX(bJump,FALSE);
        P_FINISH;
        SetPosition(NewPosition,bJump);
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        Stop();
    }
    DECLARE_FUNCTION(execAddPlayerToDirectorTracks)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_FINISH;
        AddPlayerToDirectorTracks(PC);
    }
    DECLARE_CLASS(USeqAct_Interp,USeqAct_Latent,0,Engine)
	// UObject interface.
	/**
	 * Serialize function.
	 *
	 * @param	Ar		The archive to serialize with.
	 */
	virtual void Serialize(FArchive& Ar);

	// USequenceAction interface

	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void DeActivated();
	virtual void OnCreated();

	virtual void UpdateObject();

	// USeqAct_Interp interface

	/**
	 * Begin playback of this sequence. Only called in game.
	 * Will then advance Position by (PlayRate * Deltatime) each time the SeqAct_Interp is ticked.
	 */
	void Play();

	/** Similar to play, but the playback will go backwards until the beginning of the sequence is reached. */
	void Reverse();

	/** Hold playback at its current position, but leave the sequence initialised. Calling Pause again will continue playback in its current direction. */
	void Pause();

	/** Changes the direction of playback (go in reverse if it was going forward, or vice versa) */
	void ChangeDirection();

	/** Called to notify affected actors when a new impulse changes the interpolation (paused, reversed direction, etc) */
	void NotifyActorsOfChange();

	/** Increment track forwards by given timestep and iterate over each track updating any properties. */
	virtual void StepInterp(FLOAT DeltaTime, UBOOL bPreview=FALSE);

	/** Move interpolation to new position and iterate over each track updating any properties. */
	virtual void UpdateInterp(FLOAT NewPosition, UBOOL bPreview=FALSE, UBOOL bJump=FALSE);

	/**
	 *	Updates the streaming system with the camera locations for the upcoming camera cuts, so
	 *	that it can start streaming in textures for those locations now.
	 *
	 *	@param	CurrentTime		Current time within the matinee, in seconds
	 *	@param	bPreview		If we are previewing sequence (ie. viewing in editor without gameplay running)
	 */
	void UpdateStreamingForCameraCuts(FLOAT CurrentTime, UBOOL bPreview=FALSE);

	/** For each InterGroup/Actor combination, create a InterpGroupInst, assign Actor and initialise each track. */
	void InitInterp();

	/** Destroy all InterpGroupInst. */
	void TermInterp();

	/** Reset the 'initial transform' for all movement tracks to be from the current actor positions. */
	void ResetMovementInitialTransforms();

	/** See if there is an instance referring to the supplied Actor. Returns NULL if not. */
	class UInterpGroupInst* FindGroupInst(AActor* Actor);

	/** Find the first group instance based on the given InterpGroup. */
	class UInterpGroupInst* FindFirstGroupInst(class UInterpGroup* InGroup);

	/** Find the first group instance based on the InterpGroup with the given name. */
	class UInterpGroupInst* FindFirstGroupInstByName( FName InGroupName );
	class UInterpGroupInst* FindFirstGroupInstByName( const FString& InGroupName );

	/** Find the InterpData connected to the first Variable connector. Returns NULL if none attached. */
	class UInterpData* FindInterpDataFromVariable();

	/** Finds and returns the Director group, or NULL if not found. */
	class UInterpGroupDirector* FindDirectorGroup();

	/** Synchronise the variable connectors with the currently attached InterpData. */
	virtual void UpdateConnectorsFromData();

	/** Use any existing DirectorGroup to see which Actor we currently want to view through. */
	class AActor* FindViewedActor();

	/**
	 *	Utility for getting all Actors currently being worked on by this Matinee action.
	 *	If bMovementTrackOnly is set, Actors must have a Movement track in their group to be included in the results.
	 */
	void GetAffectedActors(TArray<AActor*>& OutActors, UBOOL bMovementTrackOnly);

	/**
	 * Conditionally saves state for the specified actor and its children
	 */
	void ConditionallySaveActorState( UInterpGroupInst* GroupInst, AActor* Actor );

	/**
	 * Adds the specified actor and any actors attached to it to the list
	 * of saved actor transforms.  Does nothing if an actor has already
	 * been saved.
	 */
	void SaveActorTransforms( AActor* Actor, UBOOL bOnlyChildren );

	/**
	 * Applies the saved locations and rotations to all saved actors.
	 */
	void RestoreActorTransforms();

	/** Saves whether or not this actor is hidden so we can restore it later */
	void SaveActorVisibility( AActor* Actor );

	/** Applies the saved visibility state for all saved actors */
	void RestoreActorVisibilities();

	/**
	 * Stores the current scrub position, restores all saved actor transforms,
	 * then saves off the transforms for actors referenced (directly or indirectly)
	 * by group instances, and finally restores the scrub position.
	 */
	void RecaptureActorState();

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();

	/** Sets up the group actor for the specified InterpGroup. */
	void InitGroupActorForGroup(class UInterpGroup* InGroup, class AActor* GroupActor);

    /**
     * Checks to see if this Matinee should be associated with the specified player.  This is a relatively
     * quick test to perform.
     *
     * @param InPC The player controller to check
     *
     * @return TRUE if this Matinee sequence is compatible with the specified player
     */
    UBOOL IsMatineeCompatibleWithPlayer( APlayerController* InPC ) const;

	/**
	 * Activates the output for the named event.
	 */
	virtual void NotifyEventTriggered(class UInterpTrackEvent const* EventTrack, INT EventIdx);

	/** Scans the matinee for camera cuts and sets up the CameraCut array. */
	void SetupCameraCuts();
};

class USeqAct_LevelStreamingBase : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_LevelStreamingBase
    BITFIELD bMakeVisibleAfterLoad:1 GCC_BITFIELD_MAGIC;
    BITFIELD bShouldBlockOnLoad:1;
    //## END PROPS SeqAct_LevelStreamingBase

    DECLARE_ABSTRACT_CLASS(USeqAct_LevelStreamingBase,USeqAct_Latent,0,Engine)
	/**
	 * Handles "Activated" for single ULevelStreaming object.
	 *
	 * @param	LevelStreamingObject	LevelStreaming object to handle "Activated" for.
	 */
	void ActivateLevel( ULevelStreaming* LevelStreamingObject );

	/**
	 * Handles "UpdateOp" for single ULevelStreaming object.
	 *
	 * @param	LevelStreamingObject	LevelStreaming object to handle "UpdateOp" for.
	 *
	 * @return TRUE if operation has completed, FALSE if still in progress
	 */
	UBOOL UpdateLevel( ULevelStreaming* LevelStreamingObject );
};

class USeqAct_LevelStreaming : public USeqAct_LevelStreamingBase
{
public:
    //## BEGIN PROPS SeqAct_LevelStreaming
    class ULevelStreaming* Level;
    FName LevelName;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqAct_LevelStreaming

    DECLARE_CLASS(USeqAct_LevelStreaming,USeqAct_LevelStreamingBase,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
	virtual void UpdateStatus();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

struct FLevelStreamingNameCombo
{
    class ULevelStreaming* Level;
    FName LevelName;

    /** Constructors */
    FLevelStreamingNameCombo() {}
    FLevelStreamingNameCombo(EEventParm)
    {
        appMemzero(this, sizeof(FLevelStreamingNameCombo));
    }
};

class USeqAct_MultiLevelStreaming : public USeqAct_LevelStreamingBase
{
public:
    //## BEGIN PROPS SeqAct_MultiLevelStreaming
    TArrayNoInit<struct FLevelStreamingNameCombo> Levels;
    BITFIELD bUnloadAllOtherLevels:1;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqAct_MultiLevelStreaming

    DECLARE_CLASS(USeqAct_MultiLevelStreaming,USeqAct_LevelStreamingBase,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
	virtual void UpdateStatus();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_LevelVisibility : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_LevelVisibility
    class ULevelStreaming* Level;
    FName LevelName;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqAct_LevelVisibility

    DECLARE_CLASS(USeqAct_LevelVisibility,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
	virtual void UpdateStatus();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_PlayCameraAnim : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PlayCameraAnim
    class UCameraAnim* CameraAnim;
    BITFIELD bLoop:1;
    BITFIELD bRandomStartTime:1;
    BITFIELD bStopped:1;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    FLOAT Rate;
    FLOAT IntensityScale;
    FLOAT AnimTimeRemaining;
    //## END PROPS SeqAct_PlayCameraAnim

    DECLARE_CLASS(USeqAct_PlayCameraAnim,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
};

class USeqAct_PlaySound : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PlaySound
    class USoundCue* PlaySound;
    FLOAT ExtraDelay;
    FLOAT SoundDuration;
    FLOAT FadeInTime;
    FLOAT FadeOutTime;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    BITFIELD bSuppressSubtitles:1;
    BITFIELD bStopped:1;
    //## END PROPS SeqAct_PlaySound

    DECLARE_CLASS(USeqAct_PlaySound,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	/** stops the sound on all targets */
	void Stop();
	virtual void CleanUp();

	void DrawTitleBar(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, const FIntPoint& Pos, const FIntPoint& Size);
};

class USeqAct_PrepareMapChange : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PrepareMapChange
    FName MainLevelName;
    TArrayNoInit<FName> InitiallyLoadedSecondaryLevelNames;
    BITFIELD bIsHighPriority:1;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqAct_PrepareMapChange

    DECLARE_CLASS(USeqAct_PrepareMapChange,USeqAct_Latent,0,Engine)
	/**
	 * Called when this sequence action is being activated. Kicks off async background loading.
	 */
	void Activated();

	void DeActivated();

	/**
	 * Called from parent sequence via ExecuteActiveOps, returns TRUE to indicate this
	 * action has completed, which in this case means the engine is ready to have
	 * CommitMapChange called.
	 *
	 * @return TRUE if action has completed, FALSE otherwise
	 */
	UBOOL UpdateOp(FLOAT DeltaTime);

	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
	virtual void UpdateStatus();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_SetDOFParams : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_SetDOFParams
    FLOAT FalloffExponent;
    FLOAT BlurKernelSize;
    FLOAT MaxNearBlurAmount;
    FLOAT MaxFarBlurAmount;
    FColor ModulateBlurColor;
    FLOAT FocusInnerRadius;
    FLOAT FocusDistance;
    FVector FocusPosition;
    FLOAT InterpolateSeconds;
    FLOAT InterpolateElapsed;
    FLOAT OldFalloffExponent;
    FLOAT OldBlurKernelSize;
    FLOAT OldMaxNearBlurAmount;
    FLOAT OldMaxFarBlurAmount;
    FColor OldModulateBlurColor;
    FLOAT OldFocusInnerRadius;
    FLOAT OldFocusDistance;
    FVector OldFocusPosition;
    //## END PROPS SeqAct_SetDOFParams

    DECLARE_CLASS(USeqAct_SetDOFParams,USeqAct_Latent,0,Engine)
	void Activated();
	void DeActivated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_SetMotionBlurParams : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_SetMotionBlurParams
    FLOAT MotionBlurAmount;
    FLOAT InterpolateSeconds;
    FLOAT InterpolateElapsed;
    FLOAT OldMotionBlurAmount;
    //## END PROPS SeqAct_SetMotionBlurParams

    DECLARE_CLASS(USeqAct_SetMotionBlurParams,USeqAct_Latent,0,Engine)
	void Activated();
	void DeActivated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_StreamInTextures : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_StreamInTextures
    BITFIELD bLocationBased:1 GCC_BITFIELD_MAGIC;
    BITFIELD bStreamingActive:1;
    FLOAT Seconds;
    FLOAT StopTimestamp;
    //## END PROPS SeqAct_StreamInTextures

    DECLARE_CLASS(USeqAct_StreamInTextures,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	virtual void PostLoad();

	virtual FString GetDisplayTitle() const;
};

class USeqAct_WaitForLevelsVisible : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_WaitForLevelsVisible
    TArrayNoInit<FName> LevelNames;
    BITFIELD bShouldBlockOnLoad:1;
    //## END PROPS SeqAct_WaitForLevelsVisible

    DECLARE_CLASS(USeqAct_WaitForLevelsVisible,USeqAct_Latent,0,Engine)
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_Log : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Log
    BITFIELD bOutputToScreen:1;
    BITFIELD bIncludeObjComment:1;
    FLOAT TargetDuration;
    FVector TargetOffset;
    //## END PROPS SeqAct_Log

    DECLARE_CLASS(USeqAct_Log,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_ParticleEventGenerator : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ParticleEventGenerator
    BITFIELD bEnabled:1;
    BITFIELD bUseEmitterLocation:1;
    class AActor* Instigator;
    TArrayNoInit<FName> EventNames;
    FLOAT EventTime;
    FVector EventLocation;
    FVector EventDirection;
    FVector EventVelocity;
    FVector EventNormal;
    //## END PROPS SeqAct_ParticleEventGenerator

    DECLARE_CLASS(USeqAct_ParticleEventGenerator,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();

	/**
	 * Checks any of the bEnabled inputs and sets the new value.
	 */
	void CheckToggle()
	{
		if (InputLinks(1).bHasImpulse)
		{
			bEnabled = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			bEnabled = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			bEnabled = !bEnabled;
		}
	}
};

class USeqAct_PlayFaceFXAnim : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_PlayFaceFXAnim
    class UFaceFXAnimSet* FaceFXAnimSetRef;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXAnimName;
    class USoundCue* SoundCueToPlay;
    //## END PROPS SeqAct_PlayFaceFXAnim

    DECLARE_CLASS(USeqAct_PlayFaceFXAnim,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_PlayFaceFXAnim)
};

class USeqAct_PlayMusicTrack : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_PlayMusicTrack
    struct FMusicTrackStruct MusicTrack;
    //## END PROPS SeqAct_PlayMusicTrack

    DECLARE_CLASS(USeqAct_PlayMusicTrack,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_Possess : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Possess
    class APawn* PawnToPossess;
    BITFIELD bKillOldPawn:1;
    BITFIELD bTryToLeaveVehicle:1;
    //## END PROPS SeqAct_Possess

    DECLARE_CLASS(USeqAct_Possess,USequenceAction,0,Engine)
	void Activated();
};

struct FSwitchRange
{
    INT Min;
    INT Max;

    /** Constructors */
    FSwitchRange() {}
    FSwitchRange(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchRange));
    }
};

class USeqAct_RangeSwitch : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_RangeSwitch
    TArrayNoInit<struct FSwitchRange> Ranges;
    //## END PROPS SeqAct_RangeSwitch

    DECLARE_CLASS(USeqAct_RangeSwitch,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		if (OutputLinks.Num() < Ranges.Num())
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < Ranges.Num())
			{
				OutputLinks.AddZeroed();
			}
		}
		else
		if (OutputLinks.Num() > Ranges.Num())
		{
			while (OutputLinks.Num() > Ranges.Num())
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		// match all the link descriptions to the range values
		for (INT idx = 0; idx < Ranges.Num(); idx++)
		{
			OutputLinks(idx).LinkDesc = FString::Printf(TEXT("%d - %d"),Ranges(idx).Min,Ranges(idx).Max);
		}
		Super::PostEditChange(PropertyThatChanged);
	}

	virtual void Activated()
	{
		// get all of the attached int vars
		TArray<INT*> intVars;
		GetIntVars(intVars,TEXT("Index"));
		// and activate the matching outputs
		for (INT idx = 0; idx < intVars.Num(); idx++)
		{
			INT activeIdx = *(intVars(idx));
			for (INT rangeIdx = 0; rangeIdx < Ranges.Num(); rangeIdx++)
			{
				if (activeIdx >= Ranges(rangeIdx).Min	&&
					activeIdx <= Ranges(rangeIdx).Max	&&
					!OutputLinks(rangeIdx).bDisabled	&&
					!(OutputLinks(rangeIdx).bDisabledPIE && GIsEditor)
					)
				{
					OutputLinks(rangeIdx).bHasImpulse = 1;
				}
			}
		}
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};

class USeqAct_SetBlockRigidBody : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetBlockRigidBody
    //## END PROPS SeqAct_SetBlockRigidBody

    DECLARE_CLASS(USeqAct_SetBlockRigidBody,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetBlockRigidBody)
};

class USeqAct_SetCameraTarget : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetCameraTarget
    class AActor* CameraTarget;
    struct FViewTargetTransitionParams TransitionParams;
    //## END PROPS SeqAct_SetCameraTarget

    DECLARE_CLASS(USeqAct_SetCameraTarget,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMaterial : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMaterial
    class UMaterialInterface* NewMaterial;
    INT MaterialIndex;
    //## END PROPS SeqAct_SetMaterial

    DECLARE_CLASS(USeqAct_SetMaterial,USequenceAction,0,Engine)
	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_SetMatInstScalarParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstScalarParam
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLOAT ScalarValue;
    //## END PROPS SeqAct_SetMatInstScalarParam

    DECLARE_CLASS(USeqAct_SetMatInstScalarParam,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMatInstTexParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstTexParam
    class UMaterialInstanceConstant* MatInst;
    class UTexture* NewTexture;
    FName ParamName;
    //## END PROPS SeqAct_SetMatInstTexParam

    DECLARE_CLASS(USeqAct_SetMatInstTexParam,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMatInstVectorParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstVectorParam
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLinearColor VectorValue;
    //## END PROPS SeqAct_SetMatInstVectorParam

    DECLARE_CLASS(USeqAct_SetMatInstVectorParam,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetPhysics : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetPhysics
    BYTE newPhysics;
    //## END PROPS SeqAct_SetPhysics

    DECLARE_CLASS(USeqAct_SetPhysics,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetPhysics)
};

class USeqAct_SetRigidBodyIgnoreVehicles : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetRigidBodyIgnoreVehicles
    //## END PROPS SeqAct_SetRigidBodyIgnoreVehicles

    DECLARE_CLASS(USeqAct_SetRigidBodyIgnoreVehicles,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetRigidBodyIgnoreVehicles)
};

class USeqAct_SetSequenceVariable : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetSequenceVariable
    //## END PROPS SeqAct_SetSequenceVariable

    DECLARE_ABSTRACT_CLASS(USeqAct_SetSequenceVariable,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetSequenceVariable)
};

class USeqAct_AddFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_AddFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_AddFloat

    DECLARE_CLASS(USeqAct_AddFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA + ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_AddInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_AddInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_AddInt

    DECLARE_CLASS(USeqAct_AddInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA + ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_CastToFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_CastToFloat
    INT Value;
    FLOAT FloatResult;
    //## END PROPS SeqAct_CastToFloat

    DECLARE_CLASS(USeqAct_CastToFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		OutputLinks(0).bHasImpulse = TRUE;
		
		FloatResult = (FLOAT)Value;
	}
};

class USeqAct_CastToInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_CastToInt
    BITFIELD bTruncate:1;
    FLOAT Value;
    INT IntResult;
    //## END PROPS SeqAct_CastToInt

    DECLARE_CLASS(USeqAct_CastToInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		OutputLinks(0).bHasImpulse = TRUE;
		
		if( bTruncate )
		{
			IntResult = (INT)Value;
		}
		else
		{
			IntResult = appRound( Value );
		}
	}
};

class USeqAct_DivideFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_DivideFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_DivideFloat

    DECLARE_CLASS(USeqAct_DivideFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		if( ValueB == 0.0f )
		{
			ValueB = 1.0f;
		}
		
		FloatResult = ValueA / ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_DivideInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_DivideInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_DivideInt

    DECLARE_CLASS(USeqAct_DivideInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		if( ValueB == 0 )
		{
			ValueB = 1;
		}
		
		FloatResult = ValueA / (FLOAT)ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_ModifyObjectList : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_ModifyObjectList
    INT ListEntriesCount;
    //## END PROPS SeqAct_ModifyObjectList

    DECLARE_CLASS(USeqAct_ModifyObjectList,USeqAct_SetSequenceVariable,0,Engine)
	/**
	* When a ModifyObjectList is Activated() it may do a number of things.
	* In each of those cases we make use of a helper function.
	**/
	void Activated();

private:
	void ActivatedAddRemove();
	void ActivateAddRemove_Helper( INT LinkNum );

public:
	/**
	* SeqAct_ModifyObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();

};

class USeqAct_MultiplyFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_MultiplyFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_MultiplyFloat

    DECLARE_CLASS(USeqAct_MultiplyFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA * ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_MultiplyInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_MultiplyInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_MultiplyInt

    DECLARE_CLASS(USeqAct_MultiplyInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA * (FLOAT)ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_SetBool : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetBool
    BITFIELD DefaultValue:1;
    //## END PROPS SeqAct_SetBool

    DECLARE_CLASS(USeqAct_SetBool,USeqAct_SetSequenceVariable,0,Engine)
	void Activated();
};

class USeqAct_SetFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetFloat
    FLOAT Target;
    FLOAT Value;
    //## END PROPS SeqAct_SetFloat

    DECLARE_CLASS(USeqAct_SetFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_SetInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetInt
    INT Target;
    INT Value;
    //## END PROPS SeqAct_SetInt

    DECLARE_CLASS(USeqAct_SetInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_SetObject : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetObject
    class UObject* DefaultValue;
    class UObject* Value;
    //## END PROPS SeqAct_SetObject

    DECLARE_CLASS(USeqAct_SetObject,USeqAct_SetSequenceVariable,0,Engine)
	virtual void Activated();
};

class USeqAct_SetString : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetString
    FStringNoInit Target;
    FStringNoInit Value;
    //## END PROPS SeqAct_SetString

    DECLARE_CLASS(USeqAct_SetString,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_SubtractFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SubtractFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_SubtractFloat

    DECLARE_CLASS(USeqAct_SubtractFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA - ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_SubtractInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SubtractInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_SubtractInt

    DECLARE_CLASS(USeqAct_SubtractInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA - ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_Switch : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Switch
    INT LinkCount;
    INT IncrementAmount;
    BITFIELD bLooping:1;
    BITFIELD bAutoDisableLinks:1;
    TArrayNoInit<INT> Indices;
    //## END PROPS SeqAct_Switch

    DECLARE_CLASS(USeqAct_Switch,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		Super::PostEditChange(PropertyThatChanged);
	}

	virtual void Activated()
	{
		// activate each of the indices
		for (INT Idx = 0; Idx < Indices.Num(); Idx++)
		{
			INT ActiveIdx = Indices(Idx) - 1;
			if (ActiveIdx >= 0 &&
				ActiveIdx < OutputLinks.Num())
			{
				if (!OutputLinks(ActiveIdx).bDisabled && 
					!(OutputLinks(ActiveIdx).bDisabledPIE && GIsEditor))
				{
					OutputLinks(ActiveIdx).bHasImpulse = TRUE;
					if (bAutoDisableLinks)
					{
						OutputLinks(ActiveIdx).bDisabled = TRUE;
					}
				}
			}
			// increment the indices
			if (IncrementAmount != 0)
			{
				if (bLooping)
				{
					Indices(Idx) = 1 + ((Indices(Idx) - 1 + IncrementAmount) % OutputLinks.Num());
				}
				else
				{
					Indices(Idx) += IncrementAmount;
				}
			}
		}
	}

	virtual void UpdateObject()
	{
		// save the output links
		TArray<FSeqOpOutputLink> SavedOutputLinks = OutputLinks;
		Super::UpdateObject();
		OutputLinks.Empty();
		OutputLinks = SavedOutputLinks;
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};

class USeqAct_RandomSwitch : public USeqAct_Switch
{
public:
    //## BEGIN PROPS SeqAct_RandomSwitch
    TArrayNoInit<INT> AutoDisabledIndices;
    //## END PROPS SeqAct_RandomSwitch

    DECLARE_CLASS(USeqAct_RandomSwitch,USeqAct_Switch,0,Engine)
	virtual void Activated();
};

class USeqAct_Timer : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Timer
    FLOAT ActivationTime;
    FLOAT Time;
    //## END PROPS SeqAct_Timer

    DECLARE_CLASS(USeqAct_Timer,USequenceAction,0,Engine)
	void Activated()
	{
		// reset the activation time
		Time = 0.f;
		ActivationTime = GWorld != NULL ? GWorld->GetTimeSeconds() : 0.f;
	}

	UBOOL UpdateOp(FLOAT DeltaTime)
	{
		// check for stop
		if (InputLinks(1).bHasImpulse)
		{
			// record the exact duration
			Time = GWorld != NULL ? GWorld->GetTimeSeconds() - ActivationTime : 0.f;
			// finish the op
			return TRUE;
		}
		else
		{
			// update the current time
			Time += DeltaTime;
			// and force any attached variables to get the new value
			PopulateLinkedVariableValues();
		}
		return FALSE;
	}
};

class USeqAct_Toggle : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Toggle
    //## END PROPS SeqAct_Toggle

    DECLARE_CLASS(USeqAct_Toggle,USequenceAction,0,Engine)
	virtual void PostLoad();
	virtual void Activated();
};

class USeqAct_ToggleDynamicChannel : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ToggleDynamicChannel
    //## END PROPS SeqAct_ToggleDynamicChannel

    DECLARE_CLASS(USeqAct_ToggleDynamicChannel,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_Trace : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Trace
    BITFIELD bTraceActors:1;
    BITFIELD bTraceWorld:1;
    FVector TraceExtent;
    FVector StartOffset;
    FVector EndOffset;
    class UObject* HitObject;
    FLOAT Distance;
    //## END PROPS SeqAct_Trace

    DECLARE_CLASS(USeqAct_Trace,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void DeActivated()
	{
	}
};

class USequenceCondition : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceCondition
    //## END PROPS SequenceCondition

    DECLARE_ABSTRACT_CLASS(USequenceCondition,USequenceOp,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USequenceCondition)
};

class USeqCond_CompareBool : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareBool
    //## END PROPS SeqCond_CompareBool

    DECLARE_CLASS(USeqCond_CompareBool,USequenceCondition,0,Engine)
	void Activated();
};

class USeqCond_CompareFloat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareFloat
    FLOAT ValueA;
    FLOAT ValueB;
    //## END PROPS SeqCond_CompareFloat

    DECLARE_CLASS(USeqCond_CompareFloat,USequenceCondition,0,Engine)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_CompareInt : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareInt
    INT ValueA;
    INT ValueB;
    //## END PROPS SeqCond_CompareInt

    DECLARE_CLASS(USeqCond_CompareInt,USequenceCondition,0,Engine)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_CompareObject : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareObject
    //## END PROPS SeqCond_CompareObject

    DECLARE_CLASS(USeqCond_CompareObject,USequenceCondition,0,Engine)
	void Activated();
};

class USeqCond_GetServerType : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_GetServerType
    //## END PROPS SeqCond_GetServerType

    DECLARE_CLASS(USeqCond_GetServerType,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_Increment : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_Increment
    INT IncrementAmount;
    INT ValueA;
    INT ValueB;
    //## END PROPS SeqCond_Increment

    DECLARE_CLASS(USeqCond_Increment,USequenceCondition,0,Engine)
	void Activated()
	{
		// first increment the value
		ValueA += IncrementAmount;
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IncrementFloat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IncrementFloat
    FLOAT IncrementAmount;
    FLOAT ValueA;
    FLOAT ValueB;
    //## END PROPS SeqCond_IncrementFloat

    DECLARE_CLASS(USeqCond_IncrementFloat,USequenceCondition,0,Engine)
	void Activated()
	{
		// first increment the value
		ValueA += IncrementAmount;
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsInCombat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsInCombat
    //## END PROPS SeqCond_IsInCombat

    DECLARE_CLASS(USeqCond_IsInCombat,USequenceCondition,0,Engine)
	virtual void Activated();
};

struct SeqCond_IsLoggedIn_eventCheckLogins_Parms
{
    UBOOL ReturnValue;
    SeqCond_IsLoggedIn_eventCheckLogins_Parms(EEventParm)
    {
    }
};
class USeqCond_IsLoggedIn : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsLoggedIn
    INT NumNeededLoggedIn;
    //## END PROPS SeqCond_IsLoggedIn

    UBOOL eventCheckLogins()
    {
        SeqCond_IsLoggedIn_eventCheckLogins_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CheckLogins),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(USeqCond_IsLoggedIn,USequenceCondition,0,Engine)
	virtual void Activated()
	{
		// Trigger the output based upon meeting the num logged in criteria
		if (eventCheckLogins() == TRUE)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		else
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsSameTeam : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsSameTeam
    //## END PROPS SeqCond_IsSameTeam

    DECLARE_CLASS(USeqCond_IsSameTeam,USequenceCondition,0,Engine)
	virtual void Activated();
};

struct SeqCond_SwitchBase_eventRemoveValueEntry_Parms
{
    INT RemoveIndex;
    SeqCond_SwitchBase_eventRemoveValueEntry_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventInsertValueEntry_Parms
{
    INT InsertIndex;
    SeqCond_SwitchBase_eventInsertValueEntry_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventIsFallThruEnabled_Parms
{
    INT ValueIndex;
    UBOOL ReturnValue;
    SeqCond_SwitchBase_eventIsFallThruEnabled_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventVerifyDefaultCaseValue_Parms
{
    SeqCond_SwitchBase_eventVerifyDefaultCaseValue_Parms(EEventParm)
    {
    }
};
class USeqCond_SwitchBase : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_SwitchBase
    //## END PROPS SeqCond_SwitchBase

    void eventRemoveValueEntry(INT RemoveIndex)
    {
        SeqCond_SwitchBase_eventRemoveValueEntry_Parms Parms(EC_EventParm);
        Parms.RemoveIndex=RemoveIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveValueEntry),&Parms);
    }
    void eventInsertValueEntry(INT InsertIndex)
    {
        SeqCond_SwitchBase_eventInsertValueEntry_Parms Parms(EC_EventParm);
        Parms.InsertIndex=InsertIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertValueEntry),&Parms);
    }
    UBOOL eventIsFallThruEnabled(INT ValueIndex)
    {
        SeqCond_SwitchBase_eventIsFallThruEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ValueIndex=ValueIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsFallThruEnabled),&Parms);
        return Parms.ReturnValue;
    }
    void eventVerifyDefaultCaseValue()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_VerifyDefaultCaseValue),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USeqCond_SwitchBase,USequenceCondition,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate ) PURE_VIRTUAL(USeqCond_SwitchBase::GetOutputLinksToActivate,return FALSE;);

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const PURE_VIRTUAL(USeqCond_SwitchBase::FindCaseValueIndex,return INDEX_NONE;);

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const PURE_VIRTUAL(USeqCond_SwitchBase::GetSupportedValueCount,return 0;);

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const PURE_VIRTUAL(USeqCond_SwitchBase::GetCaseValueString,return TEXT("NOT IMPLMENTED"););

	/* === USequenceOp interface === */
	/**
	 * Called when this sequence op is activated.  Determines which output link should be activated based on the value
	 * of the linked object var.
	 */
	virtual void Activated();
	virtual void UpdateDynamicLinks();

	/**
	 * Returns the color that should be used for an input, variable, or output link connector in the kismet editor.
	 *
	 * @param	ConnType	the type of connection this represents.  Valid values are:
	 *							LOC_INPUT		(input link)
	 *							LOC_OUTPUT		(output link)
	 *							LOC_VARIABLE	(variable link)
	 *							LOC_EVENT		(event link)
	 * @param	ConnIndex	the index [into the corresponding array (i.e. InputLinks, OutputLinks, etc.)] for the link
	 *						being queried.
	 * @param	MouseOverConnType
	 *						INDEX_NONE if the user is not currently mousing over the specified link connector.  One of the values
	 *						listed for ConnType otherwise.
	 * @param	MouseOverConnIndex
	 *						INDEX_NONE if the user is not currently mousing over the specified link connector.  The index for the
	 *						link being moused over otherwise.
	 */
	virtual FColor GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );
};

struct FSwitchClassInfo
{
    FName ClassName;
    BYTE bFallThru;

    /** Constructors */
    FSwitchClassInfo() {}
    FSwitchClassInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchClassInfo));
    }
};

class USeqCond_SwitchClass : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchClass
    TArrayNoInit<struct FSwitchClassInfo> ClassArray;
    //## END PROPS SeqCond_SwitchClass

    DECLARE_CLASS(USeqCond_SwitchClass,USeqCond_SwitchBase,0,Engine)
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FSwitchNameCase
{
    FName NameValue;
    BITFIELD bFallThru:1;

    /** Constructors */
    FSwitchNameCase() {}
    FSwitchNameCase(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchNameCase));
    }
};

class USeqCond_SwitchName : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchName
    TArrayNoInit<struct FSwitchNameCase> SupportedValues;
    //## END PROPS SeqCond_SwitchName

    DECLARE_ABSTRACT_CLASS(USeqCond_SwitchName,USeqCond_SwitchBase,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FSwitchObjectCase
{
    class UObject* ObjectValue;
    BITFIELD bFallThru:1;
    BITFIELD bDefaultValue:1;

    /** Constructors */
    FSwitchObjectCase() {}
    FSwitchObjectCase(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchObjectCase));
    }
};

class USeqCond_SwitchObject : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchObject
    TArrayNoInit<struct FSwitchObjectCase> SupportedValues;
    class UClass* MetaClass;
    //## END PROPS SeqCond_SwitchObject

    DECLARE_CLASS(USeqCond_SwitchObject,USeqCond_SwitchBase,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FQueuedActivationInfo
{
    class AActor* InOriginator;
    class AActor* InInstigator;
    TArrayNoInit<INT> ActivateIndices;
    BITFIELD bPushTop:1;

    /** Constructors */
    FQueuedActivationInfo() {}
    FQueuedActivationInfo(EEventParm)
    {
        appMemzero(this, sizeof(FQueuedActivationInfo));
    }
};

struct SequenceEvent_eventToggled_Parms
{
    SequenceEvent_eventToggled_Parms(EEventParm)
    {
    }
};
struct SequenceEvent_eventRegisterEvent_Parms
{
    SequenceEvent_eventRegisterEvent_Parms(EEventParm)
    {
    }
};
class USequenceEvent : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceEvent
    TArrayNoInit<class USequenceEvent*> DuplicateEvts;
    class AActor* Originator;
    class AActor* Instigator;
    FLOAT ActivationTime;
    INT TriggerCount;
    INT MaxTriggerCount;
    FLOAT ReTriggerDelay;
    BITFIELD bEnabled:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bRegistered:1;
    BITFIELD bClientSideOnly:1;
    BYTE Priority GCC_BITFIELD_MAGIC;
    INT MaxWidth;
    TArrayNoInit<struct FQueuedActivationInfo> QueuedActivations;
    //## END PROPS SequenceEvent

    DECLARE_FUNCTION(execCheckActivate);
    void eventToggled()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Toggled),NULL);
    }
    void eventRegisterEvent()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RegisterEvent),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USequenceEvent,USequenceOp,0,Engine)
	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();
	FIntPoint GetCenterPoint(FCanvas* Canvas);

	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	/**
	 * Adds an error message to the map check dialog if this SequenceEvent's EventActivator is bStatic
	 */
	virtual void CheckForErrors();

	/**
	 * This is a debug version of ActivateEvent which can be used by automated testing tools to Activate
	 * an event for testing purposes.
	 **/
	virtual void DebugActivateEvent(AActor *InOriginator, AActor *InInstigator, TArray<INT> *ActivateIndices = NULL);

	virtual UBOOL RegisterEvent();

	/**
	 * Called after all the op has been deactivated and all linked variable values have been propagated to the next op
	 * in the sequence.
	 *
	 * This version handles cases where the event is activated multiple times in a single frame.
	 */
	virtual void PostDeActivated();

	/**
	 * Fills in the value of the "Instigator" VariableLink
	 */
	virtual void InitializeLinkedVariableValues();

	virtual void OnExport()
	{
		Super::OnExport();
		Originator = NULL;
		Instigator = NULL;
	}

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	virtual FString GetDisplayTitle() const;

protected:
	virtual void ActivateEvent(AActor *InOriginator, AActor *InInstigator, TArray<INT> *ActivateIndices = NULL, UBOOL bPushTop = FALSE, UBOOL bFromQueued = FALSE);
};

class USeqEvent_AISeeEnemy : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_AISeeEnemy
    FLOAT MaxSightDistance;
    //## END PROPS SeqEvent_AISeeEnemy

    DECLARE_CLASS(USeqEvent_AISeeEnemy,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE)
	{
		if (InOriginator != NULL &&
			InInstigator != NULL &&
			(MaxSightDistance <= 0.f ||
			 (InOriginator->Location-InInstigator->Location).Size() <= MaxSightDistance))
		{
			return Super::CheckActivate(InOriginator,InInstigator,bTest,ActivateIndices, bPushTop);
		}
		else
		{
			return FALSE;
		}
	}
};

class USeqEvent_Console : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Console
    FName ConsoleEventName;
    FStringNoInit EventDesc;
    //## END PROPS SeqEvent_Console

    DECLARE_CLASS(USeqEvent_Console,USequenceEvent,0,Engine)
protected:
	FString GetDisplayTitle() const;

public:
	virtual void PostLoad();
};

class USeqEvent_ConstraintBroken : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ConstraintBroken
    //## END PROPS SeqEvent_ConstraintBroken

    DECLARE_CLASS(USeqEvent_ConstraintBroken,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_ConstraintBroken)
};

class USeqEvent_Destroyed : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Destroyed
    //## END PROPS SeqEvent_Destroyed

    DECLARE_CLASS(USeqEvent_Destroyed,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_Destroyed)
};

class USeqEvent_GetInventory : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_GetInventory
    //## END PROPS SeqEvent_GetInventory

    DECLARE_CLASS(USeqEvent_GetInventory,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_LevelBeginning : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelBeginning
    //## END PROPS SeqEvent_LevelBeginning

    DECLARE_CLASS(USeqEvent_LevelBeginning,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelBeginning)
};

class USeqEvent_LevelLoaded : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelLoaded
    //## END PROPS SeqEvent_LevelLoaded

    DECLARE_CLASS(USeqEvent_LevelLoaded,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelLoaded)
};

class USeqEvent_LevelStartup : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelStartup
    //## END PROPS SeqEvent_LevelStartup

    DECLARE_CLASS(USeqEvent_LevelStartup,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelStartup)
};

class USeqEvent_Mover : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Mover
    FLOAT StayOpenTime;
    //## END PROPS SeqEvent_Mover

    DECLARE_CLASS(USeqEvent_Mover,USequenceEvent,0,Engine)
	virtual void OnCreated();
};

class USeqEvent_ParticleEvent : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ParticleEvent
    BYTE EventType;
    FVector EventPosition;
    FLOAT EventEmitterTime;
    FVector EventVelocity;
    FLOAT EventParticleTime;
    FVector EventNormal;
    BITFIELD UseRelfectedImpactVector:1;
    //## END PROPS SeqEvent_ParticleEvent

    DECLARE_CLASS(USeqEvent_ParticleEvent,USequenceEvent,0,Engine)
	virtual void OnCreated();
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	/** Called via PostEditChange(), lets ops create/remove dynamic links based on data. */
	virtual void UpdateDynamicLinks();

	/** Helper function for filling in the output links according to the assigned emitter. */
	virtual void SetupOutputLinks(UBOOL bPreserveExistingLinks = TRUE);
};

class USeqEvent_ProjectileLanded : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ProjectileLanded
    FLOAT MaxDistance;
    //## END PROPS SeqEvent_ProjectileLanded

    DECLARE_CLASS(USeqEvent_ProjectileLanded,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_RemoteEvent : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_RemoteEvent
    FName EventName;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqEvent_RemoteEvent

    DECLARE_CLASS(USeqEvent_RemoteEvent,USequenceEvent,0,Engine)
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
	virtual void UpdateStatus();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqEvent_RigidBodyCollision : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_RigidBodyCollision
    FLOAT MinCollisionVelocity;
    //## END PROPS SeqEvent_RigidBodyCollision

    DECLARE_CLASS(USeqEvent_RigidBodyCollision,USequenceEvent,0,Engine)
	void CheckRBCollisionActivate( const FRigidBodyCollisionInfo& OriginatorInfo, const FRigidBodyCollisionInfo& InstigatorInfo1,
					const TArray<FRigidBodyContactInfo>& ContactInfos, FLOAT VelMag );
};

class USeqEvent_SeeDeath : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_SeeDeath
    //## END PROPS SeqEvent_SeeDeath

    DECLARE_CLASS(USeqEvent_SeeDeath,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_SequenceActivated : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_SequenceActivated
    FStringNoInit InputLabel;
    //## END PROPS SeqEvent_SequenceActivated

    DECLARE_CLASS(USeqEvent_SequenceActivated,USequenceEvent,0,Engine)
	virtual void OnCreated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	UBOOL CheckActivate(UBOOL bTest = FALSE);
};

class USeqEvent_TakeDamage : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_TakeDamage
    FLOAT MinDamageAmount;
    FLOAT DamageThreshold;
    TArrayNoInit<class UClass*> DamageTypes;
    TArrayNoInit<class UClass*> IgnoreDamageTypes;
    FLOAT CurrentDamage;
    BITFIELD bResetDamageOnToggle:1;
    //## END PROPS SeqEvent_TakeDamage

    DECLARE_CLASS(USeqEvent_TakeDamage,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_TakeDamage)
};

class USeqEvent_Touch : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Touch
    TArrayNoInit<class UClass*> ClassProximityTypes;
    TArrayNoInit<class UClass*> IgnoredClassProximityTypes;
    BITFIELD bForceOverlapping:1;
    BITFIELD bUseInstigator:1;
    BITFIELD bAllowDeadPawns:1;
    TArrayNoInit<class AActor*> TouchedList;
    //## END PROPS SeqEvent_Touch

    DECLARE_FUNCTION(execCheckTouchActivate);
    DECLARE_FUNCTION(execCheckUnTouchActivate);
    DECLARE_CLASS(USeqEvent_Touch,USequenceEvent,0,Engine)
	virtual UBOOL CheckTouchActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = FALSE);
	virtual UBOOL CheckUnTouchActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = FALSE);

protected:
	// hide the default implementation to force use of CheckTouchActivate/CheckUnTouchActivate
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	virtual void DoTouchActivation(AActor *InOriginator, AActor *InInstigator);
	virtual void DoUnTouchActivation(AActor *InOriginator, AActor *InInstigator, INT TouchIdx);
};

class USeqEvent_Used : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Used
    BITFIELD bAimToInteract:1;
    FLOAT InteractDistance;
    FStringNoInit InteractText;
    class UTexture2D* InteractIcon;
    TArrayNoInit<class UClass*> ClassProximityTypes;
    TArrayNoInit<class UClass*> IgnoredClassProximityTypes;
    //## END PROPS SeqEvent_Used

    DECLARE_CLASS(USeqEvent_Used,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USequenceVariable : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceVariable
    FName VarName;
    //## END PROPS SequenceVariable

    DECLARE_ABSTRACT_CLASS(USequenceVariable,USequenceObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();

	//NOTE: yes this is unfortunate, and is tedious, but works as an interim solution
	virtual INT* GetIntRef()
	{
		return NULL;
	}

	virtual BYTE* GetByteRef()
	{
		return NULL;
	}

	virtual UBOOL* GetBoolRef()
	{
		return NULL;
	}

	virtual FLOAT* GetFloatRef()
	{
		return NULL;
	}

	virtual FVector* GetVectorRef()
	{
		return NULL;
	}

	virtual struct FUIRangeData* GetUIRangeRef()
	{
		return NULL;
	}

	virtual FString* GetStringRef()
	{
		return NULL;
	}

	virtual FName* GetNameRef()
	{
		return NULL;
	}

	virtual UObject** GetObjectRef( INT Idx )
	{
		return NULL;
	}

	virtual struct FUniqueNetId* GetUniqueNetIdRef()
	{
		return NULL;
	}

	virtual FString GetValueStr()
	{
		return FString(TEXT("Undefined"));
	}

	/**
	 * Used for property exposure to variable links, allows variables
	 * to determine what types they can support.
	 */
	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const;

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink) {}

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink) {}

	/**
	 * Allows the sequence variable to execute additional logic after copying values from the SequenceOp's members to the sequence variable.
	 *
	 * @param	SourceOp	the sequence op that contains the value that should be copied to this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PostPopulateValue( USequenceOp* SourceOp, FSeqVarLink& VarLink ) {}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter) {}

	FIntPoint GetVarConnectionLocation();
};

class UInterpData : public USequenceVariable
{
public:
    //## BEGIN PROPS InterpData
    FLOAT InterpLength;
    FLOAT PathBuildTime;
    TArrayNoInit<class UInterpGroup*> InterpGroups;
    class UInterpCurveEdSetup* CurveEdSetup;
    TArrayNoInit<class UInterpFilter*> InterpFilters;
    class UInterpFilter* SelectedFilter;
    TArrayNoInit<class UInterpFilter*> DefaultFilters;
    FLOAT EdSectionStart;
    FLOAT EdSectionEnd;
    BITFIELD bShouldBakeAndPrune:1;
    //## END PROPS InterpData

    DECLARE_CLASS(UInterpData,USequenceVariable,0,Engine)
	// SequenceVariable interface
	virtual FString GetValueStr();

	/** Search through all InterpGroups in this InterpData to find a group whose GroupName matches the given name. Returns INDEX_NONE if group not found. */
	INT FindGroupByName( FName GroupName );
	INT FindGroupByName( const FString& InGroupName );

	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);
	class UInterpGroupDirector* FindDirectorGroup();
	void GetAllEventNames(TArray<FName>& OutEventNames);
};

class USeqVar_Bool : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Bool
    INT bValue;
    //## END PROPS SeqVar_Bool

    DECLARE_CLASS(USeqVar_Bool,USequenceVariable,0,Engine)
	UBOOL* GetBoolRef()
	{
		return (UBOOL*)&bValue;
	}

	FString GetValueStr()
	{
		return bValue == TRUE ? GTrue : GFalse;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UBoolProperty::StaticClass()));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_Byte : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Byte
    BYTE ByteValue;
    //## END PROPS SeqVar_Byte

    DECLARE_CLASS(USeqVar_Byte,USequenceVariable,0,Engine)
	virtual BYTE*	GetByteRef();
	virtual FString	GetValueStr();
	virtual UBOOL	SupportsProperty(UProperty *Property);

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_External : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_External
    class UClass* ExpectedType;
    FStringNoInit VariableLabel;
    //## END PROPS SeqVar_External

    DECLARE_CLASS(USeqVar_External,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	// SequenceVariable interface
	virtual FString GetValueStr();

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }
};

class USeqVar_Float : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Float
    FLOAT FloatValue;
    //## END PROPS SeqVar_Float

    DECLARE_CLASS(USeqVar_Float,USequenceVariable,0,Engine)
	virtual FLOAT* GetFloatRef()
	{
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.3f"),FloatValue);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UFloatProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UFloatProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_RandomFloat : public USeqVar_Float
{
public:
    //## BEGIN PROPS SeqVar_RandomFloat
    FLOAT Min;
    FLOAT Max;
    //## END PROPS SeqVar_RandomFloat

    DECLARE_CLASS(USeqVar_RandomFloat,USeqVar_Float,0,Engine)
	virtual FLOAT* GetFloatRef()
	{
		FloatValue = Min + appFrand() * (Max - Min);
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.1f..%2.1f"),Min,Max);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Int : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Int
    INT IntValue;
    //## END PROPS SeqVar_Int

    DECLARE_CLASS(USeqVar_Int,USequenceVariable,0,Engine)
	virtual INT* GetIntRef()
	{
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d"),IntValue);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UIntProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UIntProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_RandomInt : public USeqVar_Int
{
public:
    //## BEGIN PROPS SeqVar_RandomInt
    INT Min;
    INT Max;
    //## END PROPS SeqVar_RandomInt

    DECLARE_CLASS(USeqVar_RandomInt,USeqVar_Int,0,Engine)
	virtual INT* GetIntRef()
	{
		IntValue = Min + (appRand() % (Max - Min + 1));
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d..%d"),Min,Max);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Name : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Name
    FName NameValue;
    //## END PROPS SeqVar_Name

    DECLARE_CLASS(USeqVar_Name,USequenceVariable,0,Engine)
	/** Returns the value of this variable */
	FName* GetNameRef()
	{
		return &NameValue;
	}

	/** Returns a string representation of the value of this variable */
	FString GetValueStr()
	{
		return NameValue.ToString();
	}

	/**
	 * Determines whether this variable can be used to contain a value for the specified property.
	 */
	virtual UBOOL SupportsProperty( UProperty *Property )
	{
		if (Cast<UNameProperty>(Property))
		{
			return TRUE;
		}

		UArrayProperty* ArrayProp = Cast<UArrayProperty>(Property);
		if (ArrayProp)
		{
			if (Cast<UNameProperty>(ArrayProp->Inner))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp* Op, UProperty* Property, FSeqVarLink& VarLink);

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp* Op, UProperty* Property, FSeqVarLink& VarLink);
};

class USeqVar_Named : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Named
    class UClass* ExpectedType;
    FName FindVarName;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqVar_Named

    DECLARE_CLASS(USeqVar_Named,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	// SequenceVariable interface
	virtual FString GetValueStr();
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	// SeqVar_Named interface
	void UpdateStatus();
};

class USeqVar_Object : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Object
    class UObject* ObjValue;
    TArrayNoInit<class UClass*> SupportedClasses;
    //## END PROPS SeqVar_Object

    DECLARE_CLASS(USeqVar_Object,USequenceVariable,0,Engine)
	virtual UObject** GetObjectRef( INT Idx )
	{
		if( Idx != 0 )
		{
			return NULL;
		}
		return &ObjValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%s"),ObjValue!=NULL?*ObjValue->GetName():TEXT("???"));
	}

	virtual void OnExport()
	{
		ObjValue = NULL;
	}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UObjectProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UObjectProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_Group : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_Group
    FName GroupName;
    BITFIELD bCachedList:1;
    TArrayNoInit<class UObject*> Actors;
    //## END PROPS SeqVar_Group

    DECLARE_CLASS(USeqVar_Group,USeqVar_Object,0,Engine)
	virtual FString GetValueStr();
	virtual UObject** GetObjectRef(INT Idx);
};

class USeqVar_ObjectList : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_ObjectList
    TArrayNoInit<class UObject*> ObjList;
    //## END PROPS SeqVar_ObjectList

    DECLARE_CLASS(USeqVar_ObjectList,USeqVar_Object,0,Engine)
	virtual void OnCreated();

	// we need to see how to export arrays here, let's look at inventory
	virtual void OnExport();

	virtual UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr();


	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

};

class USeqVar_ObjectVolume : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_ObjectVolume
    FLOAT LastUpdateTime;
    TArrayNoInit<class UObject*> ContainedObjects;
    TArrayNoInit<class UClass*> ExcludeClassList;
    BITFIELD bCollidingOnly:1;
    //## END PROPS SeqVar_ObjectVolume

    DECLARE_CLASS(USeqVar_ObjectVolume,USeqVar_Object,0,Engine)
	virtual UObject** GetObjectRef(INT Idx);
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Player : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_Player
    TArrayNoInit<class UObject*> Players;
    BITFIELD bAllPlayers:1;
    INT PlayerIdx;
    //## END PROPS SeqVar_Player

    DECLARE_CLASS(USeqVar_Player,USeqVar_Object,0,Engine)
	UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr()
	{
		if (!bAllPlayers)
		{
			return FString::Printf(TEXT("Player %d"),PlayerIdx);
		}
		else
		{
			return FString(TEXT("All Players"));
		}
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_String : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_String
    FStringNoInit StrValue;
    //## END PROPS SeqVar_String

    DECLARE_CLASS(USeqVar_String,USequenceVariable,0,Engine)
	FString* GetStringRef()
	{
		return &StrValue;
	}

	FString GetValueStr()
	{
		return StrValue;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		if (Cast<UStrProperty>(Property))
		{
			return TRUE;
		}

		UArrayProperty* ArrayProp = Cast<UArrayProperty>(Property);
		if (ArrayProp)
		{
			if (Cast<UStrProperty>(ArrayProp->Inner))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_Union : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Union
    TArrayNoInit<class UClass*> SupportedVariableClasses;
    INT IntValue;
    BYTE ByteValue;
    INT BoolValue;
    FLOAT FloatValue;
    FStringNoInit StringValue;
    class UObject* ObjectValue;
    struct FUniqueNetId NetIdValue;
    //## END PROPS SeqVar_Union

    DECLARE_CLASS(USeqVar_Union,USequenceVariable,0,Engine)
	virtual INT*		GetIntRef();
	virtual BYTE*		GetByteRef();
	virtual UBOOL*		GetBoolRef();
	virtual FLOAT*		GetFloatRef();
	virtual FString*	GetStringRef();
	virtual UObject**	GetObjectRef( INT Idx );
	virtual FString		GetValueStr();
	virtual struct FUniqueNetId* GetUniqueNetIdRef();

	/**
	 * Union should never be used as the ExpectedType in a variable link, so it doesn't support any property classes.
	 */
	virtual UBOOL SupportsProperty(UProperty *Property);

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);

	/**
	 * Allows the sequence variable to execute additional logic after copying values from the SequenceOp's members to the sequence variable.
	 *
	 * @param	SourceOp	the sequence op that contains the value that should be copied to this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PostPopulateValue( USequenceOp* SourceOp, FSeqVarLink& VarLink );
};

class USeqVar_Vector : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Vector
    FVector VectValue;
    //## END PROPS SeqVar_Vector

    DECLARE_CLASS(USeqVar_Vector,USequenceVariable,0,Engine)
	virtual FVector* GetVectorRef()
	{
		return &VectValue;
	}

	virtual FString GetValueStr()
	{
		return VectValue.ToString();
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		UStructProperty* StructProp = Cast<UStructProperty>(Property);
		if (StructProp)
		{
			if (StructProp->Struct)
			{
				if (appStricmp(*(StructProp->Struct->GetName()), TEXT("Vector")) == 0)
				{
					return TRUE;
				}
			}
		}

		UArrayProperty* ArrayProp = Cast<UArrayProperty>(Property);
		if (ArrayProp)
		{
			UStructProperty* StructProp = Cast<UStructProperty>(ArrayProp->Inner);
			if (StructProp && StructProp->Struct)
			{
				if (appStricmp(*(StructProp->Struct->GetName()), TEXT("Vector")) == 0)
				{
					return TRUE;
				}
			}
		}

		return FALSE;
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

#endif // !INCLUDED_ENGINE_SEQUENCE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UPrefabSequence,-1,execGetOwnerPrefab);
AUTOGENERATE_FUNCTION(UPrefabSequence,-1,execSetOwnerPrefab);
AUTOGENERATE_FUNCTION(USeqAct_CrowdSpawner,-1,execUpdateSpawning);
AUTOGENERATE_FUNCTION(USeqAct_CrowdSpawner,-1,execKillAgents);
AUTOGENERATE_FUNCTION(USeqAct_CrowdSpawner,-1,execCacheSpawnerVars);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execAddPlayerToDirectorTracks);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execStop);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execSetPosition);
AUTOGENERATE_FUNCTION(USeqAct_Latent,-1,execAbortFor);
AUTOGENERATE_FUNCTION(USeqEvent_Touch,-1,execCheckUnTouchActivate);
AUTOGENERATE_FUNCTION(USeqEvent_Touch,-1,execCheckTouchActivate);
AUTOGENERATE_FUNCTION(USequence,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(USequence,-1,execFindSeqObjectsByName);
AUTOGENERATE_FUNCTION(USequence,-1,execFindSeqObjectsByClass);
AUTOGENERATE_FUNCTION(USequenceEvent,-1,execCheckActivate);
AUTOGENERATE_FUNCTION(USequenceObject,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(USequenceObject,-1,execScriptLog);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execForceActivateInput);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execPublishLinkedVariableValues);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execPopulateLinkedVariableValues);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execActivateNamedOutputLink);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execActivateOutputLink);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execLinkedVariables);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetBoolVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetInterpDataVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetObjectVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetLinkedObjects);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execHasLinkedOps);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_SEQUENCE_NATIVE_DEFS
#define ENGINE_SEQUENCE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UInterpData);
DECLARE_NATIVE_TYPE(Engine,UPrefabSequence);
DECLARE_NATIVE_TYPE(Engine,UPrefabSequenceContainer);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ActivateRemoteEvent);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ActorFactory);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ActorFactoryEx);
DECLARE_NATIVE_TYPE(Engine,USeqAct_AddFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_AddInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_AIMoveToActor);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ApplySoundNode);
DECLARE_NATIVE_TYPE(Engine,USeqAct_AttachToEvent);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CameraFade);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CameraLookAt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CastToFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CastToInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CauseDamage);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CauseDamageRadial);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ChangeCollision);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CommitMapChange);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CrowdSpawner);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Delay);
DECLARE_NATIVE_TYPE(Engine,USeqAct_DelaySwitch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_DivideFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_DivideInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_FinishSequence);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ForceGarbageCollection);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ForceMaterialMipsResident);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Gate);
DECLARE_NATIVE_TYPE(Engine,USeqAct_GetDistance);
DECLARE_NATIVE_TYPE(Engine,USeqAct_GetProperty);
DECLARE_NATIVE_TYPE(Engine,USeqAct_GetVelocity);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Interp);
DECLARE_NATIVE_TYPE(Engine,USeqAct_IsInObjectList);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Latent);
DECLARE_NATIVE_TYPE(Engine,USeqAct_LevelStreaming);
DECLARE_NATIVE_TYPE(Engine,USeqAct_LevelStreamingBase);
DECLARE_NATIVE_TYPE(Engine,USeqAct_LevelVisibility);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Log);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ModifyObjectList);
DECLARE_NATIVE_TYPE(Engine,USeqAct_MultiLevelStreaming);
DECLARE_NATIVE_TYPE(Engine,USeqAct_MultiplyFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_MultiplyInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ParticleEventGenerator);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlayCameraAnim);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlayFaceFXAnim);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlayMusicTrack);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlaySound);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Possess);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PrepareMapChange);
DECLARE_NATIVE_TYPE(Engine,USeqAct_RandomSwitch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_RangeSwitch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetBlockRigidBody);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetBool);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetCameraTarget);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetDOFParams);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMaterial);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMatInstScalarParam);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMatInstTexParam);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMatInstVectorParam);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMotionBlurParams);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetObject);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetPhysics);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetRigidBodyIgnoreVehicles);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetSequenceVariable);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetString);
DECLARE_NATIVE_TYPE(Engine,USeqAct_StreamInTextures);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SubtractFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SubtractInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Switch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Timer);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Toggle);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ToggleDynamicChannel);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Trace);
DECLARE_NATIVE_TYPE(Engine,USeqAct_WaitForLevelsVisible);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareBool);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareFloat);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareInt);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareObject);
DECLARE_NATIVE_TYPE(Engine,USeqCond_GetServerType);
DECLARE_NATIVE_TYPE(Engine,USeqCond_Increment);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IncrementFloat);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IsInCombat);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IsLoggedIn);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IsSameTeam);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchBase);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchClass);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchName);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchObject);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_AISeeEnemy);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Console);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_ConstraintBroken);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Destroyed);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_GetInventory);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_LevelBeginning);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_LevelLoaded);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_LevelStartup);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Mover);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_ParticleEvent);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_ProjectileLanded);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_RemoteEvent);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_RigidBodyCollision);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_SeeDeath);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_SequenceActivated);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_TakeDamage);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Touch);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Used);
DECLARE_NATIVE_TYPE(Engine,USequence);
DECLARE_NATIVE_TYPE(Engine,USequenceAction);
DECLARE_NATIVE_TYPE(Engine,USequenceCondition);
DECLARE_NATIVE_TYPE(Engine,USequenceEvent);
DECLARE_NATIVE_TYPE(Engine,USequenceFrame);
DECLARE_NATIVE_TYPE(Engine,USequenceFrameWrapped);
DECLARE_NATIVE_TYPE(Engine,USequenceObject);
DECLARE_NATIVE_TYPE(Engine,USequenceOp);
DECLARE_NATIVE_TYPE(Engine,USequenceVariable);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Bool);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Byte);
DECLARE_NATIVE_TYPE(Engine,USeqVar_External);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Float);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Group);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Int);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Name);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Named);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Object);
DECLARE_NATIVE_TYPE(Engine,USeqVar_ObjectList);
DECLARE_NATIVE_TYPE(Engine,USeqVar_ObjectVolume);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Player);
DECLARE_NATIVE_TYPE(Engine,USeqVar_RandomFloat);
DECLARE_NATIVE_TYPE(Engine,USeqVar_RandomInt);
DECLARE_NATIVE_TYPE(Engine,USeqVar_String);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Union);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Vector);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_SEQUENCE \
	UInterpData::StaticClass(); \
	UPrefabSequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPrefabSequenceNative; \
	UPrefabSequenceContainer::StaticClass(); \
	USeqAct_ActivateRemoteEvent::StaticClass(); \
	USeqAct_ActorFactory::StaticClass(); \
	USeqAct_ActorFactoryEx::StaticClass(); \
	USeqAct_AddFloat::StaticClass(); \
	USeqAct_AddInt::StaticClass(); \
	USeqAct_AIMoveToActor::StaticClass(); \
	USeqAct_ApplySoundNode::StaticClass(); \
	USeqAct_AttachToEvent::StaticClass(); \
	USeqAct_CameraFade::StaticClass(); \
	USeqAct_CameraLookAt::StaticClass(); \
	USeqAct_CastToFloat::StaticClass(); \
	USeqAct_CastToInt::StaticClass(); \
	USeqAct_CauseDamage::StaticClass(); \
	USeqAct_CauseDamageRadial::StaticClass(); \
	USeqAct_ChangeCollision::StaticClass(); \
	USeqAct_CommitMapChange::StaticClass(); \
	USeqAct_CrowdSpawner::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_CrowdSpawnerNative; \
	USeqAct_Delay::StaticClass(); \
	USeqAct_DelaySwitch::StaticClass(); \
	USeqAct_DivideFloat::StaticClass(); \
	USeqAct_DivideInt::StaticClass(); \
	USeqAct_FinishSequence::StaticClass(); \
	USeqAct_ForceGarbageCollection::StaticClass(); \
	USeqAct_ForceMaterialMipsResident::StaticClass(); \
	USeqAct_Gate::StaticClass(); \
	USeqAct_GetDistance::StaticClass(); \
	USeqAct_GetProperty::StaticClass(); \
	USeqAct_GetVelocity::StaticClass(); \
	USeqAct_Interp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_InterpNative; \
	USeqAct_IsInObjectList::StaticClass(); \
	USeqAct_Latent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_LatentNative; \
	USeqAct_LevelStreaming::StaticClass(); \
	USeqAct_LevelStreamingBase::StaticClass(); \
	USeqAct_LevelVisibility::StaticClass(); \
	USeqAct_Log::StaticClass(); \
	USeqAct_ModifyObjectList::StaticClass(); \
	USeqAct_MultiLevelStreaming::StaticClass(); \
	USeqAct_MultiplyFloat::StaticClass(); \
	USeqAct_MultiplyInt::StaticClass(); \
	USeqAct_ParticleEventGenerator::StaticClass(); \
	USeqAct_PlayCameraAnim::StaticClass(); \
	USeqAct_PlayFaceFXAnim::StaticClass(); \
	USeqAct_PlayMusicTrack::StaticClass(); \
	USeqAct_PlaySound::StaticClass(); \
	USeqAct_Possess::StaticClass(); \
	USeqAct_PrepareMapChange::StaticClass(); \
	USeqAct_RandomSwitch::StaticClass(); \
	USeqAct_RangeSwitch::StaticClass(); \
	USeqAct_SetBlockRigidBody::StaticClass(); \
	USeqAct_SetBool::StaticClass(); \
	USeqAct_SetCameraTarget::StaticClass(); \
	USeqAct_SetDOFParams::StaticClass(); \
	USeqAct_SetFloat::StaticClass(); \
	USeqAct_SetInt::StaticClass(); \
	USeqAct_SetMaterial::StaticClass(); \
	USeqAct_SetMatInstScalarParam::StaticClass(); \
	USeqAct_SetMatInstTexParam::StaticClass(); \
	USeqAct_SetMatInstVectorParam::StaticClass(); \
	USeqAct_SetMotionBlurParams::StaticClass(); \
	USeqAct_SetObject::StaticClass(); \
	USeqAct_SetPhysics::StaticClass(); \
	USeqAct_SetRigidBodyIgnoreVehicles::StaticClass(); \
	USeqAct_SetSequenceVariable::StaticClass(); \
	USeqAct_SetString::StaticClass(); \
	USeqAct_StreamInTextures::StaticClass(); \
	USeqAct_SubtractFloat::StaticClass(); \
	USeqAct_SubtractInt::StaticClass(); \
	USeqAct_Switch::StaticClass(); \
	USeqAct_Timer::StaticClass(); \
	USeqAct_Toggle::StaticClass(); \
	USeqAct_ToggleDynamicChannel::StaticClass(); \
	USeqAct_Trace::StaticClass(); \
	USeqAct_WaitForLevelsVisible::StaticClass(); \
	USeqCond_CompareBool::StaticClass(); \
	USeqCond_CompareFloat::StaticClass(); \
	USeqCond_CompareInt::StaticClass(); \
	USeqCond_CompareObject::StaticClass(); \
	USeqCond_GetServerType::StaticClass(); \
	USeqCond_Increment::StaticClass(); \
	USeqCond_IncrementFloat::StaticClass(); \
	USeqCond_IsInCombat::StaticClass(); \
	USeqCond_IsLoggedIn::StaticClass(); \
	USeqCond_IsSameTeam::StaticClass(); \
	USeqCond_SwitchBase::StaticClass(); \
	USeqCond_SwitchClass::StaticClass(); \
	USeqCond_SwitchName::StaticClass(); \
	USeqCond_SwitchObject::StaticClass(); \
	USeqEvent_AISeeEnemy::StaticClass(); \
	USeqEvent_Console::StaticClass(); \
	USeqEvent_ConstraintBroken::StaticClass(); \
	USeqEvent_Destroyed::StaticClass(); \
	USeqEvent_GetInventory::StaticClass(); \
	USeqEvent_LevelBeginning::StaticClass(); \
	USeqEvent_LevelLoaded::StaticClass(); \
	USeqEvent_LevelStartup::StaticClass(); \
	USeqEvent_Mover::StaticClass(); \
	USeqEvent_ParticleEvent::StaticClass(); \
	USeqEvent_ProjectileLanded::StaticClass(); \
	USeqEvent_RemoteEvent::StaticClass(); \
	USeqEvent_RigidBodyCollision::StaticClass(); \
	USeqEvent_SeeDeath::StaticClass(); \
	USeqEvent_SequenceActivated::StaticClass(); \
	USeqEvent_TakeDamage::StaticClass(); \
	USeqEvent_Touch::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqEvent_TouchNative; \
	USeqEvent_Used::StaticClass(); \
	USequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceNative; \
	USequenceAction::StaticClass(); \
	USequenceCondition::StaticClass(); \
	USequenceEvent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceEventNative; \
	USequenceFrame::StaticClass(); \
	USequenceFrameWrapped::StaticClass(); \
	USequenceObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceObjectNative; \
	USequenceOp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceOpNative; \
	USequenceVariable::StaticClass(); \
	USeqVar_Bool::StaticClass(); \
	USeqVar_Byte::StaticClass(); \
	USeqVar_External::StaticClass(); \
	USeqVar_Float::StaticClass(); \
	USeqVar_Group::StaticClass(); \
	USeqVar_Int::StaticClass(); \
	USeqVar_Name::StaticClass(); \
	USeqVar_Named::StaticClass(); \
	USeqVar_Object::StaticClass(); \
	USeqVar_ObjectList::StaticClass(); \
	USeqVar_ObjectVolume::StaticClass(); \
	USeqVar_Player::StaticClass(); \
	USeqVar_RandomFloat::StaticClass(); \
	USeqVar_RandomInt::StaticClass(); \
	USeqVar_String::StaticClass(); \
	USeqVar_Union::StaticClass(); \
	USeqVar_Vector::StaticClass(); \

#endif // ENGINE_SEQUENCE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UPrefabSequence) GEngineUPrefabSequenceNatives[] = 
{ 
	MAP_NATIVE(UPrefabSequence,execGetOwnerPrefab)
	MAP_NATIVE(UPrefabSequence,execSetOwnerPrefab)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPrefabSequence);

NATIVE_INFO(USeqAct_CrowdSpawner) GEngineUSeqAct_CrowdSpawnerNatives[] = 
{ 
	MAP_NATIVE(USeqAct_CrowdSpawner,execUpdateSpawning)
	MAP_NATIVE(USeqAct_CrowdSpawner,execKillAgents)
	MAP_NATIVE(USeqAct_CrowdSpawner,execCacheSpawnerVars)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_CrowdSpawner);

NATIVE_INFO(USeqAct_Interp) GEngineUSeqAct_InterpNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Interp,execAddPlayerToDirectorTracks)
	MAP_NATIVE(USeqAct_Interp,execStop)
	MAP_NATIVE(USeqAct_Interp,execSetPosition)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_Interp);

NATIVE_INFO(USeqAct_Latent) GEngineUSeqAct_LatentNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Latent,execAbortFor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_Latent);

NATIVE_INFO(USeqEvent_Touch) GEngineUSeqEvent_TouchNatives[] = 
{ 
	MAP_NATIVE(USeqEvent_Touch,execCheckUnTouchActivate)
	MAP_NATIVE(USeqEvent_Touch,execCheckTouchActivate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqEvent_Touch);

NATIVE_INFO(USequence) GEngineUSequenceNatives[] = 
{ 
	MAP_NATIVE(USequence,execSetEnabled)
	MAP_NATIVE(USequence,execFindSeqObjectsByName)
	MAP_NATIVE(USequence,execFindSeqObjectsByClass)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequence);

NATIVE_INFO(USequenceEvent) GEngineUSequenceEventNatives[] = 
{ 
	MAP_NATIVE(USequenceEvent,execCheckActivate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceEvent);

NATIVE_INFO(USequenceObject) GEngineUSequenceObjectNatives[] = 
{ 
	MAP_NATIVE(USequenceObject,execGetWorldInfo)
	MAP_NATIVE(USequenceObject,execScriptLog)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceObject);

NATIVE_INFO(USequenceOp) GEngineUSequenceOpNatives[] = 
{ 
	MAP_NATIVE(USequenceOp,execForceActivateInput)
	MAP_NATIVE(USequenceOp,execPublishLinkedVariableValues)
	MAP_NATIVE(USequenceOp,execPopulateLinkedVariableValues)
	MAP_NATIVE(USequenceOp,execActivateNamedOutputLink)
	MAP_NATIVE(USequenceOp,execActivateOutputLink)
	MAP_NATIVE(USequenceOp,execLinkedVariables)
	MAP_NATIVE(USequenceOp,execGetBoolVars)
	MAP_NATIVE(USequenceOp,execGetInterpDataVars)
	MAP_NATIVE(USequenceOp,execGetObjectVars)
	MAP_NATIVE(USequenceOp,execGetLinkedObjects)
	MAP_NATIVE(USequenceOp,execHasLinkedOps)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceOp);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,InterpData,InterpLength)
VERIFY_CLASS_OFFSET_NODIE(U,InterpData,EdSectionEnd)
VERIFY_CLASS_SIZE_NODIE(UInterpData)
VERIFY_CLASS_OFFSET_NODIE(U,PrefabSequence,OwnerPrefab)
VERIFY_CLASS_SIZE_NODIE(UPrefabSequence)
VERIFY_CLASS_SIZE_NODIE(UPrefabSequenceContainer)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActivateRemoteEvent,Instigator)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActivateRemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActivateRemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActorFactory,Factory)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActorFactory,RemainingDelay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactory)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactoryEx)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_AddFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_AddFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AddFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_AddInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_AddInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AddInt)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AIMoveToActor)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ApplySoundNode,PlaySound)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ApplySoundNode,ApplyNode)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ApplySoundNode)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AttachToEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CameraFade,FadeColor)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CameraFade,CachedPCs)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CameraFade)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CameraLookAt,InterpSpeedRange)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CameraLookAt,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CameraLookAt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CastToFloat,Value)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CastToFloat,FloatResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CastToFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CastToInt,Value)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CastToInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CastToInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamage,DamageType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamage,Instigator)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CauseDamage)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamageRadial,DamageType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamageRadial,Instigator)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CauseDamageRadial)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ChangeCollision,CollisionType)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ChangeCollision)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CommitMapChange)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CrowdSpawner,ConformTraceDist)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CrowdSpawner,RepActor)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CrowdSpawner)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Delay,DefaultDuration)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Delay,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Delay)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DelaySwitch,LinkCount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DelaySwitch,NextLinkTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DelaySwitch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DivideFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DivideFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DivideFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DivideInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DivideInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DivideInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_FinishSequence,OutputLabel)
VERIFY_CLASS_SIZE_NODIE(USeqAct_FinishSequence)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ForceGarbageCollection)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ForceMaterialMipsResident,ForceDuration)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ForceMaterialMipsResident,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ForceMaterialMipsResident)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Gate,AutoCloseCount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Gate)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_GetDistance,Distance)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetDistance)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_GetProperty,PropertyName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetProperty)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_GetVelocity,Velocity)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Interp,SavedActorTransforms)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Interp,TerminationTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Interp)
VERIFY_CLASS_SIZE_NODIE(USeqAct_IsInObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Latent,LatentActors)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Latent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelStreaming,Level)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelStreaming,LevelName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelStreaming)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelStreamingBase)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelVisibility,Level)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelVisibility,LevelName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelVisibility)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Log,TargetDuration)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Log,TargetOffset)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Log)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ModifyObjectList,ListEntriesCount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_MultiLevelStreaming,Levels)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiLevelStreaming)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_MultiplyFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_MultiplyFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiplyFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_MultiplyInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_MultiplyInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiplyInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ParticleEventGenerator,Instigator)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ParticleEventGenerator,EventNormal)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ParticleEventGenerator)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayCameraAnim,CameraAnim)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayCameraAnim,AnimTimeRemaining)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayCameraAnim)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayFaceFXAnim,FaceFXAnimSetRef)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayFaceFXAnim,SoundCueToPlay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayFaceFXAnim)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayMusicTrack,MusicTrack)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayMusicTrack)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlaySound,PlaySound)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlaySound,PitchMultiplier)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlaySound)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Possess,PawnToPossess)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Possess)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PrepareMapChange,MainLevelName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PrepareMapChange,InitiallyLoadedSecondaryLevelNames)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PrepareMapChange)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_RandomSwitch,AutoDisabledIndices)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RandomSwitch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_RangeSwitch,Ranges)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RangeSwitch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBlockRigidBody)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBool)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetCameraTarget,CameraTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetCameraTarget,TransitionParams)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetCameraTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetDOFParams,FalloffExponent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetDOFParams,OldFocusPosition)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetDOFParams)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetFloat,Target)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetFloat,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetInt,Target)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetInt,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMaterial,NewMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMaterial,MaterialIndex)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstScalarParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstScalarParam,ScalarValue)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstScalarParam)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstTexParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstTexParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstTexParam)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstVectorParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstVectorParam,VectorValue)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstVectorParam)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMotionBlurParams,MotionBlurAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMotionBlurParams,OldMotionBlurAmount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMotionBlurParams)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetObject,DefaultValue)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetObject,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetObject)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetPhysics,newPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetRigidBodyIgnoreVehicles)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetSequenceVariable)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetString,Target)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetString,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetString)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_StreamInTextures,Seconds)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_StreamInTextures,StopTimestamp)
VERIFY_CLASS_SIZE_NODIE(USeqAct_StreamInTextures)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SubtractFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SubtractFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SubtractFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SubtractInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SubtractInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SubtractInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Switch,LinkCount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Switch,Indices)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Switch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Timer,ActivationTime)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Timer,Time)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Timer)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Toggle)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ToggleDynamicChannel)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Trace,TraceExtent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Trace,Distance)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Trace)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_WaitForLevelsVisible,LevelNames)
VERIFY_CLASS_SIZE_NODIE(USeqAct_WaitForLevelsVisible)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareBool)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareFloat,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareInt,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareInt)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareObject)
VERIFY_CLASS_SIZE_NODIE(USeqCond_GetServerType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_Increment,IncrementAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_Increment,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_Increment)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_IncrementFloat,IncrementAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_IncrementFloat,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IncrementFloat)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsInCombat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_IsLoggedIn,NumNeededLoggedIn)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsLoggedIn)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsSameTeam)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchBase)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchClass,ClassArray)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchClass)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchName,SupportedValues)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchObject,SupportedValues)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchObject,MetaClass)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchObject)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_AISeeEnemy,MaxSightDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_AISeeEnemy)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Console,ConsoleEventName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Console,EventDesc)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Console)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ConstraintBroken)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Destroyed)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_GetInventory)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelBeginning)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelLoaded)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelStartup)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Mover,StayOpenTime)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Mover)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_ParticleEvent,EventType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_ParticleEvent,EventNormal)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ParticleEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_ProjectileLanded,MaxDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ProjectileLanded)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_RemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_RemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_RigidBodyCollision,MinCollisionVelocity)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_RigidBodyCollision)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SeeDeath)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_SequenceActivated,InputLabel)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SequenceActivated)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_TakeDamage,MinDamageAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_TakeDamage,CurrentDamage)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_TakeDamage)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Touch,ClassProximityTypes)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Touch,TouchedList)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Touch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Used,InteractDistance)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Used,IgnoredClassProximityTypes)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Used)
VERIFY_CLASS_OFFSET_NODIE(U,Sequence,LogFile)
VERIFY_CLASS_OFFSET_NODIE(U,Sequence,DefaultViewZoom)
VERIFY_CLASS_SIZE_NODIE(USequence)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceAction,HandlerName)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceAction,Targets)
VERIFY_CLASS_SIZE_NODIE(USequenceAction)
VERIFY_CLASS_SIZE_NODIE(USequenceCondition)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceEvent,DuplicateEvts)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceEvent,QueuedActivations)
VERIFY_CLASS_SIZE_NODIE(USequenceEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceFrame,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceFrame,FillMaterial)
VERIFY_CLASS_SIZE_NODIE(USequenceFrame)
VERIFY_CLASS_SIZE_NODIE(USequenceFrameWrapped)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceObject,ObjInstanceVersion)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceObject,DrawHeight)
VERIFY_CLASS_SIZE_NODIE(USequenceObject)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceOp,InputLinks)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceOp,SearchTag)
VERIFY_CLASS_SIZE_NODIE(USequenceOp)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceVariable,VarName)
VERIFY_CLASS_SIZE_NODIE(USequenceVariable)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Bool,bValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Bool)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Byte,ByteValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Byte)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_External,ExpectedType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_External,VariableLabel)
VERIFY_CLASS_SIZE_NODIE(USeqVar_External)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Float,FloatValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Float)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Group,GroupName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Group,Actors)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Group)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Int,IntValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Int)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Name,NameValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Name)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Named,ExpectedType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Named,FindVarName)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Named)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Object,ObjValue)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Object,SupportedClasses)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Object)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_ObjectList,ObjList)
VERIFY_CLASS_SIZE_NODIE(USeqVar_ObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_ObjectVolume,LastUpdateTime)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_ObjectVolume,ExcludeClassList)
VERIFY_CLASS_SIZE_NODIE(USeqVar_ObjectVolume)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Player,Players)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Player,PlayerIdx)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Player)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomFloat,Min)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomFloat,Max)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomInt,Min)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomInt,Max)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_String,StrValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_String)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Union,SupportedVariableClasses)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Union,NetIdValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Union)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Vector,VectValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Vector)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
