/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_INTERPOLATION_ENUMS
#define INCLUDED_ENGINE_INTERPOLATION_ENUMS 1

enum EInterpTrackMoveRotMode
{
    IMR_Keyframed           =0,
    IMR_LookAtGroup         =1,
    IMR_MAX                 =2,
};
enum EInterpTrackMoveFrame
{
    IMF_World               =0,
    IMF_RelativeToInitial   =1,
    IMF_MAX                 =2,
};
enum ETrackToggleAction
{
    ETTA_Off                =0,
    ETTA_On                 =1,
    ETTA_Toggle             =2,
    ETTA_Trigger            =3,
    ETTA_MAX                =4,
};
enum EVisibilityTrackCondition
{
    EVTC_Always             =0,
    EVTC_GoreEnabled        =1,
    EVTC_GoreDisabled       =2,
    EVTC_MAX                =3,
};
enum EVisibilityTrackAction
{
    EVTA_Hide               =0,
    EVTA_Show               =1,
    EVTA_Toggle             =2,
    EVTA_MAX                =3,
};

#endif // !INCLUDED_ENGINE_INTERPOLATION_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_INTERPOLATION_CLASSES
#define INCLUDED_ENGINE_INTERPOLATION_CLASSES 1

class UInterpFilter : public UObject
{
public:
    //## BEGIN PROPS InterpFilter
    FStringNoInit Caption;
    //## END PROPS InterpFilter

    DECLARE_CLASS(UInterpFilter,UObject,0,Engine)
	/** 
	 * Given a interpdata object, updates visibility of groups and tracks based on the filter settings
	 *
	 * @param InData			Data to filter.
	 */
	virtual void FilterData(class USeqAct_Interp* InData);
};

class UInterpFilter_Classes : public UInterpFilter
{
public:
    //## BEGIN PROPS InterpFilter_Classes
    class UClass* ClassToFilterBy;
    TArrayNoInit<class UClass*> TrackClasses;
    //## END PROPS InterpFilter_Classes

    DECLARE_CLASS(UInterpFilter_Classes,UInterpFilter,0,Engine)
	/** 
	 * Given a interpdata object, updates visibility of groups and tracks based on the filter settings
	 *
	 * @param InData			Data to filter.
	 */
	virtual void FilterData(class USeqAct_Interp* InData);
};

class UInterpFilter_Custom : public UInterpFilter
{
public:
    //## BEGIN PROPS InterpFilter_Custom
    TArrayNoInit<class UInterpGroup*> GroupsToInclude;
    //## END PROPS InterpFilter_Custom

    DECLARE_CLASS(UInterpFilter_Custom,UInterpFilter,0,Engine)
	/** 
	 * Given a interpdata object, updates visibility of groups and tracks based on the filter settings
	 *
	 * @param InData			Data to filter.
	 */
	virtual void FilterData(class USeqAct_Interp* InData);
};

class UInterpGroup : public UObject, public FInterpEdInputInterface
{
public:
    //## BEGIN PROPS InterpGroup
    TArrayNoInit<class UInterpTrack*> InterpTracks;
    FName GroupName;
    FColor GroupColor;
    TArrayNoInit<class UAnimSet*> GroupAnimSets;
    BITFIELD bCollapsed:1;
    BITFIELD bVisible:1;
    BITFIELD bIsFolder:1;
    BITFIELD bIsParented:1;
    //## END PROPS InterpGroup

    DECLARE_CLASS(UInterpGroup,UObject,0,Engine)
	// UObject interface
	virtual void PostLoad();

	// UInterpGroup interface

	/** Iterate over all InterpTracks in this InterpGroup, doing any actions to bring the state to the specified time. */
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);

	/** Ensure this group name is unique within this InterpData (its Outer). */
	void EnsureUniqueName();

	/** 
	 *	Find all the tracks in this group of a specific class.
	 *	Tracks are in the output array in the order they appear in the group.
	 */
	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);

	/** Returns whether this Group contains at least one AnimControl track. */
	UBOOL HasAnimControlTrack() const;

	/** Returns whether this Group contains a movement track. */
	UBOOL HasMoveTrack() const;

	/** Iterate over AnimControl tracks in this Group, build the anim blend info structures, and pass to the Actor via (Preview)SetAnimWeights. */
	void UpdateAnimWeights(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);

	/** Util for determining how many AnimControl tracks within this group are using the Slot with the supplied name. */
	INT GetAnimTracksUsingSlot(FName InSlotName);
};

class UInterpGroupDirector : public UInterpGroup
{
public:
    //## BEGIN PROPS InterpGroupDirector
    //## END PROPS InterpGroupDirector

    DECLARE_CLASS(UInterpGroupDirector,UInterpGroup,0,Engine)
	// UInterpGroup interface
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);

	// UInterpGroupDirector interface
	class UInterpTrackDirector* GetDirectorTrack();
	class UInterpTrackFade* GetFadeTrack();
	class UInterpTrackSlomo* GetSlomoTrack();
	class UInterpTrackColorScale* GetColorScaleTrack();
	class UInterpTrackAudioMaster* GetAudioMasterTrack();
};

class UInterpGroupInst : public UObject
{
public:
    //## BEGIN PROPS InterpGroupInst
    class UInterpGroup* Group;
    class AActor* GroupActor;
    TArrayNoInit<class UInterpTrackInst*> TrackInst;
    //## END PROPS InterpGroupInst

    DECLARE_CLASS(UInterpGroupInst,UObject,0,Engine)
	/** 
	 *	Returns the Actor that this GroupInstance is working on. 
	 *	Should use this instead of just referencing GroupActor, as it check bDeleteMe for you.
	 */
	AActor* GetGroupActor();

	/** Called before Interp editing to save original state of Actor. @see UInterpTrackInst::SaveActorState */
	virtual void SaveGroupActorState();

	/** Called after Interp editing to put object back to its original state. @see UInterpTrackInst::RestoreActorState */
	virtual void RestoreGroupActorState();

	/** 
	 *	Initialse this Group instance. Called from USeqAct_Interp::InitInterp before doing any interpolation.
	 *	Save the Actor for the group and creates any needed InterpTrackInsts
	 */
	virtual void InitGroupInst(UInterpGroup* InGroup, AActor* InGroupActor);

	/** 
	 *	Called when done with interpolation sequence. Cleans up InterpTrackInsts etc. 
	 *	Do not do anything further with the Interpolation after this.
	 */
	virtual void TermGroupInst(UBOOL bDeleteTrackInst);

	/** Force any actors attached to this group's actor to update their position using their relative location/rotation. */
	void UpdateAttachedActors();
};

class UInterpGroupInstDirector : public UInterpGroupInst
{
public:
    //## BEGIN PROPS InterpGroupInstDirector
    //## END PROPS InterpGroupInstDirector

    DECLARE_CLASS(UInterpGroupInstDirector,UInterpGroupInst,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterpGroupInstDirector)
};

struct FDirectorTrackCut
{
    FLOAT Time;
    FLOAT TransitionTime;
    FName TargetCamGroup;

    /** Constructors */
    FDirectorTrackCut() {}
    FDirectorTrackCut(EEventParm)
    {
        appMemzero(this, sizeof(FDirectorTrackCut));
    }
};

class UInterpTrackDirector : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackDirector
    TArrayNoInit<struct FDirectorTrackCut> CutTrack;
    BITFIELD bSimulateCameraCutsOnClients:1;
    //## END PROPS InterpTrackDirector

    DECLARE_CLASS(UInterpTrackDirector,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );

	// InterpTrackDirector interface
	FName GetViewedGroupName(FLOAT CurrentTime, FLOAT& CutTime, FLOAT& CutTransitionTime);
};

struct FEventTrackKey
{
    FLOAT Time;
    FName EventName;

    /** Constructors */
    FEventTrackKey() {}
    FEventTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FEventTrackKey));
    }
};

class UInterpTrackEvent : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackEvent
    TArrayNoInit<struct FEventTrackKey> EventTrack;
    BITFIELD bFireEventsWhenForwards:1;
    BITFIELD bFireEventsWhenBackwards:1;
    BITFIELD bFireEventsWhenJumpingForwards:1;
    //## END PROPS InterpTrackEvent

    DECLARE_CLASS(UInterpTrackEvent,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
};

struct FFaceFXTrackKey
{
    FLOAT StartTime;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXSeqName;

    /** Constructors */
    FFaceFXTrackKey() {}
    FFaceFXTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FFaceFXTrackKey));
    }
};

struct FFaceFXSoundCueKey
{
    class USoundCue* FaceFXSoundCue;

    /** Constructors */
    FFaceFXSoundCueKey() {}
    FFaceFXSoundCueKey(EEventParm)
    {
        appMemzero(this, sizeof(FFaceFXSoundCueKey));
    }
};

class UInterpTrackFaceFX : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackFaceFX
    TArrayNoInit<class UFaceFXAnimSet*> FaceFXAnimSets;
    TArrayNoInit<struct FFaceFXTrackKey> FaceFXSeqs;
    class UFaceFXAsset* CachedActorFXAsset;
    TArrayNoInit<struct FFaceFXSoundCueKey> FaceFXSoundCueKeys;
    //## END PROPS InterpTrackFaceFX

    DECLARE_CLASS(UInterpTrackFaceFX,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	//virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	//virtual FColor GetKeyframeColor(INT KeyIndex);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void PreviewStopPlayback(class UInterpTrackInst* TrInst);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
	
	// InterpTrackFaceFX interface
	void GetSeqInfoForTime( FLOAT InTime, FString& OutGroupName, FString& OutSeqName, FLOAT& OutPosition, FLOAT& OutSeqStart, USoundCue*& OutSoundCue );

	/** Updates references to sound cues for all of this track's FaceFX animation keys.  Should be called at
		load time in the editor as well as whenever the track's data is changed. */
	void UpdateFaceFXSoundCueReferences( class UFaceFXAsset* FaceFXAsset );
};

struct FRandomGenerator
{
    BITFIELD bUseRandomise:1;
    INT RandomSeed;
    FLOAT StepValue;
    FLOAT StartTime;
    FLOAT EndTime;
    FLOAT StartValues[2];
    FLOAT EndValues[2];
    FLOAT ValueVariationsPerc[2];
    BITFIELD bStartAtMax:1;
    FLOAT StepValueMax;

    /** Constructors */
    FRandomGenerator() {}
    FRandomGenerator(EEventParm)
    {
        appMemzero(this, sizeof(FRandomGenerator));
    }
};

class UInterpTrackFloatBase : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackFloatBase
    FInterpCurveFloat FloatTrack;
    FLOAT CurveTension;
    struct FRandomGenerator Randomiser;
    //## END PROPS InterpTrackFloatBase

    DECLARE_ABSTRACT_CLASS(UInterpTrackFloatBase,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	virtual FColor GetKeyframeColor(INT KeyIndex);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

struct FAnimControlTrackKey
{
    FLOAT StartTime;
    FName AnimSeqName;
    FLOAT AnimStartOffset;
    FLOAT AnimEndOffset;
    FLOAT AnimPlayRate;
    BITFIELD bLooping:1;
    BITFIELD bReverse:1;

    /** Constructors */
    FAnimControlTrackKey() {}
    FAnimControlTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FAnimControlTrackKey));
    }
};

class UInterpTrackAnimControl : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackAnimControl
    TArrayNoInit<class UAnimSet*> AnimSets;
    FName SlotName;
    TArrayNoInit<struct FAnimControlTrackKey> AnimSeqs;
    //## END PROPS InterpTrackAnimControl

    DECLARE_CLASS(UInterpTrackAnimControl,UInterpTrackFloatBase,0,Engine)
	// UObject interface
	virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	virtual FColor GetKeyframeColor(INT KeyIndex);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** 
	 * Calculates the reversed time for a sequence key, if the key has bReverse set.
	 *
	 * @param SeqKey		Key that is reveresed and we are trying to find a position for.
	 * @param Seq			Anim sequence the key represents.  If NULL, the function will lookup the sequence.
	 * @param InPosition	Timeline position that we are currently at.
	 *
	 * @return Returns the position in the specified seq key. 
	 */
	FLOAT ConditionallyReversePosition(FAnimControlTrackKey &SeqKey, UAnimSequence* Seq, FLOAT InPosition);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
	
	// InterpTrackAnimControl interface
	class UAnimSequence* FindAnimSequenceFromName(FName InName);
	void GetAnimForTime(FLOAT InTime, FName& OutAnimSeqName, FLOAT& OutPosition, UBOOL& bOutLooping);
	FLOAT GetWeightForTime(FLOAT InTime);
	INT SplitKeyAtPosition(FLOAT InPosition);

	/**
	 * Crops the key at the position specified, by deleting the area of the key before or after the position.
	 *
	 * @param InPosition				Position to use as a crop point.
	 * @param bCutAreaBeforePosition	Whether we should delete the area of the key before the position specified or after.
	 *
	 * @return Returns the index of the key that was cropped.
	 */
	INT CropKeyAtPosition(FLOAT InPosition, UBOOL bCutAreaBeforePosition);

	// FInterpEdInputInterface

	/**
	 * Lets the interface object know that we are beginning a drag operation.
	 */
	virtual void BeginDrag(FInterpEdInputData &InputData);

	/**
	 * Lets the interface object know that we are ending a drag operation.
	 */
	virtual void EndDrag(FInterpEdInputData &InputData);

	/**
	 * @return Returns the mouse cursor to display when this input interface is moused over.
	 */
	EMouseCursor GetMouseCursor(FInterpEdInputData &InputData);

	/**
	 * Called when an object is dragged.
	 */
	void ObjectDragged(FInterpEdInputData& InputData);

	/** Calculate the index of this Track within its Slot (for when multiple tracks are using same slot). */
	INT CalcChannelIndex();
};

class UInterpTrackFade : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFade
    BITFIELD bPersistFade:1;
    //## END PROPS InterpTrackFade

    DECLARE_CLASS(UInterpTrackFade,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	virtual class UMaterial* GetTrackIcon();

	// InterpTrackFade interface
	FLOAT GetFadeAmountAtTime(FLOAT Time);
};

class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFloatMaterialParam
    FName ParamName;
    //## END PROPS InterpTrackFloatMaterialParam

    DECLARE_CLASS(UInterpTrackFloatMaterialParam,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	//virtual class UMaterial* GetTrackIcon();
};

class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFloatParticleParam
    FName ParamName;
    //## END PROPS InterpTrackFloatParticleParam

    DECLARE_CLASS(UInterpTrackFloatParticleParam,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	//virtual class UMaterial* GetTrackIcon();
};

class UInterpTrackFloatProp : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFloatProp
    FName PropertyName;
    //## END PROPS InterpTrackFloatProp

    DECLARE_CLASS(UInterpTrackFloatProp,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
};

class UInterpTrackMorphWeight : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackMorphWeight
    FName MorphNodeName;
    //## END PROPS InterpTrackMorphWeight

    DECLARE_CLASS(UInterpTrackMorphWeight,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
};

class UInterpTrackSkelControlScale : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackSkelControlScale
    FName SkelControlName;
    //## END PROPS InterpTrackSkelControlScale

    DECLARE_CLASS(UInterpTrackSkelControlScale,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
};

class UInterpTrackSlomo : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackSlomo
    //## END PROPS InterpTrackSlomo

    DECLARE_CLASS(UInterpTrackSlomo,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void SetTrackToSensibleDefault();

	virtual class UMaterial* GetTrackIcon();

	// InterpTrackSlomo interface
	FLOAT GetSlomoFactorAtTime(FLOAT Time);
};

struct FInterpLookupPoint
{
    FName GroupName;
    FLOAT Time;

    /** Constructors */
    FInterpLookupPoint() {}
    FInterpLookupPoint(EEventParm)
    {
        appMemzero(this, sizeof(FInterpLookupPoint));
    }
};

struct FInterpLookupTrack
{
    TArrayNoInit<struct FInterpLookupPoint> Points;

		/** Add a new keypoint to the LookupTrack.  Returns the index of the new key.*/
		INT AddPoint( const FLOAT InTime, FName &InGroupName )
		{
			INT PointIdx=0; 
			
			for( PointIdx=0; PointIdx<Points.Num() && Points(PointIdx).Time < InTime; PointIdx++);
			
			Points.Insert(PointIdx);
			Points(PointIdx).Time = InTime;
			Points(PointIdx).GroupName = InGroupName;

			return PointIdx;
		}

		/** Move a keypoint to a new In value. This may change the index of the keypoint, so the new key index is returned. */
		INT MovePoint( INT PointIndex, FLOAT NewTime )
		{
			if( PointIndex < 0 || PointIndex >= Points.Num() )
			{
				return PointIndex;
			}

			FName GroupName = Points(PointIndex).GroupName;

			Points.Remove(PointIndex);

			const INT NewPointIndex = AddPoint( NewTime, GroupName );

			return NewPointIndex;
		}
	
};

class UInterpTrackMove : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackMove
    FInterpCurveVector PosTrack;
    FInterpCurveVector EulerTrack;
    struct FInterpLookupTrack LookupTrack;
    FName LookAtGroupName;
    FLOAT LinCurveTension;
    FLOAT AngCurveTension;
    BITFIELD bUseQuatInterpolation:1;
    BITFIELD bShowArrowAtKeys:1;
    BITFIELD bDisableMovement:1;
    BITFIELD bShowTranslationOnCurveEd:1;
    BITFIELD bShowRotationOnCurveEd:1;
    BITFIELD bHide3DTrack:1;
    BYTE MoveFrame GCC_BITFIELD_MAGIC;
    BYTE RotMode;
    //## END PROPS InterpTrackMove

    DECLARE_CLASS(UInterpTrackMove,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditImport();

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void ConditionalPreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);

	virtual class UMaterial* GetTrackIcon();
	virtual FColor GetKeyframeColor(INT KeyIndex);
	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
	virtual void Render3DTrack(UInterpTrackInst* TrInst, const FSceneView* View, FPrimitiveDrawInterface* PDI, INT TrackIndex, const FColor& TrackColor, TArray<class FInterpEdSelKey>& SelectedKeys);
	virtual void SetTrackToSensibleDefault();

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();


	// InterpTrackMove interface
	virtual FName GetLookupKeyGroupName(INT KeyIndex);
	virtual void SetLookupKeyGroupName(INT KeyIndex, const FName &NewGroupName);
	virtual void ClearLookupKeyGroupName(INT KeyIndex);

	/**
	 * Replacement for the PosTrack eval function that uses GetKeyframePosition.  This is so we can replace keyframes that get their information from other tracks.
	 *
	 * @param TrInst	TrackInst to use for looking up groups.
	 * @param Time		Time to evaluate position at.
	 * @return			Final position at the specified time.
	 */
	FVector EvalPositionAtTime(UInterpTrackInst* TrInst, FLOAT Time);

	/**
	 * Replacement for the EulerTrack eval function that uses GetKeyframeRotation.  This is so we can replace keyframes that get their information from other tracks.
	 *
	 * @param TrInst	TrackInst to use for looking up groups.
	 * @param Time		Time to evaluate rotation at.
	 * @return			Final rotation at the specified time.
	 */
	FVector EvalRotationAtTime(UInterpTrackInst* TrInst, FLOAT Time);

	/**
	 * Gets the position of a keyframe given its key index.  Also optionally retrieves the Arrive and Leave tangents for the key.
	 * This function respects the LookupTrack.
	 *
	 * @param TrInst			TrackInst to use for lookup track positions.
	 * @param KeyIndex			Index of the keyframe to get the position of.
	 * @param OutTime           Final time of the keyframe.
	 * @param OutPos			Final position of the keyframe.
	 * @param OutArriveTangent	Pointer to a vector to store the arrive tangent in, can be NULL.
	 * @param OutLeaveTangent	Pointer to a vector to store the leave tangent in, can be NULL.
	 */
	void GetKeyframePosition(UInterpTrackInst* TrInst, INT KeyIndex, FLOAT& OutTime, FVector &OutPos, FVector *OutArriveTangent, FVector *OutLeaveTangent);

	/**
	 * Gets the rotation of a keyframe given its key index.  Also optionally retrieves the Arrive and Leave tangents for the key.
	 * This function respects the LookupTrack.
	 *
	 * @param TrInst			TrackInst to use for lookup track rotations.
	 * @param KeyIndex			Index of the keyframe to get the rotation of.
	 * @param OutTime           Final time of the keyframe.
	 * @param OutRot			Final rotation of the keyframe.
	 * @param OutArriveTangent	Pointer to a vector to store the arrive tangent in, can be NULL.
	 * @param OutLeaveTangent	Pointer to a vector to store the leave tangent in, can be NULL.
	 */
	void GetKeyframeRotation(UInterpTrackInst* TrInst, INT KeyIndex, FLOAT& OutTime, FVector &OutRot, FVector *OutArriveTangent, FVector *OutLeaveTangent);

    /**
     * Computes the world space coordinates for a key; handles keys that use IMF_RelativeToInitial, basing, etc.
     *
     * @param MoveTrackInst		An instance of this movement track
     * @param RelativeSpacePos	Key position value from curve
     * @param RelativeSpaceRot	Key rotation value from curve
     * @param OutPos			Output world space position
     * @param OutRot			Output world space rotation
     */
    void ComputeWorldSpaceKeyTransform( UInterpTrackInstMove* MoveTrackInst,
                                        const FVector& RelativeSpacePos,
								        const FRotator& RelativeSpaceRot,
								        FVector& OutPos,
                                        FRotator& OutRot );
													      
	virtual void GetKeyTransformAtTime(UInterpTrackInst* TrInst, FLOAT Time, FVector& OutPos, FRotator& OutRot);
	virtual void GetLocationAtTime(UInterpTrackInst* TrInst, FLOAT Time, FVector& OutPos, FRotator& OutRot);
	virtual FMatrix GetMoveRefFrame(UInterpTrackInstMove* MoveTrackInst);

	INT CalcSubIndex(UBOOL bPos, INT InIndex) const;
};

struct FParticleReplayTrackKey
{
    FLOAT Time;
    FLOAT Duration;
    INT ClipIDNumber;

    /** Constructors */
    FParticleReplayTrackKey() {}
    FParticleReplayTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FParticleReplayTrackKey));
    }
};

class UInterpTrackParticleReplay : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackParticleReplay
    TArrayNoInit<struct FParticleReplayTrackKey> TrackKeys;
    BITFIELD bIsCapturingReplay:1;
    FLOAT FixedTimeStep;
    //## END PROPS InterpTrackParticleReplay

    DECLARE_CLASS(UInterpTrackParticleReplay,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	/**
	 * Lets the interface object know that we are beginning a drag operation.
	 */
	virtual void BeginDrag(FInterpEdInputData &InputData);

	/**
	 * Lets the interface object know that we are ending a drag operation.
	 */
	virtual void EndDrag(FInterpEdInputData &InputData);

	/**
	 * @return Returns the mouse cursor to display when this input interface is moused over.
	 */
	EMouseCursor GetMouseCursor(FInterpEdInputData &InputData);

	/**
	 * Called when an object is dragged.
	 */
	void ObjectDragged(FInterpEdInputData& InputData);

	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
};

struct FToggleTrackKey
{
    FLOAT Time;
    BYTE ToggleAction;

    /** Constructors */
    FToggleTrackKey() {}
    FToggleTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FToggleTrackKey));
    }
};

class UInterpTrackToggle : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackToggle
    TArrayNoInit<struct FToggleTrackKey> ToggleTrack;
    BITFIELD bActivateSystemEachUpdate:1;
    BITFIELD bFireEventsWhenForwards:1;
    BITFIELD bFireEventsWhenBackwards:1;
    BITFIELD bFireEventsWhenJumpingForwards:1;
    //## END PROPS InterpTrackToggle

    DECLARE_CLASS(UInterpTrackToggle,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
};

struct FRandomGeneratorVector
{
    BITFIELD bUseRandomise:1;
    INT RandomSeed;
    FLOAT StepValue;
    FLOAT StepValueMax;
    FLOAT StartTime;
    FLOAT EndTime;
    FLOAT StartValues[6];
    FLOAT EndValues[6];
    FLOAT ValueVariationsPerc[6];
    BITFIELD bStartAtMaxX:1;
    BITFIELD bStartAtMaxY:1;
    BITFIELD bStartAtMaxZ:1;

    /** Constructors */
    FRandomGeneratorVector() {}
    FRandomGeneratorVector(EEventParm)
    {
        appMemzero(this, sizeof(FRandomGeneratorVector));
    }
};

class UInterpTrackVectorBase : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackVectorBase
    FInterpCurveVector VectorTrack;
    FLOAT CurveTension;
    struct FRandomGeneratorVector Randomiser;
    //## END PROPS InterpTrackVectorBase

    DECLARE_ABSTRACT_CLASS(UInterpTrackVectorBase,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual FColor GetKeyframeColor(INT KeyIndex);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UInterpTrackAudioMaster : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackAudioMaster
    //## END PROPS InterpTrackAudioMaster

    DECLARE_CLASS(UInterpTrackAudioMaster,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void SetTrackToSensibleDefault();

	/** Return the sound volume scale for the specified time */
	FLOAT GetVolumeScaleForTime( FLOAT Time ) const;

	/** Return the sound pitch scale for the specified time */
	FLOAT GetPitchScaleForTime( FLOAT Time ) const;

	virtual class UMaterial* GetTrackIcon();
};

class UInterpTrackColorProp : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackColorProp
    FName PropertyName;
    //## END PROPS InterpTrackColorProp

    DECLARE_CLASS(UInterpTrackColorProp,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
};

class UInterpTrackColorScale : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackColorScale
    //## END PROPS InterpTrackColorScale

    DECLARE_CLASS(UInterpTrackColorScale,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void SetTrackToSensibleDefault();

	virtual class UMaterial* GetTrackIcon();

	// InterpTrackColorScale interface
	FVector GetColorScaleAtTime(FLOAT Time);
};

struct FSoundTrackKey
{
    FLOAT Time;
    FLOAT Volume;
    FLOAT Pitch;
    class USoundCue* Sound;

    /** Constructors */
    FSoundTrackKey() {}
    FSoundTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FSoundTrackKey));
    }
};

class UInterpTrackSound : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackSound
    TArrayNoInit<struct FSoundTrackKey> Sounds;
    BITFIELD bContinueSoundOnMatineeEnd:1;
    BITFIELD bSuppressSubtitles:1;
    BITFIELD bStopSoundOnMatineeSkip:1;
    //## END PROPS InterpTrackSound

    DECLARE_CLASS(UInterpTrackSound,UInterpTrackVectorBase,0,Engine)
	virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void PreviewStopPlayback(class UInterpTrackInst* TrInst);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
	
	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	// InterpTrackSound interface
	/**
	 * Returns the key at the specified position in the track.
	 */
	struct FSoundTrackKey& GetSoundTrackKeyAtPosition(FLOAT InPosition);

	virtual void SetTrackToSensibleDefault();
};

class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackVectorMaterialParam
    FName ParamName;
    //## END PROPS InterpTrackVectorMaterialParam

    DECLARE_CLASS(UInterpTrackVectorMaterialParam,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	//virtual class UMaterial* GetTrackIcon();
};

class UInterpTrackVectorProp : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackVectorProp
    FName PropertyName;
    //## END PROPS InterpTrackVectorProp

    DECLARE_CLASS(UInterpTrackVectorProp,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();
};

struct FVisibilityTrackKey
{
    FLOAT Time;
    BYTE Action;
    BYTE ActiveCondition;

    /** Constructors */
    FVisibilityTrackKey() {}
    FVisibilityTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FVisibilityTrackKey));
    }
};

class UInterpTrackVisibility : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackVisibility
    TArrayNoInit<struct FVisibilityTrackKey> VisibilityTrack;
    BITFIELD bFireEventsWhenForwards:1;
    BITFIELD bFireEventsWhenBackwards:1;
    BITFIELD bFireEventsWhenJumpingForwards:1;
    //## END PROPS InterpTrackVisibility

    DECLARE_CLASS(UInterpTrackVisibility,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon();

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, const FInterpTrackDrawParams& Params );
};

class UInterpTrackInst : public UObject
{
public:
    //## BEGIN PROPS InterpTrackInst
    //## END PROPS InterpTrackInst

    DECLARE_CLASS(UInterpTrackInst,UObject,0,Engine)
	/** 
	 *	Return the Actor associated with this instance of a Group. 
	 *	Note that all Groups have at least 1 instance, even if no Actor variable is attached, so this may return NULL. 
	 */
	AActor* GetGroupActor();

	/** Called before Interp editing to put object back to its original state. */
	virtual void SaveActorState(UInterpTrack* Track) {}

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState(UInterpTrack* Track) {}

	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track) {}

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track) {}
};

class UInterpTrackInstAnimControl : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstAnimControl
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstAnimControl

    DECLARE_CLASS(UInterpTrackInstAnimControl,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstAudioMaster : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstAudioMaster
    //## END PROPS InterpTrackInstAudioMaster

    DECLARE_CLASS(UInterpTrackInstAudioMaster,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstColorScale : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstColorScale
    //## END PROPS InterpTrackInstColorScale

    DECLARE_CLASS(UInterpTrackInstColorScale,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstDirector : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstDirector
    class AActor* OldViewTarget;
    //## END PROPS InterpTrackInstDirector

    DECLARE_CLASS(UInterpTrackInstDirector,UInterpTrackInst,0,Engine)
	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);
	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstEvent : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstEvent
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstEvent

    DECLARE_CLASS(UInterpTrackInstEvent,UInterpTrackInst,0,Engine)
	/** 
	 * This will initialise LastUpdatePosition to whatever position the SeqAct_Interp is in, 
	 * so we don't play a bunch of events straight away! 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstFaceFX : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFaceFX
    BITFIELD bFirstUpdate:1;
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstFaceFX

    DECLARE_CLASS(UInterpTrackInstFaceFX,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstFade : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFade
    //## END PROPS InterpTrackInstFade

    DECLARE_CLASS(UInterpTrackInstFade,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFloatMaterialParam
    FLOAT ResetFloat;
    //## END PROPS InterpTrackInstFloatMaterialParam

    DECLARE_CLASS(UInterpTrackInstFloatMaterialParam,UInterpTrackInst,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstFloatParticleParam : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFloatParticleParam
    FLOAT ResetFloat;
    //## END PROPS InterpTrackInstFloatParticleParam

    DECLARE_CLASS(UInterpTrackInstFloatParticleParam,UInterpTrackInst,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstMorphWeight : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstMorphWeight
    //## END PROPS InterpTrackInstMorphWeight

    DECLARE_CLASS(UInterpTrackInstMorphWeight,UInterpTrackInst,0,Engine)
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstMove : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstMove
    FVector ResetLocation;
    FRotator ResetRotation;
    FMatrix InitialTM;
    FQuat InitialQuat;
    //## END PROPS InterpTrackInstMove

    DECLARE_CLASS(UInterpTrackInstMove,UInterpTrackInst,0,Engine)
	/** Will save the current position of the Actor as the 'initial position', used if MoveFrame == IMF_RelativeToInitial. */
	virtual void InitTrackInst(UInterpTrack* Track);
	
	/** Initialise InitialTMand InitialQuat. */
	void CalcInitialTransform(UInterpTrack* Track, UBOOL bZeroFromHere);
};

class UInterpTrackInstParticleReplay : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstParticleReplay
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstParticleReplay

    DECLARE_CLASS(UInterpTrackInstParticleReplay,UInterpTrackInst,0,Engine)
	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstProperty : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstProperty
    class UFunction* PropertyUpdateCallback;
    class UObject* PropertyOuterObjectInst;
    //## END PROPS InterpTrackInstProperty

    DECLARE_CLASS(UInterpTrackInstProperty,UInterpTrackInst,0,Engine)
	/**
	 * Retrieves the update callback from the interp property's metadata and stores it.
	 *
	 * @param InActor			Actor we are operating on.
	 * @param TrackProperty		Property we are interpolating.
	 */
	void SetupPropertyUpdateCallback(AActor* InActor, const FName& TrackPropertyName);

	/** 
	 * Tries to call the property update callback.
	 *
	 * @return TRUE if the callback existed and was called, FALSE otherwise.
	 */
	UBOOL CallPropertyUpdateCallback();

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstColorProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstColorProp
    FPointer ColorProp;
    FColor ResetColor;
    //## END PROPS InterpTrackInstColorProp

    DECLARE_CLASS(UInterpTrackInstColorProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstFloatProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstFloatProp
    FPointer FloatProp;
    FLOAT ResetFloat;
    //## END PROPS InterpTrackInstFloatProp

    DECLARE_CLASS(UInterpTrackInstFloatProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstVectorProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstVectorProp
    FPointer VectorProp;
    FVector ResetVector;
    //## END PROPS InterpTrackInstVectorProp

    DECLARE_CLASS(UInterpTrackInstVectorProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstSkelControlScale : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSkelControlScale
    //## END PROPS InterpTrackInstSkelControlScale

    DECLARE_CLASS(UInterpTrackInstSkelControlScale,UInterpTrackInst,0,Engine)
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstSlomo : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSlomo
    FLOAT OldTimeDilation;
    //## END PROPS InterpTrackInstSlomo

    DECLARE_CLASS(UInterpTrackInstSlomo,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);

	/** @return whether the slomo track's effects should actually be applied. We want to only do this once for the server
	 * and not at all for the clients regardless of the number of instances created for the various players
	 * to avoid collisions and replication issues
	 */
	UBOOL ShouldBeApplied();
};

class UInterpTrackInstSound : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSound
    FLOAT LastUpdatePosition;
    class UAudioComponent* PlayAudioComp;
    //## END PROPS InterpTrackInstSound

    DECLARE_CLASS(UInterpTrackInstSound,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstToggle : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstToggle
    BYTE Action;
    FLOAT LastUpdatePosition;
    BITFIELD bSavedActiveState:1;
    //## END PROPS InterpTrackInstToggle

    DECLARE_CLASS(UInterpTrackInstToggle,UInterpTrackInst,0,Engine)
	/** 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Called before Interp editing to put object back to its original state. */
	virtual void SaveActorState(UInterpTrack* Track);

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstVectorMaterialParam
    FVector ResetVector;
    //## END PROPS InterpTrackInstVectorMaterialParam

    DECLARE_CLASS(UInterpTrackInstVectorMaterialParam,UInterpTrackInst,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstVisibility : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstVisibility
    BYTE Action;
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstVisibility

    DECLARE_CLASS(UInterpTrackInstVisibility,UInterpTrackInst,0,Engine)
	/** 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);
};

#endif // !INCLUDED_ENGINE_INTERPOLATION_CLASSES
#endif // !NAMES_ONLY


#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_INTERPOLATION_NATIVE_DEFS
#define ENGINE_INTERPOLATION_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UInterpFilter);
DECLARE_NATIVE_TYPE(Engine,UInterpFilter_Classes);
DECLARE_NATIVE_TYPE(Engine,UInterpFilter_Custom);
DECLARE_NATIVE_TYPE(Engine,UInterpGroup);
DECLARE_NATIVE_TYPE(Engine,UInterpGroupDirector);
DECLARE_NATIVE_TYPE(Engine,UInterpGroupInst);
DECLARE_NATIVE_TYPE(Engine,UInterpGroupInstDirector);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackAnimControl);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackAudioMaster);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackColorProp);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackColorScale);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackDirector);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackEvent);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackFaceFX);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackFade);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackFloatBase);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackFloatMaterialParam);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackFloatParticleParam);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackFloatProp);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInst);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstAnimControl);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstAudioMaster);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstColorProp);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstColorScale);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstDirector);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstEvent);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstFaceFX);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstFade);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstFloatMaterialParam);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstFloatParticleParam);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstFloatProp);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstMorphWeight);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstMove);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstParticleReplay);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstProperty);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstSkelControlScale);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstSlomo);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstSound);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstToggle);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstVectorMaterialParam);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstVectorProp);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackInstVisibility);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackMorphWeight);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackMove);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackParticleReplay);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackSkelControlScale);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackSlomo);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackSound);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackToggle);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackVectorBase);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackVectorMaterialParam);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackVectorProp);
DECLARE_NATIVE_TYPE(Engine,UInterpTrackVisibility);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_INTERPOLATION \
	UInterpFilter::StaticClass(); \
	UInterpFilter_Classes::StaticClass(); \
	UInterpFilter_Custom::StaticClass(); \
	UInterpGroup::StaticClass(); \
	UInterpGroupDirector::StaticClass(); \
	UInterpGroupInst::StaticClass(); \
	UInterpGroupInstDirector::StaticClass(); \
	UInterpTrackAnimControl::StaticClass(); \
	UInterpTrackAudioMaster::StaticClass(); \
	UInterpTrackColorProp::StaticClass(); \
	UInterpTrackColorScale::StaticClass(); \
	UInterpTrackDirector::StaticClass(); \
	UInterpTrackEvent::StaticClass(); \
	UInterpTrackFaceFX::StaticClass(); \
	UInterpTrackFade::StaticClass(); \
	UInterpTrackFloatBase::StaticClass(); \
	UInterpTrackFloatMaterialParam::StaticClass(); \
	UInterpTrackFloatParticleParam::StaticClass(); \
	UInterpTrackFloatProp::StaticClass(); \
	UInterpTrackInst::StaticClass(); \
	UInterpTrackInstAnimControl::StaticClass(); \
	UInterpTrackInstAudioMaster::StaticClass(); \
	UInterpTrackInstColorProp::StaticClass(); \
	UInterpTrackInstColorScale::StaticClass(); \
	UInterpTrackInstDirector::StaticClass(); \
	UInterpTrackInstEvent::StaticClass(); \
	UInterpTrackInstFaceFX::StaticClass(); \
	UInterpTrackInstFade::StaticClass(); \
	UInterpTrackInstFloatMaterialParam::StaticClass(); \
	UInterpTrackInstFloatParticleParam::StaticClass(); \
	UInterpTrackInstFloatProp::StaticClass(); \
	UInterpTrackInstMorphWeight::StaticClass(); \
	UInterpTrackInstMove::StaticClass(); \
	UInterpTrackInstParticleReplay::StaticClass(); \
	UInterpTrackInstProperty::StaticClass(); \
	UInterpTrackInstSkelControlScale::StaticClass(); \
	UInterpTrackInstSlomo::StaticClass(); \
	UInterpTrackInstSound::StaticClass(); \
	UInterpTrackInstToggle::StaticClass(); \
	UInterpTrackInstVectorMaterialParam::StaticClass(); \
	UInterpTrackInstVectorProp::StaticClass(); \
	UInterpTrackInstVisibility::StaticClass(); \
	UInterpTrackMorphWeight::StaticClass(); \
	UInterpTrackMove::StaticClass(); \
	UInterpTrackParticleReplay::StaticClass(); \
	UInterpTrackSkelControlScale::StaticClass(); \
	UInterpTrackSlomo::StaticClass(); \
	UInterpTrackSound::StaticClass(); \
	UInterpTrackToggle::StaticClass(); \
	UInterpTrackVectorBase::StaticClass(); \
	UInterpTrackVectorMaterialParam::StaticClass(); \
	UInterpTrackVectorProp::StaticClass(); \
	UInterpTrackVisibility::StaticClass(); \

#endif // ENGINE_INTERPOLATION_NATIVE_DEFS

#ifdef NATIVES_ONLY
#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,InterpFilter,Caption)
VERIFY_CLASS_SIZE_NODIE(UInterpFilter)
VERIFY_CLASS_OFFSET_NODIE(U,InterpFilter_Classes,ClassToFilterBy)
VERIFY_CLASS_OFFSET_NODIE(U,InterpFilter_Classes,TrackClasses)
VERIFY_CLASS_SIZE_NODIE(UInterpFilter_Classes)
VERIFY_CLASS_OFFSET_NODIE(U,InterpFilter_Custom,GroupsToInclude)
VERIFY_CLASS_SIZE_NODIE(UInterpFilter_Custom)
VERIFY_CLASS_OFFSET_NODIE(U,InterpGroup,InterpTracks)
VERIFY_CLASS_OFFSET_NODIE(U,InterpGroup,GroupAnimSets)
VERIFY_CLASS_SIZE_NODIE(UInterpGroup)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupDirector)
VERIFY_CLASS_OFFSET_NODIE(U,InterpGroupInst,Group)
VERIFY_CLASS_OFFSET_NODIE(U,InterpGroupInst,TrackInst)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInst)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInstDirector)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackAnimControl,AnimSets)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackAnimControl,AnimSeqs)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackAnimControl)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackAudioMaster)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackColorProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackColorProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackColorScale)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackDirector,CutTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackDirector)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackEvent,EventTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackEvent)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFaceFX,FaceFXAnimSets)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFaceFX,FaceFXSoundCueKeys)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFaceFX)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFade)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFloatBase,FloatTrack)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFloatBase,Randomiser)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatBase)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFloatMaterialParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFloatParticleParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatParticleParam)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackFloatProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInst)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstAnimControl,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstAnimControl)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstAudioMaster)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstColorProp,ColorProp)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstColorProp,ResetColor)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstColorProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstColorScale)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstDirector,OldViewTarget)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstDirector)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstEvent,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstEvent)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstFaceFX,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFaceFX)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFade)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstFloatMaterialParam,ResetFloat)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstFloatParticleParam,ResetFloat)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatParticleParam)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstFloatProp,FloatProp)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstFloatProp,ResetFloat)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstMorphWeight)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstMove,ResetLocation)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstMove,InitialQuat)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstMove)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstParticleReplay,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstParticleReplay)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstProperty,PropertyUpdateCallback)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstProperty,PropertyOuterObjectInst)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstProperty)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSkelControlScale)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstSlomo,OldTimeDilation)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSlomo)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstSound,LastUpdatePosition)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstSound,PlayAudioComp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSound)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstToggle,Action)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstToggle,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstToggle)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstVectorMaterialParam,ResetVector)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstVectorMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstVectorProp,VectorProp)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstVectorProp,ResetVector)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstVectorProp)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstVisibility,Action)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackInstVisibility,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstVisibility)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackMorphWeight,MorphNodeName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackMorphWeight)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackMove,PosTrack)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackMove,RotMode)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackMove)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackParticleReplay,TrackKeys)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackParticleReplay,FixedTimeStep)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackParticleReplay)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackSkelControlScale,SkelControlName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSkelControlScale)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSlomo)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackSound,Sounds)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSound)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackToggle,ToggleTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackToggle)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackVectorBase,VectorTrack)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackVectorBase,Randomiser)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorBase)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackVectorMaterialParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackVectorProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorProp)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrackVisibility,VisibilityTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVisibility)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
