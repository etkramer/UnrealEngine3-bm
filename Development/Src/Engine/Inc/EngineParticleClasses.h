/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PARTICLE_ENUMS
#define INCLUDED_ENGINE_PARTICLE_ENUMS 1

enum ParticleSystemLODMethod
{
    PARTICLESYSTEMLODMETHOD_Automatic=0,
    PARTICLESYSTEMLODMETHOD_DirectSet=1,
    PARTICLESYSTEMLODMETHOD_MAX=2,
};
enum EParticleSystemUpdateMode
{
    EPSUM_RealTime          =0,
    EPSUM_FixedTime         =1,
    EPSUM_MAX               =2,
};
enum EParticleEventType
{
    EPET_Any                =0,
    EPET_Spawn              =1,
    EPET_Death              =2,
    EPET_Collision          =3,
    EPET_Kismet             =4,
    EPET_MAX                =5,
};
enum ParticleReplayState
{
    PRS_Disabled            =0,
    PRS_Capturing           =1,
    PRS_Replaying           =2,
    PRS_MAX                 =3,
};
enum EParticleSysParamType
{
    PSPT_None               =0,
    PSPT_Scalar             =1,
    PSPT_Vector             =2,
    PSPT_Color              =3,
    PSPT_Actor              =4,
    PSPT_Material           =5,
    PSPT_MAX                =6,
};
enum EEmitterRenderMode
{
    ERM_Normal              =0,
    ERM_Point               =1,
    ERM_Cross               =2,
    ERM_None                =3,
    ERM_MAX                 =4,
};
enum EParticleSubUVInterpMethod
{
    PSUVIM_None             =0,
    PSUVIM_Linear           =1,
    PSUVIM_Linear_Blend     =2,
    PSUVIM_Random           =3,
    PSUVIM_Random_Blend     =4,
    PSUVIM_MAX              =5,
};
enum EParticleBurstMethod
{
    EPBM_Instant            =0,
    EPBM_Interpolated       =1,
    EPBM_MAX                =2,
};
enum EParticleScreenAlignment
{
    PSA_Square              =0,
    PSA_Rectangle           =1,
    PSA_Velocity            =2,
    PSA_TypeSpecific        =3,
    PSA_MAX                 =4,
};
enum EParticleSourceSelectionMethod
{
    EPSSM_Random            =0,
    EPSSM_Sequential        =1,
    EPSSM_MAX               =2,
};
enum EModuleType
{
    EPMT_General            =0,
    EPMT_TypeData           =1,
    EPMT_Beam               =2,
    EPMT_Trail              =3,
    EPMT_Spawn              =4,
    EPMT_Required           =5,
    EPMT_Event              =6,
    EPMT_MAX                =7,
};
enum EAttractorParticleSelectionMethod
{
    EAPSM_Random            =0,
    EAPSM_Sequential        =1,
    EAPSM_MAX               =2,
};
enum Beam2SourceTargetTangentMethod
{
    PEB2STTM_Direct         =0,
    PEB2STTM_UserSet        =1,
    PEB2STTM_Distribution   =2,
    PEB2STTM_Emitter        =3,
    PEB2STTM_MAX            =4,
};
enum Beam2SourceTargetMethod
{
    PEB2STM_Default         =0,
    PEB2STM_UserSet         =1,
    PEB2STM_Emitter         =2,
    PEB2STM_Particle        =3,
    PEB2STM_Actor           =4,
    PEB2STM_MAX             =5,
};
enum BeamModifierType
{
    PEB2MT_Source           =0,
    PEB2MT_Target           =1,
    PEB2MT_MAX              =2,
};
enum EParticleCollisionComplete
{
    EPCC_Kill               =0,
    EPCC_Freeze             =1,
    EPCC_HaltCollisions     =2,
    EPCC_FreezeTranslation  =3,
    EPCC_FreezeRotation     =4,
    EPCC_FreezeMovement     =5,
    EPCC_MAX                =6,
};
enum ELocationEmitterSelectionMethod
{
    ELESM_Random            =0,
    ELESM_Sequential        =1,
    ELESM_MAX               =2,
};
enum CylinderHeightAxis
{
    PMLPC_HEIGHTAXIS_X      =0,
    PMLPC_HEIGHTAXIS_Y      =1,
    PMLPC_HEIGHTAXIS_Z      =2,
    PMLPC_HEIGHTAXIS_MAX    =3,
};
enum EOrbitChainMode
{
    EOChainMode_Add         =0,
    EOChainMode_Scale       =1,
    EOChainMode_Link        =2,
    EOChainMode_MAX         =3,
};
enum EParticleAxisLock
{
    EPAL_NONE               =0,
    EPAL_X                  =1,
    EPAL_Y                  =2,
    EPAL_Z                  =3,
    EPAL_NEGATIVE_X         =4,
    EPAL_NEGATIVE_Y         =5,
    EPAL_NEGATIVE_Z         =6,
    EPAL_ROTATE_X           =7,
    EPAL_ROTATE_Y           =8,
    EPAL_ROTATE_Z           =9,
    EPAL_MAX                =10,
};
enum ETrail2SourceMethod
{
    PET2SRCM_Default        =0,
    PET2SRCM_Particle       =1,
    PET2SRCM_Actor          =2,
    PET2SRCM_MAX            =3,
};
enum ETrail2SpawnMethod
{
    PET2SM_Emitter          =0,
    PET2SM_Velocity         =1,
    PET2SM_Distance         =2,
    PET2SM_MAX              =3,
};
enum ETrailTaperMethod
{
    PETTM_None              =0,
    PETTM_Full              =1,
    PETTM_Partial           =2,
    PETTM_MAX               =3,
};
enum EBeamEndPointMethod
{
    PEBEPM_Calculated       =0,
    PEBEPM_Distribution     =1,
    PEBEPM_Distribution_Constant=2,
    PEBEPM_MAX              =3,
};
enum EBeamMethod
{
    PEBM_Distance           =0,
    PEBM_EndPoints          =1,
    PEBM_EndPoints_Interpolated=2,
    PEBM_UserSet_EndPoints  =3,
    PEBM_UserSet_EndPoints_Interpolated=4,
    PEBM_MAX                =5,
};
enum EBeamTaperMethod
{
    PEBTM_None              =0,
    PEBTM_Full              =1,
    PEBTM_Partial           =2,
    PEBTM_MAX               =3,
};
enum EBeam2Method
{
    PEB2M_Distance          =0,
    PEB2M_Target            =1,
    PEB2M_Branch            =2,
    PEB2M_MAX               =3,
};
enum EMeshScreenAlignment
{
    PSMA_MeshFaceCameraWithRoll=0,
    PSMA_MeshFaceCameraWithSpin=1,
    PSMA_MeshFaceCameraWithLockedAxis=2,
    PSMA_MAX                =3,
};
enum EPhysXMeshRotationMethod
{
    PMRM_Disabled           =0,
    PMRM_Spherical          =1,
    PMRM_Box                =2,
    PMRM_LongBox            =3,
    PMRM_FlatBox            =4,
    PMRM_MAX                =5,
};
enum EPacketSizeMultiplier
{
    EPSM_4                  =0,
    EPSM_8                  =1,
    EPSM_16                 =2,
    EPSM_32                 =3,
    EPSM_64                 =4,
    EPSM_128                =5,
    EPSM_MAX                =6,
};
enum ESimulationMethod
{
    ESM_SPH                 =0,
    ESM_NO_PARTICLE_INTERACTION=1,
    ESM_MIXED_MODE          =2,
    ESM_MAX                 =3,
};

#endif // !INCLUDED_ENGINE_PARTICLE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(OnSystemFinished)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PARTICLE_CLASSES
#define INCLUDED_ENGINE_PARTICLE_CLASSES 1

class AEmitterCameraLensEffectBase : public AEmitter
{
public:
    //## BEGIN PROPS EmitterCameraLensEffectBase
    class UParticleSystem* PS_CameraEffect;
    class UParticleSystem* PS_CameraEffectNonExtremeContent;
    //## END PROPS EmitterCameraLensEffectBase

    DECLARE_ABSTRACT_CLASS(AEmitterCameraLensEffectBase,AEmitter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AEmitterCameraLensEffectBase)
};

struct FIndexedRBState
{
    FVector CenterOfMass;
    FVector LinearVelocity;
    FVector AngularVelocity;
    INT Index;

    /** Constructors */
    FIndexedRBState() {}
    FIndexedRBState(EEventParm)
    {
        appMemzero(this, sizeof(FIndexedRBState));
    }
};

struct FRBVolumeFill
{
    TArray<struct FIndexedRBState> RBStates;
    TArray<FVector> Positions;

    /** Constructors */
    FRBVolumeFill() {}
    FRBVolumeFill(EEventParm)
    {
        appMemzero(this, sizeof(FRBVolumeFill));
    }
};

class APhysXEmitterSpawnable : public AEmitter
{
public:
    //## BEGIN PROPS PhysXEmitterSpawnable
    FRBVolumeFill* VolumeFill;
    class UParticleSystem* ParticleTemplate;
    //## END PROPS PhysXEmitterSpawnable

    virtual void Term();
    DECLARE_FUNCTION(execTerm)
    {
        P_FINISH;
        Term();
    }
    DECLARE_CLASS(APhysXEmitterSpawnable,AEmitter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APhysXEmitterSpawnable)
};

class UParticleSystem : public UObject
{
public:
    //## BEGIN PROPS ParticleSystem
    BYTE SystemUpdateMode;
    BYTE LODMethod;
    FLOAT UpdateTime_FPS;
    FLOAT UpdateTime_Delta;
    FLOAT WarmupTime;
    TArrayNoInit<class UParticleEmitter*> Emitters;
    class UParticleSystemComponent* PreviewComponent;
    FRotator ThumbnailAngle;
    FLOAT ThumbnailDistance;
    FLOAT ThumbnailWarmup;
    BITFIELD bLit:1;
    BITFIELD bRegenerateLODDuplicate:1;
    BITFIELD bUseFixedRelativeBoundingBox:1;
    BITFIELD bShouldResetPeakCounts:1;
    BITFIELD bHasPhysics:1;
    BITFIELD bUseRealtimeThumbnail:1;
    BITFIELD ThumbnailImageOutOfDate:1;
    BITFIELD bSkipSpawnCountCheck:1;
    class UInterpCurveEdSetup* CurveEdSetup;
    FLOAT LODDistanceCheckTime;
    TArrayNoInit<FLOAT> LODDistances;
    INT EditorLODSetting;
    FBox FixedRelativeBoundingBox;
    FLOAT SecondsBeforeInactive;
    FStringNoInit FloorMesh;
    FVector FloorPosition;
    FRotator FloorRotation;
    FLOAT FloorScale;
    FVector FloorScale3D;
    class UTexture2D* ThumbnailImage;
    TArrayNoInit<FName> ContentTags;
    //## END PROPS ParticleSystem

    virtual BYTE GetCurrentLODMethod();
    virtual INT GetLODLevelCount();
    virtual FLOAT GetLODDistance(INT LODLevelIndex);
    virtual void SetCurrentLODMethod(BYTE InMethod);
    virtual UBOOL SetLODDistance(INT LODLevelIndex,FLOAT InDistance);
    DECLARE_FUNCTION(execGetCurrentLODMethod)
    {
        P_FINISH;
        *(BYTE*)Result=GetCurrentLODMethod();
    }
    DECLARE_FUNCTION(execGetLODLevelCount)
    {
        P_FINISH;
        *(INT*)Result=GetLODLevelCount();
    }
    DECLARE_FUNCTION(execGetLODDistance)
    {
        P_GET_INT(LODLevelIndex);
        P_FINISH;
        *(FLOAT*)Result=GetLODDistance(LODLevelIndex);
    }
    DECLARE_FUNCTION(execSetCurrentLODMethod)
    {
        P_GET_BYTE(InMethod);
        P_FINISH;
        SetCurrentLODMethod(InMethod);
    }
    DECLARE_FUNCTION(execSetLODDistance)
    {
        P_GET_INT(LODLevelIndex);
        P_GET_FLOAT(InDistance);
        P_FINISH;
        *(UBOOL*)Result=SetLODDistance(LODLevelIndex,InDistance);
    }
    DECLARE_CLASS(UParticleSystem,UObject,0,Engine)
	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PreSave();
	virtual void PostLoad();

	void UpdateColorModuleClampAlpha(class UParticleModuleColorBase* ColorModule);

	/**
	 *	CalculateMaxActiveParticleCounts
	 *	Determine the maximum active particles that could occur with each emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return	TRUE	if the numbers were determined for each emitter
	 *			FALSE	if not be determined
	 */
	virtual UBOOL		CalculateMaxActiveParticleCounts();
	
	/**
	 *	Retrieve the parameters associated with this particle system.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams used in the system
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions used in the system
	 */
	void GetParametersUtilized(TArray<TArray<FString> >& ParticleSysParamList,
							   TArray<TArray<FString> >& ParticleParameterList);
};

struct FParticleSysParam
{
    FName Name;
    BYTE ParamType;
    FLOAT Scalar;
    FVector Vector;
    FColor Color;
    class AActor* Actor;
    class UMaterialInterface* Material;
    FPointer VectorArray;

    /** Constructors */
    FParticleSysParam() {}
    FParticleSysParam(EEventParm)
    {
        appMemzero(this, sizeof(FParticleSysParam));
    }
};

struct FParticleEventData
{
    INT Type;
    FName EventName;
    FLOAT EmitterTime;
    FVector Location;
    FVector Direction;
    FVector Velocity;

    /** Constructors */
    FParticleEventData() {}
    FParticleEventData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventData));
    }
};

struct FParticleEventSpawnData : public FParticleEventData
{

    /** Constructors */
    FParticleEventSpawnData() {}
    FParticleEventSpawnData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventSpawnData));
    }
};

struct FParticleEventDeathData : public FParticleEventData
{
    FLOAT ParticleTime;

    /** Constructors */
    FParticleEventDeathData() {}
    FParticleEventDeathData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventDeathData));
    }
};

struct FParticleEventCollideData : public FParticleEventData
{
    FLOAT ParticleTime;
    FVector Normal;
    FLOAT Time;
    INT Item;
    FName BoneName;

    /** Constructors */
    FParticleEventCollideData() {}
    FParticleEventCollideData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventCollideData));
    }
};

struct FParticleEventKismetData : public FParticleEventData
{
    BITFIELD UsePSysCompLocation:1;
    FVector Normal;

    /** Constructors */
    FParticleEventKismetData() {}
    FParticleEventKismetData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventKismetData));
    }
};

struct ParticleSystemComponent_eventOnSystemFinished_Parms
{
    class UParticleSystemComponent* PSystem;
    ParticleSystemComponent_eventOnSystemFinished_Parms(EEventParm)
    {
    }
};
class UParticleSystemComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS ParticleSystemComponent
    class UParticleSystem* Template;
    TArrayNoInit<struct FParticleEmitterInstance*> EmitterInstances;
    TArrayNoInit<class UStaticMeshComponent*> SMComponents;
    TArrayNoInit<class UMaterialInterface*> SMMaterialInterfaces;
    BITFIELD bAutoActivate:1;
    BITFIELD bWasCompleted:1;
    BITFIELD bSuppressSpawning:1;
    BITFIELD bWasDeactivated:1;
    BITFIELD bResetOnDetach:1;
    BITFIELD bUpdateOnDedicatedServer:1;
    BITFIELD bJustAttached:1;
    BITFIELD bIsActive:1;
    BITFIELD bWarmingUp:1;
    BITFIELD bIsCachedInPool:1;
    BITFIELD bOverrideLODMethod:1;
    BITFIELD bSkipUpdateDynamicDataDuringTick:1;
    BITFIELD bUpdateComponentInTick:1;
    BITFIELD bDeferredBeamUpdate:1;
    BITFIELD bForcedInActive:1;
    BITFIELD bIsWarmingUp:1;
    BITFIELD bIsViewRelevanceDirty:1;
    BITFIELD bAudioComponentBurst:1;
    BITFIELD bRecacheViewRelevance:1;
    BITFIELD bLODUpdatePending:1;
    BITFIELD bSkipSpawnCountCheck:1;
    FVector DynamicLocalSpawnLocation;
    TArrayNoInit<struct FParticleSysParam> InstanceParameters;
    FVector OldPosition;
    FVector PartSysVelocity;
    FLOAT WarmupTime;
    INT LODLevel;
    FLOAT SecondsBeforeInactive;
    INT EditorLODLevel;
    FLOAT AccumTickTime;
    BYTE LODMethod;
    BYTE ReplayState;
    TArrayNoInit<FMaterialViewRelevance> CachedViewRelevanceFlags;
    class UAudioComponent* AudioComponentOnSpawn;
    class UAudioComponent* AudioComponentBurst;
    FLOAT fAudioComponentOnSpawnDistance;
    FLOAT fAudioComponentBurstDistance;
    FLOAT fAudioComponentOnSpawnDistanceRecheckTimer;
    FLOAT fAudioComponentBurstDistanceRecheckTimer;
    FLinearColor OpacityShadowsTint;
    FColor OpacityShadowsExtAmbient;
    FColor OpacityShadowsSelfAmbient;
    FLOAT OpacityShadowsOpacityMultiplier;
    class ALight* OpacityShadowsLightSource;
    TArrayNoInit<class UParticleSystemReplay*> ReplayClips;
    INT ReplayClipIDNumber;
    INT ReplayFrameIndex;
    FLOAT AccumLODDistanceCheckTime;
    TArrayNoInit<struct FParticleEventSpawnData> SpawnEvents;
    TArrayNoInit<struct FParticleEventDeathData> DeathEvents;
    TArrayNoInit<struct FParticleEventCollideData> CollisionEvents;
    TArrayNoInit<struct FParticleEventKismetData> KismetEvents;
    INT GameThreadDynamicDataIndex;
    FParticleDynamicBufferedData* DynamicDataBuffers[2];
    FParticleDeferredReleases* DeferredReleaseItems;
    class FRenderCommandFence* ReleaseResourcesFence;
    FScriptDelegate __OnSystemFinished__Delegate;
    //## END PROPS ParticleSystemComponent

    void SetTemplate(class UParticleSystem* NewTemplate);
    void ActivateSystem(UBOOL bFlagAsJustAttached=FALSE);
    void DeactivateSystem();
    void KillParticlesForced();
    void SetSkipUpdateDynamicDataDuringTick(UBOOL bInSkipUpdateDynamicDataDuringTick);
    UBOOL GetSkipUpdateDynamicDataDuringTick();
    virtual void SetKillOnDeactivate(INT EmitterIndex,UBOOL bKill);
    virtual void SetKillOnCompleted(INT EmitterIndex,UBOOL bKill);
    virtual void RewindEmitterInstance(INT EmitterIndex);
    virtual void RewindEmitterInstances();
    virtual void SetBeamType(INT EmitterIndex,INT NewMethod);
    virtual void SetBeamTessellationFactor(INT EmitterIndex,FLOAT NewFactor);
    virtual void SetBeamEndPoint(INT EmitterIndex,FVector NewEndPoint);
    virtual void SetBeamDistance(INT EmitterIndex,FLOAT Distance);
    virtual void SetBeamSourcePoint(INT EmitterIndex,FVector NewSourcePoint,INT SourceIndex);
    virtual void SetBeamSourceTangent(INT EmitterIndex,FVector NewTangentPoint,INT SourceIndex);
    virtual void SetBeamSourceStrength(INT EmitterIndex,FLOAT NewSourceStrength,INT SourceIndex);
    virtual void SetBeamTargetPoint(INT EmitterIndex,FVector NewTargetPoint,INT TargetIndex);
    virtual void SetBeamTargetTangent(INT EmitterIndex,FVector NewTangentPoint,INT TargetIndex);
    virtual void SetBeamTargetStrength(INT EmitterIndex,FLOAT NewTargetStrength,INT TargetIndex);
    void SetLODLevel(INT InLODLevel);
    void SetEditorLODLevel(INT InLODLevel);
    INT GetLODLevel();
    INT GetEditorLODLevel();
    void SetFloatParameter(FName ParameterName,FLOAT Param);
    void SetVectorParameter(FName ParameterName,FVector Param);
    void SetColorParameter(FName ParameterName,FColor Param);
    void SetActorParameter(FName ParameterName,class AActor* Param);
    void SetMaterialParameter(FName ParameterName,class UMaterialInterface* Param);
    virtual UBOOL GetFloatParameter(const FName InName,FLOAT& OutFloat);
    virtual UBOOL GetVectorParameter(const FName InName,FVector& OutVector);
    virtual UBOOL GetColorParameter(const FName InName,FColor& OutColor);
    virtual UBOOL GetActorParameter(const FName InName,class AActor*& OutActor);
    virtual UBOOL GetMaterialParameter(const FName InName,class UMaterialInterface*& OutMaterial);
    void ClearParameter(FName ParameterName,BYTE ParameterType=0);
    void SetActive(UBOOL bNowActive);
    void ResetToDefaults();
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(UParticleSystem,NewTemplate);
        P_FINISH;
        SetTemplate(NewTemplate);
    }
    DECLARE_FUNCTION(execActivateSystem)
    {
        P_GET_UBOOL_OPTX(bFlagAsJustAttached,FALSE);
        P_FINISH;
        ActivateSystem(bFlagAsJustAttached);
    }
    DECLARE_FUNCTION(execDeactivateSystem)
    {
        P_FINISH;
        DeactivateSystem();
    }
    DECLARE_FUNCTION(execKillParticlesForced)
    {
        P_FINISH;
        KillParticlesForced();
    }
    DECLARE_FUNCTION(execSetSkipUpdateDynamicDataDuringTick)
    {
        P_GET_UBOOL(bInSkipUpdateDynamicDataDuringTick);
        P_FINISH;
        SetSkipUpdateDynamicDataDuringTick(bInSkipUpdateDynamicDataDuringTick);
    }
    DECLARE_FUNCTION(execGetSkipUpdateDynamicDataDuringTick)
    {
        P_FINISH;
        *(UBOOL*)Result=GetSkipUpdateDynamicDataDuringTick();
    }
    DECLARE_FUNCTION(execSetKillOnDeactivate)
    {
        P_GET_INT(EmitterIndex);
        P_GET_UBOOL(bKill);
        P_FINISH;
        SetKillOnDeactivate(EmitterIndex,bKill);
    }
    DECLARE_FUNCTION(execSetKillOnCompleted)
    {
        P_GET_INT(EmitterIndex);
        P_GET_UBOOL(bKill);
        P_FINISH;
        SetKillOnCompleted(EmitterIndex,bKill);
    }
    DECLARE_FUNCTION(execRewindEmitterInstance)
    {
        P_GET_INT(EmitterIndex);
        P_FINISH;
        RewindEmitterInstance(EmitterIndex);
    }
    DECLARE_FUNCTION(execRewindEmitterInstances)
    {
        P_FINISH;
        RewindEmitterInstances();
    }
    DECLARE_FUNCTION(execSetBeamType)
    {
        P_GET_INT(EmitterIndex);
        P_GET_INT(NewMethod);
        P_FINISH;
        SetBeamType(EmitterIndex,NewMethod);
    }
    DECLARE_FUNCTION(execSetBeamTessellationFactor)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewFactor);
        P_FINISH;
        SetBeamTessellationFactor(EmitterIndex,NewFactor);
    }
    DECLARE_FUNCTION(execSetBeamEndPoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewEndPoint);
        P_FINISH;
        SetBeamEndPoint(EmitterIndex,NewEndPoint);
    }
    DECLARE_FUNCTION(execSetBeamDistance)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(Distance);
        P_FINISH;
        SetBeamDistance(EmitterIndex,Distance);
    }
    DECLARE_FUNCTION(execSetBeamSourcePoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewSourcePoint);
        P_GET_INT(SourceIndex);
        P_FINISH;
        SetBeamSourcePoint(EmitterIndex,NewSourcePoint,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamSourceTangent)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTangentPoint);
        P_GET_INT(SourceIndex);
        P_FINISH;
        SetBeamSourceTangent(EmitterIndex,NewTangentPoint,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamSourceStrength)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewSourceStrength);
        P_GET_INT(SourceIndex);
        P_FINISH;
        SetBeamSourceStrength(EmitterIndex,NewSourceStrength,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetPoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTargetPoint);
        P_GET_INT(TargetIndex);
        P_FINISH;
        SetBeamTargetPoint(EmitterIndex,NewTargetPoint,TargetIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetTangent)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTangentPoint);
        P_GET_INT(TargetIndex);
        P_FINISH;
        SetBeamTargetTangent(EmitterIndex,NewTangentPoint,TargetIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetStrength)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewTargetStrength);
        P_GET_INT(TargetIndex);
        P_FINISH;
        SetBeamTargetStrength(EmitterIndex,NewTargetStrength,TargetIndex);
    }
    DECLARE_FUNCTION(execSetLODLevel)
    {
        P_GET_INT(InLODLevel);
        P_FINISH;
        SetLODLevel(InLODLevel);
    }
    DECLARE_FUNCTION(execSetEditorLODLevel)
    {
        P_GET_INT(InLODLevel);
        P_FINISH;
        SetEditorLODLevel(InLODLevel);
    }
    DECLARE_FUNCTION(execGetLODLevel)
    {
        P_FINISH;
        *(INT*)Result=GetLODLevel();
    }
    DECLARE_FUNCTION(execGetEditorLODLevel)
    {
        P_FINISH;
        *(INT*)Result=GetEditorLODLevel();
    }
    DECLARE_FUNCTION(execSetFloatParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Param);
        P_FINISH;
        SetFloatParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetVectorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FVector,Param);
        P_FINISH;
        SetVectorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetColorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FColor,Param);
        P_FINISH;
        SetColorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetActorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(AActor,Param);
        P_FINISH;
        SetActorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetMaterialParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UMaterialInterface,Param);
        P_FINISH;
        SetMaterialParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execGetFloatParameter)
    {
        P_GET_NAME(InName);
        P_GET_FLOAT_REF(OutFloat);
        P_FINISH;
        *(UBOOL*)Result=GetFloatParameter(InName,OutFloat);
    }
    DECLARE_FUNCTION(execGetVectorParameter)
    {
        P_GET_NAME(InName);
        P_GET_STRUCT_REF(FVector,OutVector);
        P_FINISH;
        *(UBOOL*)Result=GetVectorParameter(InName,OutVector);
    }
    DECLARE_FUNCTION(execGetColorParameter)
    {
        P_GET_NAME(InName);
        P_GET_STRUCT_REF(FColor,OutColor);
        P_FINISH;
        *(UBOOL*)Result=GetColorParameter(InName,OutColor);
    }
    DECLARE_FUNCTION(execGetActorParameter)
    {
        P_GET_NAME(InName);
        P_GET_OBJECT_REF(AActor,OutActor);
        P_FINISH;
        *(UBOOL*)Result=GetActorParameter(InName,OutActor);
    }
    DECLARE_FUNCTION(execGetMaterialParameter)
    {
        P_GET_NAME(InName);
        P_GET_OBJECT_REF(UMaterialInterface,OutMaterial);
        P_FINISH;
        *(UBOOL*)Result=GetMaterialParameter(InName,OutMaterial);
    }
    DECLARE_FUNCTION(execClearParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_BYTE_OPTX(ParameterType,0);
        P_FINISH;
        ClearParameter(ParameterName,ParameterType);
    }
    DECLARE_FUNCTION(execSetActive)
    {
        P_GET_UBOOL(bNowActive);
        P_FINISH;
        SetActive(bNowActive);
    }
    DECLARE_FUNCTION(execResetToDefaults)
    {
        P_FINISH;
        ResetToDefaults();
    }
    void delegateOnSystemFinished(class UParticleSystemComponent* PSystem)
    {
        ParticleSystemComponent_eventOnSystemFinished_Parms Parms(EC_EventParm);
        Parms.PSystem=PSystem;
        ProcessDelegate(ENGINE_OnSystemFinished,&__OnSystemFinished__Delegate,&Parms);
    }
    DECLARE_CLASS(UParticleSystemComponent,UPrimitiveComponent,0,Engine)
	// ActorComponent interface.
	virtual void CheckForErrors();

	// UObject interface
	virtual void PostLoad();
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void Serialize(FArchive& Ar);

	// Collision Handling...
	virtual UBOOL SingleLineCheck(FCheckResult& Hit, AActor* SourceActor, const FVector& End, const FVector& Start, DWORD TraceFlags, const FVector& Extent);

protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	virtual void UpdateLODInformation();

	/**
	 * Static: Supplied with a chunk of replay data, this method will create dynamic emitter data that can
	 * be used to render the particle system
	 *
	 * @param	EmitterInstance		Emitter instance this replay is playing on
	 * @param	EmitterReplayData	Incoming replay data of any time, cannot be NULL
	 * @param	bSelected			TRUE if the particle system is currently selected
	 *
	 * @return	The newly created dynamic data, or NULL on failure
	 */
	static FDynamicEmitterDataBase* CreateDynamicDataFromReplay( FParticleEmitterInstance* EmitterInstance, const FDynamicEmitterReplayDataBase* EmitterReplayData, UBOOL bSelected );

	/**
	 * Creates dynamic particle data for rendering the particle system this frame.  This function
	 * handle creation of dynamic data for regularly simulated particles, but also handles capture
	 * and playback of particle replay data.
	 *
	 * @return	Returns the dynamic data to render this frame
	 */
	FParticleDynamicData* CreateDynamicData();

public:
	virtual void UpdateDynamicData();
	virtual void UpdateDynamicData(FParticleSystemSceneProxy* Proxy);
	virtual void UpdateViewRelevance(FParticleSystemSceneProxy* Proxy);

	// UPrimitiveComponent interface
	virtual void UpdateBounds();
	virtual void Tick(FLOAT DeltaTime);

	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	// UParticleSystemComponent interface
	virtual void InitParticles();
	void ResetParticles(UBOOL bEmptyInstances = FALSE);
	void ResetBurstLists();
	void UpdateInstances();
	UBOOL HasCompleted();

	void InitializeSystem();

	/**
	 * This will return detail info about this specific object. (e.g. AudioComponent will return the name of the cue,
	 * ParticleSystemComponent will return the name of the ParticleSystem)  The idea here is that in many places
	 * you have a component of interest but what you really want is some characteristic that you can use to track
	 * down where it came from.  
	 *
	 */
	virtual FString GetDetailedInfoInternal() const;

	/**
	 *	Cache the view-relevance for each emitter at each LOD level.
	 *
	 *	@param	NewTemplate		The UParticleSystem* to use as the template.
	 *							If NULL, use the currently set template.
	 */
	void CacheViewRelevanceFlags(class UParticleSystem* NewTemplate = NULL);

	/**
	*	DetermineLODLevel - determines the appropriate LOD level to utilize.
	*/
	INT DetermineLODLevel(const FSceneView* View);

	void	AutoPopulateInstanceProperties();

	void	FlushSMComponentsArray();

	/** Event reporting... */
	/** 
	 *	Record a spawning event. 
	 *
	 *	@param	InEventName			The name of the event that fired.
	 *	@param	InEmitterTime		The emitter time when the event fired.
	 *	@param	InLocation			The location of the particle when the event fired.
	 *	@param	InVelocity			The velocity of the particle when the event fired.
	 */
	void ReportEventSpawn(FName& InEventName, FLOAT InEmitterTime, 
		FVector& InLocation, FVector& InVelocity);
	/** 
	 *	Record a death event.
	 *
	 *	@param	InEventName			The name of the event that fired.
	 *	@param	InEmitterTime		The emitter time when the event fired.
	 *	@param	InLocation			The location of the particle when the event fired.
	 *	@param	InVelocity			The velocity of the particle when the event fired.
	 *	@param	InParticleTime		The relative life of the particle when the event fired.
	 */
	void ReportEventDeath(FName& InEventName, FLOAT InEmitterTime, 
		FVector& InLocation, FVector& InVelocity, FLOAT InParticleTime);
	/** 
	 *	Record a collision event.
	 *
	 *	@param	InEventName		The name of the event that fired.
	 *	@param	InEmitterTime	The emitter time when the event fired.
	 *	@param	InLocation		The location of the particle when the event fired.
	 *	@param	InDirection		The direction of the particle when the event fired.
	 *	@param	InVelocity		The velocity of the particle when the event fired.
	 *	@param	InParticleTime	The relative life of the particle when the event fired.
	 *	@param	InNormal		Normal vector of the collision in coordinate system of the returner. Zero=none.
	 *	@param	InTime			Time until hit, if line check.
	 *	@param	InItem			Primitive data item which was hit, INDEX_NONE=none.
	 *	@param	InBoneName		Name of bone we hit (for skeletal meshes).
	 */
	void ReportEventCollision(FName& InEventName, FLOAT InEmitterTime, FVector& InLocation, 
		FVector& InDirection, FVector& InVelocity, FLOAT InParticleTime, FVector& InNormal, 
		FLOAT InTime, INT InItem, FName& InBoneName);
	/** 
	 *	Record a kismet event.
	 *
	 *	@param	InEventName				The name of the event that fired.
	 *	@param	InEmitterTime			The emitter time when the event fired.
	 *	@param	InLocation				The location of the particle when the event fired.
	 *	@param	InVelocity				The velocity of the particle when the event fired.
	 *	@param	bInUsePSysCompLocation	If TRUE, use the particle system component location as spawn location.
	 *	@param	InNormal				Normal vector of the collision in coordinate system of the returner. Zero=none.
	 */
	void ReportEventKismet(FName& InEventName, FLOAT InEmitterTime, FVector& InLocation, 
		FVector& InDirection, FVector& InVelocity, UBOOL bInUsePSysCompLocation, FVector& InNormal);


	/**
	 * Finds the replay clip of the specified ID number
	 *
	 * @return Returns the replay clip or NULL if none
	 */
	UParticleSystemReplay* FindReplayClipForIDNumber( const INT InClipIDNumber );

	/**
	 *	Freeing up dynamic data... 
	 *	Due to RenderResources being held by the GameThread when double-buffering,
	 *	the system must now track the release of these items...
	 */
	void HandleDynamicDataDeletion(FParticleDynamicData* DynamicData, FDynamicEmitterDataBase* EmitterDynamicData);
};

class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
public:
    //## BEGIN PROPS DistributionFloatParticleParameter
    //## END PROPS DistributionFloatParticleParameter

    DECLARE_CLASS(UDistributionFloatParticleParameter,UDistributionFloatParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FLOAT& OutFloat);
};

class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
public:
    //## BEGIN PROPS DistributionVectorParticleParameter
    //## END PROPS DistributionVectorParticleParameter

    DECLARE_CLASS(UDistributionVectorParticleParameter,UDistributionVectorParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FVector& OutVector);
};

class UParticleLODLevel : public UObject
{
public:
    //## BEGIN PROPS ParticleLODLevel
    INT Level;
    INT LevelSetting;
    BITFIELD bEnabled:1;
    BITFIELD ConvertedModules:1;
    class UParticleModuleRequired* RequiredModule;
    TArrayNoInit<class UParticleModule*> Modules;
    class UParticleModule* TypeDataModule;
    class UParticleModuleSpawn* SpawnModule;
    class UParticleModuleEventGenerator* EventGenerator;
    TArrayNoInit<class UParticleModuleSpawnBase*> SpawningModules;
    TArrayNoInit<class UParticleModule*> SpawnModules;
    TArrayNoInit<class UParticleModule*> UpdateModules;
    TArrayNoInit<class UParticleModuleOrbit*> OrbitModules;
    TArrayNoInit<class UParticleModuleEventReceiverBase*> EventReceiverModules;
    INT PeakActiveParticles;
    //## END PROPS ParticleLODLevel

    DECLARE_CLASS(UParticleLODLevel,UObject,0,Engine)
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	PostLoad();
	virtual void	UpdateModuleLists();

	virtual UBOOL	GenerateFromLODLevel(UParticleLODLevel* SourceLODLevel, FLOAT Percentage, UBOOL bGenerateModuleData = TRUE);

	/**
	 *	CalculateMaxActiveParticleCount
	 *	Determine the maximum active particles that could occur with this emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return		The maximum active particle count for the LOD level.
	 */
	virtual INT	CalculateMaxActiveParticleCount();

	/**
	 *	Update to the new SpawnModule method
	 */
	void	ConvertToSpawnModule();
		
	/**
	 *	Return the index of the given module if it is contained in the LOD level
	 */
	INT		GetModuleIndex(UParticleModule* InModule);

	/**
	 *	Return the module at the given index if it is contained in the LOD level
	 */
	UParticleModule* GetModuleAtIndex(INT InIndex);

	/**
	 *	Sets the LOD 'Level' to the given value, properly updating the modules LOD validity settings.
	 */
	virtual void	SetLevelIndex(INT InLevelIndex);

	// For Cascade
	void	AddCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	void	RemoveCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);
	/**
	 *	Return TRUE if the given module is editable for this LOD level.
	 *	
	 *	@param	InModule	The module of interest.
	 *	@return	TRUE		If it is editable for this LOD level.
	 *			FALSE		If it is not.
	 */
	UBOOL	IsModuleEditable(UParticleModule* InModule);

};

struct FParticleBurst
{
    INT Count;
    INT CountLow;
    FLOAT Time;

    /** Constructors */
    FParticleBurst() {}
    FParticleBurst(EEventParm)
    {
        appMemzero(this, sizeof(FParticleBurst));
    }
};

class UParticleEmitter : public UObject
{
public:
    //## BEGIN PROPS ParticleEmitter
    FName EmitterName;
    BITFIELD UseLocalSpace:1;
    BITFIELD KillOnDeactivate:1;
    BITFIELD bKillOnCompleted:1;
    BITFIELD ScaleUV:1;
    BITFIELD DirectUV:1;
    BITFIELD bEnabled:1;
    BITFIELD ConvertedModules:1;
    struct FRawDistributionFloat SpawnRate;
    FLOAT EmitterDuration;
    INT EmitterLoops;
    BYTE ParticleBurstMethod;
    BYTE InterpolationMethod;
    BYTE EmitterRenderMode;
    TArrayNoInit<struct FParticleBurst> BurstList;
    INT SubImages_Horizontal;
    INT SubImages_Vertical;
    FLOAT RandomImageTime;
    INT RandomImageChanges;
    INT SubUVDataOffset;
    FColor EmitterEditorColor;
    TArrayNoInit<class UParticleLODLevel*> LODLevels;
    TArrayNoInit<class UParticleModule*> Modules;
    class UParticleModule* TypeDataModule;
    TArrayNoInit<class UParticleModule*> SpawnModules;
    TArrayNoInit<class UParticleModule*> UpdateModules;
    INT PeakActiveParticles;
    INT InitialAllocationCount;
    //## END PROPS ParticleEmitter

    DECLARE_ABSTRACT_CLASS(UParticleEmitter,UObject,0,Engine)
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual FParticleEmitterInstance* CreateInstance(UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults() {}

	virtual void PostLoad();
	virtual void UpdateModuleLists();

	void SetEmitterName(FName Name);
	FName& GetEmitterName();
	virtual	void						SetLODCount(INT LODCount);

	// For Cascade
	void	AddEmitterCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	void	RemoveEmitterCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);

	void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	// LOD
	INT					CreateLODLevel(INT LODLevel, UBOOL bGenerateModuleData = TRUE);
	UBOOL				IsLODLevelValid(INT LODLevel);

	/** GetCurrentLODLevel
	*	Returns the currently set LODLevel. Intended for game-time usage.
	*	Assumes that the given LODLevel will be in the [0..# LOD levels] range.
	*	
	*	@return NULL if the requested LODLevel is not valid.
	*			The pointer to the requested UParticleLODLevel if valid.
	*/
	inline UParticleLODLevel* GetCurrentLODLevel(FParticleEmitterInstance* Instance)
	{
		// for the game (where we care about perf) we don't branch
		if (GIsGame == TRUE)
		{
			return Instance->CurrentLODLevel;
		}
		else
		{
			EditorUpdateCurrentLOD( Instance );
			return Instance->CurrentLODLevel;
		}

	}

	void EditorUpdateCurrentLOD(FParticleEmitterInstance* Instance);

	UParticleLODLevel*	GetLODLevel(INT LODLevel);
	
	virtual UBOOL		AutogenerateLowestLODLevel(UBOOL bDuplicateHighest = FALSE);
	
	/**
	 *	CalculateMaxActiveParticleCount
	 *	Determine the maximum active particles that could occur with this emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return	TRUE	if the number was determined
	 *			FALSE	if the number could not be determined
	 */
	virtual UBOOL		CalculateMaxActiveParticleCount();

	/**
	 *	Retrieve the parameters associated with this particle system.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams used in the system
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions used in the system
	 */
	void GetParametersUtilized(TArray<FString>& ParticleSysParamList,
							   TArray<FString>& ParticleParameterList);
};

class UParticleSpriteEmitter : public UParticleEmitter
{
public:
    //## BEGIN PROPS ParticleSpriteEmitter
    //## END PROPS ParticleSpriteEmitter

    DECLARE_CLASS(UParticleSpriteEmitter,UParticleEmitter,0,Engine)
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual FParticleEmitterInstance* CreateInstance(UParticleSystemComponent* InComponent);
	virtual void SetToSensibleDefaults();
};

struct FParticleCurvePair
{
    FString CurveName;
    class UObject* CurveObject;

    /** Constructors */
    FParticleCurvePair()
    : CurveObject(NULL)
    {}
    FParticleCurvePair(EEventParm)
    {
        appMemzero(this, sizeof(FParticleCurvePair));
    }
};

class UParticleModule : public UObject
{
public:
    //## BEGIN PROPS ParticleModule
    BITFIELD bSpawnModule:1;
    BITFIELD bUpdateModule:1;
    BITFIELD bCurvesAsColor:1;
    BITFIELD b3DDrawMode:1;
    BITFIELD bSupported3DDrawMode:1;
    BITFIELD bEnabled:1;
    BITFIELD bEditable:1;
    BITFIELD LODDuplicate:1;
    FColor ModuleEditorColor;
    BYTE LODValidity;
    TArrayNoInit<FName> IdenticalIgnoreProperties;
    //## END PROPS ParticleModule

    DECLARE_ABSTRACT_CLASS(UParticleModule,UObject,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	// For Cascade
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Remove all curve-editable Objects within this module from the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to remove the curve from.
	 */
	void	RemoveModuleCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Does the module contain curves?
	 *
	 *	@return	UBOOL		TRUE if it does, FALSE if not.
	 */
	UBOOL	ModuleHasCurves();
	/** 
	 *	Are the modules curves displayed in the curve editor?
	 *
	 *	@param	EdSetup		The CurveEd setup to check.
	 *
	 *	@return	UBOOL		TRUE if they are, FALSE if not.
	 */
	UBOOL	IsDisplayedInCurveEd(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Helper function for updating the curve editor when the module editor color changes.
	 *
	 *	@param	Color		The new color the module is using.
	 *	@param	EdSetup		The CurveEd setup for the module.
	 */
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);

	/** 
	 *	Render the modules 3D visualization helper primitive.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the module.
	 *	@param	View		The scene view that is being rendered.
	 *	@param	PDI			The FPrimitiveDrawInterface to use for rendering.
	 */
	virtual void Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI)	{};

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_General;	}

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);
	
	/**
	 *	Helper function used by the editor to auto-generate LOD values from a source module
	 *	and a percentage value used to scale its values.
	 *
	 *	@param	SourceModule	The ParticleModule to utilize as the template.
	 *	@param	Percentage		The value to use when scaling the source values.
	 */
	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);

	/**
	 *	Conversion functions for distributions.
	 *	Used to setup new distributions to a percentage value of the source.
	 */
	/**
	 *	Store the given percentage of the SourceFloat distribution in the FloatDist
	 *
	 *	@param	FloatDist			The distribution to put the result into.
	 *	@param	SourceFloatDist		The distribution of use as the source.
	 *	@param	Percentage			The percentage of the source value to use [0..100]
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not.
	 */
	virtual UBOOL	ConvertFloatDistribution(UDistributionFloat* FloatDist, UDistributionFloat* SourceFloatDist, FLOAT Percentage);
	/**
	 *	Store the given percentage of the SourceVector distribution in the VectorDist
	 *
	 *	@param	VectorDist			The distribution to put the result into.
	 *	@param	SourceVectorDist	The distribution of use as the source.
	 *	@param	Percentage			The percentage of the source value to use [0..100]
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not.
	 */
	virtual UBOOL	ConvertVectorDistribution(UDistributionVector* VectorDist, UDistributionVector* SourceVectorDist, FLOAT Percentage);
	/**
	 *	Returns whether the module is SizeMultipleLife or not.
	 *
	 *	@return	UBOOL	TRUE if the module is a UParticleModuleSizeMultipleLife
	 *					FALSE if not
	 */
	virtual UBOOL   IsSizeMultiplyLife() { return FALSE; };

	/**
	 *	Comparison routine...
	 *	Intended for editor-use only, this function will return TRUE if the given
	 *	particle module settings are identical to the one the function is called on.
	 *
	 *	@param	InModule	The module to compare against.
	 *
	 *	@return	TRUE		If the modules have all the relevant settings the same.
	 *			FALSE		If they don't.
	 */
	virtual UBOOL	IsIdentical(const UParticleModule* InModule) const;

	/**
	 *	Used by the comparison routine to check for properties that are irrelevant.
	 *
	 *	@param	InPropName	The name of the property being checked.
	 *
	 *	@return	TRUE		If the property is relevant.
	 *			FALSE		If it isn't.
	 */
	virtual UBOOL	PropertyIsRelevantForIsIdentical(const FName& InPropName) const;

	/**
	 *	Generates a new module for LOD levels, setting the values appropriately.
	 *	Note that the module returned could simply be the module it was called on.
	 *
	 *	@param	SourceLODLevel		The source LODLevel
	 *	@param	DestLODLevel		The destination LODLevel
	 *	@param	Percentage			The percentage value that should be used when setting values
	 *
	 *	@return	UParticleModule*	The generated module, or this if percentage == 100.
	 */
	virtual UParticleModule* GenerateLODModule(UParticleLODLevel* SourceLODLevel, UParticleLODLevel* DestLODLevel, FLOAT Percentage, 
		UBOOL bGenerateModuleData, UBOOL bForceModuleConstruction = FALSE);

	/**
	 *	Returns TRUE if the results of LOD generation for the given percentage will result in a 
	 *	duplicate of the module.
	 *
	 *	@param	SourceLODLevel		The source LODLevel
	 *	@param	DestLODLevel		The destination LODLevel
	 *	@param	Percentage			The percentage value that should be used when setting values
	 *
	 *	@return	UBOOL				TRUE if the generated module will be a duplicate.
	 *								FALSE if not.
	 */
	virtual UBOOL WillGeneratedModuleBeIdentical(UParticleLODLevel* SourceLODLevel, UParticleLODLevel* DestLODLevel, FLOAT Percentage)
	{
		// The assumption is that at 100%, ANY module will be identical...
		// (Although this is virtual to allow over-riding that assumption on a case-by-case basis!)

		if (Percentage != 100.0f)
		{
			return LODDuplicate;
		}

		return TRUE;
	}

	/**
	 *	Returns TRUE if the module validiy flags indicate this module is used in the given LOD level.
	 *
	 *	@param	SourceLODIndex		The index of the source LODLevel
	 *
	 *	@return	UBOOL				TRUE if the generated module is used, FALSE if not.
	 */
	virtual UBOOL IsUsedInLODLevel(INT SourceLODIndex) const;

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);

	/**
	 *	Retrieve the distributions that use ParticleParameters in this module.
	 *
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions to add to
	 */
	virtual void GetParticleParametersUtilized(TArray<FString>& ParticleParameterList);
	
	/**
	 *	Refresh the module...
	 */
	virtual void RefreshModule(UInterpCurveEdSetup* EdSetup, UParticleEmitter* InEmitter, INT InLODLevel) {}
};

class UParticleModuleAccelerationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleAccelerationBase
    //## END PROPS ParticleModuleAccelerationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleAccelerationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleAccelerationBase)
};

class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
public:
    //## BEGIN PROPS ParticleModuleAcceleration
    struct FRawDistributionVector Acceleration;
    BITFIELD bApplyOwnerScale:1;
    //## END PROPS ParticleModuleAcceleration

    DECLARE_CLASS(UParticleModuleAcceleration,UParticleModuleAccelerationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
public:
    //## BEGIN PROPS ParticleModuleAccelerationOverLifetime
    struct FRawDistributionVector AccelOverLife;
    //## END PROPS ParticleModuleAccelerationOverLifetime

    DECLARE_CLASS(UParticleModuleAccelerationOverLifetime,UParticleModuleAccelerationBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleAttractorBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleAttractorBase
    //## END PROPS ParticleModuleAttractorBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleAttractorBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleAttractorBase)
};

class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorLine
    FVector EndPoint0;
    FVector EndPoint1;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    //## END PROPS ParticleModuleAttractorLine

    DECLARE_CLASS(UParticleModuleAttractorLine,UParticleModuleAttractorBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorParticle
    FName EmitterName;
    struct FRawDistributionFloat Range;
    BITFIELD bStrengthByDistance:1;
    BITFIELD bAffectBaseVelocity:1;
    BITFIELD bRenewSource:1;
    BITFIELD bInheritSourceVel:1;
    struct FRawDistributionFloat Strength;
    BYTE SelectionMethod;
    INT LastSelIndex;
    //## END PROPS ParticleModuleAttractorParticle

    DECLARE_CLASS(UParticleModuleAttractorParticle,UParticleModuleAttractorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorPoint
    struct FRawDistributionVector Position;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    BITFIELD StrengthByDistance:1;
    BITFIELD bAffectBaseVelocity:1;
    BITFIELD bOverrideVelocity:1;
    //## END PROPS ParticleModuleAttractorPoint

    DECLARE_CLASS(UParticleModuleAttractorPoint,UParticleModuleAttractorBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleBeamBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleBeamBase
    //## END PROPS ParticleModuleBeamBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleBeamBase,UParticleModule,0,Engine)
	virtual EModuleType	GetModuleType() const	{	return EPMT_Beam;	}
};

struct FBeamModifierOptions
{
    BITFIELD bModify:1;
    BITFIELD bScale:1;
    BITFIELD bLock:1;

    /** Constructors */
    FBeamModifierOptions() {}
    FBeamModifierOptions(EEventParm)
    {
        appMemzero(this, sizeof(FBeamModifierOptions));
    }
};

class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamModifier
    BYTE ModifierType;
    struct FBeamModifierOptions PositionOptions;
    struct FRawDistributionVector Position;
    struct FBeamModifierOptions TangentOptions;
    struct FRawDistributionVector Tangent;
    BITFIELD bAbsoluteTangent:1;
    struct FBeamModifierOptions StrengthOptions;
    struct FRawDistributionFloat Strength;
    //## END PROPS ParticleModuleBeamModifier

    DECLARE_CLASS(UParticleModuleBeamModifier,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
	
	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);


			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, FBeam2TypeDataPayload*& BeamDataPayload, 
						FBeamParticleModifierPayloadData*& SourceModifierPayload,
						FBeamParticleModifierPayloadData*& TargetModifierPayload);
			void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT& BeamDataOffset, INT& SourceModifierOffset, 
						INT& TargetModifierOffset);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamNoise
    BITFIELD bLowFreq_Enabled:1;
    BITFIELD bNRScaleEmitterTime:1;
    BITFIELD bSmooth:1;
    BITFIELD bNoiseLock:1;
    BITFIELD bOscillate:1;
    BITFIELD bUseNoiseTangents:1;
    BITFIELD bTargetNoise:1;
    BITFIELD bApplyNoiseScale:1;
    INT Frequency;
    INT Frequency_LowRange;
    struct FRawDistributionVector NoiseRange;
    struct FRawDistributionFloat NoiseRangeScale;
    struct FRawDistributionVector NoiseSpeed;
    FLOAT NoiseLockRadius;
    FLOAT NoiseLockTime;
    FLOAT NoiseTension;
    struct FRawDistributionFloat NoiseTangentStrength;
    INT NoiseTessellation;
    FLOAT FrequencyDistance;
    struct FRawDistributionFloat NoiseScale;
    //## END PROPS ParticleModuleBeamNoise

    DECLARE_CLASS(UParticleModuleBeamNoise,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
			void	GetNoiseRange(FVector& NoiseMin, FVector& NoiseMax);
};

class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamSource
    BYTE SourceMethod;
    BYTE SourceTangentMethod;
    FName SourceName;
    BITFIELD bSourceAbsolute:1;
    BITFIELD bLockSource:1;
    BITFIELD bLockSourceTangent:1;
    BITFIELD bLockSourceStength:1;
    struct FRawDistributionVector Source;
    struct FRawDistributionVector SourceTangent;
    struct FRawDistributionFloat SourceStrength;
    //## END PROPS ParticleModuleBeamSource

    DECLARE_CLASS(UParticleModuleBeamSource,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, 
						FBeamParticleSourceTargetPayloadData*& ParticleSource,
						FBeamParticleSourceBranchPayloadData*& BranchSource);
			void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT& ParticleSourceOffset, INT& BranchSourceOffset);
						
			UBOOL	ResolveSourceData(FParticleBeam2EmitterInstance* BeamInst, 
						FBeam2TypeDataPayload* BeamData, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning,
						FBeamParticleModifierPayloadData* ModifierData);
	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamTarget
    BYTE TargetMethod;
    BYTE TargetTangentMethod;
    FName TargetName;
    struct FRawDistributionVector Target;
    BITFIELD bTargetAbsolute:1;
    BITFIELD bLockTarget:1;
    BITFIELD bLockTargetTangent:1;
    BITFIELD bLockTargetStength:1;
    struct FRawDistributionVector TargetTangent;
    struct FRawDistributionFloat TargetStrength;
    FLOAT LockRadius;
    //## END PROPS ParticleModuleBeamTarget

    DECLARE_CLASS(UParticleModuleBeamTarget,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, 
						FBeamParticleSourceTargetPayloadData*& ParticleSource);
						
			UBOOL	ResolveTargetData(FParticleBeam2EmitterInstance* BeamInst, 
						FBeam2TypeDataPayload* BeamData, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning,
						FBeamParticleModifierPayloadData* ModifierData);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleCollisionBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleCollisionBase
    //## END PROPS ParticleModuleCollisionBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleCollisionBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleCollisionBase)
};

class UParticleModuleCollision : public UParticleModuleCollisionBase
{
public:
    //## BEGIN PROPS ParticleModuleCollision
    struct FRawDistributionVector DampingFactor;
    struct FRawDistributionVector DampingFactorRotation;
    struct FRawDistributionFloat MaxCollisions;
    BYTE CollisionCompletionOption;
    BITFIELD bApplyPhysics:1 GCC_BITFIELD_MAGIC;
    BITFIELD bPawnsDoNotDecrementCount:1;
    BITFIELD bOnlyVerticalNormalsDecrementCount:1;
    BITFIELD bDropDetail:1;
    struct FRawDistributionFloat ParticleMass;
    FLOAT DirScalar;
    FLOAT VerticalFudgeFactor;
    struct FRawDistributionFloat DelayAmount;
    //## END PROPS ParticleModuleCollision

    DECLARE_CLASS(UParticleModuleCollision,UParticleModuleCollisionBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);
};

class UParticleModuleColorBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleColorBase
    //## END PROPS ParticleModuleColorBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleColorBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleColorBase)
};

class UParticleModuleColor : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColor
    struct FRawDistributionVector StartColor;
    struct FRawDistributionFloat StartAlpha;
    BITFIELD bClampAlpha:1;
    //## END PROPS ParticleModuleColor

    DECLARE_CLASS(UParticleModuleColor,UParticleModuleColorBase,0,Engine)
	virtual void	PostLoad();
	virtual	void	PostEditChange(UProperty* PropertyThatChanged);
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColorByParameter : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorByParameter
    FName ColorParam;
    FColor DefaultColor;
    //## END PROPS ParticleModuleColorByParameter

    DECLARE_CLASS(UParticleModuleColorByParameter,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorOverLife
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    BITFIELD bClampAlpha:1;
    //## END PROPS ParticleModuleColorOverLife

    DECLARE_CLASS(UParticleModuleColorOverLife,UParticleModuleColorBase,0,Engine)
	virtual void	PostLoad();
	virtual	void	PostEditChange(UProperty* PropertyThatChanged);
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorScaleOverLife
    struct FRawDistributionVector ColorScaleOverLife;
    struct FRawDistributionFloat AlphaScaleOverLife;
    BITFIELD bEmitterTime:1;
    //## END PROPS ParticleModuleColorScaleOverLife

    DECLARE_CLASS(UParticleModuleColorScaleOverLife,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleEventBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleEventBase
    //## END PROPS ParticleModuleEventBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleEventBase,UParticleModule,0,Engine)
	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_Event;	}
};

struct FParticleEvent_GenerateInfo
{
    BYTE Type;
    INT Frequency;
    INT LowFreq;
    INT ParticleFrequency;
    BITFIELD FirstTimeOnly:1;
    BITFIELD LastTimeOnly:1;
    BITFIELD UseReflectedImpactVector:1;
    FName CustomName;

    /** Constructors */
    FParticleEvent_GenerateInfo() {}
    FParticleEvent_GenerateInfo(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEvent_GenerateInfo));
    }
};

class UParticleModuleEventGenerator : public UParticleModuleEventBase
{
public:
    //## BEGIN PROPS ParticleModuleEventGenerator
    TArrayNoInit<struct FParticleEvent_GenerateInfo> Events;
    //## END PROPS ParticleModuleEventGenerator

    DECLARE_CLASS(UParticleModuleEventGenerator,UParticleModuleEventBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	// Cascade
	/** Set the module to sensible default values - called on creation. */
	virtual void	SetToSensibleDefaults();
	/**
	 *	Called when the properties change in the property window.
	 *
	 *	@param	PropertyThatChanged		The property that was edited...
	 */
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	/**
	 *	Called when a particle is spawned and an event payload is present.
	 *
	 *	@param	Owner			Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload	Pointer to the event instance payload data.
	 *	@param	NewParticle		Pointer to the particle that was spawned.
	 *
	 *	@return	UBOOL			TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleSpawned(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, FBaseParticle* NewParticle);

	/**
	 *	Called when a particle is killed and an event payload is present.
	 *
	 *	@param	Owner			Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload	Pointer to the event instance payload data.
	 *	@param	DeadParticle	Pointer to the particle that is being killed.
	 *
	 *	@return	UBOOL			TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleKilled(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, FBaseParticle* DeadParticle);

	/**
	 *	Called when a particle collides and an event payload is present.
	 *
	 *	@param	Owner				Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload		Pointer to the event instance payload data.
	 *	@param	CollidePayload		Pointer to the collision payload data.
	 *	@param	Hit					The CheckResult for the collision.
	 *	@param	CollideParticle		Pointer to the particle that has collided.
	 *	@param	CollideDirection	The direction the particle was traveling when the collision occurred.
	 *
	 *	@return	UBOOL				TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleCollision(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, 
		FParticleCollisionPayload* CollidePayload, FCheckResult* Hit, FBaseParticle* CollideParticle, FVector& CollideDirection);
};

class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
public:
    //## BEGIN PROPS ParticleModuleEventReceiverBase
    //## END PROPS ParticleModuleEventReceiverBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleEventReceiverBase,UParticleModuleEventBase,0,Engine)
	/**
	 *	Is the module interested in events of the given type?
	 *
	 *	@param	InEventType		The event type to check
	 *
	 *	@return	UBOOL			TRUE if interested.
	 */
	virtual UBOOL WillProcessEvent(EParticleEventType InEventType)
	{
		return FALSE;
	}

	/**
	 *	Process the event...
	 *
	 *	@param	Owner		The FParticleEmitterInstance this module is contained in.
	 *	@param	InEvent		The FParticleEventData that occurred.
	 *	@param	DeltaTime	The time slice of this frame.
	 *
	 *	@return	UBOOL		TRUE if the event was processed; FALSE if not.
	 */
	virtual UBOOL ProcessEvent(FParticleEmitterInstance* Owner, FParticleEventData& InEvent, FLOAT DeltaTime)
	{
		return FALSE;
	}
};

class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase
{
public:
    //## BEGIN PROPS ParticleModuleEventReceiverSpawn
    BYTE EventGeneratorType;
    FName EventName;
    struct FRawDistributionFloat SpawnCount;
    BITFIELD bUseParticleTime:1;
    BITFIELD bUsePSysLocation:1;
    BITFIELD bInheritVelocity:1;
    struct FRawDistributionVector InheritVelocityScale;
    //## END PROPS ParticleModuleEventReceiverSpawn

    DECLARE_CLASS(UParticleModuleEventReceiverSpawn,UParticleModuleEventReceiverBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	// Cascade
	/** Set the module to sensible default values - called on creation. */
	virtual void	SetToSensibleDefaults();
	/**
	 *	Called when the properties change in the property window.
	 *
	 *	@param	PropertyThatChanged		The property that was edited...
	 */
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	// Event Receiver functionality
	/**
	 *	Is the module interested in events of the given type?
	 *
	 *	@param	InEventType		The event type to check
	 *
	 *	@return	UBOOL			TRUE if interested.
	 */
	virtual UBOOL WillProcessEvent(EParticleEventType InEventType);

	/**
	 *	Process the event...
	 *
	 *	@param	Owner		The FParticleEmitterInstance this module is contained in.
	 *	@param	InEvent		The FParticleEventData that occurred.
	 *	@param	DeltaTime	The time slice of this frame.
	 *
	 *	@return	UBOOL		TRUE if the event was processed; FALSE if not.
	 */
	virtual UBOOL ProcessEvent(FParticleEmitterInstance* Owner, FParticleEventData& InEvent, FLOAT DeltaTime);
};

class UParticleModuleKillBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleKillBase
    //## END PROPS ParticleModuleKillBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleKillBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleKillBase)
};

class UParticleModuleKillBox : public UParticleModuleKillBase
{
public:
    //## BEGIN PROPS ParticleModuleKillBox
    struct FRawDistributionVector LowerLeftCorner;
    struct FRawDistributionVector UpperRightCorner;
    BITFIELD bAbsolute:1;
    BITFIELD bKillInside:1;
    //## END PROPS ParticleModuleKillBox

    DECLARE_CLASS(UParticleModuleKillBox,UParticleModuleKillBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleKillHeight : public UParticleModuleKillBase
{
public:
    //## BEGIN PROPS ParticleModuleKillHeight
    struct FRawDistributionFloat Height;
    BITFIELD bAbsolute:1;
    BITFIELD bFloor:1;
    //## END PROPS ParticleModuleKillHeight

    DECLARE_CLASS(UParticleModuleKillHeight,UParticleModuleKillBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLifetimeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleLifetimeBase
    //## END PROPS ParticleModuleLifetimeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleLifetimeBase,UParticleModule,0,Engine)
	/** Return the maximum lifetime this module would return. */
	virtual FLOAT	GetMaxLifetime()
	{
		return 0.0f;
	}
};

class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
public:
    //## BEGIN PROPS ParticleModuleLifetime
    struct FRawDistributionFloat Lifetime;
    //## END PROPS ParticleModuleLifetime

    DECLARE_CLASS(UParticleModuleLifetime,UParticleModuleLifetimeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	virtual FLOAT	GetMaxLifetime();
};

class UParticleModuleLocationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleLocationBase
    //## END PROPS ParticleModuleLocationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleLocationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleLocationBase)
};

class UParticleModuleLocation : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocation
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleLocation

    DECLARE_CLASS(UParticleModuleLocation,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationDirect
    struct FRawDistributionVector Location;
    struct FRawDistributionVector LocationOffset;
    struct FRawDistributionVector ScaleFactor;
    struct FRawDistributionVector Direction;
    //## END PROPS ParticleModuleLocationDirect

    DECLARE_CLASS(UParticleModuleLocationDirect,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
};

class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationEmitter
    FName EmitterName;
    BYTE SelectionMethod;
    BITFIELD InheritSourceVelocity:1 GCC_BITFIELD_MAGIC;
    BITFIELD bInheritSourceRotation:1;
    FLOAT InheritSourceVelocityScale;
    FLOAT InheritSourceRotationScale;
    //## END PROPS ParticleModuleLocationEmitter

    DECLARE_CLASS(UParticleModuleLocationEmitter,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationEmitterDirect
    FName EmitterName;
    //## END PROPS ParticleModuleLocationEmitterDirect

    DECLARE_CLASS(UParticleModuleLocationEmitterDirect,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveBase
    BITFIELD Positive_X:1;
    BITFIELD Positive_Y:1;
    BITFIELD Positive_Z:1;
    BITFIELD Negative_X:1;
    BITFIELD Negative_Y:1;
    BITFIELD Negative_Z:1;
    BITFIELD SurfaceOnly:1;
    BITFIELD Velocity:1;
    struct FRawDistributionFloat VelocityScale;
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleLocationPrimitiveBase

    DECLARE_CLASS(UParticleModuleLocationPrimitiveBase,UParticleModuleLocationBase,0,Engine)
	virtual void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);
};

class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveCylinder
    BITFIELD RadialVelocity:1;
    struct FRawDistributionFloat StartRadius;
    struct FRawDistributionFloat StartHeight;
    BYTE HeightAxis;
    //## END PROPS ParticleModuleLocationPrimitiveCylinder

    DECLARE_CLASS(UParticleModuleLocationPrimitiveCylinder,UParticleModuleLocationPrimitiveBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveSphere
    struct FRawDistributionFloat StartRadius;
    //## END PROPS ParticleModuleLocationPrimitiveSphere

    DECLARE_CLASS(UParticleModuleLocationPrimitiveSphere,UParticleModuleLocationPrimitiveBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleMaterialBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleMaterialBase
    //## END PROPS ParticleModuleMaterialBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleMaterialBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleMaterialBase)
};

class UParticleModuleMaterialByParameter : public UParticleModuleMaterialBase
{
public:
    //## BEGIN PROPS ParticleModuleMaterialByParameter
    TArrayNoInit<FName> MaterialParameters;
    TArrayNoInit<class UMaterialInterface*> DefaultMaterials;
    //## END PROPS ParticleModuleMaterialByParameter

    DECLARE_CLASS(UParticleModuleMaterialByParameter,UParticleModuleMaterialBase,0,Engine)
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshMaterial
    TArrayNoInit<class UMaterialInterface*> MeshMaterials;
    //## END PROPS ParticleModuleMeshMaterial

    DECLARE_CLASS(UParticleModuleMeshMaterial,UParticleModuleMaterialBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleOrbitBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleOrbitBase
    BITFIELD bUseEmitterTime:1;
    //## END PROPS ParticleModuleOrbitBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleOrbitBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleOrbitBase)
};

struct FOrbitOptions
{
    BITFIELD bProcessDuringSpawn:1;
    BITFIELD bProcessDuringUpdate:1;
    BITFIELD bUseEmitterTime:1;

    /** Constructors */
    FOrbitOptions() {}
    FOrbitOptions(EEventParm)
    {
        appMemzero(this, sizeof(FOrbitOptions));
    }
};

class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
public:
    //## BEGIN PROPS ParticleModuleOrbit
    BYTE ChainMode GCC_BITFIELD_MAGIC;
    struct FRawDistributionVector OffsetAmount;
    struct FOrbitOptions OffsetOptions;
    struct FRawDistributionVector RotationAmount;
    struct FOrbitOptions RotationOptions;
    struct FRawDistributionVector RotationRateAmount;
    struct FOrbitOptions RotationRateOptions;
    //## END PROPS ParticleModuleOrbit

    DECLARE_CLASS(UParticleModuleOrbit,UParticleModuleOrbitBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleOrientationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleOrientationBase
    //## END PROPS ParticleModuleOrientationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleOrientationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleOrientationBase)
};

class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
public:
    //## BEGIN PROPS ParticleModuleOrientationAxisLock
    BYTE LockAxisFlags;
    //## END PROPS ParticleModuleOrientationAxisLock

    DECLARE_CLASS(UParticleModuleOrientationAxisLock,UParticleModuleOrientationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SetLockAxis(EParticleAxisLock eLockFlags);
};

class UParticleModuleParameterBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleParameterBase
    //## END PROPS ParticleModuleParameterBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleParameterBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleParameterBase)
};

struct FEmitterDynamicParameter
{
    FName ParamName;
    BITFIELD bUseEmitterTime:1;
    struct FRawDistributionFloat ParamValue;

    /** Constructors */
    FEmitterDynamicParameter() {}
    FEmitterDynamicParameter(EEventParm)
    {
        appMemzero(this, sizeof(FEmitterDynamicParameter));
    }
};

class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
public:
    //## BEGIN PROPS ParticleModuleParameterDynamic
    TArrayNoInit<struct FEmitterDynamicParameter> DynamicParams;
    //## END PROPS ParticleModuleParameterDynamic

    DECLARE_CLASS(UParticleModuleParameterDynamic,UParticleModuleParameterBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	// For Cascade
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	/** 
	 *	PostEditChange...
	 */
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);

	/**
	 *	Returns TRUE if the results of LOD generation for the given percentage will result in a 
	 *	duplicate of the module.
	 *
	 *	@param	SourceLODLevel		The source LODLevel
	 *	@param	DestLODLevel		The destination LODLevel
	 *	@param	Percentage			The percentage value that should be used when setting values
	 *
	 *	@return	UBOOL				TRUE if the generated module will be a duplicate.
	 *								FALSE if not.
	 */
	virtual UBOOL WillGeneratedModuleBeIdentical(UParticleLODLevel* SourceLODLevel, UParticleLODLevel* DestLODLevel, FLOAT Percentage)
	{
		// The assumption is that at 100%, ANY module will be identical...
		// (Although this is virtual to allow over-riding that assumption on a case-by-case basis!)
		return TRUE;
	}

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);

	/**
	 *	Retrieve the distributions that use ParticleParameters in this module.
	 *
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions to add to
	 */
	virtual void GetParticleParametersUtilized(TArray<FString>& ParticleParameterList);
	
	/**
	 *	Update the parameter names with the given material...
	 *
	 *	@param	InMaterialInterface	Pointer to the material interface
	 *
	 */
	virtual void UpdateParameterNames(UMaterialInterface* InMaterialInterface);

	/**
	 *	Refresh the module...
	 */
	virtual void RefreshModule(UInterpCurveEdSetup* EdSetup, UParticleEmitter* InEmitter, INT InLODLevel);
};

class UParticleModuleRequired : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRequired
    class UMaterialInterface* Material;
    BYTE ScreenAlignment;
    BYTE ParticleBurstMethod;
    BYTE InterpolationMethod;
    BYTE EmitterRenderMode;
    BITFIELD bUseLocalSpace:1 GCC_BITFIELD_MAGIC;
    BITFIELD bKillOnDeactivate:1;
    BITFIELD bKillOnCompleted:1;
    BITFIELD bRequiresSorting:1;
    BITFIELD bEmitterDurationUseRange:1;
    BITFIELD bDurationRecalcEachLoop:1;
    BITFIELD bDelayFirstLoopOnly:1;
    BITFIELD bScaleUV:1;
    BITFIELD bDirectUV:1;
    BITFIELD bUseMaxDrawCount:1;
    FLOAT EmitterDuration;
    FLOAT EmitterDurationLow;
    INT EmitterLoops;
    struct FRawDistributionFloat SpawnRate;
    TArrayNoInit<struct FParticleBurst> BurstList;
    FLOAT EmitterDelay;
    INT SubImages_Horizontal;
    INT SubImages_Vertical;
    FLOAT RandomImageTime;
    INT RandomImageChanges;
    INT MaxDrawCount;
    FColor EmitterEditorColor;
    //## END PROPS ParticleModuleRequired

    DECLARE_CLASS(UParticleModuleRequired,UParticleModule,0,Engine)
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
	virtual void	PostLoad();

	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup)
	{
		// Overide the base implementation to prevent old SpawnRate from being added...
	}

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_Required;	}

	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);
};

class UParticleModuleRotationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRotationBase
    //## END PROPS ParticleModuleRotationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleRotationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleRotationBase)
};

class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotation
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    //## END PROPS ParticleModuleMeshRotation

    DECLARE_CLASS(UParticleModuleMeshRotation,UParticleModuleRotationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
};

class UParticleModuleRotation : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleRotation
    struct FRawDistributionFloat StartRotation;
    //## END PROPS ParticleModuleRotation

    DECLARE_CLASS(UParticleModuleRotation,UParticleModuleRotationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
};

class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationOverLifetime
    struct FRawDistributionFloat RotationOverLife;
    BITFIELD Scale:1;
    //## END PROPS ParticleModuleRotationOverLifetime

    DECLARE_CLASS(UParticleModuleRotationOverLifetime,UParticleModuleRotationBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleRotationRateBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRotationRateBase
    //## END PROPS ParticleModuleRotationRateBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleRotationRateBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleRotationRateBase)
};

class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRate
    struct FRawDistributionVector StartRotationRate;
    //## END PROPS ParticleModuleMeshRotationRate

    DECLARE_CLASS(UParticleModuleMeshRotationRate,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRateMultiplyLife
    struct FRawDistributionVector LifeMultiplier;
    //## END PROPS ParticleModuleMeshRotationRateMultiplyLife

    DECLARE_CLASS(UParticleModuleMeshRotationRateMultiplyLife,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationRate
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleRotationRate

    DECLARE_CLASS(UParticleModuleRotationRate,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationRateMultiplyLife
    struct FRawDistributionFloat LifeMultiplier;
    //## END PROPS ParticleModuleRotationRateMultiplyLife

    DECLARE_CLASS(UParticleModuleRotationRateMultiplyLife,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSizeBase
    //## END PROPS ParticleModuleSizeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSizeBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleSizeBase)
};

class UParticleModuleSize : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSize
    struct FRawDistributionVector StartSize;
    //## END PROPS ParticleModuleSize

    DECLARE_CLASS(UParticleModuleSize,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
};

class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeMultiplyLife
    struct FRawDistributionVector LifeMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    //## END PROPS ParticleModuleSizeMultiplyLife

    DECLARE_CLASS(UParticleModuleSizeMultiplyLife,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	/**
	 *	Returns whether the module is SizeMultipleLife or not.
	 *
	 *	@return	UBOOL	TRUE if the module is a UParticleModuleSizeMultipleLife
	 *					FALSE if not
	 */
	virtual UBOOL   IsSizeMultiplyLife() { return TRUE; };
};

class UParticleModuleSizeMultiplyVelocity : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeMultiplyVelocity
    struct FRawDistributionVector VelocityMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    //## END PROPS ParticleModuleSizeMultiplyVelocity

    DECLARE_CLASS(UParticleModuleSizeMultiplyVelocity,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeScale
    struct FRawDistributionVector SizeScale;
    BITFIELD EnableX:1;
    BITFIELD EnableY:1;
    BITFIELD EnableZ:1;
    //## END PROPS ParticleModuleSizeScale

    DECLARE_CLASS(UParticleModuleSizeScale,UParticleModuleSizeBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSpawnBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSpawnBase
    BITFIELD bProcessSpawnRate:1;
    BITFIELD bProcessBurstList:1;
    //## END PROPS ParticleModuleSpawnBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSpawnBase,UParticleModule,0,Engine)
	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate)
	{
		return bProcessSpawnRate;
	}
	
	/**
	 *	Retrieve the burst count this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the default BurstList, it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to burst. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the default BurstList should be ignored.
	 *						TRUE if the default BurstList should still be processed.
	 */
	virtual UBOOL GetBurstCount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number)
	{
		Number = 0;
		return bProcessBurstList;
	}

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_Spawn;	}
};

class UParticleModuleSpawn : public UParticleModuleSpawnBase
{
public:
    //## BEGIN PROPS ParticleModuleSpawn
    struct FRawDistributionFloat Rate;
    struct FRawDistributionFloat RateScale;
    BYTE ParticleBurstMethod;
    TArrayNoInit<struct FParticleBurst> BurstList;
    //## END PROPS ParticleModuleSpawn

    DECLARE_CLASS(UParticleModuleSpawn,UParticleModuleSpawnBase,0,Engine)
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate);

	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);
};

class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
public:
    //## BEGIN PROPS ParticleModuleSpawnPerUnit
    FLOAT UnitScalar;
    struct FRawDistributionFloat SpawnPerUnit;
    BITFIELD bIgnoreSpawnRateWhenMoving:1;
    FLOAT MovementTolerance;
    //## END PROPS ParticleModuleSpawnPerUnit

    DECLARE_CLASS(UParticleModuleSpawnPerUnit,UParticleModuleSpawnBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate);
};

class UParticleModuleSubUVBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSubUVBase
    //## END PROPS ParticleModuleSubUVBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSubUVBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleSubUVBase)
};

class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUV
    struct FRawDistributionFloat SubImageIndex;
    //## END PROPS ParticleModuleSubUV

    DECLARE_CLASS(UParticleModuleSubUV,UParticleModuleSubUVBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	
			UBOOL	DetermineSpriteImageIndex(FParticleEmitterInstance* Owner, FBaseParticle* Particle, 
						EParticleSubUVInterpMethod eMethod, FFullSubUVPayload& SubUVPayload, INT& ImageIndex, FLOAT& Interp, FLOAT DeltaTime);
			UBOOL	DetermineMeshImageIndex(FParticleEmitterInstance* Owner, FBaseParticle* Particle, 
						EParticleSubUVInterpMethod eMethod, FFullSubUVPayload& SubUVPayload, INT& ImageIndex, FLOAT& Interp, FLOAT DeltaTime);
		

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSubUVDirect : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUVDirect
    struct FRawDistributionVector SubUVPosition;
    struct FRawDistributionVector SubUVSize;
    //## END PROPS ParticleModuleSubUVDirect

    DECLARE_CLASS(UParticleModuleSubUVDirect,UParticleModuleSubUVBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleSubUVSelect : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUVSelect
    struct FRawDistributionVector SubImageSelect;
    //## END PROPS ParticleModuleSubUVSelect

    DECLARE_CLASS(UParticleModuleSubUVSelect,UParticleModuleSubUVBase,0,Engine)
	virtual void Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleTrailBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleTrailBase
    //## END PROPS ParticleModuleTrailBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleTrailBase,UParticleModule,0,Engine)
	virtual EModuleType	GetModuleType() const	{	return EPMT_Trail;	}
};

class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailSource
    BYTE SourceMethod;
    BYTE SelectionMethod;
    FName SourceName;
    struct FRawDistributionFloat SourceStrength;
    BITFIELD bLockSourceStength:1;
    BITFIELD bInheritRotation:1;
    INT SourceOffsetCount;
    TArrayNoInit<FVector> SourceOffsetDefaults;
    //## END PROPS ParticleModuleTrailSource

    DECLARE_CLASS(UParticleModuleTrailSource,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, INT& CurrentOffset, 
						FTrailParticleSourcePayloadData*& ParticleSource);
			void	GetDataPointerOffsets(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, INT& CurrentOffset, 
						INT& ParticleSourceOffset);
						
			UBOOL	ResolveSourceData(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, FTrail2TypeDataPayload* TrailData, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning);

			UBOOL	ResolveSourcePoint(FParticleTrail2EmitterInstance* TrailInst, 
				FBaseParticle& Particle, FTrail2TypeDataPayload& TrailData, 
				FVector& Position, FVector& Tangent);

			FVector	ResolveSourceOffset(FParticleTrail2EmitterInstance* TrailInst, 
				FBaseParticle& Particle, FTrail2TypeDataPayload& TrailData);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleTrailSpawn : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailSpawn
    class UDistributionFloatParticleParameter* SpawnDistanceMap;
    FLOAT MinSpawnVelocity;
    //## END PROPS ParticleModuleTrailSpawn

    DECLARE_CLASS(UParticleModuleTrailSpawn,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
	virtual void	PostLoad();

	// Trail
//	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
//			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
//			FLOAT*& NoiseRate, FVector*& TargetNoisePoints, FVector*& CurrentNoisePoints, 
//			FLOAT*& TaperValues);

			UINT	GetSpawnCount(FParticleTrail2EmitterInstance* TrailInst, FLOAT DeltaTime);
};

class UParticleModuleTrailTaper : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailTaper
    BYTE TaperMethod;
    struct FRawDistributionFloat TaperFactor;
    //## END PROPS ParticleModuleTrailTaper

    DECLARE_CLASS(UParticleModuleTrailTaper,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	// Trail
//	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
//			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
//			FLOAT*& NoiseRate, FVector*& TargetNoisePoints, FVector*& CurrentNoisePoints, 
//			FLOAT*& TaperValues);
};

class UParticleModuleTypeDataBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBase
    //## END PROPS ParticleModuleTypeDataBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleTypeDataBase,UParticleModule,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
	virtual void	SetToSensibleDefaults();
	virtual void	PreSpawn(FParticleEmitterInstance* Owner, FBaseParticle* Particle)			{};
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime)		{};
	virtual void	PostUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime)	{};

	virtual EModuleType	GetModuleType() const							{	return EPMT_TypeData;	}
	virtual UBOOL		SupportsSpecificScreenAlignmentFlags() const	{	return FALSE;			}
};

class UParticleModuleTypeDataBeam : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBeam
    BYTE BeamMethod;
    BYTE EndPointMethod;
    struct FRawDistributionFloat Distance;
    struct FRawDistributionVector EndPoint;
    INT TessellationFactor;
    struct FRawDistributionFloat EmitterStrength;
    struct FRawDistributionFloat TargetStrength;
    struct FRawDistributionVector EndPointDirection;
    INT TextureTile;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    //## END PROPS ParticleModuleTypeDataBeam

    DECLARE_CLASS(UParticleModuleTypeDataBeam,UParticleModuleTypeDataBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	FVector			DetermineEndPointPosition(FParticleEmitterInstance* Owner, FLOAT DeltaTime);
	FVector			DetermineParticlePosition(FParticleEmitterInstance* Owner, FBaseParticle* pkParticle, FLOAT DeltaTime);

	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults();

	virtual void	PostEditChange(UProperty* PropertyThatChanged);
};

class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBeam2
    BYTE BeamMethod;
    BYTE TaperMethod;
    INT TextureTile;
    FLOAT TextureTileDistance;
    INT Sheets;
    INT MaxBeamCount;
    FLOAT Speed;
    INT InterpolationPoints;
    BITFIELD bAlwaysOn:1;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    INT UpVectorStepSize;
    FName BranchParentName;
    struct FRawDistributionFloat Distance;
    struct FRawDistributionFloat TaperFactor;
    struct FRawDistributionFloat TaperScale;
    TArrayNoInit<FBonePair> BonePairs;
    //## END PROPS ParticleModuleTypeDataBeam2

    DECLARE_CLASS(UParticleModuleTypeDataBeam2,UParticleModuleTypeDataBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	// For Cascade
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);

	// Beam
	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
			FLOAT*& NoiseRate, FLOAT*& NoiseDeltaTime, FVector*& TargetNoisePoints, 
			FVector*& NextNoisePoints, FLOAT*& TaperValues, FLOAT*& NoiseDistanceScale,
			FBeamParticleModifierPayloadData*& SourceModifier,
			FBeamParticleModifierPayloadData*& TargetModifier);
	virtual void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, INT& BeamDataOffset, INT& InterpolatedPointsOffset, INT& NoiseRateOffset, 
			INT& NoiseDeltaTimeOffset, INT& TargetNoisePointsOffset, INT& NextNoisePointsOffset, 
			INT& TaperCount, INT& TaperValuesOffset, INT& NoiseDistanceScaleOffset);

			void	GetNoiseRange(FVector& NoiseMin, FVector& NoiseMax);
};

class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataMesh
    class UStaticMesh* Mesh;
    BITFIELD CastShadows:1;
    BITFIELD DoCollisions:1;
    BITFIELD bOverrideMaterial:1;
    BYTE MeshAlignment GCC_BITFIELD_MAGIC;
    //## END PROPS ParticleModuleTypeDataMesh

    DECLARE_CLASS(UParticleModuleTypeDataMesh,UParticleModuleTypeDataBase,0,Engine)
	virtual void						PostEditChange(UProperty* PropertyThatChanged);
	virtual FParticleEmitterInstance*	CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
	virtual void						SetToSensibleDefaults();

	virtual UBOOL	SupportsSpecificScreenAlignmentFlags() const	{	return TRUE;	}
};

struct FPhysXEmitterVerticalLodProperties
{
    FLOAT WeightForFifo;
    FLOAT WeightForSpawnLod;
    FLOAT SpawnLodRateVsLifeBias;
    FLOAT RelativeFadeoutTime;

    /** Constructors */
    FPhysXEmitterVerticalLodProperties() {}
    FPhysXEmitterVerticalLodProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXEmitterVerticalLodProperties));
    }
};

class UParticleModuleTypeDataPhysX : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataPhysX
    class UPhysXParticleSystem* PhysXParSys;
    struct FPhysXEmitterVerticalLodProperties VerticalLod;
    //## END PROPS ParticleModuleTypeDataPhysX

    DECLARE_CLASS(UParticleModuleTypeDataPhysX,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);

	virtual void SetToSensibleDefaults();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void FinishDestroy();
};

class UParticleModuleTypeDataMeshPhysX : public UParticleModuleTypeDataMesh
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataMeshPhysX
    class UPhysXParticleSystem* PhysXParSys;
    BYTE PhysXRotationMethod;
    FLOAT FluidRotationCoefficient;
    class FPhysXMeshInstance* RenderInstance;
    struct FPhysXEmitterVerticalLodProperties VerticalLod;
    //## END PROPS ParticleModuleTypeDataMeshPhysX

    DECLARE_CLASS(UParticleModuleTypeDataMeshPhysX,UParticleModuleTypeDataMesh,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);
	virtual void SetToSensibleDefaults();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void FinishDestroy();

#if WITH_NOVODEX
	void TryCreateRenderInstance(UParticleEmitter *InEmitterParent, FParticleMeshPhysXEmitterInstance *InSpawnEmitterInstance);
    void TryRemoveRenderInstance(FParticleMeshPhysXEmitterInstance *InSpawnEmitterInstance);
#endif	//#if WITH_NOVODEX
};

class UParticleModuleTypeDataTrail : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataTrail
    BITFIELD RenderGeometry:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    BITFIELD Tapered:1;
    BITFIELD SpawnByDistance:1;
    INT TessellationFactor;
    struct FRawDistributionFloat Tension;
    FVector SpawnDistance;
    //## END PROPS ParticleModuleTypeDataTrail

    DECLARE_CLASS(UParticleModuleTypeDataTrail,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults();

	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UParticleModuleTypeDataTrail2 : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataTrail2
    INT TessellationFactor;
    FLOAT TessellationFactorDistance;
    FLOAT TessellationStrength;
    INT TextureTile;
    INT Sheets;
    INT MaxTrailCount;
    INT MaxParticleInTrailCount;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    //## END PROPS ParticleModuleTypeDataTrail2

    DECLARE_CLASS(UParticleModuleTypeDataTrail2,UParticleModuleTypeDataBase,0,Engine)
	virtual void	PreSpawn(FParticleEmitterInstance* Owner, FBaseParticle* Particle);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	// Trail
	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, FTrail2TypeDataPayload*& TrailData, FLOAT*& TaperValues);
	virtual void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, INT& TrailDataOffset, INT& TaperValuesOffset);
};

class UParticleModuleUberBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleUberBase
    TArrayNoInit<FName> RequiredModules;
    //## END PROPS ParticleModuleUberBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleUberBase,UParticleModule,0,Engine)
	/** This function will determine the proper uber-module to utilize.					*/
	static	UParticleModule*	DetermineBestUberModule(UParticleEmitter* InputEmitter);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberLTISIVCL : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCL
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberLTISIVCL

    DECLARE_CLASS(UParticleModuleUberLTISIVCL,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberLTISIVCLIL : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCLIL
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleUberLTISIVCLIL

    DECLARE_CLASS(UParticleModuleUberLTISIVCLIL,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberLTISIVCLILIRSSBLIRR : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCLILIRSSBLIRR
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector StartLocation;
    struct FRawDistributionFloat StartRotation;
    struct FRawDistributionVector SizeLifeMultiplier;
    BITFIELD SizeMultiplyX:1;
    BITFIELD SizeMultiplyY:1;
    BITFIELD SizeMultiplyZ:1;
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleUberLTISIVCLILIRSSBLIRR

    DECLARE_CLASS(UParticleModuleUberLTISIVCLILIRSSBLIRR,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberRainDrops : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainDrops
    FLOAT LifetimeMin;
    FLOAT LifetimeMax;
    FVector StartSizeMin;
    FVector StartSizeMax;
    FVector StartVelocityMin;
    FVector StartVelocityMax;
    FLOAT StartVelocityRadialMin;
    FLOAT StartVelocityRadialMax;
    FVector ColorOverLife;
    FLOAT AlphaOverLife;
    BITFIELD bIsUsingCylinder:1;
    BITFIELD bPositive_X:1;
    BITFIELD bPositive_Y:1;
    BITFIELD bPositive_Z:1;
    BITFIELD bNegative_X:1;
    BITFIELD bNegative_Y:1;
    BITFIELD bNegative_Z:1;
    BITFIELD bSurfaceOnly:1;
    BITFIELD bVelocity:1;
    BITFIELD bRadialVelocity:1;
    FLOAT PC_VelocityScale;
    FVector PC_StartLocation;
    FLOAT PC_StartRadius;
    FLOAT PC_StartHeight;
    BYTE PC_HeightAxis;
    FVector StartLocationMin;
    FVector StartLocationMax;
    //## END PROPS ParticleModuleUberRainDrops

    DECLARE_CLASS(UParticleModuleUberRainDrops,UParticleModuleUberBase,0,Engine)
	virtual void	PostLoad();
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);

	void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainImpacts : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainImpacts
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    BITFIELD bIsUsingCylinder:1;
    BITFIELD bPositive_X:1;
    BITFIELD bPositive_Y:1;
    BITFIELD bPositive_Z:1;
    BITFIELD bNegative_X:1;
    BITFIELD bNegative_Y:1;
    BITFIELD bNegative_Z:1;
    BITFIELD bSurfaceOnly:1;
    BITFIELD bVelocity:1;
    BITFIELD bRadialVelocity:1;
    struct FRawDistributionVector LifeMultiplier;
    struct FRawDistributionFloat PC_VelocityScale;
    struct FRawDistributionVector PC_StartLocation;
    struct FRawDistributionFloat PC_StartRadius;
    struct FRawDistributionFloat PC_StartHeight;
    BYTE PC_HeightAxis;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberRainImpacts

    DECLARE_CLASS(UParticleModuleUberRainImpacts,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);

	void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainSplashA : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainSplashA
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    struct FRawDistributionVector LifeMultiplier;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberRainSplashA

    DECLARE_CLASS(UParticleModuleUberRainSplashA,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL	IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL	ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainSplashB : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainSplashB
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector LifeMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleUberRainSplashB

    DECLARE_CLASS(UParticleModuleUberRainSplashB,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL	IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL	ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleVelocityBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleVelocityBase
    //## END PROPS ParticleModuleVelocityBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleVelocityBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleVelocityBase)
};

class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocity
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    //## END PROPS ParticleModuleVelocity

    DECLARE_CLASS(UParticleModuleVelocity,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
};

class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityInheritParent
    struct FRawDistributionVector Scale;
    //## END PROPS ParticleModuleVelocityInheritParent

    DECLARE_CLASS(UParticleModuleVelocityInheritParent,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
};

class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityOverLifetime
    struct FRawDistributionVector VelOverLife;
    BITFIELD Absolute:1;
    //## END PROPS ParticleModuleVelocityOverLifetime

    DECLARE_CLASS(UParticleModuleVelocityOverLifetime,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

struct FParticleEmitterReplayFrame
{
    INT EmitterType;
    INT OriginalEmitterIndex;
    struct FDynamicEmitterReplayDataBase* FrameState;

		/** Constructors */
		FParticleEmitterReplayFrame() {}
		FParticleEmitterReplayFrame( EEventParm )
			: EmitterType( DET_Unknown ),
			  OriginalEmitterIndex( INDEX_NONE ),
			  FrameState( NULL )
		{
		}

		/** Destructor */
		~FParticleEmitterReplayFrame()
		{
			// Clean up frame state
			if( FrameState != NULL )
			{
				delete FrameState;
				FrameState = NULL;
			}
		}

		/** Serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FParticleEmitterReplayFrame& Obj );
	
};

struct FParticleSystemReplayFrame
{
    TArrayNoInit<struct FParticleEmitterReplayFrame> Emitters;

		/** Constructors */
		FParticleSystemReplayFrame() {}
		FParticleSystemReplayFrame( EEventParm )
		{
			appMemzero( this, sizeof( FParticleSystemReplayFrame ) );
		}

		/** Serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FParticleSystemReplayFrame& Obj );
	
};

class UParticleSystemReplay : public UObject
{
public:
    //## BEGIN PROPS ParticleSystemReplay
    INT ClipIDNumber;
    TArrayNoInit<struct FParticleSystemReplayFrame> Frames;
    //## END PROPS ParticleSystemReplay

    DECLARE_CLASS(UParticleSystemReplay,UObject,0,Engine)
	/** Serialization */
	virtual void Serialize( FArchive& Ar );
};

class UPhysXParticleSystem : public UObject
{
public:
    //## BEGIN PROPS PhysXParticleSystem
    INT MaxParticles;
    FLOAT CollisionDistance;
    FLOAT RestitutionWithStaticShapes;
    FLOAT RestitutionWithDynamicShapes;
    FLOAT FrictionWithStaticShapes;
    FLOAT FrictionWithDynamicShapes;
    BITFIELD bDynamicCollision:1;
    BITFIELD bDisableGravity:1;
    BITFIELD bStaticCollision:1;
    BITFIELD bTwoWayCollision:1;
    BITFIELD bDestroy:1;
    BITFIELD bSyncFailed:1;
    BITFIELD bIsInGame:1;
    FLOAT MaxMotionDistance;
    FLOAT Damping;
    FVector ExternalAcceleration;
    BYTE SimulationMethod;
    BYTE PacketSizeMultiplier;
    FLOAT RestParticleDistance;
    FLOAT RestDensity;
    FLOAT KernelRadiusMultiplier;
    FLOAT Stiffness;
    FLOAT Viscosity;
    FLOAT CollisionResponseCoefficient;
    class FRBPhysScene* CascadeScene;
    class FPhysXParticleSystem* PSys;
    //## END PROPS PhysXParticleSystem

    DECLARE_CLASS(UPhysXParticleSystem,UObject,0,Engine)
    virtual void FinishDestroy();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);

    void Tick(FLOAT deltaTime);
    void TickEditor(FLOAT deltaTime);
    void RemovedFromScene();
    void RemoveSpawnInstance(struct FParticleEmitterInstance*);
    UBOOL SyncConnect();
    UBOOL SyncDisconnect();
    UBOOL TryConnect();
	void SyncPhysXData();
	FRBPhysScene* GetScene();
};

#endif // !INCLUDED_ENGINE_PARTICLE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UParticleSystem,-1,execSetLODDistance);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execSetCurrentLODMethod);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetLODDistance);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetLODLevelCount);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetCurrentLODMethod);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execResetToDefaults);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetActive);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execClearParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetMaterialParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetActorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetColorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetVectorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetFloatParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetMaterialParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetActorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetColorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetVectorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetFloatParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetEditorLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetEditorLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetStrength);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetTangent);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetPoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourceStrength);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourceTangent);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourcePoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamDistance);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamEndPoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTessellationFactor);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamType);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execRewindEmitterInstances);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execRewindEmitterInstance);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetKillOnCompleted);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetKillOnDeactivate);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetSkipUpdateDynamicDataDuringTick);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetSkipUpdateDynamicDataDuringTick);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execKillParticlesForced);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execDeactivateSystem);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execActivateSystem);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(APhysXEmitterSpawnable,-1,execTerm);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PARTICLE_NATIVE_DEFS
#define ENGINE_PARTICLE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UDistributionFloatParticleParameter);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorParticleParameter);
DECLARE_NATIVE_TYPE(Engine,AEmitterCameraLensEffectBase);
DECLARE_NATIVE_TYPE(Engine,UParticleEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleLODLevel);
DECLARE_NATIVE_TYPE(Engine,UParticleModule);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAcceleration);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAccelerationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAccelerationOverLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorLine);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorParticle);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorPoint);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamModifier);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamNoise);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamSource);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamTarget);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleCollision);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleCollisionBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColor);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorByParameter);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorOverLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorScaleOverLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleEventBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleEventGenerator);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleEventReceiverBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleEventReceiverSpawn);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleKillBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleKillBox);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleKillHeight);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLifetimeBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocation);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationDirect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationEmitterDirect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationPrimitiveBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationPrimitiveCylinder);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationPrimitiveSphere);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMaterialBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMaterialByParameter);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshMaterial);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshRotation);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshRotationRate);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshRotationRateMultiplyLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrbit);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrbitBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrientationAxisLock);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrientationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleParameterBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleParameterDynamic);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRequired);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotation);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationOverLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationRate);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationRateBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationRateMultiplyLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSize);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeMultiplyLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeMultiplyVelocity);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeScale);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSpawn);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSpawnBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSpawnPerUnit);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUV);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUVBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUVDirect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUVSelect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailSource);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailSpawn);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailTaper);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataBeam);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataBeam2);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataMesh);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataMeshPhysX);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataPhysX);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataTrail);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataTrail2);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberLTISIVCL);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberLTISIVCLIL);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberLTISIVCLILIRSSBLIRR);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainDrops);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainImpacts);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainSplashA);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainSplashB);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocity);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocityBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocityInheritParent);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocityOverLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleSpriteEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleSystem);
DECLARE_NATIVE_TYPE(Engine,UParticleSystemComponent);
DECLARE_NATIVE_TYPE(Engine,UParticleSystemReplay);
DECLARE_NATIVE_TYPE(Engine,APhysXEmitterSpawnable);
DECLARE_NATIVE_TYPE(Engine,UPhysXParticleSystem);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PARTICLE \
	UDistributionFloatParticleParameter::StaticClass(); \
	UDistributionVectorParticleParameter::StaticClass(); \
	AEmitterCameraLensEffectBase::StaticClass(); \
	UParticleEmitter::StaticClass(); \
	UParticleLODLevel::StaticClass(); \
	UParticleModule::StaticClass(); \
	UParticleModuleAcceleration::StaticClass(); \
	UParticleModuleAccelerationBase::StaticClass(); \
	UParticleModuleAccelerationOverLifetime::StaticClass(); \
	UParticleModuleAttractorBase::StaticClass(); \
	UParticleModuleAttractorLine::StaticClass(); \
	UParticleModuleAttractorParticle::StaticClass(); \
	UParticleModuleAttractorPoint::StaticClass(); \
	UParticleModuleBeamBase::StaticClass(); \
	UParticleModuleBeamModifier::StaticClass(); \
	UParticleModuleBeamNoise::StaticClass(); \
	UParticleModuleBeamSource::StaticClass(); \
	UParticleModuleBeamTarget::StaticClass(); \
	UParticleModuleCollision::StaticClass(); \
	UParticleModuleCollisionBase::StaticClass(); \
	UParticleModuleColor::StaticClass(); \
	UParticleModuleColorBase::StaticClass(); \
	UParticleModuleColorByParameter::StaticClass(); \
	UParticleModuleColorOverLife::StaticClass(); \
	UParticleModuleColorScaleOverLife::StaticClass(); \
	UParticleModuleEventBase::StaticClass(); \
	UParticleModuleEventGenerator::StaticClass(); \
	UParticleModuleEventReceiverBase::StaticClass(); \
	UParticleModuleEventReceiverSpawn::StaticClass(); \
	UParticleModuleKillBase::StaticClass(); \
	UParticleModuleKillBox::StaticClass(); \
	UParticleModuleKillHeight::StaticClass(); \
	UParticleModuleLifetime::StaticClass(); \
	UParticleModuleLifetimeBase::StaticClass(); \
	UParticleModuleLocation::StaticClass(); \
	UParticleModuleLocationBase::StaticClass(); \
	UParticleModuleLocationDirect::StaticClass(); \
	UParticleModuleLocationEmitter::StaticClass(); \
	UParticleModuleLocationEmitterDirect::StaticClass(); \
	UParticleModuleLocationPrimitiveBase::StaticClass(); \
	UParticleModuleLocationPrimitiveCylinder::StaticClass(); \
	UParticleModuleLocationPrimitiveSphere::StaticClass(); \
	UParticleModuleMaterialBase::StaticClass(); \
	UParticleModuleMaterialByParameter::StaticClass(); \
	UParticleModuleMeshMaterial::StaticClass(); \
	UParticleModuleMeshRotation::StaticClass(); \
	UParticleModuleMeshRotationRate::StaticClass(); \
	UParticleModuleMeshRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleOrbit::StaticClass(); \
	UParticleModuleOrbitBase::StaticClass(); \
	UParticleModuleOrientationAxisLock::StaticClass(); \
	UParticleModuleOrientationBase::StaticClass(); \
	UParticleModuleParameterBase::StaticClass(); \
	UParticleModuleParameterDynamic::StaticClass(); \
	UParticleModuleRequired::StaticClass(); \
	UParticleModuleRotation::StaticClass(); \
	UParticleModuleRotationBase::StaticClass(); \
	UParticleModuleRotationOverLifetime::StaticClass(); \
	UParticleModuleRotationRate::StaticClass(); \
	UParticleModuleRotationRateBase::StaticClass(); \
	UParticleModuleRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleSize::StaticClass(); \
	UParticleModuleSizeBase::StaticClass(); \
	UParticleModuleSizeMultiplyLife::StaticClass(); \
	UParticleModuleSizeMultiplyVelocity::StaticClass(); \
	UParticleModuleSizeScale::StaticClass(); \
	UParticleModuleSpawn::StaticClass(); \
	UParticleModuleSpawnBase::StaticClass(); \
	UParticleModuleSpawnPerUnit::StaticClass(); \
	UParticleModuleSubUV::StaticClass(); \
	UParticleModuleSubUVBase::StaticClass(); \
	UParticleModuleSubUVDirect::StaticClass(); \
	UParticleModuleSubUVSelect::StaticClass(); \
	UParticleModuleTrailBase::StaticClass(); \
	UParticleModuleTrailSource::StaticClass(); \
	UParticleModuleTrailSpawn::StaticClass(); \
	UParticleModuleTrailTaper::StaticClass(); \
	UParticleModuleTypeDataBase::StaticClass(); \
	UParticleModuleTypeDataBeam::StaticClass(); \
	UParticleModuleTypeDataBeam2::StaticClass(); \
	UParticleModuleTypeDataMesh::StaticClass(); \
	UParticleModuleTypeDataMeshPhysX::StaticClass(); \
	UParticleModuleTypeDataPhysX::StaticClass(); \
	UParticleModuleTypeDataTrail::StaticClass(); \
	UParticleModuleTypeDataTrail2::StaticClass(); \
	UParticleModuleUberBase::StaticClass(); \
	UParticleModuleUberLTISIVCL::StaticClass(); \
	UParticleModuleUberLTISIVCLIL::StaticClass(); \
	UParticleModuleUberLTISIVCLILIRSSBLIRR::StaticClass(); \
	UParticleModuleUberRainDrops::StaticClass(); \
	UParticleModuleUberRainImpacts::StaticClass(); \
	UParticleModuleUberRainSplashA::StaticClass(); \
	UParticleModuleUberRainSplashB::StaticClass(); \
	UParticleModuleVelocity::StaticClass(); \
	UParticleModuleVelocityBase::StaticClass(); \
	UParticleModuleVelocityInheritParent::StaticClass(); \
	UParticleModuleVelocityOverLifetime::StaticClass(); \
	UParticleSpriteEmitter::StaticClass(); \
	UParticleSystem::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUParticleSystemNative; \
	UParticleSystemComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUParticleSystemComponentNative; \
	UParticleSystemReplay::StaticClass(); \
	APhysXEmitterSpawnable::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPhysXEmitterSpawnableNative; \
	UPhysXParticleSystem::StaticClass(); \

#endif // ENGINE_PARTICLE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UParticleSystem) GEngineUParticleSystemNatives[] = 
{ 
	MAP_NATIVE(UParticleSystem,execSetLODDistance)
	MAP_NATIVE(UParticleSystem,execSetCurrentLODMethod)
	MAP_NATIVE(UParticleSystem,execGetLODDistance)
	MAP_NATIVE(UParticleSystem,execGetLODLevelCount)
	MAP_NATIVE(UParticleSystem,execGetCurrentLODMethod)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UParticleSystem);

NATIVE_INFO(UParticleSystemComponent) GEngineUParticleSystemComponentNatives[] = 
{ 
	MAP_NATIVE(UParticleSystemComponent,execResetToDefaults)
	MAP_NATIVE(UParticleSystemComponent,execSetActive)
	MAP_NATIVE(UParticleSystemComponent,execClearParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetMaterialParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetActorParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetColorParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetVectorParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetFloatParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetMaterialParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetActorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetColorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetVectorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetFloatParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetEditorLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execGetLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execSetEditorLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execSetLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTargetStrength)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTargetTangent)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTargetPoint)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamSourceStrength)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamSourceTangent)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamSourcePoint)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamDistance)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamEndPoint)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTessellationFactor)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamType)
	MAP_NATIVE(UParticleSystemComponent,execRewindEmitterInstances)
	MAP_NATIVE(UParticleSystemComponent,execRewindEmitterInstance)
	MAP_NATIVE(UParticleSystemComponent,execSetKillOnCompleted)
	MAP_NATIVE(UParticleSystemComponent,execSetKillOnDeactivate)
	MAP_NATIVE(UParticleSystemComponent,execGetSkipUpdateDynamicDataDuringTick)
	MAP_NATIVE(UParticleSystemComponent,execSetSkipUpdateDynamicDataDuringTick)
	MAP_NATIVE(UParticleSystemComponent,execKillParticlesForced)
	MAP_NATIVE(UParticleSystemComponent,execDeactivateSystem)
	MAP_NATIVE(UParticleSystemComponent,execActivateSystem)
	MAP_NATIVE(UParticleSystemComponent,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UParticleSystemComponent);

NATIVE_INFO(APhysXEmitterSpawnable) GEngineAPhysXEmitterSpawnableNatives[] = 
{ 
	MAP_NATIVE(APhysXEmitterSpawnable,execTerm)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APhysXEmitterSpawnable);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatParticleParameter)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorParticleParameter)
VERIFY_CLASS_OFFSET_NODIE(A,EmitterCameraLensEffectBase,PS_CameraEffect)
VERIFY_CLASS_OFFSET_NODIE(A,EmitterCameraLensEffectBase,PS_CameraEffectNonExtremeContent)
VERIFY_CLASS_SIZE_NODIE(AEmitterCameraLensEffectBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleEmitter,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleEmitter,InitialAllocationCount)
VERIFY_CLASS_SIZE_NODIE(UParticleEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleLODLevel,Level)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleLODLevel,PeakActiveParticles)
VERIFY_CLASS_SIZE_NODIE(UParticleLODLevel)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModule,ModuleEditorColor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModule,IdenticalIgnoreProperties)
VERIFY_CLASS_SIZE_NODIE(UParticleModule)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAcceleration,Acceleration)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAcceleration)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAccelerationOverLifetime,AccelOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorLine,EndPoint0)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorLine,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorLine)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorParticle,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorParticle,LastSelIndex)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorParticle)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorPoint,Position)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorPoint,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorPoint)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamModifier,ModifierType)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamModifier,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamModifier)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamNoise,Frequency)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamNoise,NoiseScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamNoise)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamSource,SourceMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamSource,SourceStrength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamSource)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamTarget,TargetMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamTarget,LockRadius)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamTarget)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleCollision,DampingFactor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleCollision,DelayAmount)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollision)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollisionBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColor,StartColor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColor,StartAlpha)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorByParameter,ColorParam)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorByParameter,DefaultColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorByParameter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorOverLife,ColorOverLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorOverLife,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorOverLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorScaleOverLife,ColorScaleOverLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorScaleOverLife,AlphaScaleOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorScaleOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleEventGenerator,Events)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventGenerator)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventReceiverBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleEventReceiverSpawn,EventGeneratorType)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleEventReceiverSpawn,InheritVelocityScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventReceiverSpawn)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleKillBox,LowerLeftCorner)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleKillBox,UpperRightCorner)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillBox)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleKillHeight,Height)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillHeight)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLifetime,Lifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetimeBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocation,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationDirect,Location)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationDirect,Direction)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationDirect)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationEmitter,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationEmitter,InheritSourceRotationScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationEmitterDirect,EmitterName)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationEmitterDirect)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveBase,VelocityScale)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveBase,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveCylinder,StartRadius)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveCylinder,HeightAxis)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveCylinder)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveSphere,StartRadius)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveSphere)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMaterialBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMaterialByParameter,MaterialParameters)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMaterialByParameter,DefaultMaterials)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMaterialByParameter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshMaterial,MeshMaterials)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshRotation,StartRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotation)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshRotationRate,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRate)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshRotationRateMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRateMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleOrbit,ChainMode)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleOrbit,RotationRateOptions)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrbit)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrbitBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleOrientationAxisLock,LockAxisFlags)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrientationAxisLock)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrientationBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleParameterBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleParameterDynamic,DynamicParams)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleParameterDynamic)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRequired,Material)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRequired,EmitterEditorColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRequired)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotation,StartRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotationOverLifetime,RotationOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationOverLifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotationRate,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotationRateMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSize,StartSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSizeMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSizeMultiplyVelocity,VelocityMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSizeScale,SizeScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeScale)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSpawn,Rate)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSpawn,BurstList)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawn)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawnBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSpawnPerUnit,UnitScalar)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSpawnPerUnit,MovementTolerance)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawnPerUnit)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUV,SubImageIndex)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUV)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUVDirect,SubUVPosition)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUVDirect,SubUVSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVDirect)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUVSelect,SubImageSelect)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVSelect)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSource,SourceMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSource,SourceOffsetDefaults)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailSource)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSpawn,SpawnDistanceMap)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSpawn,MinSpawnVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailSpawn)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailTaper,TaperMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailTaper,TaperFactor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailTaper)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam,BeamMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam,TextureTile)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBeam)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam2,BeamMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam2,BonePairs)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBeam2)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMesh,Mesh)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMesh,MeshAlignment)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMeshPhysX,PhysXParSys)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMeshPhysX,VerticalLod)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMeshPhysX)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataPhysX,PhysXParSys)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataPhysX,VerticalLod)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataPhysX)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail,TessellationFactor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail,SpawnDistance)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail2,TessellationFactor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail2,MaxParticleInTrailCount)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail2)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberBase,RequiredModules)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCL,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCL,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCL)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLIL,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLIL,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCLIL)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLILIRSSBLIRR,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLILIRSSBLIRR,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCLILIRSSBLIRR)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainDrops,LifetimeMin)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainDrops,StartLocationMax)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainDrops)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainImpacts,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainImpacts,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainImpacts)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashA,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashA,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainSplashA)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashB,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashB,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainSplashB)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocity,StartVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocity,StartVelocityRadial)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocityInheritParent,Scale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityInheritParent)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocityOverLifetime,VelOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystem,SystemUpdateMode)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystem,ContentTags)
VERIFY_CLASS_SIZE_NODIE(UParticleSystem)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemComponent,Template)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemComponent,__OnSystemFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemComponent)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemReplay,ClipIDNumber)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemReplay,Frames)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemReplay)
VERIFY_CLASS_OFFSET_NODIE(A,PhysXEmitterSpawnable,VolumeFill)
VERIFY_CLASS_OFFSET_NODIE(A,PhysXEmitterSpawnable,ParticleTemplate)
VERIFY_CLASS_SIZE_NODIE(APhysXEmitterSpawnable)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXParticleSystem,MaxParticles)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXParticleSystem,PSys)
VERIFY_CLASS_SIZE_NODIE(UPhysXParticleSystem)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
