/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_GAMEENGINE_ENUMS
#define INCLUDED_ENGINE_GAMEENGINE_ENUMS 1

enum ETransitionType
{
    TT_None                 =0,
    TT_Paused               =1,
    TT_Loading              =2,
    TT_Saving               =3,
    TT_Connecting           =4,
    TT_Precaching           =5,
    TT_MAX                  =6,
};
enum EFullyLoadPackageType
{
    FULLYLOAD_Map           =0,
    FULLYLOAD_Game_PreLoadClass=1,
    FULLYLOAD_Game_PostLoadClass=2,
    FULLYLOAD_Always        =3,
    FULLYLOAD_Mutator       =4,
    FULLYLOAD_MAX           =5,
};

#endif // !INCLUDED_ENGINE_GAMEENGINE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_GAMEENGINE_CLASSES
#define INCLUDED_ENGINE_GAMEENGINE_CLASSES 1

struct FStatColorMapEntry
{
    FLOAT In;
    FColor Out;

    /** Constructors */
    FStatColorMapEntry() {}
    FStatColorMapEntry(EEventParm)
    {
        appMemzero(this, sizeof(FStatColorMapEntry));
    }
};

struct FStatColorMapping
{
    FStringNoInit StatName;
    TArrayNoInit<struct FStatColorMapEntry> ColorMap;
    BITFIELD DisableBlend:1;

    /** Constructors */
    FStatColorMapping() {}
    FStatColorMapping(EEventParm)
    {
        appMemzero(this, sizeof(FStatColorMapping));
    }
};

struct FDropNoteInfo
{
    FVector Location;
    FRotator Rotation;
    FStringNoInit Comment;

    /** Constructors */
    FDropNoteInfo() {}
    FDropNoteInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDropNoteInfo));
    }
};

class UEngine : public USubsystem
{
public:
    //## BEGIN PROPS Engine
    class UFont* TinyFont;
    FStringNoInit TinyFontName;
    class UFont* SmallFont;
    FStringNoInit SmallFontName;
    class UFont* MediumFont;
    FStringNoInit MediumFontName;
    class UFont* LargeFont;
    FStringNoInit LargeFontName;
    class UFont* SubtitleFont;
    FStringNoInit SubtitleFontName;
    TArrayNoInit<class UFont*> AdditionalFonts;
    TArrayNoInit<FString> AdditionalFontNames;
    class UClass* ConsoleClass;
    FStringNoInit ConsoleClassName;
    class UClass* GameViewportClientClass;
    FStringNoInit GameViewportClientClassName;
    class UClass* DataStoreClientClass;
    FStringNoInit DataStoreClientClassName;
    class UClass* LocalPlayerClass;
    FStringNoInit LocalPlayerClassName;
    class UMaterial* DefaultMaterial;
    FStringNoInit DefaultMaterialName;
    class UMaterial* DefaultDecalMaterial;
    FStringNoInit DefaultDecalMaterialName;
    class UTexture* DefaultTexture;
    FStringNoInit DefaultTextureName;
    class UMaterial* WireframeMaterial;
    FStringNoInit WireframeMaterialName;
    class UMaterial* EmissiveTexturedMaterial;
    FStringNoInit EmissiveTexturedMaterialName;
    class UMaterial* GeomMaterial;
    FStringNoInit GeomMaterialName;
    class UMaterial* DefaultFogVolumeMaterial;
    FStringNoInit DefaultFogVolumeMaterialName;
    class UMaterial* TickMaterial;
    FStringNoInit TickMaterialName;
    class UMaterial* CrossMaterial;
    FStringNoInit CrossMaterialName;
    class UMaterial* LevelColorationLitMaterial;
    FStringNoInit LevelColorationLitMaterialName;
    class UMaterial* LevelColorationUnlitMaterial;
    FStringNoInit LevelColorationUnlitMaterialName;
    class UMaterial* ShadedLevelColorationLitMaterial;
    FStringNoInit ShadedLevelColorationLitMaterialName;
    class UMaterial* ShadedLevelColorationUnlitMaterial;
    FStringNoInit ShadedLevelColorationUnlitMaterialName;
    class UMaterial* RemoveSurfaceMaterial;
    FStringNoInit RemoveSurfaceMaterialName;
    class UMaterial* VertexColorMaterial;
    FStringNoInit VertexColorMaterialName;
    TArrayNoInit<FColor> LightComplexityColors;
    TArrayNoInit<FColor> ShaderComplexityColors;
    BITFIELD bUsePixelShaderComplexity:1;
    BITFIELD bUseAdditiveComplexity:1;
    BITFIELD bUseSound:1;
    BITFIELD bUseTextureStreaming:1;
    BITFIELD bUseBackgroundLevelStreaming:1;
    BITFIELD bSubtitlesEnabled:1;
    BITFIELD bSubtitlesForcedOff:1;
    BITFIELD bForceStaticTerrain:1;
    BITFIELD bUseInvertedLeftStick:1;
    BITFIELD bForceCPUSkinning:1;
    BITFIELD bUsePostProcessEffects:1;
    BITFIELD bOnScreenKismetWarnings:1;
    BITFIELD bEnableKismetLogging:1;
    BITFIELD bAllowMatureLanguage:1;
    BITFIELD bRenderTerrainCollisionAsOverlay:1;
    BITFIELD bPhysXuseGRB:1;
    BITFIELD bPauseOnLossOfFocus:1;
    BITFIELD bCheckParticleRenderSize:1;
    BITFIELD bDisplayDebugAudio:1;
    BITFIELD bDisplayDebugAI:1;
    BITFIELD bDisplayDebugAnim:1;
    BITFIELD bDisplayDebugPlayer:1;
    BITFIELD bDisplayDebugEngine:1;
    BITFIELD bDisplayDebugBoss:1;
    BITFIELD bEnablePerfMemDump:1;
    BITFIELD bEnableColorClear:1;
    BITFIELD bUnboundActiveController:1;
    BITFIELD bPausedCheck:1;
    FLOAT MaxPixelShaderAdditiveComplexityCount;
    FLOAT MaxPixelShaderOpaqueComplexityCount;
    FLOAT MaxVertexShaderComplexityCount;
    FLOAT MinTextureDensity;
    FLOAT IdealTextureDensity;
    FLOAT MaxTextureDensity;
    TArrayNoInit<struct FStatColorMapping> StatColorMappings;
    class UMaterial* EditorBrushMaterial;
    FStringNoInit EditorBrushMaterialName;
    class UPhysicalMaterial* DefaultPhysMaterial;
    FStringNoInit DefaultPhysMaterialName;
    class UMaterial* TerrainErrorMaterial;
    FStringNoInit TerrainErrorMaterialName;
    INT TerrainMaterialMaxTextureCount;
    INT TerrainTessellationCheckCount;
    FLOAT TerrainTessellationCheckDistance;
    class UClass* OnlineSubsystemClass;
    FStringNoInit DefaultOnlineSubsystemName;
    class UPostProcessChain* DefaultPostProcess;
    FStringNoInit DefaultPostProcessName;
    class UPostProcessChain* ThumbnailSkeletalMeshPostProcess;
    FStringNoInit ThumbnailSkeletalMeshPostProcessName;
    class UPostProcessChain* ThumbnailParticleSystemPostProcess;
    FStringNoInit ThumbnailParticleSystemPostProcessName;
    class UPostProcessChain* ThumbnailMaterialPostProcess;
    FStringNoInit ThumbnailMaterialPostProcessName;
    class UPostProcessChain* DefaultUIScenePostProcess;
    FStringNoInit DefaultUIScenePostProcessName;
    class UMaterial* DefaultUICaretMaterial;
    FStringNoInit DefaultUICaretMaterialName;
    class UMaterial* SceneCaptureReflectActorMaterial;
    FStringNoInit SceneCaptureReflectActorMaterialName;
    class UMaterial* SceneCaptureCubeActorMaterial;
    FStringNoInit SceneCaptureCubeActorMaterialName;
    class UTexture2D* RandomAngleTexture;
    FStringNoInit RandomAngleTextureName;
    class UTexture2D* RandomNormalTexture;
    FStringNoInit RandomNormalTextureName;
    class UTexture* WeightMapPlaceholderTexture;
    FStringNoInit WeightMapPlaceholderTextureName;
    class UTextureFlipBook* LoadingIconTexture;
    class USoundNodeWave* DefaultSound;
    FStringNoInit DefaultSoundName;
    FLOAT TimeBetweenPurgingPendingKillObjects;
    class UClient* Client;
    TArray<class ULocalPlayer*> GamePlayers;
    class UGameViewportClient* GameViewport;
    TArray<FString> DeferredCommands;
    INT TickCycles;
    INT GameCycles;
    INT ClientCycles;
    class UDebugManager* DebugManager;
    class FRemoteControlExec* RemoteControlExec;
    FColor C_WorldBox;
    FColor C_BrushWire;
    FColor C_AddWire;
    FColor C_SubtractWire;
    FColor C_SemiSolidWire;
    FColor C_NonSolidWire;
    FColor C_WireBackground;
    FColor C_ScaleBoxHi;
    FColor C_VolumeCollision;
    FColor C_BSPCollision;
    FColor C_OrthoBackground;
    FColor C_Volume;
    FLOAT StreamingDistanceFactor;
    FStringNoInit ScoutClassName;
    BYTE TransitionType;
    FStringNoInit TransitionDescription;
    FStringNoInit TransitionGameType;
    FLOAT MeshLODRange;
    FLOAT CameraRotationThreshold;
    FLOAT CameraTranslationThreshold;
    FLOAT PrimitiveProbablyVisibleTime;
    FLOAT PercentUnoccludedRequeries;
    FLOAT MaxOcclusionPixelsFraction;
    INT PhysXLevel;
    FLOAT PhysXgrbSpacing;
    INT MaxFluidNumVerts;
    FLOAT FluidSimulationTimeLimit;
    INT MaxParticleResize;
    INT MaxParticleResizeWarn;
    INT MaxParticleVertexMemory;
    INT MaxParticleSpriteCount;
    INT MaxParticleSubUVCount;
    class UMaterial* TerrainCollisionMaterial;
    FStringNoInit TerrainCollisionMaterialName;
    INT BeginUPTryCount;
    TArrayNoInit<struct FDropNoteInfo> PendingDroppedNotes;
    FStringNoInit DynamicCoverMeshComponentName;
    FLOAT NetClientTicksPerSecond;
    FLOAT LensFlareMaxOcclusionIncrement;
    FLOAT LensFlareOcclusionStepSize;
    class UDirectionalLightComponent* TempCollisionLight;
    class UDirectionalLightComponent* TempCollisionBackLight;
    //## END PROPS Engine

    class AWorldInfo* GetCurrentWorldInfo();
    FString GetBuildDate();
    class UFont* GetTinyFont();
    class UFont* GetSmallFont();
    class UFont* GetMediumFont();
    class UFont* GetLargeFont();
    class UFont* GetSubtitleFont();
    class UFont* GetAdditionalFont(INT AdditionalFontIndex);
    UBOOL IsSplitScreen();
    class UAudioDevice* GetAudioDevice();
    FString GetLastMovieName();
    UBOOL PlayLoadMapMovie();
    void StopMovie(UBOOL bDelayStopUntilGameHasRendered);
    void RemoveAllOverlays();
    void AddOverlay(class UFont* Font,const FString& Text,FLOAT X,FLOAT Y,FLOAT ScaleX,FLOAT ScaleY,UBOOL bIsCentered);
    void AddOverlayWrapped(class UFont* Font,const FString& Text,FLOAT X,FLOAT Y,FLOAT ScaleX,FLOAT ScaleY,FLOAT WrapWidth);
    DECLARE_FUNCTION(execGetCurrentWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetCurrentWorldInfo();
    }
    DECLARE_FUNCTION(execGetBuildDate)
    {
        P_FINISH;
        *(FString*)Result=GetBuildDate();
    }
    DECLARE_FUNCTION(execGetTinyFont)
    {
        P_FINISH;
        *(class UFont**)Result=GetTinyFont();
    }
    DECLARE_FUNCTION(execGetSmallFont)
    {
        P_FINISH;
        *(class UFont**)Result=GetSmallFont();
    }
    DECLARE_FUNCTION(execGetMediumFont)
    {
        P_FINISH;
        *(class UFont**)Result=GetMediumFont();
    }
    DECLARE_FUNCTION(execGetLargeFont)
    {
        P_FINISH;
        *(class UFont**)Result=GetLargeFont();
    }
    DECLARE_FUNCTION(execGetSubtitleFont)
    {
        P_FINISH;
        *(class UFont**)Result=GetSubtitleFont();
    }
    DECLARE_FUNCTION(execGetAdditionalFont)
    {
        P_GET_INT(AdditionalFontIndex);
        P_FINISH;
        *(class UFont**)Result=GetAdditionalFont(AdditionalFontIndex);
    }
    DECLARE_FUNCTION(execIsSplitScreen)
    {
        P_FINISH;
        *(UBOOL*)Result=IsSplitScreen();
    }
    DECLARE_FUNCTION(execGetAudioDevice)
    {
        P_FINISH;
        *(class UAudioDevice**)Result=GetAudioDevice();
    }
    DECLARE_FUNCTION(execGetLastMovieName)
    {
        P_FINISH;
        *(FString*)Result=GetLastMovieName();
    }
    DECLARE_FUNCTION(execPlayLoadMapMovie)
    {
        P_FINISH;
        *(UBOOL*)Result=PlayLoadMapMovie();
    }
    DECLARE_FUNCTION(execStopMovie)
    {
        P_GET_UBOOL(bDelayStopUntilGameHasRendered);
        P_FINISH;
        StopMovie(bDelayStopUntilGameHasRendered);
    }
    DECLARE_FUNCTION(execRemoveAllOverlays)
    {
        P_FINISH;
        RemoveAllOverlays();
    }
    DECLARE_FUNCTION(execAddOverlay)
    {
        P_GET_OBJECT(UFont,Font);
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT(ScaleX);
        P_GET_FLOAT(ScaleY);
        P_GET_UBOOL(bIsCentered);
        P_FINISH;
        AddOverlay(Font,Text,X,Y,ScaleX,ScaleY,bIsCentered);
    }
    DECLARE_FUNCTION(execAddOverlayWrapped)
    {
        P_GET_OBJECT(UFont,Font);
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT(ScaleX);
        P_GET_FLOAT(ScaleY);
        P_GET_FLOAT(WrapWidth);
        P_FINISH;
        AddOverlayWrapped(Font,Text,X,Y,ScaleX,ScaleY,WrapWidth);
    }
    DECLARE_ABSTRACT_CLASS(UEngine,USubsystem,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// Constructors.
	UEngine();
	void StaticConstructor();

	// UObject interface.
	virtual void FinishDestroy();

	// UEngine interface.
	virtual void Init();

	/**
	 * Called at shutdown, just before the exit purge.
	 */
	virtual void PreExit() {}

	virtual UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Out=*GLog );
	virtual void Tick( FLOAT DeltaSeconds ) PURE_VIRTUAL(UEngine::Tick,);
	virtual void SetClientTravel( const TCHAR* NextURL, ETravelType TravelType ) PURE_VIRTUAL(UEngine::SetClientTravel,);
	virtual FLOAT GetMaxTickRate( FLOAT /*DeltaTime*/, UBOOL bAllowFrameRateSmoothing = TRUE ) { return 0.0f; }
	virtual void SetProgress( EProgressMessageType MessageType, const FString& Title, const FString& Message );

	/**
	 * Ticks the FPS chart.
	 *
	 * @param DeltaSeconds	Time in seconds passed since last tick.
	 */
	virtual void TickFPSChart( FLOAT DeltaSeconds );

	/**
	* Ticks the Memory chart.
	*
	* @param DeltaSeconds	Time in seconds passed since last tick.
	*/
	virtual void TickMemoryChart( FLOAT DeltaSeconds );

	/**
	 * Pauses / unpauses the game-play when focus of the game's window gets lost / gained.
	 * @param EnablePause TRUE to pause; FALSE to unpause the game
	 */
	virtual void OnLostFocusPause( UBOOL EnablePause );

	/**
	 * Resets the FPS chart data.
	 */
	virtual void ResetFPSChart();

	/**
	 * Dumps the FPS chart information to the passed in archive.
	 *
	 * @param	bForceDump	Whether to dump even if FPS chart info is not enabled.
	 */
	virtual void DumpFPSChart( UBOOL bForceDump = FALSE );

	/** Dumps info on DistanceFactor used for rendering SkeletalMeshComponents during the game. */
	virtual void DumpDistanceFactorChart();

	/**
 	 * Resets the Memory chart data.
	 */
	virtual void ResetMemoryChart();

	/**
	 * Dumps the Memory chart information to various places.
	 */
	virtual void DumpMemoryChart();


private:
	/**
	 * Dumps the FPS chart information to HTML.
	 */
	virtual void DumpFPSChartToHTML( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames, UBOOL bOutputToGlobalLog );

	/**
	 * Dumps the FPS chart information to the log.
	 */
	virtual void DumpFPSChartToLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the FPS chart information to the special stats log file.
	 */
	virtual void DumpFPSChartToStatsLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the Memory chart information to HTML.
	 */
	virtual void DumpMemoryChartToHTML( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames, UBOOL bOutputToGlobalLog );

	/**
	 * Dumps the Memory chart information to the log.
	 */
	virtual void DumpMemoryChartToLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the Memory chart information to the special stats log file.
	 */
	virtual void DumpMemoryChartToStatsLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

public:

	/**
	 * Spawns any registered server actors
	 */
	virtual void SpawnServerActors(void)
	{
	}

	/**
	 * Loads all Engine object references from their corresponding config entries.
	 */
	void InitializeObjectReferences();

	/**
	 * Clean up the GameViewport
	 */
	void CleanupGameViewport();

	/** Get some viewport. Will be GameViewport in game, and one of the editor viewport windows in editor. */
	virtual FViewport* GetAViewport();

	/**
	 * Allows the editor to accept or reject the drawing of wireframe brush shapes based on mode and tool.
	 */
	virtual UBOOL ShouldDrawBrushWireframe( class AActor* InActor ) { return TRUE; }

	/**
	 * Looks at all currently loaded packages and prompts the user to save them
	 * if their "bDirty" flag is set.
	 *
	 * @param	bShouldSaveMap				TRUE if the function should save the map first before other packages.
	 * @param	bForcePackagesToFullyLoad	If TRUE, fully load dirty packages without first prompting the user.
	 * @return								TRUE on success, FALSE on fail.
	 */
	virtual UBOOL SaveDirtyPackages(UBOOL bShouldSaveMap, UBOOL bForcePackagesToFullyLoad) { return TRUE; }

	/**
	 * Issued by code reuqesting that decals be reattached.
	 */
	virtual void IssueDecalUpdateRequest() {}

	/**
	 * Returns whether or not the map build in progressed was cancelled by the user.
	 */
	virtual UBOOL GetMapBuildCancelled() const
	{
		return FALSE;
	}

	/**
	 * Sets the flag that states whether or not the map build was cancelled.
	 *
	 * @param InCancelled	New state for the cancelled flag.
	 */
	virtual void SetMapBuildCancelled( UBOOL InCancelled )
	{
		// Intentionally empty.
	}

	/**
	 * Computes a color to use for property coloration for the given object.
	 *
	 * @param	Object		The object for which to compute a property color.
	 * @param	OutColor	[out] The returned color.
	 * @return				TRUE if a color was successfully set on OutColor, FALSE otherwise.
	 */
	virtual UBOOL GetPropertyColorationColor(class UObject* Object, FColor& OutColor);

	/** Uses StatColorMappings to find a color for this stat's value. */
	UBOOL GetStatValueColoration(const FString& StatName, FLOAT Value, FColor& OutColor);


	/**
	 * @return TRUE if we allow shadow volume resources to be loaded/rendered
	 */
	static FORCEINLINE UBOOL ShadowVolumesAllowed()
	{
		return( (GIsEditor && !(GCookingTarget & UE3::PLATFORM_Console)) || (GAllowShadowVolumes && (GIsGame || (GCookingTarget & UE3::PLATFORM_Console))) );
	}

protected:
	/**
	 * Handles freezing/unfreezing of rendering
	 */
	virtual void ProcessToggleFreezeCommand()
	{
		// Intentionally empty.
	}

	/**
	 * Handles frezing/unfreezing of streaming
	 */
	 virtual void ProcessToggleFreezeStreamingCommand()
	 {
		// Intentionally empty.
	 }
};

struct FURL
{
    FString Protocol;
    FString Host;
    INT Port;
    FString Map;
    TArray<FString> Op;
    FString Portal;
    INT Valid;


	// Statics.
	static FString DefaultProtocol;
	static FString DefaultName;
	static FString DefaultMap;
	static FString DefaultLocalMap;
	static FString DefaultTransitionMap; // map used as in-between for seamless travel
	static FString DefaultHost;
	static FString DefaultPortal;
	static FString DefaultMapExt;
	static FString DefaultSaveExt;
	static INT DefaultPort;
	static UBOOL bDefaultsInitialized;

	// Constructors.
	FURL( const TCHAR* Filename=NULL );
	FURL( FURL* Base, const TCHAR* TextURL, ETravelType Type );
	static void StaticInit();
	static void StaticExit();

	/**
	 * Static: Removes any special URL characters from the specified string
	 *
	 * @param Str String to be filtered
	 */
	static void FilterURLString( FString& Str );


	// Functions.
	UBOOL IsInternal() const;
	UBOOL IsLocalInternal() const;
	UBOOL HasOption( const TCHAR* Test ) const;
	const TCHAR* GetOption( const TCHAR* Match, const TCHAR* Default ) const;
	void LoadURLConfig( const TCHAR* Section, const TCHAR* Filename=NULL );
	void SaveURLConfig( const TCHAR* Section, const TCHAR* Item, const TCHAR* Filename=NULL ) const;
	void AddOption( const TCHAR* Str );
	void RemoveOption( const TCHAR* Key, const TCHAR* Section = NULL, const TCHAR* Filename = NULL);
	FString String( UBOOL FullyQualified=0 ) const;
	friend FArchive& operator<<( FArchive& Ar, FURL& U );

	// Operators.
	UBOOL operator==( const FURL& Other ) const;

};

struct FLevelStreamingStatus
{
    FName PackageName;
    BITFIELD bShouldBeLoaded:1;
    BITFIELD bShouldBeVisible:1;

		/** Constructors */
		FLevelStreamingStatus(FName InPackageName, UBOOL bInShouldBeLoaded, UBOOL bInShouldBeVisible)
		: PackageName(InPackageName), bShouldBeLoaded(bInShouldBeLoaded), bShouldBeVisible(bInShouldBeVisible)
		{}
		FLevelStreamingStatus()
		{}
    		FLevelStreamingStatus(EEventParm)
		{
			appMemzero(this, sizeof(FLevelStreamingStatus));
		}
	
};

struct FFullyLoadedPackagesInfo
{
    BYTE FullyLoadType;
    FStringNoInit Tag;
    TArrayNoInit<FName> PackagesToLoad;
    TArrayNoInit<class UObject*> LoadedObjects;

    /** Constructors */
    FFullyLoadedPackagesInfo() {}
    FFullyLoadedPackagesInfo(EEventParm)
    {
        appMemzero(this, sizeof(FFullyLoadedPackagesInfo));
    }
};

struct FNamedNetDriver
{
    FName NetDriverName;
    class UNetDriver* NetDriver;

    /** Constructors */
    FNamedNetDriver() {}
    FNamedNetDriver(EEventParm)
    {
        appMemzero(this, sizeof(FNamedNetDriver));
    }
};

class UGameEngine : public UEngine
{
public:
    //## BEGIN PROPS GameEngine
    class UPendingLevel* GPendingLevel;
    FStringNoInit PendingLevelPlayerControllerClassName;
    struct FURL LastURL;
    struct FURL LastRemoteURL;
    TArrayNoInit<FString> ServerActors;
    FStringNoInit TravelURL;
    BYTE TravelType;
    BITFIELD bWorldWasLoadedThisTick:1 GCC_BITFIELD_MAGIC;
    BITFIELD bShouldCommitPendingMapChange:1;
    BITFIELD bShouldSkipLevelStartupEventOnMapCommit:1;
    BITFIELD bShouldSkipLevelBeginningEventOnMapCommit:1;
    BITFIELD bSmoothFrameRate:1;
    BITFIELD bClearAnimSetLinkupCachesOnLoadMap:1;
    class UOnlineSubsystem* OnlineSubsystem;
    TArrayNoInit<FName> LevelsToLoadForPendingMapChange;
    TArrayNoInit<class ULevel*> LoadedLevelsForPendingMapChange;
    FStringNoInit PendingMapChangeFailureDescription;
    FLOAT MaxSmoothedFrameRate;
    FLOAT MinSmoothedFrameRate;
    FLOAT MaxDeltaTime;
    TArrayNoInit<struct FLevelStreamingStatus> PendingLevelStreamingStatusUpdates;
    TArrayNoInit<class UObjectReferencer*> ObjectReferencers;
    TArrayNoInit<struct FFullyLoadedPackagesInfo> PackagesToFullyLoad;
    TArrayNoInit<struct FNamedNetDriver> NamedNetDrivers;
    //## END PROPS GameEngine

    virtual UBOOL CreateNamedNetDriver(FName NetDriverName);
    virtual void DestroyNamedNetDriver(FName NetDriverName);
    DECLARE_FUNCTION(execCreateNamedNetDriver)
    {
        P_GET_NAME(NetDriverName);
        P_FINISH;
        *(UBOOL*)Result=CreateNamedNetDriver(NetDriverName);
    }
    DECLARE_FUNCTION(execDestroyNamedNetDriver)
    {
        P_GET_NAME(NetDriverName);
        P_FINISH;
        DestroyNamedNetDriver(NetDriverName);
    }
    DECLARE_FUNCTION(execGetOnlineSubsystem);
    DECLARE_CLASS(UGameEngine,UEngine,0|CLASS_Transient|CLASS_Config,Engine)
	/**
	* Finds a UNetDriver based on its name.
	*
	* @param NetDriverName The name associated with the driver to find.
	*
	* @return A pointer to the UNetDriver that was found, or NULL if it wasn't found.
	*/
	UNetDriver* FindNamedNetDriver(FName NetDriverName);

	// Constructors.
	UGameEngine();

	/**
	 * Redraws all viewports.
	 */
	void RedrawViewports();

	// UObject interface.
	void FinishDestroy();

	// UEngine interface.
	void Init();

	/**
	 * Called at shutdown, just before the exit purge.
	 */
	virtual void PreExit();

	virtual void Tick( FLOAT DeltaSeconds );
	UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Ar=*GLog );
	void SetClientTravel( const TCHAR* NextURL, ETravelType TravelType );
	virtual FLOAT GetMaxTickRate( FLOAT DeltaTime, UBOOL bAllowFrameRateSmoothing = TRUE );
	virtual void SetProgress( EProgressMessageType MessageType, const FString& Title, const FString& Message );

	/**
	 * Handles freezing/unfreezing of rendering
	 */
	virtual void ProcessToggleFreezeCommand();

	/**
	 * Handles frezing/unfreezing of streaming
	 */
	 virtual void ProcessToggleFreezeStreamingCommand();

	// UGameEngine interface.
	virtual UBOOL Browse( FURL URL, FString& Error );
	virtual UBOOL LoadMap( const FURL& URL, class UPendingLevel* Pending, FString& Error );
	virtual void CancelPending();

	/**
	 * Spawns all of the registered server actors
	 */
	virtual void SpawnServerActors(void);

	/**
	 * Returns the online subsystem object. Returns null if GEngine isn't a
	 * game engine
	 */
	static UOnlineSubsystem* GetOnlineSubsystem(void);

	/**
	 * Creates the online subsystem that was specified in UEngine's
	 * OnlineSubsystemClass. This function is virtual so that licensees
	 * can provide their own version without modifying Epic code.
	 */
	virtual void InitOnlineSubsystem(void);


	// Async map change/ persistent level transition code.

	/**
	 * Prepares the engine for a map change by pre-loading level packages in the background.
	 *
	 * @param	LevelNames	Array of levels to load in the background; the first level in this
	 *						list is assumed to be the new "persistent" one.
	 *
	 * @return	TRUE if all packages were in the package file cache and the operation succeeded,
	 *			FALSE otherwise. FALSE as a return value also indicates that the code has given
	 *			up.
	 */
	UBOOL PrepareMapChange(const TArray<FName>& LevelNames);

	/**
	 * Returns the failure description in case of a failed map change request.
	 *
	 * @return	Human readable failure description in case of failure, empty string otherwise
	 */
	FString GetMapChangeFailureDescription();

	/**
	 * Returns whether we are currently preparing for a map change or not.
	 *
	 * @return TRUE if we are preparing for a map change, FALSE otherwise
	 */
	UBOOL IsPreparingMapChange();

	/**
	 * Returns whether the prepared map change is ready for commit having called.
	 *
	 * @return TRUE if we're ready to commit the map change, FALSE otherwise
	 */
	UBOOL IsReadyForMapChange();

	/**
	 * Finalizes the pending map change that was being kicked off by PrepareMapChange.
	 *
	 * @param bShouldSkipLevelStartupEvent TRUE if this function NOT fire the SeqEvent_LevelBStartup event.
	 * @param bShouldSkipLevelBeginningEvent TRUE if this function NOT fire the SeqEvent_LevelBeginning event. Useful for when skipping to the middle of a map by savegame or something
	 *
	 * @return	TRUE if successful, FALSE if there were errors (use GetMapChangeFailureDescription
	 *			for error description)
	 */
	UBOOL CommitMapChange(UBOOL bShouldSkipLevelStartupEvent=FALSE, UBOOL bShouldSkipLevelBeginningEvent=FALSE);

	/**
	 * Commit map change if requested and map change is pending. Called every frame.
	 */
	void ConditionalCommitMapChange();

	/**
	 * Cancels pending map change.
	 */
	void CancelPendingMapChange();

	/**
	 * Adds a map/package array pair for pacakges to load at LoadMap
	 *
	 * @param FullyLoadType When to load the packages (based on map, gametype, etc)
	 * @param Tag Map/game for which the packages need to be loaded
	 * @param Packages List of package names to fully load when the map is loaded
	 * @param bLoadPackagesForCurrentMap If TRUE, the packages for the currently loaded map will be loaded now
	 */
	void AddPackagesToFullyLoad(EFullyLoadPackageType FullyLoadType, const FString& Tag, const TArray<FName>& Packages, UBOOL bLoadPackagesForCurrentMap);

	/**
	 * Empties the PerMapPackages array, and removes any currently loaded packages from the Root
	 */
	void CleanupAllPackagesToFullyLoad();

	/**
	 * Loads the PerMapPackages for the given map, and adds them to the RootSet
	 *
	 * @param FullyLoadType When to load the packages (based on map, gametype, etc)
	 * @param Tag Name of the map/game to load packages for
	 */
	void LoadPackagesFully(EFullyLoadPackageType FullyLoadType, const FString& Tag);

	/**
	 * Removes the PerMapPackages from the RootSet
	 *
	 * @param FullyLoadType When to load the packages (based on map, gametype, etc)
	 * @param Tag Name of the map/game to cleanup packages for
	 */
	void CleanupPackagesToFullyLoad(EFullyLoadPackageType FullyLoadType, const FString& Tag);
};

#endif // !INCLUDED_ENGINE_GAMEENGINE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UEngine,-1,execAddOverlayWrapped);
AUTOGENERATE_FUNCTION(UEngine,-1,execAddOverlay);
AUTOGENERATE_FUNCTION(UEngine,-1,execRemoveAllOverlays);
AUTOGENERATE_FUNCTION(UEngine,-1,execStopMovie);
AUTOGENERATE_FUNCTION(UEngine,-1,execPlayLoadMapMovie);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetLastMovieName);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetAudioDevice);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsSplitScreen);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetAdditionalFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSubtitleFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetLargeFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetMediumFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSmallFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetTinyFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetBuildDate);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetCurrentWorldInfo);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execGetOnlineSubsystem);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execDestroyNamedNetDriver);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execCreateNamedNetDriver);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_GAMEENGINE_NATIVE_DEFS
#define ENGINE_GAMEENGINE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UEngine);
DECLARE_NATIVE_TYPE(Engine,UGameEngine);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_GAMEENGINE \
	UEngine::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUEngineNative; \
	UGameEngine::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUGameEngineNative; \

#endif // ENGINE_GAMEENGINE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UEngine) GEngineUEngineNatives[] = 
{ 
	MAP_NATIVE(UEngine,execAddOverlayWrapped)
	MAP_NATIVE(UEngine,execAddOverlay)
	MAP_NATIVE(UEngine,execRemoveAllOverlays)
	MAP_NATIVE(UEngine,execStopMovie)
	MAP_NATIVE(UEngine,execPlayLoadMapMovie)
	MAP_NATIVE(UEngine,execGetLastMovieName)
	MAP_NATIVE(UEngine,execGetAudioDevice)
	MAP_NATIVE(UEngine,execIsSplitScreen)
	MAP_NATIVE(UEngine,execGetAdditionalFont)
	MAP_NATIVE(UEngine,execGetSubtitleFont)
	MAP_NATIVE(UEngine,execGetLargeFont)
	MAP_NATIVE(UEngine,execGetMediumFont)
	MAP_NATIVE(UEngine,execGetSmallFont)
	MAP_NATIVE(UEngine,execGetTinyFont)
	MAP_NATIVE(UEngine,execGetBuildDate)
	MAP_NATIVE(UEngine,execGetCurrentWorldInfo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UEngine);

NATIVE_INFO(UGameEngine) GEngineUGameEngineNatives[] = 
{ 
	MAP_NATIVE(UGameEngine,execGetOnlineSubsystem)
	MAP_NATIVE(UGameEngine,execDestroyNamedNetDriver)
	MAP_NATIVE(UGameEngine,execCreateNamedNetDriver)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UGameEngine);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,Engine,TinyFont)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,TempCollisionBackLight)
VERIFY_CLASS_SIZE_NODIE(UEngine)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,GPendingLevel)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,NamedNetDrivers)
VERIFY_CLASS_SIZE_NODIE(UGameEngine)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
