/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_MESH_ENUMS
#define INCLUDED_ENGINE_MESH_ENUMS 1

enum EPhysXDestructibleChunkState
{
    DCS_StaticRoot          =0,
    DCS_StaticChild         =1,
    DCS_DynamicRoot         =2,
    DCS_DynamicChild        =3,
    DCS_Hidden              =4,
    DCS_MAX                 =5,
};

#endif // !INCLUDED_ENGINE_MESH_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(BreakOffIsolatedIslands)
AUTOGENERATE_NAME(BreakOffPartsInRadius)
AUTOGENERATE_NAME(Explode)
AUTOGENERATE_NAME(HideFragmentsToMaximizeMemoryUsage)
AUTOGENERATE_NAME(HideOneFragment)
AUTOGENERATE_NAME(ResetVisibility)
AUTOGENERATE_NAME(ReturnPartActor)
AUTOGENERATE_NAME(SpawnChunkDestroyEffect)
AUTOGENERATE_NAME(SpawnDeferredParts)
AUTOGENERATE_NAME(SpawnEffects)
AUTOGENERATE_NAME(SpawnPartActor)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_MESH_CLASSES
#define INCLUDED_ENGINE_MESH_CLASSES 1

class UFracturedBaseComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS FracturedBaseComponent
protected:
    class FFracturedBaseResources* ComponentBaseResources;
    FRenderCommandFence ReleaseResourcesFence;
    TArrayNoInit<BYTE> VisibleFragments;
    BITFIELD bVisibilityHasChanged:1;
    BITFIELD bVisibilityReset:1;
    BITFIELD bInitialVisibilityValue:1;
    BITFIELD bUseDynamicIndexBuffer:1;
    BITFIELD bUseDynamicIBWithHiddenFragments:1;
private:
    INT NumResourceIndices;
    INT ComponentIndexBufferSize;
protected:
    INT bResetStaticMesh;
public:
    //## END PROPS FracturedBaseComponent

    virtual UBOOL SetStaticMesh(class UStaticMesh* NewMesh,UBOOL bForce=FALSE);
    virtual TArray<BYTE> GetVisibleFragments() const;
    virtual UBOOL IsFragmentVisible(INT FragmentIndex) const;
    virtual INT GetNumFragments() const;
    virtual INT GetNumVisibleFragments() const;
    DECLARE_FUNCTION(execGetVisibleFragments)
    {
        P_FINISH;
        *(TArray<BYTE>*)Result=GetVisibleFragments();
    }
    DECLARE_FUNCTION(execIsFragmentVisible)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=IsFragmentVisible(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetNumFragments)
    {
        P_FINISH;
        *(INT*)Result=GetNumFragments();
    }
    DECLARE_FUNCTION(execGetNumVisibleFragments)
    {
        P_FINISH;
        *(INT*)Result=GetNumVisibleFragments();
    }
    DECLARE_ABSTRACT_CLASS(UFracturedBaseComponent,UStaticMeshComponent,0,Engine)
public:
	//UObject

	/** Blocks until the component's render resources have been released so that they can safely be modified */
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** 
	 * Signals to the object to begin asynchronously releasing resources
	 */
	virtual void BeginDestroy();

	/**
	 * Check for asynchronous resource cleanup completion
	 * @return	TRUE if the rendering resources have been released
	 */
	virtual UBOOL IsReadyForFinishDestroy();

	//Accessors
	INT GetNumVisibleTriangles() const;
	UBOOL GetInitialVisibilityValue() const;

protected:

	/**
	 * Called after all objects referenced by this object have been serialized. Order of PostLoad routed to 
	 * multiple objects loaded in one set is not deterministic though ConditionalPostLoad can be forced to
	 * ensure an object has been "PostLoad"ed.
	 */
	virtual void PostLoad();

	virtual void InitResources();
	virtual void ReleaseResources();
	void ReleaseBaseResources();

	/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
	virtual void Attach();	

	/** Checks if the given fragment is visible. */
	virtual UBOOL IsElementFragmentVisible(INT ElementIndex, INT FragmentIndex, INT InteriorElementIndex, INT CoreFragmentIndex, UBOOL bAnyFragmentsHidden) const;

	/** 
	 * Updates the fragments of this component that are visible.  
	 * @param NewVisibleFragments - visibility factors for this component, corresponding to FracturedStaticMesh's Fragments array
	 * @param bForceUpdate - whether to update this component's resources even if no fragments have changed visibility
	 */
	virtual void UpdateVisibleFragments(const TArray<BYTE>& NewVisibleFragments, UBOOL bForceUpdate);

	/** 
	 * Resets VisibleFragments to bInitialVisibilityValue. 
	 * Does not cause a reattach, so the results won't be propagated to the render thread until the next reattach. 
	 */
	void ResetVisibility();

	/** 
	* Determine if the mesh currently has any hidden fragments
	* @return TRUE if >0 hidden fragments
	*/
	UBOOL HasHiddenFragments() const;

private:

	/** Enqueues a rendering command to update the component's dynamic index buffer. */
	void UpdateComponentIndexBuffer();

	friend class FFracturedBaseSceneProxy;
};

class UFracturedSkinnedMeshComponent : public UFracturedBaseComponent
{
public:
    //## BEGIN PROPS FracturedSkinnedMeshComponent
protected:
    class FFracturedSkinResources* ComponentSkinResources;
    TArrayNoInit<FMatrix> FragmentTransforms;
    TArrayNoInit<class UFracturedStaticMeshComponent*> DependentComponents;
    BITFIELD bBecameVisible:1;
    BITFIELD bFragmentTransformsChanged:1;
public:
    //## END PROPS FracturedSkinnedMeshComponent

    DECLARE_CLASS(UFracturedSkinnedMeshComponent,UFracturedBaseComponent,0,Engine)
public:
	//UPrimitiveComponent
	virtual void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;

	/* Sets the visiblity of a single fragment, and starts a deferred reattach if visiblity changed. */
	void SetFragmentVisibility(INT FragmentIndex, UBOOL bVisibility);

	/* Updates the transform of a single fragment. */
	void SetFragmentTransform(INT FragmentIndex, const FMatrix& LocalToWorld);

	/* Adds a dependent component whose visibility will affect this component's visibility. */
	void RegisterDependentComponent(UFracturedStaticMeshComponent* InComponent);

	/* Removes a dependent component whose visibility will affect this component's visibility. */
	void RemoveDependentComponent(UFracturedStaticMeshComponent* InComponent);

	/** Static: Updates the GPU with bone matrices for this skinned fractured mesh */
	static void UpdateDynamicBoneData_RenderThread(FFracturedSkinResources* ComponentSkinResources, const TArray<FMatrix>& FragmentTransforms);

protected:

	virtual void InitResources();
	virtual void ReleaseResources();
	void ReleaseSkinResources();

	/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
	virtual void Attach();

	virtual void UpdateTransform();

	friend class FFracturedSkinnedMeshSceneProxy;
};

struct FFragmentGroup
{
    TArrayNoInit<INT> FragmentIndices;
    BITFIELD bGroupIsRooted:1;

    /** Constructors */
    FFragmentGroup() {}
    FFragmentGroup(EEventParm)
    {
        appMemzero(this, sizeof(FFragmentGroup));
    }
};

class UFracturedStaticMeshComponent : public UFracturedBaseComponent
{
public:
    //## BEGIN PROPS FracturedStaticMeshComponent
protected:
    TArrayNoInit<BYTE> FragmentNeighborsVisible;
    FBox VisibleBox;
    BITFIELD bUseSkinnedRendering:1;
public:
    BITFIELD bUseVisibleVertsForBounds:1;
    BITFIELD bTopFragmentsRootNonDestroyable:1;
    BITFIELD bBottomFragmentsRootNonDestroyable:1;
    FLOAT TopBottomFragmentDistThreshold;
    class UMaterialInterface* LoseChunkOutsideMaterialOverride;
    FLOAT FragmentBoundsMaxZ;
    FLOAT FragmentBoundsMinZ;
    class UFracturedSkinnedMeshComponent* SkinnedComponent;
    //## END PROPS FracturedStaticMeshComponent

    virtual void SetVisibleFragments(const TArray<BYTE>& VisibilityFactors);
    virtual UBOOL IsFragmentDestroyable(INT FragmentIndex) const;
    virtual UBOOL IsRootFragment(INT FragmentIndex) const;
    virtual UBOOL IsNoPhysFragment(INT FragmentIndex) const;
    virtual FBox GetFragmentBox(INT FragmentIndex) const;
    virtual FVector GetFragmentAverageExteriorNormal(INT FragmentIndex) const;
    virtual INT GetCoreFragmentIndex() const;
    virtual TArray<struct FFragmentGroup> GetFragmentGroups(const TArray<INT>& IgnoreFragments,FLOAT MinConnectionArea) const;
    DECLARE_FUNCTION(execSetVisibleFragments)
    {
        P_GET_TARRAY(BYTE,VisibilityFactors);
        P_FINISH;
        SetVisibleFragments(VisibilityFactors);
    }
    DECLARE_FUNCTION(execIsFragmentDestroyable)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=IsFragmentDestroyable(FragmentIndex);
    }
    DECLARE_FUNCTION(execIsRootFragment)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=IsRootFragment(FragmentIndex);
    }
    DECLARE_FUNCTION(execIsNoPhysFragment)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=IsNoPhysFragment(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetFragmentBox)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(FBox*)Result=GetFragmentBox(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetFragmentAverageExteriorNormal)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(FVector*)Result=GetFragmentAverageExteriorNormal(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetCoreFragmentIndex)
    {
        P_FINISH;
        *(INT*)Result=GetCoreFragmentIndex();
    }
    DECLARE_FUNCTION(execGetFragmentGroups)
    {
        P_GET_TARRAY(INT,IgnoreFragments);
        P_GET_FLOAT(MinConnectionArea);
        P_FINISH;
        *(TArray<struct FFragmentGroup>*)Result=GetFragmentGroups(IgnoreFragments,MinConnectionArea);
    }
    DECLARE_CLASS(UFracturedStaticMeshComponent,UFracturedBaseComponent,0,Engine)
public:
	//UObject
	virtual void Serialize(FArchive& Ar);

	//UPrimitiveComponent
	virtual void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL LineCheck(FCheckResult& Result, const FVector& End, const FVector& Start, const FVector& Extent, DWORD TraceFlags);
	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual void CookPhysConvexDataForScale(ULevel* Level, const FVector& TotalScale3D, INT& TriByteCount, INT& TriMeshCount, INT& HullByteCount, INT& HullCount);
	virtual void CheckForErrors();
	virtual class FDecalRenderData* GenerateDecalRenderData(class FDecalState* Decal) const;

	/** Allocates an implementation of FStaticLightingMesh that will handle static lighting for this component */
	virtual class FStaticMeshStaticLightingMesh* AllocateStaticLightingMesh(INT LODIndex, const TArray<ULightComponent*>& InRelevantLights);

protected:

	/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
	virtual void Attach();

	/** 
	* Detach the component from the scene and remove its render proxy 
	* @param bWillReattach TRUE if the detachment will be followed by an attachment
	*/
	virtual void Detach( UBOOL bWillReattach = FALSE );
	
	/**
	* @return	FALSE since fractured geometry will handle its own decal detachment
	*/
	virtual UBOOL AllowDecalRemovalOnDetach() const
	{
		return FALSE;
	}

	virtual void UpdateTransform();

	/** Update FragmentBoundsMin/MaxZ */
	void UpdateFragmentMinMaxZ();

	/** See if the bTopFragmentsSupportNonDestroyable/bBottomFragmentsSupportNonDestroyable flags indicate this chunk. */
	UBOOL FragmentInstanceIsSupportNonDestroyable(int FragmentIndex) const;

	/** Checks if the given fragment is visible. */
	virtual UBOOL IsElementFragmentVisible(INT ElementIndex, INT FragmentIndex, INT InteriorElementIndex, INT CoreFragmentIndex, UBOOL bAnyFragmentsHidden) const;

	/** 
	 * Updates the fragments of this component that are visible.  
	 * @param NewVisibleFragments - visibility factors for this component, corresponding to FracturedStaticMesh's Fragments array
	 * @param bForceUpdate - whether to update this component's resources even if no fragments have changed visibility
	 */
	virtual void UpdateVisibleFragments(const TArray<BYTE>& NewVisibleFragments, UBOOL bForceUpdate);

	friend class FFracturedStaticMeshSceneProxy;
};

class UPhysXDestructibleComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS PhysXDestructibleComponent
    class URB_BodySetup* DetailedCollision;
    TArrayNoInit<BYTE> Fragmented;
    TArrayNoInit<INT> BoxElemStart;
    TArrayNoInit<INT> ConvexElemStart;
    //## END PROPS PhysXDestructibleComponent

    DECLARE_CLASS(UPhysXDestructibleComponent,UPrimitiveComponent,0,Engine)
	UBOOL							CreateDetailedCollisionFromDestructible( UPhysXDestructible * Destructible, URB_BodySetup * Template );
	
	UBOOL							DestroyStaticFragmentCollision( INT FragmentIndex );

	/* PrimitiveComponent interface */
	virtual class URB_BodySetup*	GetRBBodySetup();
	virtual void InitComponentRBPhys(UBOOL bFixed);
};

struct FDeferredPartToSpawn
{
    INT ChunkIndex;
    FVector InitialVel;
    FVector InitialAngVel;
    FLOAT RelativeScale;
    BITFIELD bExplosion:1;

    /** Constructors */
    FDeferredPartToSpawn() {}
    FDeferredPartToSpawn(EEventParm)
    {
        appMemzero(this, sizeof(FDeferredPartToSpawn));
    }
};

struct FracturedStaticMeshActor_eventHideFragmentsToMaximizeMemoryUsage_Parms
{
    FracturedStaticMeshActor_eventHideFragmentsToMaximizeMemoryUsage_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventHideOneFragment_Parms
{
    FracturedStaticMeshActor_eventHideOneFragment_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventResetVisibility_Parms
{
    FracturedStaticMeshActor_eventResetVisibility_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventBreakOffPartsInRadius_Parms
{
    FVector Origin;
    FLOAT Radius;
    FLOAT RBStrength;
    UBOOL bWantPhysChunksAndParticles;
    FracturedStaticMeshActor_eventBreakOffPartsInRadius_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventExplode_Parms
{
    FracturedStaticMeshActor_eventExplode_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventSpawnDeferredParts_Parms
{
    UBOOL ReturnValue;
    FracturedStaticMeshActor_eventSpawnDeferredParts_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventBreakOffIsolatedIslands_Parms
{
    TArray<BYTE> FragmentVis;
    TArray<INT> IgnoreFrags;
    FVector ChunkDir;
    TArray<class AFracturedStaticMeshPart*> DisableCollWithPart;
    UBOOL bWantPhysChunks;
    FracturedStaticMeshActor_eventBreakOffIsolatedIslands_Parms(EEventParm)
    {
    }
};
class AFracturedStaticMeshActor : public AActor
{
public:
    //## BEGIN PROPS FracturedStaticMeshActor
    INT MaxPartsToSpawnAtOnce;
    class UFracturedStaticMeshComponent* FracturedStaticMeshComponent;
    class UFracturedSkinnedMeshComponent* SkinnedComponent;
    TArrayNoInit<INT> ChunkHealth;
    BITFIELD bBreakChunksOnPawnTouch:1;
    TArrayNoInit<class UClass*> FracturedByDamageType;
    FLOAT ChunkHealthScale;
    TArrayNoInit<class UParticleSystem*> OverrideFragmentDestroyEffects;
    FLOAT FractureCullMinDistance;
    FLOAT FractureCullMaxDistance;
    TArrayNoInit<struct FDeferredPartToSpawn> DeferredPartsToSpawn;
    struct FPhysEffectInfo PartImpactEffect;
    class USoundCue* ExplosionFractureSound;
    class USoundCue* SingleChunkFractureSound;
    //## END PROPS FracturedStaticMeshActor

    virtual class AFracturedStaticMeshPart* SpawnPart(INT ChunkIndex,FVector InitialVel,FVector InitialAngVel,FLOAT RelativeScale,UBOOL bExplosion);
    virtual class AFracturedStaticMeshPart* SpawnPartMulti(const TArray<INT>& ChunkIndices,FVector InitialVel,FVector InitialAngVel,FLOAT RelativeScale,UBOOL bExplosion);
    virtual void RecreatePhysState();
    virtual class UPhysicalMaterial* GetFracturedMeshPhysMaterial();
    virtual void ResetHealth();
    virtual void BreakOffIsolatedIslands(TArray<BYTE>& FragmentVis,const TArray<INT>& IgnoreFrags,FVector ChunkDir,const TArray<class AFracturedStaticMeshPart*>& DisableCollWithPart,UBOOL bWantPhysChunks);
    virtual UBOOL SpawnDeferredParts();
    virtual void RemoveDecals(INT IndexToRemoveDecalsFrom);
    virtual void BreakOffPartsInRadius(FVector Origin,FLOAT Radius,FLOAT RBStrength,UBOOL bWantPhysChunksAndParticles);
    virtual void ResetVisibility();
    DECLARE_FUNCTION(execSpawnPart)
    {
        P_GET_INT(ChunkIndex);
        P_GET_STRUCT(FVector,InitialVel);
        P_GET_STRUCT(FVector,InitialAngVel);
        P_GET_FLOAT(RelativeScale);
        P_GET_UBOOL(bExplosion);
        P_FINISH;
        *(class AFracturedStaticMeshPart**)Result=SpawnPart(ChunkIndex,InitialVel,InitialAngVel,RelativeScale,bExplosion);
    }
    DECLARE_FUNCTION(execSpawnPartMulti)
    {
        P_GET_TARRAY(INT,ChunkIndices);
        P_GET_STRUCT(FVector,InitialVel);
        P_GET_STRUCT(FVector,InitialAngVel);
        P_GET_FLOAT(RelativeScale);
        P_GET_UBOOL(bExplosion);
        P_FINISH;
        *(class AFracturedStaticMeshPart**)Result=SpawnPartMulti(ChunkIndices,InitialVel,InitialAngVel,RelativeScale,bExplosion);
    }
    DECLARE_FUNCTION(execRecreatePhysState)
    {
        P_FINISH;
        RecreatePhysState();
    }
    DECLARE_FUNCTION(execGetFracturedMeshPhysMaterial)
    {
        P_FINISH;
        *(class UPhysicalMaterial**)Result=GetFracturedMeshPhysMaterial();
    }
    DECLARE_FUNCTION(execResetHealth)
    {
        P_FINISH;
        ResetHealth();
    }
    DECLARE_FUNCTION(execBreakOffIsolatedIslands)
    {
        P_GET_TARRAY_REF(BYTE,FragmentVis);
        P_GET_TARRAY(INT,IgnoreFrags);
        P_GET_STRUCT(FVector,ChunkDir);
        P_GET_TARRAY(class AFracturedStaticMeshPart*,DisableCollWithPart);
        P_GET_UBOOL(bWantPhysChunks);
        P_FINISH;
        BreakOffIsolatedIslands(FragmentVis,IgnoreFrags,ChunkDir,DisableCollWithPart,bWantPhysChunks);
    }
    DECLARE_FUNCTION(execSpawnDeferredParts)
    {
        P_FINISH;
        *(UBOOL*)Result=SpawnDeferredParts();
    }
    DECLARE_FUNCTION(execRemoveDecals)
    {
        P_GET_INT(IndexToRemoveDecalsFrom);
        P_FINISH;
        RemoveDecals(IndexToRemoveDecalsFrom);
    }
    DECLARE_FUNCTION(execBreakOffPartsInRadius)
    {
        P_GET_STRUCT(FVector,Origin);
        P_GET_FLOAT(Radius);
        P_GET_FLOAT(RBStrength);
        P_GET_UBOOL(bWantPhysChunksAndParticles);
        P_FINISH;
        BreakOffPartsInRadius(Origin,Radius,RBStrength,bWantPhysChunksAndParticles);
    }
    DECLARE_FUNCTION(execResetVisibility)
    {
        P_FINISH;
        ResetVisibility();
    }
    void eventHideFragmentsToMaximizeMemoryUsage()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_HideFragmentsToMaximizeMemoryUsage),NULL);
    }
    void eventHideOneFragment()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_HideOneFragment),NULL);
    }
    void eventResetVisibility()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResetVisibility),NULL);
    }
    void eventBreakOffPartsInRadius(FVector Origin,FLOAT Radius,FLOAT RBStrength,UBOOL bWantPhysChunksAndParticles)
    {
        FracturedStaticMeshActor_eventBreakOffPartsInRadius_Parms Parms(EC_EventParm);
        Parms.Origin=Origin;
        Parms.Radius=Radius;
        Parms.RBStrength=RBStrength;
        Parms.bWantPhysChunksAndParticles=bWantPhysChunksAndParticles ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_BreakOffPartsInRadius),&Parms);
    }
    void eventExplode()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Explode),NULL);
    }
    UBOOL eventSpawnDeferredParts()
    {
        FracturedStaticMeshActor_eventSpawnDeferredParts_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnDeferredParts),&Parms);
        return Parms.ReturnValue;
    }
    void eventBreakOffIsolatedIslands(TArray<BYTE>& FragmentVis,const TArray<INT>& IgnoreFrags,FVector ChunkDir,const TArray<class AFracturedStaticMeshPart*>& DisableCollWithPart,UBOOL bWantPhysChunks)
    {
        FracturedStaticMeshActor_eventBreakOffIsolatedIslands_Parms Parms(EC_EventParm);
        Parms.FragmentVis=FragmentVis;
        Parms.IgnoreFrags=IgnoreFrags;
        Parms.ChunkDir=ChunkDir;
        Parms.DisableCollWithPart=DisableCollWithPart;
        Parms.bWantPhysChunks=bWantPhysChunks ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_BreakOffIsolatedIslands),&Parms);
        FragmentVis=Parms.FragmentVis;
    }
    DECLARE_CLASS(AFracturedStaticMeshActor,AActor,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual UBOOL InStasis();
};

class AFracturedStaticMeshPart : public AFracturedStaticMeshActor
{
public:
    //## BEGIN PROPS FracturedStaticMeshPart
    FLOAT DestroyPartRadiusFactor;
    class AFracturedStaticMeshActor* BaseFracturedMeshActor;
    BITFIELD bHasBeenRecycled:1;
    BITFIELD bChangeRBChannelWhenAsleep:1;
    BITFIELD bCompositeThatExplodesOnImpact:1;
    FLOAT LastSpawnTime;
    INT PartPoolIndex;
    FLOAT FracPartGravScale;
    BYTE AsleepRBChannel;
    FVector OldVelocity;
    FLOAT CurrentVibrationLevel;
    FLOAT LastImpactSoundTime;
    //## END PROPS FracturedStaticMeshPart

    virtual void Initialize();
    virtual void RecyclePart(UBOOL bAddToFreePool);
    DECLARE_FUNCTION(execInitialize)
    {
        P_FINISH;
        Initialize();
    }
    DECLARE_FUNCTION(execRecyclePart)
    {
        P_GET_UBOOL(bAddToFreePool);
        P_FINISH;
        RecyclePart(bAddToFreePool);
    }
    DECLARE_CLASS(AFracturedStaticMeshPart,AFracturedStaticMeshActor,0,Engine)
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual UBOOL InStasis();
	virtual FLOAT GetGravityZ();
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
#if WITH_NOVODEX
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp, const class NxGroupsMask& GroupsMask, UINT MatIndex);
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp);
#endif // WITH_NOVODEX
};

struct FPhysXDestructibleDepthParameters
{
    BITFIELD bTakeImpactDamage:1;
    BITFIELD bPlaySoundEffect:1;
    BITFIELD bPlayParticleEffect:1;
    BITFIELD bDoNotTimeOut:1;
    BITFIELD bNoKillDummy:1;

    /** Constructors */
    FPhysXDestructibleDepthParameters() {}
    FPhysXDestructibleDepthParameters(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXDestructibleDepthParameters));
    }
};

struct FPhysXDestructibleParameters
{
    FLOAT DamageThreshold;
    FLOAT DamageToRadius;
    FLOAT DamageCap;
    FLOAT ForceToDamage;
    class USoundCue* FractureSound;
    class UParticleSystem* CrumbleParticleSystem;
    FLOAT CrumbleParticleSize;
    BITFIELD bAccumulateDamage:1;
    FLOAT ScaledDamageToRadius;
    TArrayNoInit<struct FPhysXDestructibleDepthParameters> DepthParameters;

    /** Constructors */
    FPhysXDestructibleParameters() {}
    FPhysXDestructibleParameters(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXDestructibleParameters));
    }
};

class UPhysXDestructible : public UObject
{
public:
    //## BEGIN PROPS PhysXDestructible
    class UFracturedStaticMesh* FracturedStaticMesh;
    TArrayNoInit<class UPhysXDestructibleAsset*> DestructibleAssets;
    struct FPhysXDestructibleParameters DestructibleParameters;
    TArrayNoInit<FVector> CookingScales;
    //## END PROPS PhysXDestructible

    DECLARE_CLASS(UPhysXDestructible,UObject,0,Engine)
	/**	Editor change to CookingScales gets applied to all DestructibleAssets */
	UBOOL	ApplyCookingScalesToAssets();
};

struct FSpawnBasis
{
    FVector Location;
    FRotator Rotation;
    FLOAT Scale;

    /** Constructors */
    FSpawnBasis() {}
    FSpawnBasis(EEventParm)
    {
        appMemzero(this, sizeof(FSpawnBasis));
    }
};

struct PhysXDestructibleActor_eventSpawnEffects_Parms
{
    PhysXDestructibleActor_eventSpawnEffects_Parms(EEventParm)
    {
    }
};
class APhysXDestructibleActor : public AFracturedStaticMeshActor
{
public:
    //## BEGIN PROPS PhysXDestructibleActor
    class UPhysXDestructibleComponent* DestructibleComponent;
    class ULightEnvironmentComponent* LightEnvironment;
    class UPhysXDestructible* PhysXDestructible;
    class UPhysXDestructibleStructure* Structure;
    TArrayNoInit<INT> PartFirstChunkIndices;
    TArrayNoInit<class APhysXDestructiblePart*> Parts;
    TArrayNoInit<INT> Neighbors;
    struct FPhysXDestructibleParameters DestructibleParameters;
    FLOAT LinearSize;
    BITFIELD bPlayFractureSound:1;
    BITFIELD bSupportChunksTouchWorld:1;
    BITFIELD bSupportChunksInSupportFragment:1;
    TArrayNoInit<struct FSpawnBasis> EffectBases;
    struct FRBVolumeFill* VolumeFill;
    INT PerFrameProcessBudget;
    INT SupportDepth;
    BYTE NumPartsRemaining;
    //## END PROPS PhysXDestructibleActor

    virtual void Init();
    virtual void Term();
    virtual void NativeSpawnEffects();
    virtual void NativeTakeDamage(INT Damage,class AController* EventInstigator,FVector HitLocation,FVector Momentum,class UClass* DamageType,struct FTraceHitInfo HitInfo=FTraceHitInfo(EC_EventParm),class AActor* DamageCauser=NULL);
    virtual void TakeRadiusDamage(class AController* InstigatedBy,FLOAT BaseDamage,FLOAT DamageRadius,class UClass* DamageType,FLOAT Momentum,FVector HurtOrigin,UBOOL bFullDamage,class AActor* DamageCauser);
    DECLARE_FUNCTION(execInit)
    {
        P_FINISH;
        Init();
    }
    DECLARE_FUNCTION(execTerm)
    {
        P_FINISH;
        Term();
    }
    DECLARE_FUNCTION(execNativeSpawnEffects)
    {
        P_FINISH;
        NativeSpawnEffects();
    }
    DECLARE_FUNCTION(execNativeTakeDamage)
    {
        P_GET_INT(Damage);
        P_GET_OBJECT(AController,EventInstigator);
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_STRUCT(FVector,Momentum);
        P_GET_OBJECT(UClass,DamageType);
        P_GET_STRUCT_OPTX(struct FTraceHitInfo,HitInfo,FTraceHitInfo(EC_EventParm));
        P_GET_OBJECT_OPTX(AActor,DamageCauser,NULL);
        P_FINISH;
        NativeTakeDamage(Damage,EventInstigator,HitLocation,Momentum,DamageType,HitInfo,DamageCauser);
    }
    DECLARE_FUNCTION(execTakeRadiusDamage)
    {
        P_GET_OBJECT(AController,InstigatedBy);
        P_GET_FLOAT(BaseDamage);
        P_GET_FLOAT(DamageRadius);
        P_GET_OBJECT(UClass,DamageType);
        P_GET_FLOAT(Momentum);
        P_GET_STRUCT(FVector,HurtOrigin);
        P_GET_UBOOL(bFullDamage);
        P_GET_OBJECT(AActor,DamageCauser);
        P_FINISH;
        TakeRadiusDamage(InstigatedBy,BaseDamage,DamageRadius,DamageType,Momentum,HurtOrigin,bFullDamage,DamageCauser);
    }
    void eventSpawnEffects()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnEffects),NULL);
    }
    DECLARE_CLASS(APhysXDestructibleActor,AFracturedStaticMeshActor,0,Engine)
	void			SpawnPart( INT FragmentIndex, UBOOL bFixed );
	void			QueueEffects( struct FPhysXDestructibleChunk & Chunk, INT DepthOffset = 0 );
	virtual void	OnRigidBodyCollision( const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData );
	virtual void	PostLoad();
};

#define UCONST_FSM_DEFAULTRECYCLETIME 0.2

struct FractureManager_eventReturnPartActor_Parms
{
    class AFracturedStaticMeshPart* Part;
    FractureManager_eventReturnPartActor_Parms(EEventParm)
    {
    }
};
struct FractureManager_eventSpawnPartActor_Parms
{
    class AFracturedStaticMeshActor* Parent;
    FVector SpawnLocation;
    FRotator SpawnRotation;
    class AFracturedStaticMeshPart* ReturnValue;
    FractureManager_eventSpawnPartActor_Parms(EEventParm)
    {
    }
};
struct FractureManager_eventSpawnChunkDestroyEffect_Parms
{
    class UParticleSystem* Effect;
    FBox ChunkBox;
    FVector ChunkDir;
    FLOAT Scale;
    FractureManager_eventSpawnChunkDestroyEffect_Parms(EEventParm)
    {
    }
};
class AFractureManager : public AActor
{
public:
    //## BEGIN PROPS FractureManager
    INT FSMPartPoolSize;
    BITFIELD bEnableAntiVibration:1;
    BITFIELD bEnableSpawnChunkEffectForRadialDamage:1;
    FLOAT DestroyVibrationLevel;
    FLOAT DestroyMinAngVel;
    FLOAT ExplosionVelScale;
    TArrayNoInit<class AFracturedStaticMeshPart*> PartPool;
    TArrayNoInit<INT> FreeParts;
    TArrayNoInit<class AFracturedStaticMeshActor*> ActorsWithDeferredPartsToSpawn;
    //## END PROPS FractureManager

    virtual FLOAT GetNumFSMPartsScale();
    virtual FLOAT GetFSMDirectSpawnChanceScale();
    virtual FLOAT GetFSMRadialSpawnChanceScale();
    virtual FLOAT GetFSMFractureCullDistanceScale();
    virtual void CreateFSMParts();
    virtual void ResetPoolVisibility();
    virtual class AFracturedStaticMeshPart* GetFSMPart(class AFracturedStaticMeshActor* Parent,FVector SpawnLocation,FRotator SpawnRotation);
    DECLARE_FUNCTION(execGetNumFSMPartsScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetNumFSMPartsScale();
    }
    DECLARE_FUNCTION(execGetFSMDirectSpawnChanceScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetFSMDirectSpawnChanceScale();
    }
    DECLARE_FUNCTION(execGetFSMRadialSpawnChanceScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetFSMRadialSpawnChanceScale();
    }
    DECLARE_FUNCTION(execGetFSMFractureCullDistanceScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetFSMFractureCullDistanceScale();
    }
    DECLARE_FUNCTION(execCreateFSMParts)
    {
        P_FINISH;
        CreateFSMParts();
    }
    DECLARE_FUNCTION(execResetPoolVisibility)
    {
        P_FINISH;
        ResetPoolVisibility();
    }
    DECLARE_FUNCTION(execGetFSMPart)
    {
        P_GET_OBJECT(AFracturedStaticMeshActor,Parent);
        P_GET_STRUCT(FVector,SpawnLocation);
        P_GET_STRUCT(FRotator,SpawnRotation);
        P_FINISH;
        *(class AFracturedStaticMeshPart**)Result=GetFSMPart(Parent,SpawnLocation,SpawnRotation);
    }
    void eventReturnPartActor(class AFracturedStaticMeshPart* Part)
    {
        FractureManager_eventReturnPartActor_Parms Parms(EC_EventParm);
        Parms.Part=Part;
        ProcessEvent(FindFunctionChecked(ENGINE_ReturnPartActor),&Parms);
    }
    class AFracturedStaticMeshPart* eventSpawnPartActor(class AFracturedStaticMeshActor* Parent,FVector SpawnLocation,FRotator SpawnRotation)
    {
        FractureManager_eventSpawnPartActor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Parent=Parent;
        Parms.SpawnLocation=SpawnLocation;
        Parms.SpawnRotation=SpawnRotation;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnPartActor),&Parms);
        return Parms.ReturnValue;
    }
    void eventSpawnChunkDestroyEffect(class UParticleSystem* Effect,FBox ChunkBox,FVector ChunkDir,FLOAT Scale)
    {
        FractureManager_eventSpawnChunkDestroyEffect_Parms Parms(EC_EventParm);
        Parms.Effect=Effect;
        Parms.ChunkBox=ChunkBox;
        Parms.ChunkDir=ChunkDir;
        Parms.Scale=Scale;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnChunkDestroyEffect),&Parms);
    }
    DECLARE_CLASS(AFractureManager,AActor,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void TickSpecial( FLOAT DeltaSeconds );
};

class APhysXDestructiblePart : public AActor
{
public:
    //## BEGIN PROPS PhysXDestructiblePart
    INT FirstChunk;
    INT NumChunks;
    class UPhysXDestructibleStructure* Structure;
    class APhysXDestructibleActor* DestructibleActor;
    class UPhysXDestructibleAsset* DestructibleAsset;
    class ULightEnvironmentComponent* LightEnvironment;
    TArrayNoInit<class USkeletalMeshComponent*> SkeletalMeshComponents;
    TArrayNoInit<BYTE> NumChunksRemaining;
    BYTE NumMeshesRemaining;
    //## END PROPS PhysXDestructiblePart

    virtual void TakeDamage(INT Damage,class AController* EventInstigator,FVector HitLocation,FVector Momentum,class UClass* DamageType,struct FTraceHitInfo HitInfo=FTraceHitInfo(EC_EventParm),class AActor* DamageCauser=NULL);
    virtual void TakeRadiusDamage(class AController* InstigatedBy,FLOAT BaseDamage,FLOAT DamageRadius,class UClass* DamageType,FLOAT Momentum,FVector HurtOrigin,UBOOL bFullDamage,class AActor* DamageCauser);
    DECLARE_FUNCTION(execTakeDamage)
    {
        P_GET_INT(Damage);
        P_GET_OBJECT(AController,EventInstigator);
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_STRUCT(FVector,Momentum);
        P_GET_OBJECT(UClass,DamageType);
        P_GET_STRUCT_OPTX(struct FTraceHitInfo,HitInfo,FTraceHitInfo(EC_EventParm));
        P_GET_OBJECT_OPTX(AActor,DamageCauser,NULL);
        P_FINISH;
        TakeDamage(Damage,EventInstigator,HitLocation,Momentum,DamageType,HitInfo,DamageCauser);
    }
    DECLARE_FUNCTION(execTakeRadiusDamage)
    {
        P_GET_OBJECT(AController,InstigatedBy);
        P_GET_FLOAT(BaseDamage);
        P_GET_FLOAT(DamageRadius);
        P_GET_OBJECT(UClass,DamageType);
        P_GET_FLOAT(Momentum);
        P_GET_STRUCT(FVector,HurtOrigin);
        P_GET_UBOOL(bFullDamage);
        P_GET_OBJECT(AActor,DamageCauser);
        P_FINISH;
        TakeRadiusDamage(InstigatedBy,BaseDamage,DamageRadius,DamageType,Momentum,HurtOrigin,bFullDamage,DamageCauser);
    }
    DECLARE_CLASS(APhysXDestructiblePart,AActor,0,Engine)
	FBox	GetSkeletalMeshComponentsBoundingBox();

	// AActor interface
	virtual void InitRBPhys();
	virtual void TermRBPhys( FRBPhysScene* Scene );
	virtual void SyncActorToRBPhysics();
	virtual void OnRigidBodyCollision( const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData );
};

struct FPhysXDestructibleAssetChunk
{
    INT Index;
    INT FragmentIndex;
    FLOAT Volume;
    FLOAT Size;
    INT Depth;
    INT ParentIndex;
    INT FirstChildIndex;
    INT NumChildren;
    INT MeshIndex;
    INT BoneIndex;
    FName BoneName;
    INT BodyIndex;

    /** Constructors */
    FPhysXDestructibleAssetChunk() {}
    FPhysXDestructibleAssetChunk(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXDestructibleAssetChunk));
    }
};

class UPhysXDestructibleAsset : public UObject
{
public:
    //## BEGIN PROPS PhysXDestructibleAsset
    TArrayNoInit<struct FPhysXDestructibleAssetChunk> ChunkTree;
    TArrayNoInit<class USkeletalMesh*> Meshes;
    TArrayNoInit<class UPhysicsAsset*> Assets;
    INT MaxDepth;
    //## END PROPS PhysXDestructibleAsset

    DECLARE_CLASS(UPhysXDestructibleAsset,UObject,0,Engine)
	void ComputeChunkSurfaceAreaAndVolume( INT ChunkIndex, FLOAT & Area, FLOAT & Volume ) const;
};

struct FPhysXDestructibleChunk
{
    BITFIELD WorldCentroidValid:1;
    BITFIELD WorldMatrixValid:1;
    BITFIELD bCrumble:1;
    BITFIELD IsEnvironmentSupported:1;
    BITFIELD IsRouting:1;
    BITFIELD IsRouteValid:1;
    BITFIELD IsRouteBlocker:1;
    INT ActorIndex;
    INT FragmentIndex;
    INT Index;
    INT MeshIndex;
    INT BoneIndex;
    FName BoneName;
    INT BodyIndex;
    FVector RelativeCentroid;
    FVector WorldCentroid;
    FMatrix RelativeMatrix;
    FMatrix WorldMatrix;
    FLOAT Radius;
    INT ParentIndex;
    INT FirstChildIndex;
    INT NumChildren;
    INT Depth;
    FLOAT Age;
    FLOAT Damage;
    FLOAT Size;
    BYTE CurrentState;
    class UPhysXDestructibleStructure* Structure;
    INT FIFOIndex;
    INT FirstOverlapIndex;
    INT NumOverlaps;
    INT ShortestRoute;
    INT NumSupporters;
    INT NumChildrenDup;

    /** Constructors */
    FPhysXDestructibleChunk() {}
    FPhysXDestructibleChunk(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXDestructibleChunk));
    }
};

struct FPhysXDestructibleOverlap
{
    INT ChunkIndex0;
    INT ChunkIndex1;
    INT Adjacent;

    /** Constructors */
    FPhysXDestructibleOverlap() {}
    FPhysXDestructibleOverlap(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXDestructibleOverlap));
    }
};

class UPhysXDestructibleStructure : public UObject
{
public:
    //## BEGIN PROPS PhysXDestructibleStructure
    class FPhysXDestructibleManager* Manager;
    TArrayNoInit<class APhysXDestructibleActor*> Actors;
    TArrayNoInit<class APhysXDestructibleActor*> ActorKillList;
    TArrayNoInit<struct FPhysXDestructibleChunk> Chunks;
    TArrayNoInit<struct FPhysXDestructibleOverlap> Overlaps;
    TArrayNoInit<INT> Active;
    TArrayNoInit<INT> PseudoSupporterFifo;
    INT PseudoSupporterFifoStart;
    TArrayNoInit<INT> FractureOriginFifo;
    INT FractureOriginFifoStart;
    TArrayNoInit<INT> FractureOriginChunks;
    TArrayNoInit<INT> RouteUpdateArea;
    INT PerFrameProcessBudget;
    TArrayNoInit<INT> PassiveFractureChunks;
    TArrayNoInit<INT> RouteUpdateFifo;
    INT RouteUpdateFifoStart;
    INT SupportDepth;
    //## END PROPS PhysXDestructibleStructure

    virtual UBOOL DamageChunk(INT ChunkIndex,FVector Point,FLOAT BaseDamage,FLOAT Radius,UBOOL bFullDamage,TArray<INT>& Output);
    virtual void FractureChunk(INT ChunkIndex,FVector Point,FVector Impulse,UBOOL bInheritRootVel);
    virtual void CrumbleChunk(INT ChunkIndex);
    virtual FMatrix GetChunkMatrix(INT ChunkIndex);
    virtual FVector GetChunkCentroid(INT ChunkIndex);
    DECLARE_FUNCTION(execDamageChunk)
    {
        P_GET_INT(ChunkIndex);
        P_GET_STRUCT(FVector,Point);
        P_GET_FLOAT(BaseDamage);
        P_GET_FLOAT(Radius);
        P_GET_UBOOL(bFullDamage);
        P_GET_TARRAY_REF(INT,Output);
        P_FINISH;
        *(UBOOL*)Result=DamageChunk(ChunkIndex,Point,BaseDamage,Radius,bFullDamage,Output);
    }
    DECLARE_FUNCTION(execFractureChunk)
    {
        P_GET_INT(ChunkIndex);
        P_GET_STRUCT(FVector,Point);
        P_GET_STRUCT(FVector,Impulse);
        P_GET_UBOOL(bInheritRootVel);
        P_FINISH;
        FractureChunk(ChunkIndex,Point,Impulse,bInheritRootVel);
    }
    DECLARE_FUNCTION(execCrumbleChunk)
    {
        P_GET_INT(ChunkIndex);
        P_FINISH;
        CrumbleChunk(ChunkIndex);
    }
    DECLARE_FUNCTION(execGetChunkMatrix)
    {
        P_GET_INT(ChunkIndex);
        P_FINISH;
        *(FMatrix*)Result=GetChunkMatrix(ChunkIndex);
    }
    DECLARE_FUNCTION(execGetChunkCentroid)
    {
        P_GET_INT(ChunkIndex);
        P_FINISH;
        *(FVector*)Result=GetChunkCentroid(ChunkIndex);
    }
    DECLARE_CLASS(UPhysXDestructibleStructure,UObject,0,Engine)
	/** Update actors within structure, and state of "active" (dynamic) chunks */
	void TickStructure( FLOAT DeltaTime );
	
	/** Apply damage directly to a chunk.  Damage is propagated to other nearby chunks within the structure */
	UBOOL ApplyDamage( INT FirstChunkIndex, INT NumChunks, FLOAT BaseDamage, FLOAT DamageRadius, FLOAT Momentum, FVector HurtOrigin, UBOOL bInheritRootVel, UBOOL bFullDamage );
	
#if WITH_NOVODEX
	/** Return the physical actor for a chunk */
	NxActor* GetChunkNxActor( INT ChunkIndex );
#endif

	/** Return the skeletal mesh component that a chunk lies in */
	USkeletalMeshComponent* GetChunkMesh( int ChunkIndex );
	
	/** Shows the mesh and initializes the RB associated with a chunk.  If InitTM != NULL, uses InitTM for the mesh */
	void ShowChunk( INT ChunkIndex, BOOL bFixed, FMatrix * InitTM = NULL );
	
	/** Hides the mesh and destroys the RB associated with a chunk.  If bRecurse is true, hides all child chunks as well */
	void HideChunk( INT ChunkIndex, UBOOL bRecurse = TRUE );
	
	/** Mark dirty state of chunk */
	void MarkMoved( int ChunkIndex );
	
	/** Changes state of chunk and all children to dynamic */
	void SwitchToDynamic( INT ChunkIndex );
	
	/** Support algorithm */
	void PropagateFracture();
	void AppendFractureOriginFifo(INT ChunkIndex);
	void ExtendRerouteAreaFromPseudoSupporter(TArray<INT>& Area, INT Limit);
	void ExtendRerouteAreaFromFractureOrigin(TArray<INT>& Area, INT Limit);
	void RerouteArea(TArray<INT>& Area);
	void SupportDepthPassiveFracture(INT ChunkIndex);
	
	/** Remove actor from this structure.  Call this instead of destroying the actor directly. */
	UBOOL RemoveActor( APhysXDestructibleActor * Actor );
};

#endif // !INCLUDED_ENGINE_MESH_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execGetNumVisibleFragments);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execGetNumFragments);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execIsFragmentVisible);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execGetVisibleFragments);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execSetStaticMesh);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execResetVisibility);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execBreakOffPartsInRadius);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execRemoveDecals);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execSpawnDeferredParts);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execBreakOffIsolatedIslands);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execResetHealth);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execGetFracturedMeshPhysMaterial);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execRecreatePhysState);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execSpawnPartMulti);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execSpawnPart);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFragmentGroups);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetCoreFragmentIndex);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFragmentAverageExteriorNormal);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFragmentBox);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execIsNoPhysFragment);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execIsRootFragment);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execIsFragmentDestroyable);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execSetVisibleFragments);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshPart,-1,execRecyclePart);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshPart,-1,execInitialize);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMPart);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execResetPoolVisibility);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execCreateFSMParts);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMFractureCullDistanceScale);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMRadialSpawnChanceScale);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMDirectSpawnChanceScale);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetNumFSMPartsScale);
AUTOGENERATE_FUNCTION(APhysXDestructibleActor,-1,execTakeRadiusDamage);
AUTOGENERATE_FUNCTION(APhysXDestructibleActor,-1,execNativeTakeDamage);
AUTOGENERATE_FUNCTION(APhysXDestructibleActor,-1,execNativeSpawnEffects);
AUTOGENERATE_FUNCTION(APhysXDestructibleActor,-1,execTerm);
AUTOGENERATE_FUNCTION(APhysXDestructibleActor,-1,execInit);
AUTOGENERATE_FUNCTION(APhysXDestructiblePart,-1,execTakeRadiusDamage);
AUTOGENERATE_FUNCTION(APhysXDestructiblePart,-1,execTakeDamage);
AUTOGENERATE_FUNCTION(UPhysXDestructibleStructure,-1,execGetChunkCentroid);
AUTOGENERATE_FUNCTION(UPhysXDestructibleStructure,-1,execGetChunkMatrix);
AUTOGENERATE_FUNCTION(UPhysXDestructibleStructure,-1,execCrumbleChunk);
AUTOGENERATE_FUNCTION(UPhysXDestructibleStructure,-1,execFractureChunk);
AUTOGENERATE_FUNCTION(UPhysXDestructibleStructure,-1,execDamageChunk);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_MESH_NATIVE_DEFS
#define ENGINE_MESH_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UFracturedBaseComponent);
DECLARE_NATIVE_TYPE(Engine,UFracturedSkinnedMeshComponent);
DECLARE_NATIVE_TYPE(Engine,AFracturedStaticMeshActor);
DECLARE_NATIVE_TYPE(Engine,UFracturedStaticMeshComponent);
DECLARE_NATIVE_TYPE(Engine,AFracturedStaticMeshPart);
DECLARE_NATIVE_TYPE(Engine,AFractureManager);
DECLARE_NATIVE_TYPE(Engine,UPhysXDestructible);
DECLARE_NATIVE_TYPE(Engine,APhysXDestructibleActor);
DECLARE_NATIVE_TYPE(Engine,UPhysXDestructibleAsset);
DECLARE_NATIVE_TYPE(Engine,UPhysXDestructibleComponent);
DECLARE_NATIVE_TYPE(Engine,APhysXDestructiblePart);
DECLARE_NATIVE_TYPE(Engine,UPhysXDestructibleStructure);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_MESH \
	UFracturedBaseComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUFracturedBaseComponentNative; \
	UFracturedSkinnedMeshComponent::StaticClass(); \
	AFracturedStaticMeshActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAFracturedStaticMeshActorNative; \
	UFracturedStaticMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUFracturedStaticMeshComponentNative; \
	AFracturedStaticMeshPart::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAFracturedStaticMeshPartNative; \
	AFractureManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAFractureManagerNative; \
	UPhysXDestructible::StaticClass(); \
	APhysXDestructibleActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPhysXDestructibleActorNative; \
	UPhysXDestructibleAsset::StaticClass(); \
	UPhysXDestructibleComponent::StaticClass(); \
	APhysXDestructiblePart::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPhysXDestructiblePartNative; \
	UPhysXDestructibleStructure::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPhysXDestructibleStructureNative; \

#endif // ENGINE_MESH_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UFracturedBaseComponent) GEngineUFracturedBaseComponentNatives[] = 
{ 
	MAP_NATIVE(UFracturedBaseComponent,execGetNumVisibleFragments)
	MAP_NATIVE(UFracturedBaseComponent,execGetNumFragments)
	MAP_NATIVE(UFracturedBaseComponent,execIsFragmentVisible)
	MAP_NATIVE(UFracturedBaseComponent,execGetVisibleFragments)
	MAP_NATIVE(UFracturedBaseComponent,execSetStaticMesh)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UFracturedBaseComponent);

NATIVE_INFO(AFracturedStaticMeshActor) GEngineAFracturedStaticMeshActorNatives[] = 
{ 
	MAP_NATIVE(AFracturedStaticMeshActor,execResetVisibility)
	MAP_NATIVE(AFracturedStaticMeshActor,execBreakOffPartsInRadius)
	MAP_NATIVE(AFracturedStaticMeshActor,execRemoveDecals)
	MAP_NATIVE(AFracturedStaticMeshActor,execSpawnDeferredParts)
	MAP_NATIVE(AFracturedStaticMeshActor,execBreakOffIsolatedIslands)
	MAP_NATIVE(AFracturedStaticMeshActor,execResetHealth)
	MAP_NATIVE(AFracturedStaticMeshActor,execGetFracturedMeshPhysMaterial)
	MAP_NATIVE(AFracturedStaticMeshActor,execRecreatePhysState)
	MAP_NATIVE(AFracturedStaticMeshActor,execSpawnPartMulti)
	MAP_NATIVE(AFracturedStaticMeshActor,execSpawnPart)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AFracturedStaticMeshActor);

NATIVE_INFO(UFracturedStaticMeshComponent) GEngineUFracturedStaticMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UFracturedStaticMeshComponent,execGetFragmentGroups)
	MAP_NATIVE(UFracturedStaticMeshComponent,execGetCoreFragmentIndex)
	MAP_NATIVE(UFracturedStaticMeshComponent,execGetFragmentAverageExteriorNormal)
	MAP_NATIVE(UFracturedStaticMeshComponent,execGetFragmentBox)
	MAP_NATIVE(UFracturedStaticMeshComponent,execIsNoPhysFragment)
	MAP_NATIVE(UFracturedStaticMeshComponent,execIsRootFragment)
	MAP_NATIVE(UFracturedStaticMeshComponent,execIsFragmentDestroyable)
	MAP_NATIVE(UFracturedStaticMeshComponent,execSetVisibleFragments)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UFracturedStaticMeshComponent);

NATIVE_INFO(AFracturedStaticMeshPart) GEngineAFracturedStaticMeshPartNatives[] = 
{ 
	MAP_NATIVE(AFracturedStaticMeshPart,execRecyclePart)
	MAP_NATIVE(AFracturedStaticMeshPart,execInitialize)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AFracturedStaticMeshPart);

NATIVE_INFO(AFractureManager) GEngineAFractureManagerNatives[] = 
{ 
	MAP_NATIVE(AFractureManager,execGetFSMPart)
	MAP_NATIVE(AFractureManager,execResetPoolVisibility)
	MAP_NATIVE(AFractureManager,execCreateFSMParts)
	MAP_NATIVE(AFractureManager,execGetFSMFractureCullDistanceScale)
	MAP_NATIVE(AFractureManager,execGetFSMRadialSpawnChanceScale)
	MAP_NATIVE(AFractureManager,execGetFSMDirectSpawnChanceScale)
	MAP_NATIVE(AFractureManager,execGetNumFSMPartsScale)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AFractureManager);

NATIVE_INFO(APhysXDestructibleActor) GEngineAPhysXDestructibleActorNatives[] = 
{ 
	MAP_NATIVE(APhysXDestructibleActor,execTakeRadiusDamage)
	MAP_NATIVE(APhysXDestructibleActor,execNativeTakeDamage)
	MAP_NATIVE(APhysXDestructibleActor,execNativeSpawnEffects)
	MAP_NATIVE(APhysXDestructibleActor,execTerm)
	MAP_NATIVE(APhysXDestructibleActor,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APhysXDestructibleActor);

NATIVE_INFO(APhysXDestructiblePart) GEngineAPhysXDestructiblePartNatives[] = 
{ 
	MAP_NATIVE(APhysXDestructiblePart,execTakeRadiusDamage)
	MAP_NATIVE(APhysXDestructiblePart,execTakeDamage)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APhysXDestructiblePart);

NATIVE_INFO(UPhysXDestructibleStructure) GEngineUPhysXDestructibleStructureNatives[] = 
{ 
	MAP_NATIVE(UPhysXDestructibleStructure,execGetChunkCentroid)
	MAP_NATIVE(UPhysXDestructibleStructure,execGetChunkMatrix)
	MAP_NATIVE(UPhysXDestructibleStructure,execCrumbleChunk)
	MAP_NATIVE(UPhysXDestructibleStructure,execFractureChunk)
	MAP_NATIVE(UPhysXDestructibleStructure,execDamageChunk)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPhysXDestructibleStructure);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,FracturedBaseComponent,ComponentBaseResources)
VERIFY_CLASS_OFFSET_NODIE(U,FracturedBaseComponent,bResetStaticMesh)
VERIFY_CLASS_SIZE_NODIE(UFracturedBaseComponent)
VERIFY_CLASS_OFFSET_NODIE(U,FracturedSkinnedMeshComponent,ComponentSkinResources)
VERIFY_CLASS_OFFSET_NODIE(U,FracturedSkinnedMeshComponent,DependentComponents)
VERIFY_CLASS_SIZE_NODIE(UFracturedSkinnedMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,FracturedStaticMeshActor,MaxPartsToSpawnAtOnce)
VERIFY_CLASS_OFFSET_NODIE(A,FracturedStaticMeshActor,SingleChunkFractureSound)
VERIFY_CLASS_SIZE_NODIE(AFracturedStaticMeshActor)
VERIFY_CLASS_OFFSET_NODIE(U,FracturedStaticMeshComponent,FragmentNeighborsVisible)
VERIFY_CLASS_OFFSET_NODIE(U,FracturedStaticMeshComponent,SkinnedComponent)
VERIFY_CLASS_SIZE_NODIE(UFracturedStaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,FracturedStaticMeshPart,DestroyPartRadiusFactor)
VERIFY_CLASS_OFFSET_NODIE(A,FracturedStaticMeshPart,LastImpactSoundTime)
VERIFY_CLASS_SIZE_NODIE(AFracturedStaticMeshPart)
VERIFY_CLASS_OFFSET_NODIE(A,FractureManager,FSMPartPoolSize)
VERIFY_CLASS_OFFSET_NODIE(A,FractureManager,ActorsWithDeferredPartsToSpawn)
VERIFY_CLASS_SIZE_NODIE(AFractureManager)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructible,FracturedStaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructible,CookingScales)
VERIFY_CLASS_SIZE_NODIE(UPhysXDestructible)
VERIFY_CLASS_OFFSET_NODIE(A,PhysXDestructibleActor,DestructibleComponent)
VERIFY_CLASS_OFFSET_NODIE(A,PhysXDestructibleActor,NumPartsRemaining)
VERIFY_CLASS_SIZE_NODIE(APhysXDestructibleActor)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructibleAsset,ChunkTree)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructibleAsset,MaxDepth)
VERIFY_CLASS_SIZE_NODIE(UPhysXDestructibleAsset)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructibleComponent,DetailedCollision)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructibleComponent,ConvexElemStart)
VERIFY_CLASS_SIZE_NODIE(UPhysXDestructibleComponent)
VERIFY_CLASS_OFFSET_NODIE(A,PhysXDestructiblePart,FirstChunk)
VERIFY_CLASS_OFFSET_NODIE(A,PhysXDestructiblePart,NumMeshesRemaining)
VERIFY_CLASS_SIZE_NODIE(APhysXDestructiblePart)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructibleStructure,Manager)
VERIFY_CLASS_OFFSET_NODIE(U,PhysXDestructibleStructure,SupportDepth)
VERIFY_CLASS_SIZE_NODIE(UPhysXDestructibleStructure)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
