/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#include "EngineUIPrivateGlobalIncludes.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_UIPRIVATE_ENUMS
#define INCLUDED_ENGINE_UIPRIVATE_ENUMS 1

enum EFadeType
{
    EFT_None                =0,
    EFT_Fading              =1,
    EFT_Pulsing             =2,
    EFT_MAX                 =3,
};
enum EUIAnimNotifyType
{
    EANT_WidgetFunction     =0,
    EANT_SceneFunction      =1,
    EANT_KismetEvent        =2,
    EANT_Sound              =3,
    EANT_MAX                =4,
};
enum EUIAnimationLoopMode
{
    UIANIMLOOP_None         =0,
    UIANIMLOOP_Continuous   =1,
    UIANIMLOOP_Bounce       =2,
    UIANIMLOOP_MAX          =3,
};
enum EUIAnimationInterpMode
{
    UIANIMMODE_Linear       =0,
    UIANIMMODE_EaseIn       =1,
    UIANIMMODE_EaseOut      =2,
    UIANIMMODE_EaseInOut    =3,
    UIANIMMODE_MAX          =4,
};
enum EUIAnimType
{
    EAT_None                =0,
    EAT_Position            =1,
    EAT_PositionOffset      =2,
    EAT_RelPosition         =3,
    EAT_Rotation            =4,
    EAT_RelRotation         =5,
    EAT_Color               =6,
    EAT_Opacity             =7,
    EAT_Visibility          =8,
    EAT_Scale               =9,
    EAT_Left                =10,
    EAT_Top                 =11,
    EAT_Right               =12,
    EAT_Bottom              =13,
    EAT_PPBloom             =14,
    EAT_PPBlurSampleSize    =15,
    EAT_PPBlurAmount        =16,
    EAT_MAX                 =17,
};
enum EProviderAccessType
{
    ACCESS_ReadOnly         =0,
    ACCESS_PerField         =1,
    ACCESS_WriteAll         =2,
    ACCESS_MAX              =3,
};
enum EStatsFetchType
{
    SFT_Player              =0,
    SFT_CenteredOnPlayer    =1,
    SFT_Friends             =2,
    SFT_TopRankings         =3,
    SFT_MAX                 =4,
};
enum EMenuOptionType
{
    MENUOT_ComboReadOnly    =0,
    MENUOT_ComboNumeric     =1,
    MENUOT_CheckBox         =2,
    MENUOT_Slider           =3,
    MENUOT_Spinner          =4,
    MENUOT_EditBox          =5,
    MENUOT_CollectionCheckBox=6,
    MENUOT_CollapsingList   =7,
    MENUOT_MAX              =8,
};
enum ECalloutButtonLayoutType
{
    CBLT_None               =0,
    CBLT_DockLeft           =1,
    CBLT_DockRight          =2,
    CBLT_Centered           =3,
    CBLT_Justified          =4,
    CBLT_MAX                =5,
};
enum EFrameBoxImage
{
    FBI_TopLeft             =0,
    FBI_Top                 =1,
    FBI_TopRight            =2,
    FBI_CenterLeft          =3,
    FBI_Center              =4,
    FBI_CenterRight         =5,
    FBI_BottomLeft          =6,
    FBI_Bottom              =7,
    FBI_BottomRight         =8,
    FBI_MAX                 =9,
};
enum ESafeRegionType
{
    ESRT_FullRegion         =0,
    ESRT_TextSafeRegion     =1,
    ESRT_MAX                =2,
};
enum EListWrapBehavior
{
    LISTWRAP_None           =0,
    LISTWRAP_Smooth         =1,
    LISTWRAP_Jump           =2,
    LISTWRAP_MAX            =3,
};
enum ECellLinkType
{
    LINKED_None             =0,
    LINKED_Rows             =1,
    LINKED_Columns          =2,
    LINKED_MAX              =3,
};
enum ECellAutoSizeMode
{
    CELLAUTOSIZE_None       =0,
    CELLAUTOSIZE_Uniform    =1,
    CELLAUTOSIZE_Constrain  =2,
    CELLAUTOSIZE_AdjustList =3,
    CELLAUTOSIZE_MAX        =4,
};
enum EContextMenuItemType
{
    CMIT_Normal             =0,
    CMIT_Submenu            =1,
    CMIT_Separator          =2,
    CMIT_Check              =3,
    CMIT_Radio              =4,
    CMIT_MAX                =5,
};
enum EUITabAutosizeType
{
    TAST_Manual             =0,
    TAST_Fill               =1,
    TAST_Auto               =2,
    TAST_MAX                =3,
};

#endif // !INCLUDED_ENGINE_UIPRIVATE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(ActivateFocusHint)
AUTOGENERATE_NAME(ActivateKeyFrameCompletedDelegates)
AUTOGENERATE_NAME(ActivateNextPage)
AUTOGENERATE_NAME(ActivatePage)
AUTOGENERATE_NAME(ActivatePreviousPage)
AUTOGENERATE_NAME(ActivateToolTip)
AUTOGENERATE_NAME(ActivateTrackCompletedDelegates)
AUTOGENERATE_NAME(AddedChild)
AUTOGENERATE_NAME(AllMutexesDisabled)
AUTOGENERATE_NAME(AllowPublishingToField)
AUTOGENERATE_NAME(CalculateInputMask)
AUTOGENERATE_NAME(CanButtonAcceptFocus)
AUTOGENERATE_NAME(CanShowToolTip)
AUTOGENERATE_NAME(CanShowToolTips)
AUTOGENERATE_NAME(CanSupportComplexPropertyType)
AUTOGENERATE_NAME(ClearMenuItems)
AUTOGENERATE_NAME(ClearUIAnimationLoop)
AUTOGENERATE_NAME(CloseScene)
AUTOGENERATE_NAME(ContainsButton)
AUTOGENERATE_NAME(CreateCustomComboButton)
AUTOGENERATE_NAME(CreateCustomComboEditbox)
AUTOGENERATE_NAME(CreateCustomComboList)
AUTOGENERATE_NAME(CreateCustomDecrementButton)
AUTOGENERATE_NAME(CreateCustomIncrementButton)
AUTOGENERATE_NAME(CreateGame)
AUTOGENERATE_NAME(CreateTabButton)
AUTOGENERATE_NAME(DeactivateToolTip)
AUTOGENERATE_NAME(DecrementAllMutexes)
AUTOGENERATE_NAME(DisablePlayerInput)
AUTOGENERATE_NAME(DisableSetIndex)
AUTOGENERATE_NAME(DisableValueChangeNotification)
AUTOGENERATE_NAME(EnableAutoSizing)
AUTOGENERATE_NAME(EnableButton)
AUTOGENERATE_NAME(EnablePlayerInput)
AUTOGENERATE_NAME(EnableSetIndex)
AUTOGENERATE_NAME(EnableTabPage)
AUTOGENERATE_NAME(EnableValueChangeNotification)
AUTOGENERATE_NAME(FindButton)
AUTOGENERATE_NAME(FindButtonIndex)
AUTOGENERATE_NAME(FindMenuItemIndex)
AUTOGENERATE_NAME(GenerateCompleteCaptionMarkup)
AUTOGENERATE_NAME(GenerateFillerData)
AUTOGENERATE_NAME(GenerateScriptMarkupString)
AUTOGENERATE_NAME(GetActiveGameSearch)
AUTOGENERATE_NAME(GetAllMenuItems)
AUTOGENERATE_NAME(GetCachedPlayerProfile)
AUTOGENERATE_NAME(GetCalloutDataStoreName)
AUTOGENERATE_NAME(GetCalloutMarkupString)
AUTOGENERATE_NAME(GetCaption)
AUTOGENERATE_NAME(GetCellFieldType)
AUTOGENERATE_NAME(GetCellFieldValue)
AUTOGENERATE_NAME(GetCurrentGameSearch)
AUTOGENERATE_NAME(GetCurrentGameSettings)
AUTOGENERATE_NAME(GetCurrentProvider)
AUTOGENERATE_NAME(GetCustomPropertyValue)
AUTOGENERATE_NAME(GetElementCellSchemaProvider)
AUTOGENERATE_NAME(GetElementCellTags)
AUTOGENERATE_NAME(GetElementCellValueProvider)
AUTOGENERATE_NAME(GetElementCount)
AUTOGENERATE_NAME(GetElementProviderTags)
AUTOGENERATE_NAME(GetFieldValue)
AUTOGENERATE_NAME(GetFocusHint)
AUTOGENERATE_NAME(GetListElements)
AUTOGENERATE_NAME(GetMenuItem)
AUTOGENERATE_NAME(GetSceneInputModeOverride)
AUTOGENERATE_NAME(GetSearchResultFromIndex)
AUTOGENERATE_NAME(GetSupportedScriptFields)
AUTOGENERATE_NAME(GetSupportedUIActionKeyNames)
AUTOGENERATE_NAME(HideList)
AUTOGENERATE_NAME(IncrementAllMutexes)
AUTOGENERATE_NAME(Initialized)
AUTOGENERATE_NAME(InitializeProvider)
AUTOGENERATE_NAME(InsertButton)
AUTOGENERATE_NAME(InsertMenuItem)
AUTOGENERATE_NAME(InsertPage)
AUTOGENERATE_NAME(IsActivationAllowed)
AUTOGENERATE_NAME(IsAnimating)
AUTOGENERATE_NAME(IsCollectionDataType)
AUTOGENERATE_NAME(IsElementEnabled)
AUTOGENERATE_NAME(IsGamepadConnected)
AUTOGENERATE_NAME(IsProviderDisabled)
AUTOGENERATE_NAME(IsSetIndexEnabled)
AUTOGENERATE_NAME(IsValidDataSourceClass)
AUTOGENERATE_NAME(IsValueChangeNotificationEnabled)
AUTOGENERATE_NAME(LinkToTabButton)
AUTOGENERATE_NAME(MatchesStyleData)
AUTOGENERATE_NAME(MoveToNext)
AUTOGENERATE_NAME(MoveToPrevious)
AUTOGENERATE_NAME(NotifyActiveSkinChanged)
AUTOGENERATE_NAME(NotifyActiveStateChanged)
AUTOGENERATE_NAME(NotifyPositionChanged)
AUTOGENERATE_NAME(NotifyPropertyChanged)
AUTOGENERATE_NAME(NotifyResolutionChanged)
AUTOGENERATE_NAME(NotifyVisibilityChanged)
AUTOGENERATE_NAME(OnAddTeamProvider)
AUTOGENERATE_NAME(OnButtonDragged)
AUTOGENERATE_NAME(OnClicked)
AUTOGENERATE_NAME(OnClickedScrollZone)
AUTOGENERATE_NAME(OnCloseContextMenu)
AUTOGENERATE_NAME(OnContextMenuItemSelected)
AUTOGENERATE_NAME(OnCreate)
AUTOGENERATE_NAME(OnDataProviderPropertyChange)
AUTOGENERATE_NAME(OnDataStoreValueUpdated)
AUTOGENERATE_NAME(OnDoubleClick)
AUTOGENERATE_NAME(OnFadeComplete)
AUTOGENERATE_NAME(OnInitialSceneUpdate)
AUTOGENERATE_NAME(OnIsCurrValueValid)
AUTOGENERATE_NAME(OnListElementsSorted)
AUTOGENERATE_NAME(OnOpenContextMenu)
AUTOGENERATE_NAME(OnOverrideListElementState)
AUTOGENERATE_NAME(OnPageActivated)
AUTOGENERATE_NAME(OnPageInserted)
AUTOGENERATE_NAME(OnPageRemoved)
AUTOGENERATE_NAME(OnPostSceneUpdate)
AUTOGENERATE_NAME(OnPreSceneUpdate)
AUTOGENERATE_NAME(OnPressed)
AUTOGENERATE_NAME(OnPressRelease)
AUTOGENERATE_NAME(OnPressRepeat)
AUTOGENERATE_NAME(OnProcessInputAxis)
AUTOGENERATE_NAME(OnProcessInputKey)
AUTOGENERATE_NAME(OnQueryBeginAnimation_DisableInput)
AUTOGENERATE_NAME(OnQueryCloseSceneAllowed)
AUTOGENERATE_NAME(OnQueryEndAnimation_EnableInput)
AUTOGENERATE_NAME(OnQueryToolTip)
AUTOGENERATE_NAME(OnRawInputAxis)
AUTOGENERATE_NAME(OnRawInputKey)
AUTOGENERATE_NAME(OnRefreshDataFieldValue)
AUTOGENERATE_NAME(OnRefreshSubscriberValue)
AUTOGENERATE_NAME(OnRegister)
AUTOGENERATE_NAME(OnSceneActivated)
AUTOGENERATE_NAME(OnSceneDeactivated)
AUTOGENERATE_NAME(OnScriptTick)
AUTOGENERATE_NAME(OnScrollActivity)
AUTOGENERATE_NAME(OnSubmitSelection)
AUTOGENERATE_NAME(OnSubmitText)
AUTOGENERATE_NAME(OnTopSceneChanged)
AUTOGENERATE_NAME(OnUIAnim_KeyFrameCompleted)
AUTOGENERATE_NAME(OnUIAnim_TrackCompleted)
AUTOGENERATE_NAME(OnUnregister)
AUTOGENERATE_NAME(OnValueChanged)
AUTOGENERATE_NAME(OpenScene)
AUTOGENERATE_NAME(OverrideListSort)
AUTOGENERATE_NAME(PauseGame)
AUTOGENERATE_NAME(PlayUIAnimation)
AUTOGENERATE_NAME(PostInitialize)
AUTOGENERATE_NAME(PrivateActivatePage)
AUTOGENERATE_NAME(ProviderClientBound)
AUTOGENERATE_NAME(ProviderClientUnbound)
AUTOGENERATE_NAME(ProviderInstanceBound)
AUTOGENERATE_NAME(ProviderInstanceUnbound)
AUTOGENERATE_NAME(RefreshFriendsList)
AUTOGENERATE_NAME(RefreshStats)
AUTOGENERATE_NAME(RefreshSubscribers)
AUTOGENERATE_NAME(Registered)
AUTOGENERATE_NAME(RemoveAllButtons)
AUTOGENERATE_NAME(RemoveButton)
AUTOGENERATE_NAME(RemoveButtonByAlias)
AUTOGENERATE_NAME(RemovedChild)
AUTOGENERATE_NAME(RemovedFromParent)
AUTOGENERATE_NAME(RemoveMenuItem)
AUTOGENERATE_NAME(RemoveMenuItemAtIndex)
AUTOGENERATE_NAME(RemovePage)
AUTOGENERATE_NAME(ReplacePage)
AUTOGENERATE_NAME(SaveProfileData)
AUTOGENERATE_NAME(SceneActivated)
AUTOGENERATE_NAME(SceneDeactivated)
AUTOGENERATE_NAME(ScriptTick)
AUTOGENERATE_NAME(ScrollZoneClicked)
AUTOGENERATE_NAME(SetAutoSizePadding)
AUTOGENERATE_NAME(SetButtonCallback)
AUTOGENERATE_NAME(SetButtonCaption)
AUTOGENERATE_NAME(SetButtonInputAlias)
AUTOGENERATE_NAME(SetCurrentByIndex)
AUTOGENERATE_NAME(SetCurrentByName)
AUTOGENERATE_NAME(SetFieldValue)
AUTOGENERATE_NAME(SetInputAlias)
AUTOGENERATE_NAME(SetMenuItems)
AUTOGENERATE_NAME(SetVisibility)
AUTOGENERATE_NAME(ShouldDisableElement)
AUTOGENERATE_NAME(ShouldModulateBackgroundAlpha)
AUTOGENERATE_NAME(ShowButton)
AUTOGENERATE_NAME(ShowGamercard)
AUTOGENERATE_NAME(ShowHostGamercard)
AUTOGENERATE_NAME(ShowList)
AUTOGENERATE_NAME(StopUIAnimation)
AUTOGENERATE_NAME(SubmitGameSearch)
AUTOGENERATE_NAME(SubscriberAttached)
AUTOGENERATE_NAME(SubscriberDetached)
AUTOGENERATE_NAME(SynchronizeInputAliases)
AUTOGENERATE_NAME(SynchronizePlayers)
AUTOGENERATE_NAME(UIAnimationEnded)
AUTOGENERATE_NAME(UIAnimationStarted)
AUTOGENERATE_NAME(Unregistered)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_UIPRIVATE_CLASSES
#define INCLUDED_ENGINE_UIPRIVATE_CLASSES 1

class UUIComp_AutoAlignment : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_AutoAlignment
    BYTE HorzAlignment;
    BYTE VertAlignment;
    //## END PROPS UIComp_AutoAlignment

    DECLARE_CLASS(UUIComp_AutoAlignment,UUIComponent,0,Engine)
    DECLARE_WITHIN(UUIObject)
	/**
	 * Adds the specified face to the owning scene's DockingStack for the owning widget.  Takes wrap behavior and
	 * autosizing into account, ensuring that all widget faces are added to the scene's docking stack in the appropriate
	 * order.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual void AddDockingNode( TLookupMap<FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Adjusts the child widget's positions according to the specified autoalignment setting
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Converts the value of the Vertical and Horizontal alignment
	 */
	virtual void Serialize( FArchive& Ar );

protected:
	/**
	 *	Updates the horizontal position of child widgets according to the specified alignment setting
	 *
	 * @param	ContainerWidget			The widget to whose bounds the widgets will be aligned
	 * @param	HorizontalAlignment		The horizontal alignment setting
	 */
	void AlignWidgetsHorizontally( UUIObject* ContainerWidget, EUIAlignment HorizontalAlignment );

	/**
	 *	Updates the vertical position of child widgets according to the specified alignment setting
	 *
	 * @param	ContainerWidget			The widget to whose bounds the widgets will be aligned
	 * @param	VerticalAlignment		The vertical alignment setting
	 */
	void AlignWidgetsVertically( UUIObject* ContainerWidget, EUIAlignment VerticalAlignment );
};

struct UIComp_DrawComponents_eventOnFadeComplete_Parms
{
    class UUIComp_DrawComponents* Sender;
    UIComp_DrawComponents_eventOnFadeComplete_Parms(EEventParm)
    {
    }
};
class UUIComp_DrawComponents : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_DrawComponents
    BYTE FadeType;
    FLOAT FadeAlpha;
    FLOAT FadeTarget;
    FLOAT FadeTime;
    FLOAT LastRenderTime;
    FLOAT FadeRate;
    FScriptDelegate __OnFadeComplete__Delegate;
    //## END PROPS UIComp_DrawComponents

    void Fade(FLOAT FromAlpha,FLOAT ToAlpha,FLOAT TargetFadeTime);
    void Pulse(FLOAT MaxAlpha=1.000000,FLOAT MinAlpha=0.000000,FLOAT PulseRate=1.000000);
    void ResetFade();
    DECLARE_FUNCTION(execFade)
    {
        P_GET_FLOAT(FromAlpha);
        P_GET_FLOAT(ToAlpha);
        P_GET_FLOAT(TargetFadeTime);
        P_FINISH;
        Fade(FromAlpha,ToAlpha,TargetFadeTime);
    }
    DECLARE_FUNCTION(execPulse)
    {
        P_GET_FLOAT_OPTX(MaxAlpha,1.000000);
        P_GET_FLOAT_OPTX(MinAlpha,0.000000);
        P_GET_FLOAT_OPTX(PulseRate,1.000000);
        P_FINISH;
        Pulse(MaxAlpha,MinAlpha,PulseRate);
    }
    DECLARE_FUNCTION(execResetFade)
    {
        P_FINISH;
        ResetFade();
    }
    void delegateOnFadeComplete(class UUIComp_DrawComponents* Sender)
    {
        UIComp_DrawComponents_eventOnFadeComplete_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_OnFadeComplete,&__OnFadeComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UUIComp_DrawComponents,UUIComponent,0,Engine)
    DECLARE_WITHIN(UUIObject)
	/**
	 * @Returns true if an update is needed
	 * @Param	FadeValue - In: The current Alpha, Out: The New Alpha
	 */
	UBOOL UpdateFade(FLOAT& FadeAlpha);
};

class UUIDataStoreSubscriber : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIDataStoreSubscriber,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStoreSubscriber)
};

class IUIDataStoreSubscriber
{
protected:
	virtual ~IUIDataStoreSubscriber() {}
public:
	typedef UUIDataStoreSubscriber UClassType;
	virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber()=0;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1)=0;
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const=0;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1)=0;
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex)=0;
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores)=0;
    virtual void ClearBoundDataStores()=0;
    NO_DEFAULT_CONSTRUCTOR(IUIDataStoreSubscriber)
};

class UUIDataStorePublisher : public UUIDataStoreSubscriber
{
public:
    DECLARE_ABSTRACT_CLASS(UUIDataStorePublisher,UUIDataStoreSubscriber,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStorePublisher)
};

class IUIDataStorePublisher : public IUIDataStoreSubscriber
{
protected:
	virtual ~IUIDataStorePublisher() {}
public:
	typedef UUIDataStorePublisher UClassType;
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIDataStorePublisher)
};

#define UCONST_UnknownCellDataFieldName NAME_None

class UUIListElementCellProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIListElementCellProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIListElementCellProvider)
};

class IUIListElementCellProvider
{
protected:
	virtual ~IUIListElementCellProvider() {}
public:
	typedef UUIListElementCellProvider UClassType;
	virtual UObject* GetUObjectInterfaceUIListElementCellProvider()=0;
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags )=0;

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType )=0;

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )=0;
};

class UUIListElementProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIListElementProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIListElementProvider)
};

class IUIListElementProvider
{
protected:
	virtual ~IUIListElementProvider() {}
public:
	typedef UUIListElementProvider UClassType;
	virtual UObject* GetUObjectInterfaceUIListElementProvider()=0;
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags()=0;

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName )=0;

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements )=0;

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters )
	{
		return FALSE;
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex ) { return TRUE; }

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName )=0;

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex )=0;
};

class UUIStringRenderer : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIStringRenderer,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIStringRenderer)
};

class IUIStringRenderer
{
protected:
	virtual ~IUIStringRenderer() {}
public:
	typedef UUIStringRenderer UClassType;
	virtual UObject* GetUObjectInterfaceUIStringRenderer()=0;
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIStringRenderer)
};

class UUIStyleResolver : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIStyleResolver,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIStyleResolver)
};

class IUIStyleResolver
{
protected:
	virtual ~IUIStyleResolver() {}
public:
	typedef UUIStyleResolver UClassType;
	virtual UObject* GetUObjectInterfaceUIStyleResolver()=0;
    virtual FName GetStyleResolverTag()=0;
    virtual UBOOL SetStyleResolverTag(FName NewResolverTag)=0;
    virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIStyleResolver)
};

class UUITickableObject : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUITickableObject,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUITickableObject)
};

class IUITickableObject
{
protected:
	virtual ~IUITickableObject() {}
public:
	typedef UUITickableObject UClassType;
	virtual UObject* GetUObjectInterfaceUITickableObject()=0;
	/**
	 * Called each frame to allow the object to perform work.
	 *
	 * @param	PreviousFrameSeconds	amount of time (in seconds) between the start of this frame and the start of the previous frame.
	 */
	virtual void Tick( FLOAT PreviousFrameSeconds )=0;
};

class UUIComp_DrawImage : public UUIComp_DrawComponents, public IUIStyleResolver, public ICustomPropertyItemHandler
{
public:
    //## BEGIN PROPS UIComp_DrawImage
    FName StyleResolverTag;
    class UUITexture* ImageRef;
    struct FUIImageStyleOverride StyleCustomization;
    struct FUIStyleReference ImageStyle;
    //## END PROPS UIComp_DrawImage

    void SetImage(class USurface* NewImage);
    void SetCoordinates(struct FTextureCoordinates NewCoordinates);
    void SetColor(FLinearColor NewColor);
    void SetOpacity(FLOAT NewOpacity);
    void SetPadding(FLOAT HorizontalPadding,FLOAT VerticalPadding);
    void SetFormatting(BYTE Orientation,struct FUIImageAdjustmentData NewFormattingData);
    void DisableCustomCoordinates();
    void DisableCustomColor();
    void DisableCustomOpacity();
    void DisableCustomPadding();
    void DisableCustomFormatting();
    class USurface* GetImage() const;
    virtual FName GetStyleResolverTag();
    virtual UBOOL SetStyleResolverTag(FName NewResolverTag);
    virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None);
    DECLARE_FUNCTION(execGetAppliedImageStyle);
    DECLARE_FUNCTION(execSetImage)
    {
        P_GET_OBJECT(USurface,NewImage);
        P_FINISH;
        SetImage(NewImage);
    }
    DECLARE_FUNCTION(execSetCoordinates)
    {
        P_GET_STRUCT(struct FTextureCoordinates,NewCoordinates);
        P_FINISH;
        SetCoordinates(NewCoordinates);
    }
    DECLARE_FUNCTION(execSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        SetColor(NewColor);
    }
    DECLARE_FUNCTION(execSetOpacity)
    {
        P_GET_FLOAT(NewOpacity);
        P_FINISH;
        SetOpacity(NewOpacity);
    }
    DECLARE_FUNCTION(execSetPadding)
    {
        P_GET_FLOAT(HorizontalPadding);
        P_GET_FLOAT(VerticalPadding);
        P_FINISH;
        SetPadding(HorizontalPadding,VerticalPadding);
    }
    DECLARE_FUNCTION(execSetFormatting)
    {
        P_GET_BYTE(Orientation);
        P_GET_STRUCT(struct FUIImageAdjustmentData,NewFormattingData);
        P_FINISH;
        SetFormatting(Orientation,NewFormattingData);
    }
    DECLARE_FUNCTION(execDisableCustomCoordinates)
    {
        P_FINISH;
        DisableCustomCoordinates();
    }
    DECLARE_FUNCTION(execDisableCustomColor)
    {
        P_FINISH;
        DisableCustomColor();
    }
    DECLARE_FUNCTION(execDisableCustomOpacity)
    {
        P_FINISH;
        DisableCustomOpacity();
    }
    DECLARE_FUNCTION(execDisableCustomPadding)
    {
        P_FINISH;
        DisableCustomPadding();
    }
    DECLARE_FUNCTION(execDisableCustomFormatting)
    {
        P_FINISH;
        DisableCustomFormatting();
    }
    DECLARE_FUNCTION(execGetImage)
    {
        P_FINISH;
        *(class USurface**)Result=GetImage();
    }
    DECLARE_FUNCTION(execGetStyleResolverTag)
    {
        P_FINISH;
        *(FName*)Result=GetStyleResolverTag();
    }
    DECLARE_FUNCTION(execSetStyleResolverTag)
    {
        P_GET_NAME(NewResolverTag);
        P_FINISH;
        *(UBOOL*)Result=SetStyleResolverTag(NewResolverTag);
    }
    DECLARE_FUNCTION(execNotifyResolveStyle)
    {
        P_GET_OBJECT(UUISkin,ActiveSkin);
        P_GET_UBOOL(bClearExistingValue);
        P_GET_OBJECT_OPTX(UUIState,CurrentMenuState,NULL);
        P_GET_NAME_OPTX(StylePropertyName,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=NotifyResolveStyle(ActiveSkin,bClearExistingValue,CurrentMenuState,StylePropertyName);
    }
    DECLARE_CLASS(UUIComp_DrawImage,UUIComp_DrawComponents,0,Engine)
    virtual UObject* GetUObjectInterfaceUIStyleResolver(){return this;}
    virtual UObject* GetUObjectInterfaceCustomPropertyItemHandler(){return this;}
	/* === UIComp_DrawImage interface === */
	/**
	 * Renders the image.  The owning widget is responsible for applying any transformations to the canvas
	 * prior to rendering this component.
	 *
	 * @param	Canvas		the canvas to render the image to
	 * @param	Parameters	the bounds for the region that this texture can render to.
	 */
	virtual void RenderComponent( class FCanvas* Canvas, FRenderParameters Parameters );

	/**
	 * Returns TRUE if this component's UIStyleReference can be resolved into a valid UIStyle.
	 *
	 * @param	CurrentlyActiveSkin		the currently active skin; used for resolving the style reference's default style if it doesn't yet have a valid style id.
	 */
	virtual UBOOL HasValidStyleReference( class UUISkin* CurrentlyActiveSkin=NULL );

	/**
	 * Returns the image style data being used by this image rendering component.  If the component's ImageStyle is not set, the style data
	 * will be pulled from the owning widget's primary style.
	 *
	 * @param	DesiredMenuState	the menu state for the style data to retrieve; if not speicified, uses the owning widget's current menu state.
	 * @param	SourceSkin			the skin to use for resolving this component's image style; only relevant when the component's image style is invalid
	 *								(or if TRUE is passed for bClearExistingValue). If the image style is invalid and a value is not specified, returned value
	 *								will be NULL.
	 * @param	bClearExistingValue	used to force the component's image style to be re-resolved from the specified skin; if TRUE, you must supply a valid value for
	 *								SourceSkin.
	 *
	 * @return	the image style data used to render this component's image for the specified menu state.
	 */
	virtual class UUIStyle_Image* GetAppliedImageStyle( class UUIState* DesiredMenuState=NULL, class UUISkin* SourceSkin=NULL, UBOOL bClearExistingValue=FALSE );

	/**
	 * Initializes the combinedstyledata using the component's current image sytle, then applies any per-instance values
	 * which are intended to override values in the style.
	 *
	 * @param	CustomizedStyleData		struct which receives the per-instance style data configured for this component;
	 *									should be initialized using an image style prior to calling this function.
	 */
	void CustomizeAppliedStyle( FUICombinedStyleData& CustomizedStyleData ) const;

	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the component's image.
	 */
	void RefreshAppliedStyleData();

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.
	 *
	 * This version migrates the ImageCoordinates value over to the StyleCustomization member.
	 */
	virtual void PostLoad();

	/* === CustomPropertyItemHandler interface === */
	/**
	 * Determines whether the specified property value matches the current value of the property.  Called after the user
	 * has changed the value of a property handled by a custom property window item.  Is used to determine whether Pre/PostEditChange
	 * should be called for the selected objects.
	 *
	 * @param	InProperty			the property whose value is being checked.
	 * @param	NewPropertyValue	the value to compare against the current value of the property.
	 * @param	ArrayIndex			the array index for the element being compared; only relevant for array properties
	 *
	 * @return	TRUE if NewPropertyValue matches the current value of the property specified, indicating that no effective changes
	 *			were actually made.
	 */
	virtual UBOOL IsCustomPropertyValueIdentical( UProperty* InProperty, const union UPropertyValue& NewPropertyValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Method for overriding the default behavior of applying property values received from a custom editor property window item.
	 *
	 * @param	InProperty		the property that is being edited
	 * @param	PropertyValue	the value to assign to the property
	 * @param	ArrayIndex		the array index for the element being changed; only relevant for array properties
	 *
	 * @return	TRUE if the property was handled by this object and the property value was successfully applied to the
	 *			object's data.
	 */
	virtual UBOOL EditorSetPropertyValue( UProperty* InProperty, const UPropertyValue& PropertyValue, INT ArrayIndex=INDEX_NONE );
};

struct UIComp_DrawString_eventSetAutoSizePadding_Parms
{
    BYTE Orientation;
    FLOAT NearValue;
    FLOAT FarValue;
    BYTE NearScaleType;
    BYTE FarScaleType;
    UIComp_DrawString_eventSetAutoSizePadding_Parms(EEventParm)
    {
    }
};
struct UIComp_DrawString_eventEnableAutoSizing_Parms
{
    BYTE Orientation;
    UBOOL bShouldEnable;
    UIComp_DrawString_eventEnableAutoSizing_Parms(EEventParm)
    {
    }
};
class UUIComp_DrawString : public UUIComp_DrawComponents, public IUIStyleResolver
{
public:
    //## BEGIN PROPS UIComp_DrawString
    TScriptInterface<class IUIDataStoreSubscriber> SubscriberOwner;
    FName StyleResolverTag;
    class UUIString* ValueString;
    class UClass* StringClass;
    struct FAutoSizeData AutoSizeParameters[2];
    struct FUIRenderingSubregion ClampRegion[2];
    struct FUITextStyleOverride TextStyleCustomization;
    struct FUIStyleReference StringStyle;
    BITFIELD bIgnoreMarkup:1;
    BITFIELD bAllowBoundsAdjustment:1;
    BITFIELD bRefreshString:1;
    BITFIELD bReapplyFormatting:1;
    //## END PROPS UIComp_DrawString

    virtual void SetValue(const FString& NewText);
    virtual FString GetValue(UBOOL bReturnProcessedText=TRUE) const;
    void RefreshValue();
    UBOOL IsSubregionEnabled(BYTE Orientation) const;
    FLOAT GetSubregionSize(BYTE Orientation,BYTE OutputType=0) const;
    FLOAT GetSubregionOffset(BYTE Orientation,BYTE OutputType=0) const;
    BYTE GetSubregionAlignment(BYTE Orientation) const;
    void EnableSubregion(BYTE Orientation,UBOOL bShouldEnable=TRUE);
    void SetSubregionSize(BYTE Orientation,FLOAT NewValue,BYTE EvalType);
    void SetSubregionOffset(BYTE Orientation,FLOAT NewValue,BYTE EvalType);
    void SetSubregionAlignment(BYTE Orientation,BYTE NewValue);
    void SetColor(FLinearColor NewColor);
    void SetOpacity(FLOAT NewOpacity);
    void SetPadding(FLOAT HorizontalPadding,FLOAT VerticalPadding);
    void SetFont(class UFont* NewFont);
    void SetAttributes(struct FUITextAttributes NewAttributes);
    void SetAlignment(BYTE Orientation,BYTE NewAlignment);
    void SetWrapMode(BYTE NewClipMode);
    void SetClipAlignment(BYTE NewClipAlignment);
    void SetAutoScaling(BYTE NewAutoScaleMode,FLOAT NewMinScaleValue=-1.000000);
    void SetScale(BYTE Orientation,FLOAT NewScale);
    void SetSpacingAdjust(BYTE Orientation,FLOAT NewSpacingAdjust);
    void DisableCustomColor();
    void DisableCustomOpacity();
    void DisableCustomPadding();
    void DisableCustomFont();
    void DisableCustomAttributes();
    void DisableCustomAlignment();
    void DisableCustomClipMode();
    void DisableCustomClipAlignment();
    void DisableCustomAutoScaling();
    void DisableCustomScale();
    void DisableCustomSpacingAdjust();
    BYTE GetWrapMode() const;
    UBOOL GetFinalStringStyle(struct FUICombinedStyleData& FinalStyleData);
    virtual FName GetStyleResolverTag();
    virtual UBOOL SetStyleResolverTag(FName NewResolverTag);
    virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None);
    void SetAutoSizeExtent(BYTE Orientation,FLOAT MinValue,FLOAT MaxValue,BYTE MinScaleType,BYTE MaxScaleType);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(NewText);
        P_FINISH;
        SetValue(NewText);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnProcessedText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnProcessedText);
    }
    DECLARE_FUNCTION(execRefreshValue)
    {
        P_FINISH;
        RefreshValue();
    }
    DECLARE_FUNCTION(execIsSubregionEnabled)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(UBOOL*)Result=IsSubregionEnabled(Orientation);
    }
    DECLARE_FUNCTION(execGetSubregionSize)
    {
        P_GET_BYTE(Orientation);
        P_GET_BYTE_OPTX(OutputType,0);
        P_FINISH;
        *(FLOAT*)Result=GetSubregionSize(Orientation,OutputType);
    }
    DECLARE_FUNCTION(execGetSubregionOffset)
    {
        P_GET_BYTE(Orientation);
        P_GET_BYTE_OPTX(OutputType,0);
        P_FINISH;
        *(FLOAT*)Result=GetSubregionOffset(Orientation,OutputType);
    }
    DECLARE_FUNCTION(execGetSubregionAlignment)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(BYTE*)Result=GetSubregionAlignment(Orientation);
    }
    DECLARE_FUNCTION(execEnableSubregion)
    {
        P_GET_BYTE(Orientation);
        P_GET_UBOOL_OPTX(bShouldEnable,TRUE);
        P_FINISH;
        EnableSubregion(Orientation,bShouldEnable);
    }
    DECLARE_FUNCTION(execSetSubregionSize)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewValue);
        P_GET_BYTE(EvalType);
        P_FINISH;
        SetSubregionSize(Orientation,NewValue,EvalType);
    }
    DECLARE_FUNCTION(execSetSubregionOffset)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewValue);
        P_GET_BYTE(EvalType);
        P_FINISH;
        SetSubregionOffset(Orientation,NewValue,EvalType);
    }
    DECLARE_FUNCTION(execSetSubregionAlignment)
    {
        P_GET_BYTE(Orientation);
        P_GET_BYTE(NewValue);
        P_FINISH;
        SetSubregionAlignment(Orientation,NewValue);
    }
    DECLARE_FUNCTION(execSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        SetColor(NewColor);
    }
    DECLARE_FUNCTION(execSetOpacity)
    {
        P_GET_FLOAT(NewOpacity);
        P_FINISH;
        SetOpacity(NewOpacity);
    }
    DECLARE_FUNCTION(execSetPadding)
    {
        P_GET_FLOAT(HorizontalPadding);
        P_GET_FLOAT(VerticalPadding);
        P_FINISH;
        SetPadding(HorizontalPadding,VerticalPadding);
    }
    DECLARE_FUNCTION(execSetFont)
    {
        P_GET_OBJECT(UFont,NewFont);
        P_FINISH;
        SetFont(NewFont);
    }
    DECLARE_FUNCTION(execSetAttributes)
    {
        P_GET_STRUCT(struct FUITextAttributes,NewAttributes);
        P_FINISH;
        SetAttributes(NewAttributes);
    }
    DECLARE_FUNCTION(execSetAlignment)
    {
        P_GET_BYTE(Orientation);
        P_GET_BYTE(NewAlignment);
        P_FINISH;
        SetAlignment(Orientation,NewAlignment);
    }
    DECLARE_FUNCTION(execSetWrapMode)
    {
        P_GET_BYTE(NewClipMode);
        P_FINISH;
        SetWrapMode(NewClipMode);
    }
    DECLARE_FUNCTION(execSetClipAlignment)
    {
        P_GET_BYTE(NewClipAlignment);
        P_FINISH;
        SetClipAlignment(NewClipAlignment);
    }
    DECLARE_FUNCTION(execSetAutoScaling)
    {
        P_GET_BYTE(NewAutoScaleMode);
        P_GET_FLOAT_OPTX(NewMinScaleValue,-1.000000);
        P_FINISH;
        SetAutoScaling(NewAutoScaleMode,NewMinScaleValue);
    }
    DECLARE_FUNCTION(execSetScale)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewScale);
        P_FINISH;
        SetScale(Orientation,NewScale);
    }
    DECLARE_FUNCTION(execSetSpacingAdjust)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewSpacingAdjust);
        P_FINISH;
        SetSpacingAdjust(Orientation,NewSpacingAdjust);
    }
    DECLARE_FUNCTION(execDisableCustomColor)
    {
        P_FINISH;
        DisableCustomColor();
    }
    DECLARE_FUNCTION(execDisableCustomOpacity)
    {
        P_FINISH;
        DisableCustomOpacity();
    }
    DECLARE_FUNCTION(execDisableCustomPadding)
    {
        P_FINISH;
        DisableCustomPadding();
    }
    DECLARE_FUNCTION(execDisableCustomFont)
    {
        P_FINISH;
        DisableCustomFont();
    }
    DECLARE_FUNCTION(execDisableCustomAttributes)
    {
        P_FINISH;
        DisableCustomAttributes();
    }
    DECLARE_FUNCTION(execDisableCustomAlignment)
    {
        P_FINISH;
        DisableCustomAlignment();
    }
    DECLARE_FUNCTION(execDisableCustomClipMode)
    {
        P_FINISH;
        DisableCustomClipMode();
    }
    DECLARE_FUNCTION(execDisableCustomClipAlignment)
    {
        P_FINISH;
        DisableCustomClipAlignment();
    }
    DECLARE_FUNCTION(execDisableCustomAutoScaling)
    {
        P_FINISH;
        DisableCustomAutoScaling();
    }
    DECLARE_FUNCTION(execDisableCustomScale)
    {
        P_FINISH;
        DisableCustomScale();
    }
    DECLARE_FUNCTION(execDisableCustomSpacingAdjust)
    {
        P_FINISH;
        DisableCustomSpacingAdjust();
    }
    DECLARE_FUNCTION(execGetWrapMode)
    {
        P_FINISH;
        *(BYTE*)Result=GetWrapMode();
    }
    DECLARE_FUNCTION(execGetAppliedStringStyle);
    DECLARE_FUNCTION(execGetFinalStringStyle)
    {
        P_GET_STRUCT_REF(struct FUICombinedStyleData,FinalStyleData);
        P_FINISH;
        *(UBOOL*)Result=GetFinalStringStyle(FinalStyleData);
    }
    DECLARE_FUNCTION(execGetStyleResolverTag)
    {
        P_FINISH;
        *(FName*)Result=GetStyleResolverTag();
    }
    DECLARE_FUNCTION(execSetStyleResolverTag)
    {
        P_GET_NAME(NewResolverTag);
        P_FINISH;
        *(UBOOL*)Result=SetStyleResolverTag(NewResolverTag);
    }
    DECLARE_FUNCTION(execNotifyResolveStyle)
    {
        P_GET_OBJECT(UUISkin,ActiveSkin);
        P_GET_UBOOL(bClearExistingValue);
        P_GET_OBJECT_OPTX(UUIState,CurrentMenuState,NULL);
        P_GET_NAME_OPTX(StylePropertyName,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=NotifyResolveStyle(ActiveSkin,bClearExistingValue,CurrentMenuState,StylePropertyName);
    }
    DECLARE_FUNCTION(execSetAutoSizeExtent)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(MinValue);
        P_GET_FLOAT(MaxValue);
        P_GET_BYTE(MinScaleType);
        P_GET_BYTE(MaxScaleType);
        P_FINISH;
        SetAutoSizeExtent(Orientation,MinValue,MaxValue,MinScaleType,MaxScaleType);
    }
    void eventSetAutoSizePadding(BYTE Orientation,FLOAT NearValue,FLOAT FarValue,BYTE NearScaleType,BYTE FarScaleType)
    {
        UIComp_DrawString_eventSetAutoSizePadding_Parms Parms(EC_EventParm);
        Parms.Orientation=Orientation;
        Parms.NearValue=NearValue;
        Parms.FarValue=FarValue;
        Parms.NearScaleType=NearScaleType;
        Parms.FarScaleType=FarScaleType;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAutoSizePadding),&Parms);
    }
    void eventEnableAutoSizing(BYTE Orientation,UBOOL bShouldEnable=TRUE)
    {
        UIComp_DrawString_eventEnableAutoSizing_Parms Parms(EC_EventParm);
        Parms.Orientation=Orientation;
        Parms.bShouldEnable=bShouldEnable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnableAutoSizing),&Parms);
    }
    DECLARE_CLASS(UUIComp_DrawString,UUIComp_DrawComponents,0,Engine)
    virtual UObject* GetUObjectInterfaceUIStyleResolver(){return this;}
	/**
	 * Initializes this component, creating the UIString needed for rendering text.
	 *
	 * @param	InSubscriberOwner	if this component is owned by a widget that implements the IUIDataStoreSubscriber interface,
	 *								the TScriptInterface containing the interface data for the owner.
	 */
	virtual void InitializeComponent( TScriptInterface<IUIDataStoreSubscriber>* InSubscriberOwner=NULL );

	/**
	 * Adds the specified face to the owning scene's DockingStack for the owning widget.  Takes wrap behavior and
	 * autosizing into account, ensuring that all widget faces are added to the scene's docking stack in the appropriate
	 * order.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	UBOOL AddDockingNode( TLookupMap<FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value, and triggers the methods which apply
	 * formatting data to the string.
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Marks the Position for any faces dependent on the specified face, in this component's owning widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

	/**
	 * Calculates the position and size of the bounding region available for rendering this component's string, taking
	 * into account any configured bounding region clamping.
	 *
	 * @param	[out] BoundingRegionStart	receives the location of the upper left corner of the bounding region, in
	 *										pixels relative to the upper left corner of the screen.
	 * @param	[out] BoundingRegionSize	receives the size of the bounding region, in absolute pixels.
	 */
	virtual void CalculateBoundingRegion( FLOAT* BoundingRegionStart[UIORIENT_MAX], FLOAT* BoundingRegionSize[UIORIENT_MAX] ) const;

	/**
	 * Returns TRUE if autosizing is enabled for the specified orientation.
	 *
	 * @param	Orientation		the orientation to check
	 *
	 * @return	TRUE if auto-sizing is enabled for the specified orientation
	 */
	UBOOL IsAutoSizeEnabled( BYTE Orientation ) const
	{
		checkSlow(Orientation<UIORIENT_MAX);
		return AutoSizeParameters[Orientation].bAutoSizeEnabled;
	}

	/**
	 * Changes the style for this UIString.
	 *
	 * @param	NewStringStyle	the new style to use for rendering the string
	 */
	void SetStringStyle( UUIStyle_Combo* NewComboStyle );

	/**
	 * Returns TRUE if this component's UIStyleReference can be resolved into a valid UIStyle.
	 *
	 * @param	CurrentlyActiveSkin		the currently active skin; used for resolving the style reference's default style if it doesn't yet have a valid style id.
	 */
	virtual UBOOL HasValidStyleReference( UUISkin* CurrentlyActiveSkin=NULL );

	/**
	 * Returns the combo style data being used by this string rendering component.  If the component's StringStyle is not set, the style data
	 * will be pulled from the owning widget's PrimaryStyle, if possible.
	 *
	 * @param	DesiredMenuState	the menu state for the style data to retrieve; if not specified, uses the owning widget's current menu state.
	 * @param	SourceSkin			the skin to use for resolving this component's combo style; only relevant when the component's combo style is invalid
	 *								(or if TRUE is passed for bClearExistingValue). If the combo style is invalid and a value is not specified, returned value
	 *								will be NULL.
	 * @param	bClearExistingValue	used to force the component's combo style to be re-resolved from the specified skin; if TRUE, you must supply a valid value for
	 *								SourceSkin.
	 *
	 * @return	the combo style data used to render this component's string for the specified menu state.
	 */
	virtual UUIStyle_Combo* GetAppliedStringStyle( UUIState* DesiredMenuState=NULL, UUISkin* SourceSkin=NULL, UBOOL bClearExistingValue=FALSE );

	/**
	 * Initializes the CustomizedStyleData using the string current style, then applies any per-instance values
	 * which are intended to override values in the style.
	 *
	 * @param	CustomizedStyleData		struct which receives the per-instance style data configured for this component;
	 *									should be initialized using a combo style prior to calling this function.
	 */
	void CustomizeAppliedStyle( FUICombinedStyleData& CustomizedStyleData ) const;

	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the string.
	 */
	void RefreshAppliedStyleData();

	/**
	 * Calculate the rendering bounding region, adjust for alignment, and renders the string.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this string
	 */
	void Render_String( FCanvas* Canvas );

	/**
	 * Flags the component to be reformatted during the next scene update.
	 *
	 * @param	bRequestSceneUpdate		if TRUE, requests the scene to update the positions for all widgets at the beginning of the next frame
	 */
	virtual void ReapplyFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Retrieves a list of all data stores resolved by ValueString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by the UIString.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	virtual void GetResolvedDataStores( TArray<UUIDataStore*>& StringDataStores );

protected:
	/**
	 * Initializes the render parameters that will be used for formatting the string.
	 *
	 * @param	Face			the face that was being resolved
	 * @param	out_Parameters	[out] the formatting parameters to use for formatting the string.
	 *
	 * @return	TRUE if the formatting data is ready to be applied to the string, taking into account the autosize settings.
	 */
	virtual UBOOL GetStringFormatParameters( EUIWidgetFace Face, FRenderParameters& out_Parameters ) const;

	/**
	 * Wrapper for getting the docking-state of the owning widget's four faces.  No special logic here, but child classes
	 * can use this method to make the formatting code ignore the fact that the widget may be docked (in cases where it is
	 * irrelevant)
	 *
	 * @param	bFaceDocked		[out] an array of bools representing whether the widget is docked on the respective face.
	 */
	virtual void GetOwnerDockingState( UBOOL* bFaceDocked[UIFACE_MAX] ) const;

	/**
	 * Adjusts the owning widget's bounds according to the wrapping mode and autosize behaviors.
	 */
	virtual void UpdateOwnerBounds( FRenderParameters& Parameters );

	/**
	 * Wrapper method which applies final formatting to the string and resets the value of bReapplyFormatting.
	 *
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 * @param	bIgnoreMarkup	@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyStringFormatting( FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Renders the string using the parameters specified.  Must have a different name than Render_String, or I can't call
	 * the other version, for some reason.
	 *
	 * @param	Canvas	the canvas to use for rendering this string
	 */
	virtual void InternalRender_String( FCanvas* Canvas, FRenderParameters& Parameters );

	/**
	 * Handles unregistering the "RefreshSubscriberValue" callbacks for the data stores that were previously resolved by this
	 * component's UIString and registering the callbacks for the data stores currently resolved by the UIString.  Requires that
	 * the SubscriberOwner value be set.
	 *
	 * @param	RemovedDataStores	the list of data stores that were previously bound to this component's string.  SubscriberOwner
	 *								will be removed from each data store's "RefreshSubscriberValue" callback list.
	 * @param	AddedDataStores		the list of data stores that are now bound to this component's string.  SubscriberOwner
	 *								will be registered with each data store's "RefreshSubscriberValue" callback list.
	 */
	void UpdateSubscriberCallbacks( TArray<UUIDataStore*> RemovedDataStores, TArray<UUIDataStore*> AddedDataStores );
};

class UUIComp_DrawCaption : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_DrawCaption
    //## END PROPS UIComp_DrawCaption

    DECLARE_CLASS(UUIComp_DrawCaption,UUIComp_DrawString,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_DrawCaption)
};

struct FUIStringSelectionRegion
{
    INT SelectionStartCharIndex;
    INT SelectionEndCharIndex;

		/**
		 * Determines whether this selection region contains characters.
		 *
		 * @param	StringLength	if specified, the range of selected characters will also be validated against this
		 *							value.  Otherwise, the region is considered valid as long as the starting index is
		 *							greater than zero and the ending index is greater than the starting index.
		 *
		 * @return	TRUE if a valid range of characters is selected.
		 */
		UBOOL IsValid( INT StringLength=INDEX_NONE ) const;

		/**
		 * Resets this selection region.
		 *
		 * @return	TRUE for success.
		 */
		UBOOL ClearSelection();
	
};

class UUIComp_DrawStringEditbox : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_DrawStringEditbox
protected:
    FStringNoInit UserText;
public:
    struct FUIStringCaretParameters StringCaret;
    struct FUIStringSelectionRegion SelectionRegion;
    FLinearColor SelectionTextColor;
    FLinearColor SelectionBackgroundColor;
    struct FUIStringNode_Image* CaretNode;
    INT FirstCharacterPosition;
    BITFIELD bRecalculateFirstCharacter:1;
    FLOAT CaretOffset;
    //## END PROPS UIComp_DrawStringEditbox

    UBOOL SetUserText(const FString& NewValue);
    INT GetUserTextLength() const;
    UBOOL SetSelectionRange(INT StartIndex,INT EndIndex);
    UBOOL SetSelectionStart(INT StartIndex);
    UBOOL SetSelectionEnd(INT EndIndex);
    UBOOL ClearSelection();
    UBOOL GetSelectionRange(INT& out_StartIndex,INT& out_EndIndex) const;
    FString GetSelectedText() const;
    DECLARE_FUNCTION(execSetUserText)
    {
        P_GET_STR(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetUserText(NewValue);
    }
    DECLARE_FUNCTION(execGetUserTextLength)
    {
        P_FINISH;
        *(INT*)Result=GetUserTextLength();
    }
    DECLARE_FUNCTION(execSetSelectionRange)
    {
        P_GET_INT(StartIndex);
        P_GET_INT(EndIndex);
        P_FINISH;
        *(UBOOL*)Result=SetSelectionRange(StartIndex,EndIndex);
    }
    DECLARE_FUNCTION(execSetSelectionStart)
    {
        P_GET_INT(StartIndex);
        P_FINISH;
        *(UBOOL*)Result=SetSelectionStart(StartIndex);
    }
    DECLARE_FUNCTION(execSetSelectionEnd)
    {
        P_GET_INT(EndIndex);
        P_FINISH;
        *(UBOOL*)Result=SetSelectionEnd(EndIndex);
    }
    DECLARE_FUNCTION(execClearSelection)
    {
        P_FINISH;
        *(UBOOL*)Result=ClearSelection();
    }
    DECLARE_FUNCTION(execGetSelectionRange)
    {
        P_GET_INT_REF(out_StartIndex);
        P_GET_INT_REF(out_EndIndex);
        P_FINISH;
        *(UBOOL*)Result=GetSelectionRange(out_StartIndex,out_EndIndex);
    }
    DECLARE_FUNCTION(execGetSelectedText)
    {
        P_FINISH;
        *(FString*)Result=GetSelectedText();
    }
    DECLARE_CLASS(UUIComp_DrawStringEditbox,UUIComp_DrawString,0|CLASS_Config,Engine)
    DECLARE_WITHIN(UUIEditBox)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	// UIEditboxString needs direct access to UserText
	friend class UUIEditboxString;

	/* === UUIComp_DrawStringEditbox interface === */
	/**
	 * Requests a new UIStringNode_Image from the Images data store.  Initializes the image node
	 * and assigns it to the value of CaretNode.
	 *
	 * @param	bRecreateExisting	specifies what should happen if this component already has a valid CaretNode.  If
	 *								TRUE, the existing caret is deleted and a new one is created.
	 */
	void ResolveCaretImageNode( UBOOL bRecreateExisting=FALSE );

	/**
	 * Inserts the markup necessary to render the caret at the appropriate position in SourceText.
	 *
	 * @param	out_CaretMarkupString	a string containing markup code necessary for the caret image to be resolved into a UIStringNode_Image
	 *
	 * @return	TRUE if out_ProcessedString contains valid caret markup text.
	 *			FALSE if this component is configured to not render a caret, or the caret reference is invalid.
	 */
	UBOOL GenerateCaretMarkup( FString& out_CaretMarkupString );

	/**
	 * Retrieves the image style data associated with the caret's configured style from the currently active
	 * skin and applies that style data to the caret's UITexture.
	 *
	 * @param	CurrentWidgetStyle		the current state of the widget that owns this draw string component.  Used
	 *									for choosing which style data set [from the caret's style] to use for rendering.
	 *									If not specified, the current state of the widget that owns this component will be used.
	 */
	void ApplyCaretStyle( UUIState* CurrentWidgetState=NULL );

	/**
	 * Moves the caret to a new position in the text.
	 *
	 * @param	NewCaretPosition	the location to put the caret.  Should be a non-zero integer between 0 and the length
	 *								of UserText.  Values outside the valid range will be clamed.
	 * @param	bSelectionActive	specify TRUE to expand/contract the selection region to end at the specified position
	 *
	 * @return	TRUE if the string's new caret position is different than the string's previous caret position.
	 */
	UBOOL SetCaretPosition( INT NewCaretPosition, UBOOL bSelectionActive );

	/**
	 * Updates the value of FirstCharacterPosition with the location of the first character of the string that is now visible.
	 */
	void UpdateFirstVisibleCharacter( FRenderParameters& Parameters );

	/**
	 * Calculates the total width of the characters that precede the FirstCharacterPosition.
	 *
	 * @param	Parameters	@see UUIString::StringSize() (intentionally passed by value)
	 *
	 * @return	the width (in pixels) of a sub-string containing all characters up to FirstCharacterPosition.
	 */
	FLOAT CalculateFirstVisibleOffset( FRenderParameters Parameters ) const;

	/**
	 * Calculates the total width of the characters that precede the CaretPosition.
	 *
	 * @param	Parameters	@see UUIString::StringSize() (intentionally passed by value)
	 *
	 * @return	the width (in pixels) of a sub-string containing all characters up to StringCaret.CaretPosition.
	 */
	FLOAT CalculateCaretOffset( FRenderParameters Parameters ) const;

	/**
	 * Returns a reference to this editbox component's UserText variable (useful in cases where you need to work with the
	 * string but don't want to make a copy of it).
	 */
	const FString& GetUserTextRef() const { return UserText; }

	/**
	 * @return	the string being rendered in the editbox; equal to UserText unless the editbox is in password mode.
	 */
	FString GetDisplayString() const;

private:
	/**
	 * Deletes the existing caret node if one exists, and unregisters this component from the images data store.
	 */
	virtual void DeleteCaretNode();
public:

	/* === UUIComp_DrawString interface === */
	/**
	 * Initializes this component, creating the UIString needed for rendering text.
	 *
	 * @param	InSubscriberOwner	if this component is owned by a widget that implements the IUIDataStoreSubscriber interface,
	 *								the TScriptInterface containing the interface data for the owner.
	 */
	virtual void InitializeComponent( TScriptInterface<IUIDataStoreSubscriber>* InSubscriberOwner=NULL );

	/**
	 * Changes the text that will be parsed by the UIString, and updates UserText to the resolved value.
	 *
	 * @param	NewText		the new text that should be displayed
	 */
	virtual void SetValue( const FString& NewText );

	/**
	 * Retrieve the text value of this editbox.
	 *
	 * @param	bReturnInputText	specify TRUE to return the value of UserText; FALSE to return the raw text stored
	 *								in the UIString's node's SourceText
	 *
	 * @return	either the raw value of this editbox string component or the text that the user entered
	 */
	virtual FString GetValue( UBOOL bReturnInputText=TRUE ) const;

	/**
	 * Retrieves a list of all data stores resolved by ValueString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by the UIString.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	virtual void GetResolvedDataStores( TArray<class UUIDataStore*>& StringDataStores );

	/**
	 * Flags the component to be reformatted during the next scene update, and flags the editbox to recalculate its
	 * first visible character, if necessary.
	 *
	 * @param	bRequestSceneUpdate		if TRUE, requests the scene to update the positions for all widgets at the beginning of the next frame
	 */
	virtual void ReapplyFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Resolves the combo style for this string rendering component.
	 *
	 * This version also resolves the caret image style.
	 *
	 * @param	ActiveSkin			the skin the use for resolving the style reference.
	 * @param	bClearExistingValue	if TRUE, style references will be invalidated first.
	 * @param	CurrentMenuState	the menu state to use for resolving the style data; if not specified, uses the current
	 *								menu state of the owning widget.
	 * @param	StyleProperty		if specified, only the style reference corresponding to the specified property
	 *								will be resolved; otherwise, all style references will be resolved.
	 */
	virtual UBOOL NotifyResolveStyle( class UUISkin* ActiveSkin, UBOOL bClearExistingValue, class UUIState* CurrentMenuState=NULL, const FName StylePropertyName=NAME_None );

protected:
	/**
	 * Wrapper for calling ApplyFormatting on the string.  Resets the value of bReapplyFormatting and bRecalculateFirstCharacter.
	 *
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 * @param	bIgnoreMarkup	@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyStringFormatting( struct FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Renders the string using the parameters specified.
	 *
	 * @param	Canvas	the canvas to use for rendering this string
	 */
	virtual void InternalRender_String( FCanvas* Canvas, FRenderParameters& Parameters );

public:
	/* === UObject interface === */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void FinishDestroy();

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUIComp_DrawStringSlider : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_DrawStringSlider
    //## END PROPS UIComp_DrawStringSlider

    DECLARE_CLASS(UUIComp_DrawStringSlider,UUIComp_DrawString,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_DrawStringSlider)
};

class UUIComp_ListComponentBase : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_ListComponentBase
    //## END PROPS UIComp_ListComponentBase

    DECLARE_ABSTRACT_CLASS(UUIComp_ListComponentBase,UUIComponent,0,Engine)
    DECLARE_WITHIN(UUIList)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListComponentBase)
};

struct FUIListSortingParameters
{
    INT PrimaryIndex;
    INT SecondaryIndex;
    BITFIELD bReversePrimarySorting:1;
    BITFIELD bReverseSecondarySorting:1;
    BITFIELD bCaseSensitive:1;
    BITFIELD bIntSortPrimary:1;
    BITFIELD bIntSortSecondary:1;
    BITFIELD bFloatSortPrimary:1;
    BITFIELD bFloatSortSecondary:1;

	/** Constructors */
	FUIListSortingParameters()
	: PrimaryIndex(INDEX_NONE), SecondaryIndex(INDEX_NONE)
	, bReversePrimarySorting(FALSE), bReverseSecondarySorting(FALSE), bCaseSensitive(FALSE)
	, bIntSortPrimary(FALSE), bIntSortSecondary(FALSE), bFloatSortPrimary(FALSE), bFloatSortSecondary(FALSE)
	{
	}
	FUIListSortingParameters( INT InPrimaryIndex, INT InSecondaryIndex, UBOOL bReversePrimary, UBOOL bReverseSecondary, UBOOL bInCaseSensitive, UBOOL bIntSort[2], UBOOL bFloatSort[2] )
	: PrimaryIndex(InPrimaryIndex), SecondaryIndex(InSecondaryIndex)
	, bReversePrimarySorting(bReversePrimary), bReverseSecondarySorting(bReverseSecondary), bCaseSensitive(bInCaseSensitive)
	, bIntSortPrimary(bIntSort[0]), bIntSortSecondary(bIntSort[1]), bFloatSortPrimary(bFloatSort[0]), bFloatSortSecondary(bFloatSort[1])
	{
	}

};

struct UIComp_ListElementSorter_eventOverrideListSort_Parms
{
    class UUIList* Sender;
    FName CollectionFieldName;
    struct FUIListSortingParameters SortParameters;
    TArray<INT> OrderedIndices;
    UBOOL ReturnValue;
    UIComp_ListElementSorter_eventOverrideListSort_Parms(EEventParm)
    {
    }
};
class UUIComp_ListElementSorter : public UUIComp_ListComponentBase
{
public:
    //## BEGIN PROPS UIComp_ListElementSorter
    BITFIELD bAllowCompoundSorting:1;
    BITFIELD bReversePrimarySorting:1;
    BITFIELD bReverseSecondarySorting:1;
    INT InitialSortColumn;
    INT InitialSecondarySortColumn;
    INT PrimarySortColumn;
    INT SecondarySortColumn;
    FScriptDelegate __OverrideListSort__Delegate;
    //## END PROPS UIComp_ListElementSorter

    void ResetSortColumns(UBOOL bResort=TRUE);
    UBOOL SortItems(INT ColumnIndex,UBOOL bSecondarySort=FALSE,UBOOL bCaseSensitive=FALSE);
    UBOOL ResortItems(UBOOL bCaseSensitive=FALSE);
    DECLARE_FUNCTION(execResetSortColumns)
    {
        P_GET_UBOOL_OPTX(bResort,TRUE);
        P_FINISH;
        ResetSortColumns(bResort);
    }
    DECLARE_FUNCTION(execSortItems)
    {
        P_GET_INT(ColumnIndex);
        P_GET_UBOOL_OPTX(bSecondarySort,FALSE);
        P_GET_UBOOL_OPTX(bCaseSensitive,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SortItems(ColumnIndex,bSecondarySort,bCaseSensitive);
    }
    DECLARE_FUNCTION(execResortItems)
    {
        P_GET_UBOOL_OPTX(bCaseSensitive,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ResortItems(bCaseSensitive);
    }
    UBOOL delegateOverrideListSort(class UUIList* Sender,FName CollectionFieldName,const struct FUIListSortingParameters& SortParameters,TArray<INT>& OrderedIndices)
    {
        UIComp_ListElementSorter_eventOverrideListSort_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.CollectionFieldName=CollectionFieldName;
        Parms.SortParameters=SortParameters;
        Parms.OrderedIndices=OrderedIndices;
        ProcessDelegate(ENGINE_OverrideListSort,&__OverrideListSort__Delegate,&Parms);
        OrderedIndices=Parms.OrderedIndices;
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIComp_ListElementSorter,UUIComp_ListComponentBase,0,Engine)
	/**
	 * Determines whether the element values should be converted to int/floats for the purposes of sorting.
	 *
	 * @param	bShouldIntSortPrimary		receives the value for whether the primary sort column should be converted to int for sorting
	 * @param	bShouldIntSortSecondary		receives the value for whether the secondary sort column should be converted to int for sorting
	 * @param	bShouldFloatSortPrimary		receives the value for whether the primary sort column should be converted to float for sorting
	 * @param	bShouldFloatSortSecondary	receives the value for whether the secondary sort column should be converted to float for sorting
	 */
	void SetNumericSortFlags( UBOOL& bShouldIntSortPrimary, UBOOL& bShouldIntSortSecondary, UBOOL& bShouldFloatSortPrimary, UBOOL& bShouldFloatSortSecondary );
};

struct FUIListItemDataBinding
{
    TScriptInterface<class IUIListElementCellProvider> DataSourceProvider;
    FName DataSourceTag;
    INT DataSourceIndex;

		/** Constructors */
		FUIListItemDataBinding() {}
		FUIListItemDataBinding(EEventParm)
		{
			appMemzero(this, sizeof(FUIListItemDataBinding));
		}

		FUIListItemDataBinding( TScriptInterface<class IUIListElementCellProvider> InDataSource, FName DataTag, INT InIndex )
		: DataSourceProvider(InDataSource)
		, DataSourceTag(DataTag)
		, DataSourceIndex(InIndex)
		{}
	
};

class UUIComp_ListPresenterBase : public UUIComp_ListComponentBase
{
public:
    //## BEGIN PROPS UIComp_ListPresenterBase
    BITFIELD bReapplyFormatting:1;
    //## END PROPS UIComp_ListPresenterBase

    TScriptInterface<class IUIListElementCellProvider> GetCellSchemaProvider() const;
    UBOOL ShouldAdjustListBounds(BYTE Orientation) const;
    virtual UBOOL ShouldRenderColumnHeaders() const;
    virtual void EnableColumnHeaderRendering(UBOOL bShouldRenderColHeaders=TRUE);
    DECLARE_FUNCTION(execGetCellSchemaProvider)
    {
        P_FINISH;
        *(TScriptInterface<class IUIListElementCellProvider>*)Result=GetCellSchemaProvider();
    }
    DECLARE_FUNCTION(execGetSchemaCellCount)
    {
        P_FINISH;
        *(INT*)Result=GetSchemaCellCount();
    }
    DECLARE_FUNCTION(execGetSchemaCellSize);
    DECLARE_FUNCTION(execSetSchemaCellSize);
    DECLARE_FUNCTION(execGetSchemaCellPosition)
    {
        P_GET_INT(SchemaCellIndex);
        P_FINISH;
        *(FLOAT*)Result=GetSchemaCellPosition(SchemaCellIndex);
    }
    DECLARE_FUNCTION(execCalculateAutoSizeRowHeight)
    {
        P_GET_INT(RowIndex);
        P_GET_FLOAT_REF(out_RowHeight);
        P_GET_FLOAT_REF(out_StylePadding);
        P_GET_UBOOL_OPTX(bReturnUnformattedValue,FALSE);
        P_FINISH;
        CalculateAutoSizeRowHeight(RowIndex,out_RowHeight,out_StylePadding,bReturnUnformattedValue);
    }
    DECLARE_FUNCTION(execCalculateAutoSizeColumnWidth)
    {
        P_GET_INT(ColIndex);
        P_GET_FLOAT_REF(out_ColWidth);
        P_GET_FLOAT_REF(out_StylePadding);
        P_GET_UBOOL_OPTX(bReturnUnformattedValue,FALSE);
        P_FINISH;
        CalculateAutoSizeColumnWidth(ColIndex,out_ColWidth,out_StylePadding,bReturnUnformattedValue);
    }
    DECLARE_FUNCTION(execShouldAdjustListBounds)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(UBOOL*)Result=ShouldAdjustListBounds(Orientation);
    }
    DECLARE_FUNCTION(execShouldRenderColumnHeaders)
    {
        P_FINISH;
        *(UBOOL*)Result=ShouldRenderColumnHeaders();
    }
    DECLARE_FUNCTION(execEnableColumnHeaderRendering)
    {
        P_GET_UBOOL_OPTX(bShouldRenderColHeaders,TRUE);
        P_FINISH;
        EnableColumnHeaderRendering(bShouldRenderColHeaders);
    }
    DECLARE_FUNCTION(execGetElementValue)
    {
        P_GET_INT(ElementIndex);
        P_GET_INT_OPTX(CellIndex,-1);
        P_FINISH;
        *(FString*)Result=GetElementValue(ElementIndex,CellIndex);
    }
    DECLARE_FUNCTION(execSetMaxElementsPerPage)
    {
        P_GET_INT(NewMaxVisibleElements);
        P_FINISH;
        SetMaxElementsPerPage(NewMaxVisibleElements);
    }
    DECLARE_FUNCTION(execGetMaxElementsPerPage)
    {
        P_FINISH;
        *(INT*)Result=GetMaxElementsPerPage();
    }
    DECLARE_ABSTRACT_CLASS(UUIComp_ListPresenterBase,UUIComp_ListComponentBase,0,Engine)
	friend class UUIList;

	/**
	 * Called when a new element is added to the list that owns this component.
	 *
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the element.  If the value is
	 *								not a valid index, the element will be added to the end of the list.
	 * @param	ElementValue		the index [into the data provider's collection] for the element that is being inserted into the list.
	 *
	 * @return	the index where the new element was inserted, or INDEX_NONE if the element wasn't added to the list.
	 */
	virtual INT InsertElement( INT InsertIndex, INT ElementValue ) PURE_VIRTUAL(UUIComp_ListPresenterBase::InsertElement,return INDEX_NONE;);

	/**
	 * Called when an element is removed from the list that owns this component.
	 *
	 * @param	RemovalIndex	the index for the element that should be removed from the list
	 *
	 * @return	the index [into the ElementCells array] for the element that was removed, or INDEX_NONE if RemovalIndex was invalid
	 *			or that element couldn't be removed from this list.
	 */
	virtual INT RemoveElement( INT RemovalIndex ) PURE_VIRTUAL(UUIComp_ListPresenterBase::RemoveElement,return INDEX_NONE;);

	/**
	 * Refreshes the value of all cells for the specified element
	 *
	 * @param	ElementIndex	the index of the element that needs to be refreshed.
	 */
	virtual void RefreshElement( INT ElementIndex ) PURE_VIRTUAL(UUIComp_ListPresenterBase::RefreshElement,);

	/**
	 * Swaps the values at the specified indexes, reversing their positions in the array of items.
	 *
	 * @param	IndexA	the index into the ListItems array for the first element to swap
	 * @param	IndexB	the index into the ListItems array for the second element to swap
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElements( INT IndexA, INT IndexB ) PURE_VIRTUAL(UUIComp_ListPresenterBase::SwapElements,return FALSE;);

	/**
	 * Returns the text value for the specified element.
	 *
	 * @param	ElementIndex	index [into the Items array] for the value to return.
	 * @param	CellIndex		for lists which have linked columns or rows, indicates which column/row to retrieve.
	 *
	 * @return	the value of the specified element, or an empty string if that element doesn't have a text value.
	 */
	virtual FString GetElementValue( INT ElementIndex, INT CellIndex=INDEX_NONE ) const PURE_VIRTUAL(UUIComp_ListPresenterBase::GetElementValue,return TEXT(""););

	/**
	 * Allows the list presenter to override the menu state that is used for rendering a specific element in the list.  Used for those
	 * lists which need to render some elements using the disabled state, for example.
	 *
	 * @param	ElementIndex		the index into the Elements array for the element to retrieve the menu state for.
	 * @param	out_OverrideState	receives the value of the menu state that should be used for rendering this element. if a specific
	 *								menu state is desired for the specified element, this value should be set to a child of UIState corresponding
	 *								to the menu state that should be used;  only used if the return value for this method is TRUE.
	 *
	 * @return	TRUE if the list presenter assigned a value to out_OverrideState, indicating that the element should be rendered using that menu
	 *			state, regardless of which menu state the list is currently in.  FALSE if the list presenter doesn't want to override the menu
	 *			state for this element.
	 */
	virtual UBOOL GetOverrideMenuState( INT ElementIndex, UClass*& out_OverrideState ) PURE_VIRTUAL(UUIComp_ListPresenterBase::GetOverrideMenuState,return FALSE;);

	/**
	 * Resolves the element schema provider based on the owning list's data source binding, and repopulates the element schema based on
	 * the available data fields in that element schema provider.
	 */
	virtual void RefreshElementSchema() {}

	/**
	 * @return	TRUE if the index is a valid index for this component's schema cell array
	 */
	virtual UBOOL IsValidSchemaIndex( INT SchemaCellIndex ) const PURE_VIRTUAL(UUIComp_ListPresenterBase::IsValidSchemaIndex,return FALSE;);

	/**
	 * @return	TRUE if the index is a valid index for this component's list of elements.
	 */
	virtual UBOOL IsValidElementIndex( INT ElementIndex ) const PURE_VIRTUAL(UUIComp_ListPresenterBase::IsValidElementIndex,return FALSE;);

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState ) PURE_VIRTUAL(UUIComp_ListPresenterBase::ToggleStyleDirtiness,);

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle ) PURE_VIRTUAL(UUIComp_ListPresenterBase::UsesStyle,return FALSE;);

	/**
	 * Retrieves a reference to the custom style currently assigned to the specified cell
	 *
	 * @param	ElementState	the cell state to retrieve the custom style for
	 * @param	CellIndex		the index of the cell (column if linked columns, row if linked rows) to retrieve style for
	 *
	 * @return	a pointer to the UIStyleReference struct from the specified cell, or NULL if the state of cell index are invalid.
	 */
	virtual struct FUIStyleReference* GetCustomCellStyle( EUIListElementState ElementState, INT CellIndex ) { return NULL; }

	/**
	 * Assigns the style for the cell specified and refreshes the cell's resolved style.
	 *
	 * @param	NewStyle		the new style to assign to this widget
	 * @param	ElementState	the list element state to set the element style for
	 * @param	CellIndex		indicates the column (if columns are linked) or row (if rows are linked) to apply the style to
	 *
	 * @return	TRUE if the style was successfully applied to the cell.
	 */
	virtual UBOOL SetCustomCellStyle( class UUIStyle* NewStyle, EUIListElementState ElementState, INT CellIndex ) { return FALSE; };

	/**
	 * Applies the resolved style data for the column header style to the schema cells' strings.  This function is called anytime
	 * the header style data that is applied to the schema cells is no longer valid, such as when the owning list's menu state is changed.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 */
	virtual void ApplyColumnHeaderStyle( UUIStyle* ResolvedStyle ) {}

	/**
	 * Notification that the list's style has been changed.  Updates the cached cell styles for all elements for the specified
	 * list element state.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	virtual void OnListStyleChanged( EUIListElementState ElementState ) {}

	/**
	 * Notification that the list's menu state has changed.  Reapplies the specified cell style for all elements based on the
	 * new menu state.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	virtual void OnListMenuStateChanged( EUIListElementState ElementState ) {}

	/**
	 * Renders the elements in this list.
	 *
	 * @param	RI					the render interface to use for rendering
	 */
	virtual void Render_List( FCanvas* Canvas ) PURE_VIRTUAL(UUIComp_ListPresenterBase::Render_List,);

	/**
	 * Notifies the owning widget that the formatting and render parameters for the list need to be updated.
	 *
	 * @param	bRequestSceneUpdate		if TRUE, requests the scene to update the positions for all widgets at the beginning of the next frame
	 */
	virtual void ReapplyFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Wrapper for determining the optimal size of a single row in the list.  Only relevant for lists which have a CellLinkType of LINKED_None
	 * or LINKED_Columns.
	 *
	 * @param	RowIndex			the index for the row to get the height for.  If the index is invalid, returns the height of the list's
	 *								schema cells instead, which do not necessarily use the same font.
	 * @param	out_RowHeight		receives the height of the row
	 * @param	out_StylePadding	receives the value for an optional padding amount applied by the cell's style.
	 * @param	bReturnUnformattedValue
	 *							specify TRUE to return a value determined by the size of a typical character from the font applied to the cell; otherwise,
	 *							uses the cell string's calculated StringExtent, which will include any scaling that has been applied.
	 */
	virtual void CalculateAutoSizeRowHeight( INT RowIndex, FLOAT& out_RowHeight, FLOAT& out_StylePadding, UBOOL bReturnUnformattedValue=FALSE ) PURE_VIRTUAL(UUIComp_ListPresenterBase::CalculateAutoSizeRowHeight,);

	/**
	 * Wrapper for determining the optimal size of a single column in the list.  Only relevant for lists which have a CellLinkType of LINKED_None
	 * or LINKED_Rows.
	 *
	 * @param	ColIndex			the index for the column to get the width for.  If the index is invalid, returns the width of the list's
	 *								schema cells instead, which do not necessarily use the same font.
	 * @param	out_ColWidth		receives the width of the column
	 * @param	out_StylePadding	receives the value for an optional padding amount applied by the cell's style.
	 * @param	bReturnUnformattedValue
	 *							specify TRUE to return a value determined by the size of a typical character from the font applied to the cell; otherwise,
	 *							uses the cell string's calculated StringExtent, which will include any scaling that has been applied.
	 */
	virtual void CalculateAutoSizeColumnWidth( INT ColIndex, FLOAT& out_ColWidth, FLOAT& out_StylePadding, UBOOL bReturnUnformattedValue=FALSE ) PURE_VIRTUAL(UUIComp_ListPresenterBase::CalculateAutoSizeColumnWidth,);

	/**
	 * Wrapper for setting the maximum number of elements that will be displayed by the list at once.
	 *
	 * @param	NewMaxVisibleElements	the maximum number of elements to show at a time. 0 to disable.
	 */
	virtual void SetMaxElementsPerPage( INT NewMaxVisibleElements ) PURE_VIRTUAL(UUIComp_ListPresenterBase::SetMaxElementsPerPage,);

	/**
	 * Wrapper for retrieving the current value of MaxElementsPerPage
	 */
	virtual INT GetMaxElementsPerPage() const PURE_VIRTUAL(UUIComp_ListPresenterBase::GetMaxElementsPerPage,return 0;);

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Adjusts the owning widget's bounds
	 * according to the wrapping mode and autosize behaviors.
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Returns the number of rows the list can dislay
	 */
	INT GetMaxNumVisibleRows() const;

	/**
	 * Returns the number of columns the list can display
	 */
	INT GetMaxNumVisibleColumns() const;

	/**
	 * Returns the total number of rows in this list.
	 */
	INT GetTotalRowCount() const;

	/**
	 * Returns the total number of columns in this list.
	 */
	INT GetTotalColumnCount() const;

	/**
	 * Returns whether element size is determined by the elements themselves.  For lists with linked columns, returns whether
	 * the item height is autosized; for lists with linked rows, returns whether item width is autosized.
	 */
	UBOOL IsElementAutoSizingEnabled() const;

	/**
	 * @return the number of cells in the list's schema
	 */
	virtual INT GetSchemaCellCount() const { return 0; }

	/**
	 * Determine the size of the schema cell at the specified index.
	 *
	 * @param	SchemaCellIndex		the index of the schema cell to get the size for
	 * @param	EvalType			the desired format to return the size in.
	 *
	 * @return	the size of the schema cell at the specified index in the desired format, or -1 if the index is invalid.
	 */
	virtual FLOAT GetSchemaCellSize( INT SchemaCellIndex, EUIExtentEvalType EvalType=UIEXTENTEVAL_Pixels ) const { return -1.f; }

	/**
	 * Change the size of the schema cell at the specified index.
	 *
	 * @param	SchemaCellIndex		the index of the schema cell to set the size for
	 * @param	NewCellSize			the new size for the cell
	 * @param	EvalType			indicates how to evalute the input value
	 *
	 * @return	TRUE if the size was updated successfully; FALSE if the size was not changed or the index was invalid.
	 */
	virtual UBOOL SetSchemaCellSize( INT SchemaCellIndex, FLOAT NewCellSize, EUIExtentEvalType EvalType=UIEXTENTEVAL_Pixels ) { return FALSE; }

	/**
	 * Retrieves the position of the left or top of the cell specified.  For lists with linked columns, SchemaCellIndex would correspond to the column;
	 * for cells with linked rows, it would represent the row index.
	 *
	 * @param	SchemaCellIndex		the index of the schema cell to get the position for
	 *
	 * @return	the position for the specified cell, in screen space absolute pixels relative to 0,0, or -1 if the cell index is invalid.
	 */
	virtual FLOAT GetSchemaCellPosition( INT SchemaCellIndex ) const { return -1.f; }

protected:
	/**
	 * Changes the cell state for the specified element.
	 *
	 * @param	ElementIndex	the index of the element to change states for
	 * @param	NewElementState	the new state to place the element in
	 *
	 * @return	TRUE if the new state was successfully applied to the new element, FALSE otherwise.
	 */
	virtual UBOOL SetElementState( INT ElementIndex, EUIListElementState NewElementState ) PURE_VIRTUAL(UUIComp_ListPresenterBase::SetElementState,return FALSE;);

	/**
	 * @return	the cell state for the specified element, or ELEMENT_MAX if the index is invalid.
	 */
	virtual EUIListElementState GetElementState( INT ElementIndex ) const PURE_VIRTUAL(UUIComp_ListPresenterBase::GetElementState,return ELEMENT_MAX;);

public:
	/**
	 * Determines the appropriate position for the selection hint object based on the size of the list's rows and any padding that must be taken
	 * into account.
	 *
	 * @param	SelectionHintObject		the widget that will display the selection hint (usually a label).
	 * @param	ElementIndex			the index of the element to display the selection hint next to.
	 */
	virtual UBOOL SetSelectionHintPosition( UUIObject* SelectionHintObject, INT ElementIndex ) { return FALSE; }

protected:
	/**
	 * Determines the maximum number of elements which can be rendered given the owning list's bounding region.
	 */
	virtual void CalculateVisibleElements( FRenderParameters& Parameters );

	/**
	 * Initializes the render parameters that will be used for formatting the list elements.
	 *
	 * @param	Face			the face that was being resolved
	 * @param	out_Parameters	[out] the formatting parameters to use when calling ApplyFormatting.
	 *
	 * @return	TRUE if the formatting data is ready to be applied to the list elements, taking into account the autosize settings.
	 */
	virtual UBOOL GetListRenderParameters( EUIWidgetFace Face, FRenderParameters& out_Parameters );

	/**
	 * Wrapper for getting the docking-state of the owning widget's four faces.  No special logic here, but child classes
	 * can use this method to make the formatting code ignore the fact that the widget may be docked (in cases where it is
	 * irrelevant)
	 *
	 * @param	bFaceDocked		[out] an array of bools representing whether the widget is docked on the respective face.
	 */
	virtual void GetOwnerDockingState( UBOOL* bFaceDocked[UIFACE_MAX] ) const;

	/**
	 * Adjusts the owning widget's bounds according to the autosize settings.
	 */
	virtual void UpdateOwnerBounds( FRenderParameters& Parameters );

	/**
	 * Setup the left, top, width, and height values that will be used to render the list.  This will typically be the list's
	 * RenderBounds, unless the elements should be rendered in a subportion of the list.
	 *
	 * @fixme ronp - mmmmm, this is a bit hacky..  we're already doing something similar on the formatting side...seems like
	 * we should be able to leverage that work so that we don't get out of sync.  :\
	 */
	virtual void InitializeRenderingParms( FRenderParameters& Parameters, FCanvas* Canvas=NULL );

	/**
	 * Calculates the maximum number of visible elements and calls ApplyElementFormatting for all elements.
	 *
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyListFormatting( FRenderParameters& Parameters );

	/**
	 * Updates the formatting parameters for all cells of the specified element.
	 *
	 * @param	ElementIndex	the list element to apply formatting for.
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyElementFormatting( INT ElementIndex, FRenderParameters& Parameters ) PURE_VIRTUAL(UUIComp_ListPresenterBase::ApplyElementFormatting,);

	/**
	 * Wrapper for applying formatting to the schema cells.
	 */
	virtual void FormatSchemaCells( FRenderParameters& Parameters ) {};

	/**
	 * Renders the list element specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	ElementIndex	the list element to render
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in]	specifies the pixel location of the start of the horizontal bounding region that should be used for
	 *												rendering this element
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the pixel Y location of the bounding region that should be used for rendering this list element.
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering this element.  This is the Y position for rendering
	 *												the next element should be rendered
	 *							DrawXL:		[in]	specifies the pixel location of the end of the horizontal bounding region that should be used for rendering this element.
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in pixels.  If this value is not large enough to render the specified element,
	 *												the element will not be rendered.
	 *										[out]	Will be reduced by the height of the element that was rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the element
	 */
	virtual void Render_ListElement( FCanvas* Canvas, INT ElementIndex, FRenderParameters& Parameters ) PURE_VIRTUAL(UUIComp_ListPresenterBase::Render_ListElement,);

	/**
	 * Retrieves the list of data stores bound by this subscriber.
	 *
	 * @param	out_BoundDataStores		receives the array of data stores that subscriber is bound to.
	 */
	virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores) PURE_VIRTUAL(UUIComp_ListPresenterBase::GetBoundDataStores,);

	/**
	 * Changes the data binding for the specified cell index.
	 *
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader		the string that should be displayed in the column header for this cell.
	 * @param	BindingIndex		the column or row to bind this data field to.  If BindingIndex is greater than the number
	 *								schema cells, empty schema cells will be added to meet the number required to place the data
	 *								at BindingIndex.
	 *								If a value of INDEX_NONE is specified, the cell binding will only occur if there are no other
	 *								schema cells bound to that data field.  In this case, a new schema cell will be appended and
	 *								it will be bound to the data field specified.
	 */
	virtual UBOOL SetCellBinding( FName CellDataBinding, const FString& ColumnHeader, INT BindingIndex ) PURE_VIRTUAL(UUIComp_ListPresenterBase::SetCellBinding,return FALSE;);

	/**
	 * Inserts a new schema cell at the specified index and assigns the data binding.
	 *
	 * @param	InsertIndex			the column/row to insert the schema cell; must be a valid index.
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
	 *
	 * @return	TRUE if the schema cell was successfully inserted into the list
	 */
	virtual UBOOL InsertSchemaCell( INT InsertIndex, FName CellDataBinding, const FString& ColumnHeader ) PURE_VIRTUAL(UUIComp_ListPresenterBase::InsertSchemaCell,return FALSE;);

	/**
	 * Retrieves the name of the binding for the specified location in the schema.
	 *
	 * @param	BindingIndex	the index for the cell/column to get the binding for
	 *
	 * @return	the value assigned to the schema cell at the specified location, or NAME_None if the binding index is invalid.
	 */
	virtual FName GetCellBinding( INT BindingIndex ) const PURE_VIRTUAL(UUIComp_ListPresenterBase::GetCellBinding,return NAME_None;);

	/**
	 * Removes all schema cells which are bound to the specified data field.
	 *
	 * @return	TRUE if one or more schema cells were successfully removed.
	 */
	virtual UBOOL ClearCellBinding( FName CellDataBinding ) PURE_VIRTUAL(UUIComp_ListPresenterBase::ClearCellBinding,return FALSE;);

	/**
	 * Removes schema cells at the location specified.  If the list's columns are linked, this index should correspond to
	 * the column that should be removed; if the list's rows are linked, this index should correspond to the row that should
	 * be removed.
	 *
	 * @return	TRUE if the schema cell at BindingIndex was successfully removed.
	 */
	virtual UBOOL ClearCellBinding( INT BindingIndex ) PURE_VIRTUAL(UUIComp_ListPresenterBase::ClearCellBinding,return FALSE;);

	/**
	 * Wrapper for changing the surface assigned to a UITexture contained by this component.
	 *
	 * @param	ImageRef	the UITexture that will be created and/or updated
	 * @param	NewImage	the texture or material to apply to the ImageRef.
	 */
	void SetImage( UUITexture** ImageRef, USurface* NewImage );
};

struct FUIListElementCell
{
    INT ContainerElementIndex;
    class UUIList* OwnerList;
    struct FUIStyleReference CellStyle[4];

		union { class UUIObject* ValueChild; class UUIListString* ValueString; };

		/** Script Constructors */
		FUIListElementCell()
		: ContainerElementIndex(INDEX_NONE), OwnerList(NULL), ValueChild(NULL)
		{}
		FUIListElementCell(EEventParm);

		/**
		 * Called when this cell is created while populating the elements for the owning list. Creates the cell's UIListString.
		 */
		void OnCellCreated( INT ElementIndex, class UUIList* inOwnerList );

		/**
		 * Called when this cell is created while populating the elements for the owning list. Assigns the specified
		 * widget as the value for ValueChild.
		 */
		void OnCellCreated( INT ElementIndex, class UUIList* inOwnerList, class UUIObject* CellWidget );

		/**
		 * Resolves the value of the specified tag from the DataProvider and assigns the result to this cell's ValueString.
		 *
		 * @param	DataSource		the data source to use for populating this cell's data
		 * @param	CellBindingTag	the tag (from the list supported by DataProvider) that should be associated with this
		 *							UIListElementCell.
		 *
		 * @note: even though this method is overridden in FUIListElementCellTemplate, it is intended to be non-virtual!
		 */
		void AssignBinding( struct FUIListItemDataBinding& DataSource, FName CellBindingTag );

		/**
		 * Resolves the CellStyle for the specified element state using the currently active skin.  This function is called
		 * anytime the cached cell style no longer is out of date, such as when the currently active skin has been changed.
		 *
		 * @param	ElementState	the list element state to update the element style for
		 */
		void ResolveCellStyles( EUIListElementState ElementState );

		/**
		 * Propagates the style data for the current menu state and element state to each cell .  This function is called anytime
		 * the style data that is applied to each cell is no longer valid, such as when the cell's CellState changes or when the
		 * owning list's menu state is changed.
		 *
		 * @param	ElementState	the list element state to update the element style for
		 */
		void ApplyCellStyleData( EUIListElementState ElementState );

		/**
		 * @return	the list element (UIListItem) that contains this cell
		 */
		struct FUIListItem* GetContainerElement() const;

		/**
		 * @return	TRUE if this cell displays a UIObject rather than a string.
		 */
		UBOOL IsObjectCell() const;
	
};

struct FUIListElementCellTemplate : public FUIListElementCell
{
    FName CellDataField;
    FStringNoInit ColumnHeaderText;
    struct FUIScreenValue_Extent CellSize;
    FLOAT CellPosition;

		/** Script Constructor */
		FUIListElementCellTemplate() {}
		FUIListElementCellTemplate(EEventParm);

		/**
		 * Called when this cell is created while populating the elements for the owning list. Creates the cell's UIListString.
		 */
		void OnCellCreated( class UUIList* inOwnerList );

		/**
		 * Initializes the specified cell based on this cell template.
		 *
		 * @param	DataSource		the information about the data source for this element
		 * @param	TargetCell		the cell to initialize.
		 */
		void InitializeCell( struct FUIListItemDataBinding& DataSource, struct FUIListElementCell& TargetCell );

		/**
		 * Resolves the value of the specified tag from the DataProvider and assigns the result to this cell's ValueString.
		 *
		 * @param	DataProvider	the object which contains the data for this element cell.
		 * @param	CellBindingTag	the tag (from the list supported by DataProvider) that should be associated with this
		 *							UIListElementCell.
		 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
		 */
		void AssignBinding( TScriptInterface<class IUIListElementCellProvider> DataProvider, FName CellBindingTag, const FString& ColumnHeader );

		/**
		 * Applies the resolved style data for the column header style to the schema cells' strings.  This function is called anytime
		 * the header style data that is applied to the schema cells is no longer valid, such as when the owning list's menu state is changed.
		 *
		 * @param	ResolvedStyle			the style resolved by the style reference
		 */
		void ApplyHeaderStyleData( UUIStyle* ResolvedStyle );
	
};

struct FUIListItem
{
    struct FUIListItemDataBinding DataSource;
    TArrayNoInit<struct FUIListElementCell> Cells;
    BYTE ElementState;
    class UUIObject* ElementWidget;

		/** Script Constructors */
		FUIListItem() {}
		FUIListItem(EEventParm)
		{
			appMemzero(this, sizeof(FUIListItem));
		}

		/** Standard ctor */
		FUIListItem( const struct FUIListItemDataBinding& InDataSource, UUIObject* inValueChild=NULL );

		/**
		 * Changes the ElementState for this element and refreshes its cell's cached style references based on the new cell state
		 *
		 * @param	NewElementState	the new element state to use.
		 *
		 * @return	TRUE if the element state actually changed.
		 */
		UBOOL SetElementState( EUIListElementState NewElementState );
	
};

struct FUIElementCellSchema
{
    TArrayNoInit<struct FUIListElementCellTemplate> Cells;

		/** Script Constructors */
		FUIElementCellSchema() {}
		FUIElementCellSchema(EEventParm)
		{
			appMemzero(this, sizeof(FUIElementCellSchema));
		}
	
};

class UUIComp_ListPresenter : public UUIComp_ListPresenterBase, public ICustomPropertyItemHandler
{
public:
    //## BEGIN PROPS UIComp_ListPresenter
    struct FUIElementCellSchema ElementSchema;
    struct FUIScreenValue_Extent SelectionHintPadding;
    TArray<struct FUIListItem> ListItems;
    class UUITexture* ColumnHeaderBackground[3];
    class UUITexture* ListItemOverlay[4];
    struct FTextureCoordinates ColumnHeaderBackgroundCoordinates[3];
    struct FTextureCoordinates ListItemOverlayCoordinates[4];
private:
    INT MaxElementsPerPage;
    BITFIELD bDisplayColumnHeaders:1;
public:
    //## END PROPS UIComp_ListPresenter

    INT FindElementIndex(INT DataSourceIndex) const;
    DECLARE_FUNCTION(execFindElementIndex)
    {
        P_GET_INT(DataSourceIndex);
        P_FINISH;
        *(INT*)Result=FindElementIndex(DataSourceIndex);
    }
    DECLARE_CLASS(UUIComp_ListPresenter,UUIComp_ListPresenterBase,0,Engine)
    virtual UObject* GetUObjectInterfaceCustomPropertyItemHandler(){return this;}
	friend class UUIList;

	/**
	 * Called when a new element is added to the list that owns this component.  Creates a UIElementCellList for the specified element.
	 *
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the element.  If the value is
	 *								not a valid index, the element will be added to the end of the list.
	 * @param	ElementValue		the index [into the data provider's collection] for the element that is being inserted into the list.
	 *
	 * @return	the index where the new element was inserted, or INDEX_NONE if the element wasn't added to the list.
	 */
	virtual INT InsertElement( INT InsertIndex, INT ElementValue );

	/**
	 * Called when an element is removed from the list that owns this component.  Removes the UIElementCellList located at the
	 * specified index.
	 *
	 * @param	RemovalIndex	the index for the element that should be removed from the list
	 *
	 * @return	the index [into the ElementCells array] for the element that was removed, or INDEX_NONE if RemovalIndex was invalid
	 *			or that element couldn't be removed from this list.
	 */
	virtual INT RemoveElement( INT RemovalIndex );

	/**
	 * Refreshes the value of all cells for the specified element
	 *
	 * @param	ElementIndex	the index of the element that needs to be refreshed.
	 */
	virtual void RefreshElement( INT ElementIndex );

	/**
	 * Swaps the values at the specified indexes, reversing their positions in the ListItems array.
	 *
	 * @param	IndexA	the index into the ListItems array for the first element to swap
	 * @param	IndexB	the index into the ListItems array for the second element to swap
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElements( INT IndexA, INT IndexB );

	/**
	 * Returns the text value for the specified element.
	 *
	 * @param	ElementIndex	index [into the Items array] for the value to return.
	 * @param	CellIndex		for lists which have linked columns or rows, indicates which column/row to retrieve.
	 *
	 * @return	the value of the specified element, or an empty string if that element doesn't have a text value.
	 *
	 * @note: noexport because it is pure virtual natively
	 */
	virtual FString GetElementValue( INT ElementIndex, INT CellIndex=INDEX_NONE ) const;

	/**
	 * Wrapper for determining the optimal size of a single row in the list.  Only relevant for lists which have a CellLinkType of LINKED_None
	 * or LINKED_Columns.
	 *
	 * @param	RowIndex			the index for the row to get the height for.  If the index is invalid, returns the height of the list's
	 *								schema cells instead, which do not necessarily use the same font.
	 * @param	out_RowHeight		receives the height of the row
	 * @param	out_StylePadding	receives the value for an optional padding amount applied by the cell's style.
	 * @param	bReturnUnformattedValue
	 *							specify TRUE to return a value determined by the size of a typical character from the font applied to the cell; otherwise,
	 *							uses the cell string's calculated StringExtent, which will include any scaling that has been applied.
	 *
	 * @note: noexport because it is pure virtual natively
	 */
	virtual void CalculateAutoSizeRowHeight( INT RowIndex, FLOAT& out_RowHeight, FLOAT& out_StylePadding, UBOOL bReturnUnformattedValue=FALSE );

	/**
	 * Wrapper for determining the optimal size of a single column in the list.  Only relevant for lists which have a CellLinkType of LINKED_None
	 * or LINKED_Rows.
	 *
	 * @param	ColIndex			the index for the column to get the width for.  If the index is invalid, returns the width of the list's
	 *								schema cells instead, which do not necessarily use the same font.
	 * @param	out_ColWidth		receives the width of the column
	 * @param	out_StylePadding	receives the value for an optional padding amount applied by the cell's style.
	 * @param	bReturnUnformattedValue
	 *							specify TRUE to return a value determined by the size of a typical character from the font applied to the cell; otherwise,
	 *							uses the cell string's calculated StringExtent, which will include any scaling that has been applied.
	 *
	 * @note: noexport because it is pure virtual natively
	 */
	virtual void CalculateAutoSizeColumnWidth( INT ColIndex, FLOAT& out_ColWidth, FLOAT& out_StylePadding, UBOOL bReturnUnformattedValue=FALSE );

	/**
	 * Allows the list presenter to override the menu state that is used for rendering a specific element in the list.  Used for those
	 * lists which need to render some elements using the disabled state, for example.
	 *
	 * @param	ElementIndex		the index into the Elements array for the element to retrieve the menu state for.
	 * @param	out_OverrideState	receives the value of the menu state that should be used for rendering this element. if a specific
	 *								menu state is desired for the specified element, this value should be set to a child of UIState corresponding
	 *								to the menu state that should be used;  only used if the return value for this method is TRUE.
	 *
	 * @return	TRUE if the list presenter assigned a value to out_OverrideState, indicating that the element should be rendered using that menu
	 *			state, regardless of which menu state the list is currently in.  FALSE if the list presenter doesn't want to override the menu
	 *			state for this element.
	 */
	virtual UBOOL GetOverrideMenuState( INT ElementIndex, UClass*& out_OverrideState );

	/**
	 * Resolves the element schema provider based on the owning list's data source binding, and repopulates the element schema based on
	 * the available data fields in that element schema provider.
	 */
	virtual void RefreshElementSchema();

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState );

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle );

	/**
	 * Retrieves a reference to the custom style currently assigned to the specified cell
	 *
	 * @param	ElementState	the cell state to retrieve the custom style for
	 * @param	CellIndex		the index of the cell (column if linked columns, row if linked rows) to retrieve style for
	 *
	 * @return	a pointer to the UIStyleReference struct from the specified cell, or NULL if the state of cell index are invalid.
	 */
	virtual FUIStyleReference* GetCustomCellStyle( EUIListElementState ElementState, INT CellIndex );

	/**
	 * Assigns the style for the cell specified and refreshes the cell's resolved style.
	 *
	 * @param	NewStyle		the new style to assign to this widget
	 * @param	ElementState	the list element state to set the element style for
	 * @param	CellIndex		indicates the column (if columns are linked) or row (if rows are linked) to apply the style to
	 *
	 * @return	TRUE if the style was successfully applied to the cell.
	 */
	virtual UBOOL SetCustomCellStyle( class UUIStyle* NewStyle, EUIListElementState ElementState, INT CellIndex );

	/**
	 * Applies the resolved style data for the column header style to the schema cells' strings.  This function is called anytime
	 * the header style data that is applied to the schema cells is no longer valid, such as when the owning list's menu state is changed.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 */
	virtual void ApplyColumnHeaderStyle( UUIStyle* ResolvedStyle );

	/**
	 * Notification that the list's style has been changed.  Updates the cached cell styles for all elements for the specified
	 * list element state.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	virtual void OnListStyleChanged( EUIListElementState ElementState );

	/**
	 * Notification that the list's menu state has changed.  Reapplies the specified cell style for all elements based on the
	 * new menu state.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	virtual void OnListMenuStateChanged( EUIListElementState ElementState );

	/**
	 * Renders the elements in this list.
	 *
	 * @param	RI					the render interface to use for rendering
	 */
	virtual void Render_List( FCanvas* Canvas );

protected:
	/**
	 * Changes the cell state for the specified element.
	 *
	 * @param	ElementIndex	the index of the element to change states for
	 * @param	NewElementState	the new state to place the element in
	 *
	 * @return	TRUE if the new state was successfully applied to the new element, FALSE otherwise.
	 */
	virtual UBOOL SetElementState( INT ElementIndex, EUIListElementState NewElementState );

	/**
	 * @return	the cell state for the specified element, or ELEMENT_MAX if the index is invalid.
	 */
	virtual EUIListElementState GetElementState( INT ElementIndex ) const;

public:
	/**
	 * @return	TRUE if the index is a valid index for this component's schema cell array
	 */
	virtual UBOOL IsValidSchemaIndex( INT SchemaCellIndex ) const;

	/**
	 * @return	TRUE if the index is a valid index for this component's list of elements.
	 */
	virtual UBOOL IsValidElementIndex( INT ElementIndex ) const;

	/**
	 * Determines the appropriate position for the selection hint object based on the size of the list's rows and any padding that must be taken
	 * into account.
	 *
	 * @param	SelectionHintObject		the widget that will display the selection hint (usually a label).
	 * @param	ElementIndex			the index of the element to display the selection hint next to.
	 */
	virtual UBOOL SetSelectionHintPosition( UUIObject* SelectionHintObject, INT ElementIndex );

	/**
	 * Determine the size of the schema cell at the specified index.
	 *
	 * @param	SchemaCellIndex		the index of the schema cell to get the size for
	 * @param	EvalType			the desired format to return the size in.
	 *
	 * @return	the size of the schema cell at the specified index in the desired format, or -1 if the index is invalid.
	 */
	virtual FLOAT GetSchemaCellSize( INT SchemaCellIndex, EUIExtentEvalType EvalType=UIEXTENTEVAL_Pixels ) const;

	/**
	 * Change the size of the schema cell at the specified index.
	 *
	 * @param	SchemaCellIndex		the index of the schema cell to set the size for
	 * @param	NewCellSize			the new size for the cell
	 * @param	EvalType			indicates how to evalute the input value
	 *
	 * @return	TRUE if the size was updated successfully; FALSE if the size was not changed or the index was invalid.
	 */
	virtual UBOOL SetSchemaCellSize( INT SchemaCellIndex, FLOAT NewCellSize, EUIExtentEvalType EvalType=UIEXTENTEVAL_Pixels );

	/**
	 * Retrieves the position of the left or top of the cell specified.  For lists with linked columns, SchemaCellIndex would correspond to the column;
	 * for cells with linked rows, it would represent the row index.
	 *
	 * @param	SchemaCellIndex		the index of the schema cell to get the position for
	 *
	 * @return	the position for the specified cell, in screen space absolute pixels relative to 0,0, or -1 if the cell index is invalid.
	 */
	virtual FLOAT GetSchemaCellPosition( INT SchemaCellIndex ) const;

	/**
	 * @return the number of cells in the list's schema
	 */
	virtual INT GetSchemaCellCount() const;

	/**
	 * Returns whether this list should render column headers
	 */
	virtual UBOOL ShouldRenderColumnHeaders() const;

	/**
	 * Changes whether this list renders colum headers or not.  Only applicable if the owning list's CellLinkType is LINKED_Columns
	 */
	virtual void EnableColumnHeaderRendering( UBOOL bShouldRenderColHeaders=TRUE );

	/**
	 * Wrapper for setting the maximum number of elements that will be displayed by the list at once.
	 *
	 * @param	NewMaxVisibleElements	the maximum number of elements to show at a time. 0 to disable.
	 */
	virtual void SetMaxElementsPerPage( INT NewMaxVisibleElements );

	/**
	 * Wrapper for retrieving the current value of MaxElementsPerPage
	 */
	virtual INT GetMaxElementsPerPage() const;

protected:
	/**
	 * Updates the formatting parameters for all cells of the specified element.
	 *
	 * @param	ElementIndex	the list element to apply formatting for.
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyElementFormatting( INT ElementIndex, FRenderParameters& Parameters );

	/**
	 * Wrapper for applying formatting to the schema cells.
	 */
	virtual void FormatSchemaCells( FRenderParameters& Parameters );

	/**
	 * Updates the formatting parameters for all cells of the specified element.
	 *
	 * @param	Cells			the list of cells to render
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyCellFormatting( TArray<FUIListElementCell*> Cells, FRenderParameters& Parameters );

	/**
	 * Renders the overlay image for a single list element.  Moved into a separate function to allow child classes to easily override
	 * and modify the way that the overlay is rendered.
	 *
	 * @param	same as Render_ListElement, except that no values are passed back to the caller.
	 */
	virtual void Render_ElementOverlay( FCanvas* Canvas, INT ElementIndex, const FRenderParameters& Parameters, const FVector2D& DefaultCellSize );

	/**
	 * Renders the list element specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	ElementIndex	the list element to render
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in]	specifies the pixel location of the start of the horizontal bounding region that should be used for
	 *												rendering this element
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the pixel Y location of the bounding region that should be used for rendering this list element.
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering this element.  This is the Y position for rendering
	 *												the next element should be rendered
	 *							DrawXL:		[in]	specifies the pixel location of the end of the horizontal bounding region that should be used for rendering this element.
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in pixels.  If this value is not large enough to render the specified element,
	 *												the element will not be rendered.
	 *										[out]	Will be reduced by the height of the element that was rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the element
	 */
	virtual void Render_ListElement( FCanvas* Canvas, INT ElementIndex, FRenderParameters& Parameters );

	/**
	 * Renders the list element cells specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	ElementIndex	the index of the element being rendered; INDEX_NONE if rendering header cells.
	 * @param	Cells			the list of cells to render
	 * @param	CellParameters	Used for various purposes:
	 *							DrawX:		[in]	specifies the location of the start of the horizontal bounding region that should be used for
	 *												rendering the cells, in absolute screen pixels
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the location of the start of the vertical bounding region that should be used for rendering
	 *												the cells, in absolute screen pixels
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering all cells.
	 *							DrawXL:		[in]	specifies the location of the end of the horizontal bounding region that should be used for rendering this element, in absolute screen pixels
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in absolute screen pixels.  If this value is not large enough to render the cells, they will not be
	 *												rendered
	 *										[out]	Will be reduced by the height of the cells that were rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the cells
	 */
	virtual void Render_Cells( FCanvas* Canvas, INT ElementIndex, const TArray<FUIListElementCell*> Cells, FRenderParameters& CellParameters );

	/**
	 * Renders the background texture for a column header.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	CellParameters	see Render_Cells
	 * @param	CellIndex		which column is being rendered; used for determining whether one of the "sort" styles should be used.
	 */
	virtual void Render_ColumnBackground( FCanvas* Canvas, const FRenderParameters& CellParameters, INT CellIndex );

	/**
	 * Retrieves the list of data stores bound by this subscriber.
	 *
	 * @param	out_BoundDataStores		receives the array of data stores that subscriber is bound to.
	 */
	virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);

	/**
	 * Changes the data binding for the specified cell index.
	 *
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader		the string that should be displayed in the column header for this cell.
	 * @param	BindingIndex		the column or row to bind this data field to.  If BindingIndex is greater than the number
	 *								schema cells, empty schema cells will be added to meet the number required to place the data
	 *								at BindingIndex.
	 *								If a value of INDEX_NONE is specified, the cell binding will only occur if there are no other
	 *								schema cells bound to that data field.  In this case, a new schema cell will be appended and
	 *								it will be bound to the data field specified.
	 */
	virtual UBOOL SetCellBinding( FName CellDataBinding, const FString& ColumnHeader, INT BindingIndex );

	/**
	 * Inserts a new schema cell at the specified index and assigns the data binding.
	 *
	 * @param	InsertIndex			the column/row to insert the schema cell; must be a valid index.
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
	 *
	 * @return	TRUE if the schema cell was successfully inserted into the list
	 */
	virtual UBOOL InsertSchemaCell( INT InsertIndex, FName CellDataBinding, const FString& ColumnHeader );

	/**
	 * Retrieves the name of the binding for the specified location in the schema.
	 *
	 * @param	BindingIndex	the index for the cell/column to get the binding for
	 *
	 * @return	the value assigned to the schema cell at the specified location, or NAME_None if the binding index is invalid.
	 */
	virtual FName GetCellBinding( INT BindingIndex ) const;

	/**
	 * Removes all schema cells which are bound to the specified data field.
	 *
	 * @return	TRUE if one or more schema cells were successfully removed.
	 */
	virtual UBOOL ClearCellBinding( FName CellDataBinding );

	/**
	 * Removes schema cells at the location specified.  If the list's columns are linked, this index should correspond to
	 * the column that should be removed; if the list's rows are linked, this index should correspond to the row that should
	 * be removed.
	 *
	 * @return	TRUE if the schema cell at BindingIndex was successfully removed.
	 */
	virtual UBOOL ClearCellBinding( INT BindingIndex );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.  When the data source for the cell schema is changed,
	 * refreshes the list's data.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a member property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Copies the value of the deprecated SelectionOverlay/Coordinates into the appropriate element of the ItemOverlay array.
	 */
	virtual void PostLoad();

	/* === CustomPropertyItemHandler interface === */
	/**
	 * Determines whether the specified property value matches the current value of the property.  Called after the user
	 * has changed the value of a property handled by a custom property window item.  Is used to determine whether Pre/PostEditChange
	 * should be called for the selected objects.
	 *
	 * @param	InProperty			the property whose value is being checked.
	 * @param	NewPropertyValue	the value to compare against the current value of the property.
	 * @param	ArrayIndex			the array index for the element being compared; only relevant for array properties
	 *
	 * @return	TRUE if NewPropertyValue matches the current value of the property specified, indicating that no effective changes
	 *			were actually made.
	 */
	virtual UBOOL IsCustomPropertyValueIdentical( UProperty* InProperty, const union UPropertyValue& NewPropertyValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Method for overriding the default behavior of applying property values received from a custom editor property window item.
	 *
	 * @param	InProperty		the property that is being edited
	 * @param	PropertyValue	the value to assign to the property
	 * @param	ArrayIndex		the array index for the element being changed; only relevant for array properties
	 *
	 * @return	TRUE if the property was handled by this object and the property value was successfully applied to the
	 *			object's data.
	 */
	virtual UBOOL EditorSetPropertyValue( UProperty* InProperty, const UPropertyValue& PropertyValue, INT ArrayIndex=INDEX_NONE );
};

class UUIComp_ListPresenterCascade : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_ListPresenterCascade
    //## END PROPS UIComp_ListPresenterCascade

    DECLARE_CLASS(UUIComp_ListPresenterCascade,UUIComp_ListPresenter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListPresenterCascade)
};

class UUIComp_ContextMenuListPresenter : public UUIComp_ListPresenterCascade
{
public:
    //## BEGIN PROPS UIComp_ContextMenuListPresenter
    //## END PROPS UIComp_ContextMenuListPresenter

    DECLARE_CLASS(UUIComp_ContextMenuListPresenter,UUIComp_ListPresenterCascade,0,Engine)
    DECLARE_WITHIN(UUIContextMenu)
	/**
	 * Resolves the element schema provider based on the owning list's data source binding, and repopulates the element schema based on
	 * the available data fields in that element schema provider.
	 */
	virtual void RefreshElementSchema();
};

class UUIComp_ListPresenterTree : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_ListPresenterTree
    //## END PROPS UIComp_ListPresenterTree

    DECLARE_CLASS(UUIComp_ListPresenterTree,UUIComp_ListPresenter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListPresenterTree)
};

class UUIComp_ObjectListPresenter : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_ObjectListPresenter
    //## END PROPS UIComp_ObjectListPresenter

    DECLARE_CLASS(UUIComp_ObjectListPresenter,UUIComp_ListPresenter,0,Engine)
    DECLARE_WITHIN(UUIObjectList)
	/* === UUIComp_ListPresenter interface === */
	/**
	 * Wrapper for determining the optimal size of a single row in the list.  Only relevant for lists which have a CellLinkType of LINKED_None
	 * or LINKED_Columns.
	 *
	 * @param	RowIndex			the index for the row to get the height for.  If the index is invalid, returns the height of the list's
	 *								schema cells instead, which do not necessarily use the same font.
	 * @param	out_RowHeight		receives the height of the row
	 * @param	out_StylePadding	receives the value for an optional padding amount applied by the cell's style.
	 * @param	bReturnUnformattedValue
	 *							specify TRUE to return a value determined by the size of a typical character from the font applied to the cell; otherwise,
	 *							uses the cell string's calculated StringExtent, which will include any scaling that has been applied.
	 */
	virtual void CalculateAutoSizeRowHeight( INT RowIndex, FLOAT& out_RowHeight, FLOAT& out_StylePadding, UBOOL bReturnUnformattedValue=FALSE );

	/**
	 * Wrapper for determining the optimal size of a single column in the list.  Only relevant for lists which have a CellLinkType of LINKED_None
	 * or LINKED_Rows.
	 *
	 * @param	ColIndex			the index for the column to get the width for.  If the index is invalid, returns the width of the list's
	 *								schema cells instead, which do not necessarily use the same font.
	 * @param	out_ColWidth		receives the width of the column
	 * @param	out_StylePadding	receives the value for an optional padding amount applied by the cell's style.
	 * @param	bReturnUnformattedValue
	 *							specify TRUE to return a value determined by the size of a typical character from the font applied to the cell; otherwise,
	 *							uses the cell string's calculated StringExtent, which will include any scaling that has been applied.
	 */
	virtual void CalculateAutoSizeColumnWidth( INT ColIndex, FLOAT& out_ColWidth, FLOAT& out_StylePadding, UBOOL bReturnUnformattedValue=FALSE );

	/**
	 * Called when a new element is added to the list that owns this component.  Creates a UIElementCellList for the specified element.
	 *
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the element.  If the value is
	 *								not a valid index, the element will be added to the end of the list.
	 * @param	ElementValue		the index [into the data provider's collection] for the element that is being inserted into the list.
	 *
	 * @return	the index where the new element was inserted, or INDEX_NONE if the element wasn't added to the list.
	 */
	virtual INT InsertElement( INT InsertIndex, INT ElementValue );
};

struct FUIAnimationNotify
{
    BYTE NotifyType;
    FName NotifyName;

    /** Constructors */
    FUIAnimationNotify() {}
    FUIAnimationNotify(EEventParm)
    {
        appMemzero(this, sizeof(FUIAnimationNotify));
    }
};

struct FUIAnimationRawData
{
    FLOAT DestAsFloat;
    FLinearColor DestAsColor;
    FRotator DestAsRotator;
    FVector DestAsVector;
    struct FUIAnimationNotify DestAsNotify;

    /** Constructors */
    FUIAnimationRawData() {}
    FUIAnimationRawData(EEventParm)
    {
        appMemzero(this, sizeof(FUIAnimationRawData));
    }
};

struct FUIAnimationKeyFrame
{
    FLOAT RemainingTime;
    BYTE InterpMode;
    FLOAT InterpExponent;
    struct FUIAnimationRawData Data;

		/** Constructors */
		FUIAnimationKeyFrame() {}
		FUIAnimationKeyFrame(EEventParm)
		{
			appMemzero(this, sizeof(FUIAnimationKeyFrame));
		}
		FUIAnimationKeyFrame(ENativeConstructor)
		: RemainingTime(0.f), InterpMode(UIANIMMODE_Linear)
		, InterpExponent(1.5f), Data(EC_EventParm)
		{
		}
	
};

struct FUIAnimTrack
{
    BYTE TrackType;
    TArrayNoInit<struct FUIAnimationKeyFrame> KeyFrames;
    TArrayNoInit<struct FUIAnimationKeyFrame> LoopFrames;

    /** Constructors */
    FUIAnimTrack() {}
    FUIAnimTrack(EEventParm)
    {
        appMemzero(this, sizeof(FUIAnimTrack));
    }
};

struct FUIAnimSequence
{
    class UUIAnimationSeq* SequenceRef;
    TArray<struct FUIAnimTrack> AnimationTracks;
    BYTE LoopMode;
    FLOAT PlaybackRate;

		/** Constructors */
		FUIAnimSequence() {}
		FUIAnimSequence(EEventParm)
		{
			appMemzero(this, sizeof(FUIAnimSequence));
		}


		/**
		 * Applies the specified track's current keyframe data to the widget.
		 *
		 * @param	Target		the widget to apply the update to.
		 * @param	TrackIndex	the index of the track to apply data from
		 * @param	DeltaTime	the time (in seconds) since the beginning of the last frame; used to determine how much to interpolate
		 *						the current keyframe's value.
		 *
		 * @return	TRUE if the widget's state was updated with the current keyframe's data.
		 */
		UBOOL ApplyUIAnimation( UUIScreenObject* Target, INT TrackIndex, FLOAT DeltaTime );

		/**
		 * Wrapper for verifying whether the index is a valid index for the track's keyframes array.
		 *
		 * @param	TrackIndex	the index [into the Tracks array] for the track to check
		 * @param	FrameIndex	the index [into the KeyFrames array of the track] for the keyframe to check
		 *
		 * @return	TRUE if the specified track contains a keyframe at the specified index.
		 */
		UBOOL IsValidFrameIndex( INT TrackIndex, INT FrameIndex ) const;

		/**
		 * Wrapper for getting the length of a specific frame in one of this animation sequence's tracks.
		 *
		 * @param	TrackIndex			the index [into the Tracks array] for the track to check
		 * @param	FrameIndex			the index [into the KeyFrames array of the track] for the keyframe to check
		 * @param	out_FrameLength		receives the remaining seconds for the frame specified
		 *
		 * @return	TRUE if the call succeeded; FALSE if an invalid track or frame index was specified.
		 */
		UBOOL GetFrameLength( INT TrackIndex, INT FrameIndex, FLOAT& out_FrameLength ) const;

		/**
		 * Wrapper for getting the length of a specific track in this animation sequence.
		 *
		 * @param	TrackIndex	the index [into the Tracks array] for the track to check
		 * @param	out_TrackLength		receives the remaining number of seconds for the track specified.
		 *
		 * @return	TRUE if the call succeeded; FALSE if an invalid track index was specified.
		 */
		UBOOL GetTrackLength( INT TrackIndex, FLOAT& out_TrackLength ) const;

		/**
		 * Wrapper for getting the length of this animation sequence.
		 *
		 * @return	the total number of seconds in this animation sequence.
		 */
		FLOAT GetSequenceLength() const;
	
};

class UUIAnimation : public UUIRoot
{
public:
    //## BEGIN PROPS UIAnimation
    //## END PROPS UIAnimation

    DECLARE_ABSTRACT_CLASS(UUIAnimation,UUIRoot,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIAnimation)
};

class UUIAnimationSeq : public UUIAnimation
{
public:
    //## BEGIN PROPS UIAnimationSeq
    FName SeqName;
    TArrayNoInit<struct FUIAnimTrack> Tracks;
    BYTE LoopMode;
    //## END PROPS UIAnimationSeq

    UBOOL IsValidFrameIndex(INT TrackIndex,INT FrameIndex) const;
    UBOOL GetFrameLength(INT TrackIndex,INT FrameIndex,FLOAT& out_FrameLength) const;
    UBOOL GetTrackLength(INT TrackIndex,FLOAT& out_TrackLength) const;
    FLOAT GetSequenceLength() const;
    DECLARE_FUNCTION(execIsValidFrameIndex)
    {
        P_GET_INT(TrackIndex);
        P_GET_INT(FrameIndex);
        P_FINISH;
        *(UBOOL*)Result=IsValidFrameIndex(TrackIndex,FrameIndex);
    }
    DECLARE_FUNCTION(execGetFrameLength)
    {
        P_GET_INT(TrackIndex);
        P_GET_INT(FrameIndex);
        P_GET_FLOAT_REF(out_FrameLength);
        P_FINISH;
        *(UBOOL*)Result=GetFrameLength(TrackIndex,FrameIndex,out_FrameLength);
    }
    DECLARE_FUNCTION(execGetTrackLength)
    {
        P_GET_INT(TrackIndex);
        P_GET_FLOAT_REF(out_TrackLength);
        P_FINISH;
        *(UBOOL*)Result=GetTrackLength(TrackIndex,out_TrackLength);
    }
    DECLARE_FUNCTION(execGetSequenceLength)
    {
        P_FINISH;
        *(FLOAT*)Result=GetSequenceLength();
    }
    DECLARE_CLASS(UUIAnimationSeq,UUIAnimation,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIAnimationSeq)
};

struct FUIDataProviderField
{
    FName FieldTag;
    BYTE FieldType;
private:
    TArray<class UUIDataProvider*> FieldProviders;
public:

	/** Constructors */
	FUIDataProviderField() {}

	FUIDataProviderField( FName InFieldTag, EUIDataProviderFieldType InFieldType=DATATYPE_Property, class UUIDataProvider* InFieldProvider=NULL );
	FUIDataProviderField( FName InFieldTag, const TArray<class UUIDataProvider*>& InFieldProviders );

	/**
	 * Retrieves the list of providers contained by this data provider field.
	 *
	 * @return	FALSE if the FieldType for this provider field is not DATATYPE_Provider/ProviderCollection
	 */
	UBOOL GetProviders( TArray<class UUIDataProvider*>& out_Providers ) const;

};

struct UIDataProvider_eventNotifyPropertyChanged_Parms
{
    FName PropTag;
    UIDataProvider_eventNotifyPropertyChanged_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventIsCollectionDataType_Parms
{
    BYTE FieldType;
    UBOOL ReturnValue;
    UIDataProvider_eventIsCollectionDataType_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventIsProviderDisabled_Parms
{
    UBOOL ReturnValue;
    UIDataProvider_eventIsProviderDisabled_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGenerateFillerData_Parms
{
    FString DataTag;
    FString ReturnValue;
    UIDataProvider_eventGenerateFillerData_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGenerateScriptMarkupString_Parms
{
    FName DataTag;
    FString ReturnValue;
    UIDataProvider_eventGenerateScriptMarkupString_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventSetFieldValue_Parms
{
    FString FieldName;
    struct FUIProviderScriptFieldValue FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventSetFieldValue_Parms(EEventParm)
    : FieldValue(EC_EventParm)
    {
    }
};
struct UIDataProvider_eventGetFieldValue_Parms
{
    FString FieldName;
    struct FUIProviderScriptFieldValue FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventGetFieldValue_Parms(EEventParm)
    : FieldValue(EC_EventParm)
    {
    }
};
struct UIDataProvider_eventAllowPublishingToField_Parms
{
    FString FieldName;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventAllowPublishingToField_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGetSupportedScriptFields_Parms
{
    TArray<struct FUIDataProviderField> out_Fields;
    UIDataProvider_eventGetSupportedScriptFields_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventOnDataProviderPropertyChange_Parms
{
    class UUIDataProvider* SourceProvider;
    FName PropTag;
    UIDataProvider_eventOnDataProviderPropertyChange_Parms(EEventParm)
    {
    }
};
class UUIDataProvider : public UUIRoot
{
public:
    //## BEGIN PROPS UIDataProvider
    BYTE WriteAccessType;
    TArrayNoInit<FScriptDelegate> ProviderChangedNotifies;
    FScriptDelegate __OnDataProviderPropertyChange__Delegate;
    //## END PROPS UIDataProvider

    UBOOL GetProviderFieldType(const FString& DataTag,BYTE& out_ProviderFieldType);
    virtual INT ParseArrayDelimiter(FString& DataTag) const;
    DECLARE_FUNCTION(execGetProviderFieldType)
    {
        P_GET_STR(DataTag);
        P_GET_BYTE_REF(out_ProviderFieldType);
        P_FINISH;
        *(UBOOL*)Result=GetProviderFieldType(DataTag,out_ProviderFieldType);
    }
    DECLARE_FUNCTION(execParseArrayDelimiter)
    {
        P_GET_STR_REF(DataTag);
        P_FINISH;
        *(INT*)Result=ParseArrayDelimiter(DataTag);
    }
    void eventNotifyPropertyChanged(FName PropTag=NAME_None)
    {
        UIDataProvider_eventNotifyPropertyChanged_Parms Parms(EC_EventParm);
        Parms.PropTag=PropTag;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPropertyChanged),&Parms);
    }
    UBOOL eventIsCollectionDataType(BYTE FieldType)
    {
        UIDataProvider_eventIsCollectionDataType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldType=FieldType;
        ProcessEvent(FindFunctionChecked(ENGINE_IsCollectionDataType),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsProviderDisabled()
    {
        UIDataProvider_eventIsProviderDisabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsProviderDisabled),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGenerateFillerData(const FString& DataTag)
    {
        UIDataProvider_eventGenerateFillerData_Parms Parms(EC_EventParm);
        Parms.DataTag=DataTag;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateFillerData),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGenerateScriptMarkupString(FName DataTag)
    {
        UIDataProvider_eventGenerateScriptMarkupString_Parms Parms(EC_EventParm);
        Parms.DataTag=DataTag;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateScriptMarkupString),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetFieldValue(const FString& FieldName,const struct FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex=-1)
    {
        UIDataProvider_eventSetFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.FieldValue=FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetFieldValue),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetFieldValue(const FString& FieldName,struct FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex=-1)
    {
        UIDataProvider_eventGetFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.FieldValue=FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFieldValue),&Parms);
        FieldValue=Parms.FieldValue;
        return Parms.ReturnValue;
    }
    UBOOL eventAllowPublishingToField(const FString& FieldName,INT ArrayIndex=-1)
    {
        UIDataProvider_eventAllowPublishingToField_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_AllowPublishingToField),&Parms);
        return Parms.ReturnValue;
    }
    void eventGetSupportedScriptFields(TArray<struct FUIDataProviderField>& out_Fields)
    {
        UIDataProvider_eventGetSupportedScriptFields_Parms Parms(EC_EventParm);
        Parms.out_Fields=out_Fields;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSupportedScriptFields),&Parms);
        out_Fields=Parms.out_Fields;
    }
    void delegateOnDataProviderPropertyChange(class UUIDataProvider* SourceProvider,FName PropTag=NAME_None)
    {
        UIDataProvider_eventOnDataProviderPropertyChange_Parms Parms(EC_EventParm);
        Parms.SourceProvider=SourceProvider;
        Parms.PropTag=PropTag;
        ProcessDelegate(ENGINE_OnDataProviderPropertyChange,&__OnDataProviderPropertyChange__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataProvider,UUIRoot,0|CLASS_Transient,Engine)
protected:
	/**
	 * Returns the data tag associated with the specified provider.
	 *
	 * @return	the data field tag associated with the provider specified, or NAME_None if the provider specified is not
	 *			contained by this data store.
	 */
	virtual FName GetProviderDataTag( class UUIDataProvider* Provider );

	/**
	 * Determines whether publishing updated values to the specified field is allowed.
	 *
	 * @param	PropTag		the name of the field within this data provider to check access for (might be blank)
	 * @param	ArrayIndex	optional array index for use with data collections.
	 *
	 * @return	TRUE if publishing updated values is allowed for the field.
	 */
	virtual UBOOL AllowsPublishingData( const FString& PropTag, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return eventGetFieldValue(FieldName, out_FieldValue, ArrayIndex);
	}

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return eventSetFieldValue(FieldName, FieldValue, ArrayIndex);
	}

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue );

	/**
	 * Parses the data store reference and publishes the value specified to that location.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	FieldValue		contains the value that should be published to the location specified by MarkupString.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL SetDataStoreValue( const FString& MarkupString, const struct FUIProviderScriptFieldValue& FieldValue );

	/**
	 * For data stores that are responsible for applying inline style modifications (such as the font, style, and attribute data stores),
	 * parses the data store reference and applies the appropriate style changes.
	 *
	 * @param	MarkupString	a markup string representing a style modification that this data store is aware of; i.e. the name of the font,
	 *							style, or attribute.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if this data store applied a change to StyleData based on the value of MarkupString, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& MarkupString, struct FUIStringNodeModifier& StyleData ) { return FALSE; }

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider() { return this; }

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	virtual UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex );

	// NON VIRTUALS
	/**
	 * Returns whether the specified provider is contained by this data provider.
	 *
	 * @param	Provider			the provider to search for
	 * @param	out_ProviderOwner	will contain the UIDataProvider that contains the field tag which corresonds to the
	 *								Provider being searched for.
	 *
	 * @return	TRUE if Provider can be accessed through this data provider.
	 */
	UBOOL ContainsProvider( class UUIDataProvider* Provider, class UUIDataProvider*& out_ProviderOwner );

	/**
	 * Generates a data store path to the specified provider.
	 *
	 * @param	Provider			the data store provider to generate a path name to
	 * @param	out_DataStorePath	will be filled in with the path name necessary to access the specified provider,
	 *								including any trailing dots or colons
	 */
	void GetPathToProvider(class UUIDataStore* ContainerDataStore, class UUIDataProvider* Provider, FString& out_DataStorePath );

	/**
	 * Builds the data store path name necessary to access the specified tag of this data provider.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the data field path
	 * @param	DataTag				the tag corresponding to the data field that we want a path to
	 *
	 * @return		a string containing the complete path name required to access the specified data field
	 */
	FString BuildDataFieldPath( class UUIDataStore* ContainerDataStore, const FName& DataTag );

	/**
	 * Generates a data store markup string which can be used to access the data field specified.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the markup string
	 * @param	DataTag				the data field tag to generate the markup string for
	 *
	 * @return	a datastore markup string which resolves to the datastore field associated with DataTag, in the format:
	 *			<DataStoreTag:DataFieldTag>
	 */
	FString GenerateDataMarkupString( class UUIDataStore* ContainerDataStore, FName DataTag );

	/**
	 * Builds the data store path name necessary to access the specified tag of this data provider.
	 *
	 * This is a bulk version of the BuildDataFieldPath function.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the data field path
	 * @param	DataTags			Array of tags to build paths for, ALL of these tags are assumed to be under the same data provider.
	 * @param	Out_Paths			Array of generated paths, one for each of the datatags passed in.
	 */
	void BuildDataFieldPath( class UUIDataStore* ContainerDataStore, const TArray<FName>& DataTags, TArray<FString> &Out_Paths );


	/**
	 * Generates a data store markup string which can be used to access the data field specified.
	 *
	 * This is a bulk version of the GenerateDataMarkupString function.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the markup string
	 * @param	DataTags			array of tags to generate the markup string for, ALL of these tags are assumed to be under the same data provider.
	 * @param	Out_Markup			Array of strings of generated markup, one for each tag passed in.
	 */
	void GenerateDataMarkupString( class UUIDataStore* ContainerDataStore, const TArray<FName>& DataTags, TArray<FString> &Out_Markup );


	/**
	 * Determines if the specified data tag is supported by this data provider
	 *
	 * @param	DataTag		the tag corresponding to the data field that we want to check for
	 *
	 * @return	TRUE if the data tag specified is supported by this data provider.
	 */
	UBOOL IsDataTagSupported( FName DataTag );

	/**
	 * Determines if the specified data tag is supported by this data provider
	 *
	 * @param	DataTag		a tag corresponding to the data field that we want to check for; ok for the tag to contain array indexes
	 * @param	SupportedFields		the collection of fields to search through; if empty, will automatically fill in the array by calling
	 *								GetSupportedFields; useful optimization when calling this method repeatedly, e.g. in a loop
	 *
	 * @return	TRUE if the data tag specified is supported by this data provider.
	 */
	UBOOL IsDataTagSupported( FName DataTag, TArray<struct FUIDataProviderField>& SupportedFields );

	/**
	 * Parses the specified markup string to get the data tag that should be evaluated by this data provider.
	 *
	 * @param	MarkupString	a string that contains a markup reference (either in whole, or in part), e.g. CurrentGame:Players;1.PlayerName.
	 *							if successfully parsed, after parsing,
	 * @param	out_NextDataTag	a string representing the data tag for the next portion of the data store path reference, including any
	 *							any array delimiters.
	 *
	 * @return	TRUE if the a data tag was successfully parsed.
	 */
	UBOOL ParseNextDataTag( FString& MarkupString, FString& out_NextDataTag ) const;

	/**
	 * Encapsulates the construction of a UITexture wrapper for the specified USurface.
	 *
	 * @param	SourceImage		the texture or material instance to apply to the newly created wrapper
	 *
	 * @return	a pointer to a UITexture instance which wraps the SourceImage passed in, or NULL if SourceImage was invalid
	 *			or the wrapper couldn't be created for some reason.
	 */
	static class UUITexture* CreateTextureWrapper( class USurface* SourceImage );

	/**
	 * Creates the appropriate type of string node for the NodeValue specified.  If NodeValue.CustomStringNode is set, returns
	 * that node; If NodeValue.StringValue is set, creates and initializes a UIStringNode_Text; if NodeValue.ImageValue is
	 * set, creates and initializes a UIStringNode_Image.
	 *
	 * @param	SourceText	the text to assign as the SourceText in the returned node
	 * @param	NodeValue	the value to use for initiailizing the string node that is returned
	 *
	 * @return	a pointer to either a UIStringNode of the appropriate type (Text or Image) that has been initialized from the
	 *			NodeValue specified.  The caller is responsible for cleaning up the memory for this return value.
	 */
	static struct FUIStringNode* CreateStringNode( const FString& SourceText, const struct FUIProviderFieldValue& NodeValue );
};

class UUIConfigProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIConfigProvider
    //## END PROPS UIConfigProvider

    DECLARE_ABSTRACT_CLASS(UUIConfigProvider,UUIDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIConfigProvider)
};

class UUIConfigFileProvider : public UUIConfigProvider
{
public:
    //## BEGIN PROPS UIConfigFileProvider
    TArrayNoInit<class UUIConfigSectionProvider*> Sections;
    //## END PROPS UIConfigFileProvider

    DECLARE_CLASS(UUIConfigFileProvider,UUIConfigProvider,0|CLASS_Transient,Engine)
	/** the name of the config file associated with this data provider */
	FFilename	ConfigFileName;

	/* === UIConfigFileProvider interface === */
	/**
	 * Initializes this config file provider, creating the section data providers for each of the sections contained
	 * within the ConfigFile specified.
	 *
	 * @param	ConfigFile	the config file to associated with this data provider
	 */
	void InitializeProvider( class FConfigFile* ConfigFile );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIConfigSectionProvider : public UUIConfigProvider
{
public:
    //## BEGIN PROPS UIConfigSectionProvider
    FStringNoInit SectionName;
    //## END PROPS UIConfigSectionProvider

    DECLARE_CLASS(UUIConfigSectionProvider,UUIConfigProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIConfigFileProvider)
	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct UIDataProvider_OnlinePlayerDataBase_eventOnUnregister_Parms
{
    UIDataProvider_OnlinePlayerDataBase_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlinePlayerDataBase : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayerDataBase
    class ULocalPlayer* Player;
    //## END PROPS UIDataProvider_OnlinePlayerDataBase

    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataProvider_OnlinePlayerDataBase,UUIDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Provides the data provider with the player they were just bound to
	 *
	 * @param Player the local player associated with this player settings provider
	 */
	virtual void OnRegister(ULocalPlayer* InPlayer)
	{
		eventOnRegister(InPlayer);
	}

	/**
	 * Tells the provider that the player is no longer valid
	 */
	virtual void OnUnregister(void)
	{
		eventOnUnregister();
	}
};

class UUIDataProvider_OnlineClanMates : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineClanMates
    //## END PROPS UIDataProvider_OnlineClanMates

    DECLARE_CLASS(UUIDataProvider_OnlineClanMates,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineClanMate
	 *
	 * @see OnlineClanMate structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags )
	{
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType )
	{
		return FALSE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ClanMates")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}
};

class UUIDataProvider_OnlineFriendMessages : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineFriendMessages
    TArrayNoInit<struct FOnlineFriendMessage> Messages;
    FStringNoInit SendingPlayerNameCol;
    FStringNoInit bIsFriendInviteCol;
    FStringNoInit bWasAcceptedCol;
    FStringNoInit bWasDeniedCol;
    FStringNoInit MessageCol;
    FStringNoInit LastInviteFrom;
    //## END PROPS UIDataProvider_OnlineFriendMessages

    DECLARE_CLASS(UUIDataProvider_OnlineFriendMessages,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags)
	{
		CellTags.Set(FName(TEXT("SendingPlayerNick")),*SendingPlayerNameCol);
		CellTags.Set(FName(TEXT("bIsFriendInvite")),*bIsFriendInviteCol);
		CellTags.Set(FName(TEXT("bWasAccepted")),*bWasAcceptedCol);
		CellTags.Set(FName(TEXT("bWasDenied")),*bWasDeniedCol);
		CellTags.Set(FName(TEXT("Message")),*MessageCol);
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType )
	{
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields(TArray<struct FUIDataProviderField>& out_Fields)
	{
		new(out_Fields)FUIDataProviderField(FName(TEXT("FriendMessages")),DATATYPE_Collection);
		new(out_Fields)FUIDataProviderField(FName(TEXT("LastInviteFrom")));
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct UIDataProvider_OnlineFriends_eventRefreshFriendsList_Parms
{
    UIDataProvider_OnlineFriends_eventRefreshFriendsList_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlineFriends : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineFriends
    TArrayNoInit<struct FOnlineFriend> FriendsList;
    FStringNoInit NickNameCol;
    FStringNoInit PresenceInfoCol;
    FStringNoInit FriendStateCol;
    FStringNoInit bIsOnlineCol;
    FStringNoInit bIsPlayingCol;
    FStringNoInit bIsPlayingThisGameCol;
    FStringNoInit bIsJoinableCol;
    FStringNoInit bHasVoiceSupportCol;
    FStringNoInit bHaveInvitedCol;
    FStringNoInit bHasInvitedYouCol;
    FStringNoInit OfflineText;
    FStringNoInit OnlineText;
    FStringNoInit AwayText;
    FStringNoInit BusyText;
    //## END PROPS UIDataProvider_OnlineFriends

    void eventRefreshFriendsList()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshFriendsList),NULL);
    }
    DECLARE_CLASS(UUIDataProvider_OnlineFriends,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags)
	{
		CellTags.Set(FName(TEXT("NickName")),*NickNameCol);
		CellTags.Set(FName(TEXT("PresenceInfo")),*PresenceInfoCol);
		CellTags.Set(FName(TEXT("FriendState")),*FriendStateCol);
		CellTags.Set(FName(TEXT("bIsOnline")),*bIsOnlineCol);
		CellTags.Set(FName(TEXT("bIsPlaying")),*bIsPlayingCol);
		CellTags.Set(FName(TEXT("bIsPlayingThisGame")),*bIsPlayingThisGameCol);
		CellTags.Set(FName(TEXT("bIsJoinable")),*bIsJoinableCol);
		CellTags.Set(FName(TEXT("bHasVoiceSupport")),*bHasVoiceSupportCol);
		CellTags.Set(FName(TEXT("bHaveInvited")),*bHaveInvitedCol);
		CellTags.Set(FName(TEXT("bHasInvitedYou")),*bHasInvitedYouCol);
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& CellFieldType)
	{
		CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Friends")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_OnlinePlayers : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayers
    //## END PROPS UIDataProvider_OnlinePlayers

    DECLARE_CLASS(UUIDataProvider_OnlinePlayers,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlinePlayer
	 *
	 * @see OnlinePlayer structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags )
	{
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType )
	{
		return FALSE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Players")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}
};

struct FProfileSettingsArrayProvider
{
    INT ProfileSettingsId;
    FName ProfileSettingsName;
    class UUIDataProvider_OnlineProfileSettingsArray* Provider;

    /** Constructors */
    FProfileSettingsArrayProvider() {}
    FProfileSettingsArrayProvider(EEventParm)
    {
        appMemzero(this, sizeof(FProfileSettingsArrayProvider));
    }
};

struct UIDataProvider_OnlineProfileSettings_eventSaveProfileData_Parms
{
    UBOOL ReturnValue;
    UIDataProvider_OnlineProfileSettings_eventSaveProfileData_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlineProfileSettings : public UUIDataProvider_OnlinePlayerDataBase
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineProfileSettings
    class UOnlineProfileSettings* Profile;
    FName ProviderName;
    BITFIELD bWasErrorLastRead:1;
    BITFIELD bInitializeFromDefaults:1;
    TArrayNoInit<struct FProfileSettingsArrayProvider> ProfileSettingsArrayProviders;
    //## END PROPS UIDataProvider_OnlineProfileSettings

    UBOOL eventSaveProfileData()
    {
        UIDataProvider_OnlineProfileSettings_eventSaveProfileData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SaveProfileData),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIDataProvider_OnlineProfileSettings,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Tells the provider the settings object it is resposible for exposing to
	 * the UI
	 *
	 * @param InSettings the settings object to expose
	 */
	virtual void BindProfileSettings(UOnlineProfileSettings* InSettings);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );
};

class UUIDataProvider_PlayerAchievements : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_PlayerAchievements
    TArrayNoInit<struct FAchievementDetails> Achievements;
    //## END PROPS UIDataProvider_PlayerAchievements

    INT GetTotalGamerScore() const;
    DECLARE_FUNCTION(execGetTotalGamerScore)
    {
        P_FINISH;
        *(INT*)Result=GetTotalGamerScore();
    }
    DECLARE_CLASS(UUIDataProvider_PlayerAchievements,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === IUIListElement interface === */
	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags);

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& CellFieldType);

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_OnlineProfileSettingsArray : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineProfileSettingsArray
    class UOnlineProfileSettings* ProfileSettings;
    INT ProfileSettingId;
    FName ProfileSettingsName;
    FStringNoInit ColumnHeaderText;
    TArrayNoInit<FName> Values;
    //## END PROPS UIDataProvider_OnlineProfileSettingsArray

    DECLARE_CLASS(UUIDataProvider_OnlineProfileSettingsArray,UUIDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Binds the new profile object and id to this provider.
	 *
	 * @param NewProfile the new object to bind
	 * @param NewProfileSettingsId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindStringSetting(UOnlineProfileSettings* NewProfile,INT NewProfileSettingsId);

	/**
	 * Binds the new profile object and id to this provider.
	 *
	 * @param NewProfile the new object to bind
	 * @param PropertyId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindPropertySetting(UOnlineProfileSettings* NewProfile,INT PropertyId);

	/**
	 * Determines if the specified name matches ours
	 *
	 * @param Property the name to compare with our own
	 *
	 * @return TRUE if the name matches, FALSE otherwise
	 */
	UBOOL IsMatch(const TCHAR* Property);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

class UUIDataProvider_SettingsArray : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_SettingsArray
    class USettings* Settings;
    INT SettingsId;
    FName SettingsName;
    FStringNoInit ColumnHeaderText;
    TArrayNoInit<struct FIdToStringMapping> Values;
    //## END PROPS UIDataProvider_SettingsArray

    DECLARE_CLASS(UUIDataProvider_SettingsArray,UUIDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Binds the new settings object and id to this provider.
	 *
	 * @param NewSettings the new object to bind
	 * @param NewSettingsId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindStringSetting(USettings* NewSettings,INT NewSettingsId);

	/**
	 * Binds the property id as an array item. Requires that the property
	 * has a mapping type of PVMT_PredefinedValues
	 *
	 * @param NewSettings the new object to bind
	 * @param PropertyId the id of the property to expose as an array
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindPropertySetting(USettings* NewSettings,INT PropertyId);

	/**
	 * Determines if the specified name matches ours
	 *
	 * @param Property the name to compare with our own
	 *
	 * @return TRUE if the name matches, FALSE otherwise
	 */
	UBOOL IsMatch(const TCHAR* Property);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

struct UIDataStore_eventRefreshSubscribers_Parms
{
    FName PropertyTag;
    UBOOL bInvalidateValues;
    class UUIDataProvider* SourceProvider;
    INT ArrayIndex;
    UIDataStore_eventRefreshSubscribers_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventSubscriberDetached_Parms
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    UIDataStore_eventSubscriberDetached_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventSubscriberAttached_Parms
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    UIDataStore_eventSubscriberAttached_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventUnregistered_Parms
{
    class ULocalPlayer* PlayerOwner;
    UIDataStore_eventUnregistered_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventRegistered_Parms
{
    class ULocalPlayer* PlayerOwner;
    UIDataStore_eventRegistered_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventOnDataStoreValueUpdated_Parms
{
    class UUIDataStore* SourceDataStore;
    UBOOL bValuesInvalidated;
    FName PropertyTag;
    class UUIDataProvider* SourceProvider;
    INT ArrayIndex;
    UIDataStore_eventOnDataStoreValueUpdated_Parms(EEventParm)
    {
    }
};
class UUIDataStore : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataStore
    FName Tag;
    TArrayNoInit<FScriptDelegate> RefreshSubscriberNotifies;
    FScriptDelegate __OnDataStoreValueUpdated__Delegate;
    //## END PROPS UIDataStore

    virtual void OnCommit();
    DECLARE_FUNCTION(execOnCommit)
    {
        P_FINISH;
        OnCommit();
    }
    void eventRefreshSubscribers(FName PropertyTag=NAME_None,UBOOL bInvalidateValues=TRUE,class UUIDataProvider* SourceProvider=NULL,INT ArrayIndex=-1)
    {
        UIDataStore_eventRefreshSubscribers_Parms Parms(EC_EventParm);
        Parms.PropertyTag=PropertyTag;
        Parms.bInvalidateValues=bInvalidateValues ? FIRST_BITFIELD : FALSE;
        Parms.SourceProvider=SourceProvider;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshSubscribers),&Parms);
    }
    void eventSubscriberDetached(const TScriptInterface<class IUIDataStoreSubscriber>& Subscriber)
    {
        UIDataStore_eventSubscriberDetached_Parms Parms(EC_EventParm);
        Parms.Subscriber=Subscriber;
        ProcessEvent(FindFunctionChecked(ENGINE_SubscriberDetached),&Parms);
    }
    void eventSubscriberAttached(const TScriptInterface<class IUIDataStoreSubscriber>& Subscriber)
    {
        UIDataStore_eventSubscriberAttached_Parms Parms(EC_EventParm);
        Parms.Subscriber=Subscriber;
        ProcessEvent(FindFunctionChecked(ENGINE_SubscriberAttached),&Parms);
    }
    void eventUnregistered(class ULocalPlayer* PlayerOwner)
    {
        UIDataStore_eventUnregistered_Parms Parms(EC_EventParm);
        Parms.PlayerOwner=PlayerOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_Unregistered),&Parms);
    }
    void eventRegistered(class ULocalPlayer* PlayerOwner)
    {
        UIDataStore_eventRegistered_Parms Parms(EC_EventParm);
        Parms.PlayerOwner=PlayerOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_Registered),&Parms);
    }
    void delegateOnDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex)
    {
        UIDataStore_eventOnDataStoreValueUpdated_Parms Parms(EC_EventParm);
        Parms.SourceDataStore=SourceDataStore;
        Parms.bValuesInvalidated=bValuesInvalidated ? FIRST_BITFIELD : FALSE;
        Parms.PropertyTag=PropertyTag;
        Parms.SourceProvider=SourceProvider;
        Parms.ArrayIndex=ArrayIndex;
        ProcessDelegate(ENGINE_OnDataStoreValueUpdated,&__OnDataStoreValueUpdated__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore,UUIDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Allows each data store the chance to load any dependent classes
	 */
	virtual void LoadDependentClasses(void)
	{
	}

	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/**
	 * Called when this data store is removed from the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnUnregister( class ULocalPlayer* PlayerOwner );

	/**
	 * Retrieves the tag used for referencing this data store.  Normally corresponds to Tag, but may be different for some special
	 * data stores.
	 */
	virtual FName GetDataStoreID() const { return Tag; }
};

class USceneDataStore : public UUIDataStore, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS SceneDataStore
    class UUIScene* OwnerScene;
    class UUIDynamicFieldProvider* SceneDataProvider;
    //## END PROPS SceneDataStore

    DECLARE_CLASS(USceneDataStore,UUIDataStore,0,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UIDataStore interface === */
	/**
	 * Creates the data provider for this scene data store.
	 */
	virtual void InitializeDataStore();

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();


	/** === IUIListElementProviderInterface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );


	/* === IUIListElementCellProvider === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataStore_Color : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Color
    //## END PROPS UIDataStore_Color

    DECLARE_CLASS(UUIDataStore_Color,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataProvider interface === */

	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }

	/**
	 * Attempst to load the font specified and if successful changes the style data's DrawFont.
	 *
	 * @param	MarkupString	a string corresponding to the name of a font.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if a font was found matching the specified FontName, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& ColorParams, struct FUIStringNodeModifier& StyleData );
};

struct FDynamicResourceProviderDefinition
{
    FName ProviderTag;
    FStringNoInit ProviderClassName;
    class UClass* ProviderClass;

    /** Constructors */
    FDynamicResourceProviderDefinition() {}
    FDynamicResourceProviderDefinition(EEventParm)
    {
        appMemzero(this, sizeof(FDynamicResourceProviderDefinition));
    }
};

class UUIDataStore_DynamicResource : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_DynamicResource
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    class UUIDataStore_GameResource* GameResourceDataStore;
    TArrayNoInit<struct FDynamicResourceProviderDefinition> ResourceProviderDefinitions;
    TMultiMap<FName,class UUIResourceCombinationProvider*> ResourceProviders;
    //## END PROPS UIDataStore_DynamicResource

    INT FindProviderTypeIndex(FName ProviderTag) const;
    FName GenerateProviderAccessTag(INT ProviderIndex,INT InstanceIndex) const;
    virtual INT GetProviderCount(FName ProviderTag) const;
    UBOOL GetResourceProviders(FName ProviderTag,TArray<class UUIResourceCombinationProvider*>& out_Providers) const;
    UBOOL GetResourceProviderFields(FName ProviderTag,TArray<FName>& ProviderFieldTags) const;
    UBOOL GetProviderFieldValue(FName ProviderTag,FName SearchField,INT ProviderIndex,struct FUIProviderScriptFieldValue& out_FieldValue) const;
    INT FindProviderIndexByFieldValue(FName ProviderTag,FName SearchField,const struct FUIProviderScriptFieldValue& ValueToSearchFor) const;
    void OnLoginChange();
    DECLARE_FUNCTION(execFindProviderTypeIndex)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=FindProviderTypeIndex(ProviderTag);
    }
    DECLARE_FUNCTION(execGenerateProviderAccessTag)
    {
        P_GET_INT(ProviderIndex);
        P_GET_INT(InstanceIndex);
        P_FINISH;
        *(FName*)Result=GenerateProviderAccessTag(ProviderIndex,InstanceIndex);
    }
    DECLARE_FUNCTION(execGetProviderCount)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=GetProviderCount(ProviderTag);
    }
    DECLARE_FUNCTION(execGetResourceProviders)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(class UUIResourceCombinationProvider*,out_Providers);
        P_FINISH;
        *(UBOOL*)Result=GetResourceProviders(ProviderTag,out_Providers);
    }
    DECLARE_FUNCTION(execGetResourceProviderFields)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(FName,ProviderFieldTags);
        P_FINISH;
        *(UBOOL*)Result=GetResourceProviderFields(ProviderTag,ProviderFieldTags);
    }
    DECLARE_FUNCTION(execGetProviderFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_INT(ProviderIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,out_FieldValue);
        P_FINISH;
        *(UBOOL*)Result=GetProviderFieldValue(ProviderTag,SearchField,ProviderIndex,out_FieldValue);
    }
    DECLARE_FUNCTION(execFindProviderIndexByFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,ValueToSearchFor);
        P_FINISH;
        *(INT*)Result=FindProviderIndexByFieldValue(ProviderTag,SearchField,ValueToSearchFor);
    }
    DECLARE_FUNCTION(execOnLoginChange)
    {
        P_FINISH;
        OnLoginChange();
    }
    DECLARE_CLASS(UUIDataStore_DynamicResource,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataStore_GameResource interface === */
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Finds the data provider associated with the tag specified.
	 *
	 * @param	ProviderTag		The tag of the provider to find.  Must match the ProviderTag value for one of elements
	 *							in the ElementProviderTypes array, though it can contain an array index (in which case
	 *							the array index will be removed from the ProviderTag value passed in).
	 * @param	InstanceIndex	If ProviderTag contains an array index, this will be set to the array index value that was parsed.
	 *
	 * @return	a data provider instance (or CDO if no array index was included in ProviderTag) for the element provider
	 *			type associated with ProviderTag.
	 */
	class UUIResourceCombinationProvider* ResolveProviderReference( FName& ProviderTag, INT* InstanceIndex=NULL ) const;

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === UIDataStore interface === */
	/**
	 * Loads the classes referenced by the ElementProviderTypes array.
	 */
	virtual void LoadDependentClasses();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/**
	 * Parses the string specified, separating the array index portion from the data field tag.
	 *
	 * @param	DataTag		the data tag that possibly contains an array index
	 *
	 * @return	the array index that was parsed from DataTag, or INDEX_NONE if there was no array index in the string specified.
	 */
	virtual INT ParseArrayDelimiter( FString& DataTag ) const;

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIDataStore_Fonts : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Fonts
    //## END PROPS UIDataStore_Fonts

    DECLARE_CLASS(UUIDataStore_Fonts,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataProvider interface === */
	/**
	 * Gets the list of font names available through this data store.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }

	/**
	 * Attempst to load the font specified and if successful changes the style data's DrawFont.
	 *
	 * @param	MarkupString	a string corresponding to the name of a font.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if a font was found matching the specified FontName, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& FontName, struct FUIStringNodeModifier& StyleData );
};

struct FGameResourceDataProvider
{
    FName ProviderTag;
    FStringNoInit ProviderClassName;
    BITFIELD bExpandProviders:1;
    class UClass* ProviderClass;

    /** Constructors */
    FGameResourceDataProvider() {}
    FGameResourceDataProvider(EEventParm)
    {
        appMemzero(this, sizeof(FGameResourceDataProvider));
    }
};

class UUIDataStore_GameResource : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_GameResource
    TArrayNoInit<struct FGameResourceDataProvider> ElementProviderTypes;
    TMultiMap<FName,class UUIResourceDataProvider*> ListElementProviders;
    //## END PROPS UIDataStore_GameResource

    INT FindProviderTypeIndex(FName ProviderTag) const;
    FName GenerateProviderAccessTag(INT ProviderIndex,INT InstanceIndex) const;
    virtual INT GetProviderCount(FName ProviderTag) const;
    UBOOL GetResourceProviders(FName ProviderTag,TArray<class UUIResourceDataProvider*>& out_Providers) const;
    UBOOL GetResourceProviderFields(FName ProviderTag,TArray<FName>& ProviderFieldTags) const;
    UBOOL GetProviderFieldValue(FName ProviderTag,FName SearchField,INT ProviderIndex,struct FUIProviderScriptFieldValue& out_FieldValue) const;
    INT FindProviderIndexByFieldValue(FName ProviderTag,FName SearchField,const struct FUIProviderScriptFieldValue& ValueToSearchFor) const;
    DECLARE_FUNCTION(execFindProviderTypeIndex)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=FindProviderTypeIndex(ProviderTag);
    }
    DECLARE_FUNCTION(execGenerateProviderAccessTag)
    {
        P_GET_INT(ProviderIndex);
        P_GET_INT(InstanceIndex);
        P_FINISH;
        *(FName*)Result=GenerateProviderAccessTag(ProviderIndex,InstanceIndex);
    }
    DECLARE_FUNCTION(execGetProviderCount)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=GetProviderCount(ProviderTag);
    }
    DECLARE_FUNCTION(execGetResourceProviders)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(class UUIResourceDataProvider*,out_Providers);
        P_FINISH;
        *(UBOOL*)Result=GetResourceProviders(ProviderTag,out_Providers);
    }
    DECLARE_FUNCTION(execGetResourceProviderFields)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(FName,ProviderFieldTags);
        P_FINISH;
        *(UBOOL*)Result=GetResourceProviderFields(ProviderTag,ProviderFieldTags);
    }
    DECLARE_FUNCTION(execGetProviderFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_INT(ProviderIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,out_FieldValue);
        P_FINISH;
        *(UBOOL*)Result=GetProviderFieldValue(ProviderTag,SearchField,ProviderIndex,out_FieldValue);
    }
    DECLARE_FUNCTION(execFindProviderIndexByFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,ValueToSearchFor);
        P_FINISH;
        *(INT*)Result=FindProviderIndexByFieldValue(ProviderTag,SearchField,ValueToSearchFor);
    }
    DECLARE_CLASS(UUIDataStore_GameResource,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataStore_GameResource interface === */
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Finds the data provider associated with the tag specified.
	 *
	 * @param	ProviderTag		The tag of the provider to find.  Must match the ProviderTag value for one of elements
	 *							in the ElementProviderTypes array, though it can contain an array index (in which case
	 *							the array index will be removed from the ProviderTag value passed in).
	 * @param	InstanceIndex	If ProviderTag contains an array index, this will be set to the array index value that was parsed.
	 *
	 * @return	a data provider instance (or CDO if no array index was included in ProviderTag) for the element provider
	 *			type associated with ProviderTag.
	 */
	class UUIResourceDataProvider* ResolveProviderReference( FName& ProviderTag, INT* InstanceIndex=NULL ) const;

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === UIDataStore interface === */
	/**
	 * Loads the classes referenced by the ElementProviderTypes array.
	 */
	virtual void LoadDependentClasses();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/**
	 * Parses the string specified, separating the array index portion from the data field tag.
	 *
	 * @param	DataTag		the data tag that possibly contains an array index
	 *
	 * @return	the array index that was parsed from DataTag, or INDEX_NONE if there was no array index in the string specified.
	 */
	virtual INT ParseArrayDelimiter( FString& DataTag ) const;

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIDataStore_MenuItems : public UUIDataStore_GameResource
{
public:
    //## BEGIN PROPS UIDataStore_MenuItems
    FName CurrentGameSettingsTag;
    TMultiMap<FName, class UUIDataProvider_MenuItem*> OptionProviders;
    TArrayNoInit<class UUIDataProvider_MenuItem*> DynamicProviders;
    //## END PROPS UIDataStore_MenuItems

    virtual void ClearSet(FName SetName);
    virtual void AppendToSet(FName SetName,INT NumOptions);
    virtual void GetSet(FName SetName,TArray<class UUIDataProvider_MenuItem*>& OutProviders);
    DECLARE_FUNCTION(execClearSet)
    {
        P_GET_NAME(SetName);
        P_FINISH;
        ClearSet(SetName);
    }
    DECLARE_FUNCTION(execAppendToSet)
    {
        P_GET_NAME(SetName);
        P_GET_INT(NumOptions);
        P_FINISH;
        AppendToSet(SetName,NumOptions);
    }
    DECLARE_FUNCTION(execGetSet)
    {
        P_GET_NAME(SetName);
        P_GET_TARRAY_REF(class UUIDataProvider_MenuItem*,OutProviders);
        P_FINISH;
        GetSet(SetName,OutProviders);
    }
    DECLARE_CLASS(UUIDataStore_MenuItems,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UUIDataStore_MenuItems interface === */
	/**
	 * Converts the specified name into the tag required to access the options for the current game settings object,
	 * if the specified field is CurrentGameSettingsTag.  Otherwise, does nothing.
	 *
	 * @param	FieldName	the name of the field that was passed to this data store.
	 *
	 * @return	a tag which can be used to access the settings collection for the current game settings object, or the same
	 *			value as the input value.
	 */
	FName ResolveFieldName( FName FieldName ) const;
	FString ResolveFieldString( const FString& FieldString ) const;

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUIDataProvider_MenuItem*>& OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );
};

struct UIDataStore_GameState_eventOnRefreshDataFieldValue_Parms
{
    UIDataStore_GameState_eventOnRefreshDataFieldValue_Parms(EEventParm)
    {
    }
};
class UUIDataStore_GameState : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_GameState
    FScriptDelegate __OnRefreshDataFieldValue__Delegate;
    //## END PROPS UIDataStore_GameState

    void delegateOnRefreshDataFieldValue()
    {
        ProcessDelegate(ENGINE_OnRefreshDataFieldValue,&__OnRefreshDataFieldValue__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_GameState,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_GameState)
};

struct FGameDataProviderTypes
{
    class UClass* GameDataProviderClass;
    class UClass* PlayerDataProviderClass;
    class UClass* TeamDataProviderClass;

    /** Constructors */
    FGameDataProviderTypes() {}
    FGameDataProviderTypes(EEventParm)
    {
        appMemzero(this, sizeof(FGameDataProviderTypes));
    }
};

struct CurrentGameDataStore_eventOnAddTeamProvider_Parms
{
    class UTeamDataProvider* Provider;
    CurrentGameDataStore_eventOnAddTeamProvider_Parms(EEventParm)
    {
    }
};
class UCurrentGameDataStore : public UUIDataStore_GameState, public IUIListElementProvider
{
public:
    //## BEGIN PROPS CurrentGameDataStore
    struct FGameDataProviderTypes ProviderTypes;
    class UGameInfoDataProvider* GameData;
    TArrayNoInit<class UPlayerDataProvider*> PlayerData;
    TArrayNoInit<class UTeamDataProvider*> TeamData;
    BITFIELD bRefreshPlayerDataProviders:1;
    BITFIELD bRefreshTeamDataProviders:1;
    FScriptDelegate __OnAddTeamProvider__Delegate;
    //## END PROPS CurrentGameDataStore

    void delegateOnAddTeamProvider(class UTeamDataProvider* Provider)
    {
        CurrentGameDataStore_eventOnAddTeamProvider_Parms Parms(EC_EventParm);
        Parms.Provider=Provider;
        ProcessDelegate(ENGINE_OnAddTeamProvider,&__OnAddTeamProvider__Delegate,&Parms);
    }
    DECLARE_CLASS(UCurrentGameDataStore,UUIDataStore_GameState,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/**
	 * Parses the markup string for a reference to a specific element of the TeamData collection.
	 *
	 * @param	FieldName	a markup string possibly containing markup referencing a specific element of the TeamData array.
	 *						If a reference is found (i.e. TeamData;0), will be set to the remainder of the string.
	 *
	 * @return	a pointer to the element of the TeamData array if the markup contains a reference to one; otherwise NULL.
	 */
	virtual UTeamDataProvider* ParseTeamProviderCollectionReference( FString& FieldName ) const;

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();
	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );
};

struct FPlayerDataProviderTypes
{
    class UClass* PlayerOwnerDataProviderClass;
    class UClass* CurrentWeaponDataProviderClass;
    class UClass* WeaponDataProviderClass;
    class UClass* PowerupDataProviderClass;

    /** Constructors */
    FPlayerDataProviderTypes() {}
    FPlayerDataProviderTypes(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerDataProviderTypes));
    }
};

class UPlayerOwnerDataStore : public UUIDataStore_GameState
{
public:
    //## BEGIN PROPS PlayerOwnerDataStore
    struct FPlayerDataProviderTypes ProviderTypes;
    class UPlayerOwnerDataProvider* PlayerData;
    class UCurrentWeaponDataProvider* CurrentWeapon;
    TArrayNoInit<class UWeaponDataProvider*> WeaponList;
    TArrayNoInit<class UPowerupDataProvider*> PowerupList;
    //## END PROPS PlayerOwnerDataStore

    DECLARE_CLASS(UPlayerOwnerDataStore,UUIDataStore_GameState,0|CLASS_Transient,Engine)
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataStore_Gamma : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Gamma
    //## END PROPS UIDataStore_Gamma

    DECLARE_CLASS(UUIDataStore_Gamma,UUIDataStore,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

private:
	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE );

	/**
	 * Tells the D3D device to flush it's INI settings to disk to save the gamma value
	 */
	void OnCommit(void);
};

class UUIDataStore_Images : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Images
    //## END PROPS UIDataStore_Images

    DECLARE_CLASS(UUIDataStore_Images,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataStore interface === */
	/**
	 * Retrieves the tag used for referencing this data store.  Loc data store is always referenced using the special tag "Strings"
	 */
	virtual FName GetDataStoreID() const { return NAME_Images; }

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString, out_FieldValue);
	}
};

class UUIDataStore_Registry : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Registry
    class UUIDynamicFieldProvider* RegistryDataProvider;
    //## END PROPS UIDataStore_Registry

    DECLARE_CLASS(UUIDataStore_Registry,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataStore interface === */
	/**
	 * Creates the data provider for this registry data store.
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but in this data store, the data fields are pulled from an internal provider but presented as though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();

	/**
	 * Notifies the data store that all values bound to this data store in the current scene have been saved.  Provides data stores which
	 * perform buffered or batched data transactions with a way to determine when the UI system has finished writing data to the data store.
	 */
	virtual void OnCommit();
};

class UUIDataStore_Remote : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Remote
    //## END PROPS UIDataStore_Remote

    DECLARE_ABSTRACT_CLASS(UUIDataStore_Remote,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_Remote)
};

struct FGameSearchCfg
{
    class UClass* GameSearchClass;
    class UClass* DefaultGameSettingsClass;
    class UClass* SearchResultsProviderClass;
    class UUIDataProvider_Settings* DesiredSettingsProvider;
    TArrayNoInit<class UUIDataProvider_Settings*> SearchResults;
    class UOnlineGameSearch* Search;
    FName SearchName;

    /** Constructors */
    FGameSearchCfg() {}
    FGameSearchCfg(EEventParm)
    {
        appMemzero(this, sizeof(FGameSearchCfg));
    }
};

struct UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms
{
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventMoveToNext_Parms
{
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventMoveToNext_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms
{
    FName SearchName;
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms
{
    INT NewIndex;
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetActiveGameSearch_Parms
{
    class UOnlineGameSearch* ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetActiveGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms
{
    class UOnlineGameSearch* ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms
{
    BYTE ControllerIndex;
    INT ListIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms
{
    INT ListIndex;
    struct FOnlineGameSearchResult Result;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms
{
    BYTE ControllerIndex;
    UBOOL bInvalidateExistingSearchResults;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventInit_Parms
{
    UIDataStore_OnlineGameSearch_eventInit_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineGameSearch : public UUIDataStore_Remote, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlineGameSearch
    FName SearchResultsName;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> GameInterface;
    TArrayNoInit<struct FGameSearchCfg> GameSearchCfgList;
    INT SelectedIndex;
    INT ActiveSearchIndex;
    //## END PROPS UIDataStore_OnlineGameSearch

    virtual void BuildSearchResults();
    DECLARE_FUNCTION(execBuildSearchResults)
    {
        P_FINISH;
        BuildSearchResults();
    }
    void eventMoveToPrevious(UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms Parms(EC_EventParm);
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToPrevious),&Parms);
    }
    void eventMoveToNext(UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventMoveToNext_Parms Parms(EC_EventParm);
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToNext),&Parms);
    }
    void eventSetCurrentByName(FName SearchName,UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms Parms(EC_EventParm);
        Parms.SearchName=SearchName;
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByName),&Parms);
    }
    void eventSetCurrentByIndex(INT NewIndex,UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByIndex),&Parms);
    }
    class UOnlineGameSearch* eventGetActiveGameSearch()
    {
        UIDataStore_OnlineGameSearch_eventGetActiveGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActiveGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    class UOnlineGameSearch* eventGetCurrentGameSearch()
    {
        UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShowHostGamercard(BYTE ControllerIndex,INT ListIndex)
    {
        UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        Parms.ListIndex=ListIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowHostGamercard),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetSearchResultFromIndex(INT ListIndex,struct FOnlineGameSearchResult& Result)
    {
        UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ListIndex=ListIndex;
        Parms.Result=Result;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSearchResultFromIndex),&Parms);
        Result=Parms.Result;
        return Parms.ReturnValue;
    }
    UBOOL eventSubmitGameSearch(BYTE ControllerIndex,UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SubmitGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineGameSearch,UUIDataStore_Remote,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
protected:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered provider objects for each
	 * registered OnlineGameSettings class
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

struct UIDataStore_OnlinePlayerData_eventGetCachedPlayerProfile_Parms
{
    INT ControllerId;
    class UOnlineProfileSettings* ReturnValue;
    UIDataStore_OnlinePlayerData_eventGetCachedPlayerProfile_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventSaveProfileData_Parms
{
    UBOOL ReturnValue;
    UIDataStore_OnlinePlayerData_eventSaveProfileData_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventOnUnregister_Parms
{
    UIDataStore_OnlinePlayerData_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    UIDataStore_OnlinePlayerData_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlinePlayerData : public UUIDataStore_Remote, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlinePlayerData
    class UUIDataProvider_OnlineFriends* FriendsProvider;
    class UUIDataProvider_OnlinePlayers* PlayersProvider;
    class UUIDataProvider_OnlineClanMates* ClanMatesProvider;
    class ULocalPlayer* Player;
    FStringNoInit PlayerNick;
    INT NumNewDownloads;
    INT NumTotalDownloads;
    FStringNoInit ProfileSettingsClassName;
    class UClass* ProfileSettingsClass;
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    class UUIDataProvider_OnlineFriendMessages* FriendMessagesProvider;
    class UUIDataProvider_PlayerAchievements* AchievementsProvider;
    FStringNoInit FriendsProviderClassName;
    class UClass* FriendsProviderClass;
    FStringNoInit PlayersProviderClassName;
    class UClass* PlayersProviderClass;
    FStringNoInit ClanMatesProviderClassName;
    class UClass* ClanMatesProviderClass;
    FStringNoInit FriendMessagesProviderClassName;
    class UClass* FriendMessagesProviderClass;
    FStringNoInit AchievementsProviderClassName;
    class UClass* AchievementsProviderClass;
    //## END PROPS UIDataStore_OnlinePlayerData

    void OnSettingProviderChanged(class UUIDataProvider* SourceProvider,FName SettingsName=NAME_None);
    DECLARE_FUNCTION(execOnSettingProviderChanged)
    {
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_NAME_OPTX(SettingsName,NAME_None);
        P_FINISH;
        OnSettingProviderChanged(SourceProvider,SettingsName);
    }
    class UOnlineProfileSettings* eventGetCachedPlayerProfile(INT ControllerId)
    {
        UIDataStore_OnlinePlayerData_eventGetCachedPlayerProfile_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCachedPlayerProfile),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSaveProfileData()
    {
        UIDataStore_OnlinePlayerData_eventSaveProfileData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SaveProfileData),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        UIDataStore_OnlinePlayerData_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_CLASS(UUIDataStore_OnlinePlayerData,UUIDataStore_Remote,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
/* === UIDataStore interface === */

	/**
	 * Loads the game specific OnlineProfileSettings class
	 */
	virtual void LoadDependentClasses(void);

	/**
	 * Creates the data providers exposed by this data store
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Forwards the calls to the data providers so they can do their start up
	 *
	 * @param Player the player that will be associated with this DataStore
	 */
	virtual void OnRegister(ULocalPlayer* Player);

	/**
	 * Tells all of the child providers to clear their player data
	 *
	 * @param Player ignored
	 */
	virtual void OnUnregister(ULocalPlayer*);

	/**
	 * Gets the list of data fields exposed by this data provider
	 *
	 * @param OutFields Filled in with the list of fields supported by its aggregated providers
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	virtual UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex );

	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

/* === IUIListElementProvider interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );
};

struct FPlayerNickMetaData
{
    FName PlayerNickName;
    FStringNoInit PlayerNickColumnName;

    /** Constructors */
    FPlayerNickMetaData() {}
    FPlayerNickMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerNickMetaData));
    }
};

struct FRankMetaData
{
    FName RankName;
    FStringNoInit RankColumnName;

    /** Constructors */
    FRankMetaData() {}
    FRankMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FRankMetaData));
    }
};

struct UIDataStore_OnlineStats_eventShowGamercard_Parms
{
    BYTE ConrollerIndex;
    INT ListIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineStats_eventShowGamercard_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineStats_eventRefreshStats_Parms
{
    BYTE ControllerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineStats_eventRefreshStats_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineStats_eventInit_Parms
{
    UIDataStore_OnlineStats_eventInit_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineStats : public UUIDataStore_Remote, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlineStats
    TArrayNoInit<class UClass*> StatsReadClasses;
    FName StatsReadName;
    struct FPlayerNickMetaData PlayerNickData;
    struct FRankMetaData RankNameMetaData;
    FName TotalRowsName;
    TArrayNoInit<class UOnlineStatsRead*> StatsReadObjects;
    class UOnlineStatsRead* StatsRead;
    BYTE CurrentReadType;
    TScriptInterface<class IInterface> StatsInterface;
    TScriptInterface<class IInterface> PlayerInterface;
    //## END PROPS UIDataStore_OnlineStats

    virtual void SortResultsByRank();
    DECLARE_FUNCTION(execSortResultsByRank)
    {
        P_FINISH;
        SortResultsByRank();
    }
    UBOOL eventShowGamercard(BYTE ConrollerIndex,INT ListIndex)
    {
        UIDataStore_OnlineStats_eventShowGamercard_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ConrollerIndex=ConrollerIndex;
        Parms.ListIndex=ListIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowGamercard),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRefreshStats(BYTE ControllerIndex)
    {
        UIDataStore_OnlineStats_eventRefreshStats_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshStats),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineStats,UUIDataStore_Remote,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
protected:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered stats read object
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Returns the stats read results as a collection
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields)
	{
		OutFields.Empty();
		new(OutFields)FUIDataProviderField(StatsReadName,DATATYPE_Collection);
		new(OutFields)FUIDataProviderField(TotalRowsName);
	}

	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE)
	{
		if (FName(*FieldName) == TotalRowsName)
		{
			OutFieldValue.PropertyType = DATATYPE_Property;
			OutFieldValue.StringValue = FString::Printf(TEXT("%d"),StatsRead ? StatsRead->TotalRowsInView : 0);
			return TRUE;
		}
		return FALSE;
	}

	/**
	 * Returns the list element provider for the specified proprety name
	 *
	 * @param PropertyName the name of the property to look up
	 *
	 * @return pointer to the interface or null if the property name is invalid
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName)
	{
		if (FName(*PropertyName) == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementProvider>();
	}

// IUIListElement interface

	/**
	 * Returns the names of the columns that can be bound to
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param CellTag the tag for the element cell to get the field type for
	 * @param OutCellFieldType receives the field type for the specified cell (property)
	 *
	 * @return TRUE if the cell tag is valid, FALSE otherwise
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& OutCellFieldType);

	/**
	 * Finds the value for the specified column in a row (if valid)
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param CellTag the tag for the element cell to resolve the value for
	 * @param ListIndex the index into the stats read results array
	 * @param OutFieldValue the out value that holds the cell's value
	 * @param ArrayIndex ignored
	 *
	 * @return TRUE if the cell value was found, FALSE otherwise
	 */
	virtual UBOOL GetCellFieldValue(FName FieldName, const FName& CellTag,INT ListIndex,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

// IUIListElementProvider interface

	/**
	 * Fetches the column names that can be bound
	 *
	 * @return the list of tags supported
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of rows in the data set
	 *
	 * @param DataTag the name of the collection that is being queried
	 *
	 * @return the number of items in the list
	 */
	virtual INT GetElementCount(FName DataTag)
	{
		check(StatsRead);
		return StatsRead->Rows.Num();
	}

	/**
	 * Returns the list of indices for the list items
	 *
	 * @param	FieldName		the name of the property to get the indices for
	 * @param	OutElements		will be filled with the indices into the list
	 *
	 * @return	TRUE if the field name is valid, FALSE otherwise
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Fetches the interface that allows the UI to query for column names
	 *
	 * @param DataTag the tag of the list needed
	 *
	 * @return a pointer to the interface or null if invalid
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName)
	{
		if (FieldName == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementCellProvider>();
	}

	/**
	 * Fetches the interface that allows the UI to query for column values
	 *
	 * @param FieldName the tag of the list that needs the interface
	 * @param ListIndex ignored
	 *
	 * @return a pointer to the interface or null if invalid
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT)
	{
		if (FieldName == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementCellProvider>();
	}
};

class UUIDataStore_Settings : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Settings
    //## END PROPS UIDataStore_Settings

    DECLARE_ABSTRACT_CLASS(UUIDataStore_Settings,UUIDataStore,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_Settings)
};

struct FGameSettingsCfg
{
    class UClass* GameSettingsClass;
    class UUIDataProvider_Settings* Provider;
    class UOnlineGameSettings* GameSettings;
    FName SettingsName;

    /** Constructors */
    FGameSettingsCfg() {}
    FGameSettingsCfg(EEventParm)
    {
        appMemzero(this, sizeof(FGameSettingsCfg));
    }
};

struct UIDataStore_OnlineGameSettings_eventMoveToPrevious_Parms
{
    UIDataStore_OnlineGameSettings_eventMoveToPrevious_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventMoveToNext_Parms
{
    UIDataStore_OnlineGameSettings_eventMoveToNext_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms
{
    FName SettingsName;
    UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms
{
    INT NewIndex;
    UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms
{
    class UUIDataProvider_Settings* ReturnValue;
    UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms
{
    class UOnlineGameSettings* ReturnValue;
    UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventCreateGame_Parms
{
    BYTE ControllerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSettings_eventCreateGame_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineGameSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_OnlineGameSettings
    TArrayNoInit<struct FGameSettingsCfg> GameSettingsCfgList;
    class UClass* SettingsProviderClass;
    INT SelectedIndex;
    //## END PROPS UIDataStore_OnlineGameSettings

    void OnSettingProviderChanged(class UUIDataProvider* SourceProvider,FName SettingsName=NAME_None);
    DECLARE_FUNCTION(execOnSettingProviderChanged)
    {
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_NAME_OPTX(SettingsName,NAME_None);
        P_FINISH;
        OnSettingProviderChanged(SourceProvider,SettingsName);
    }
    void eventMoveToPrevious()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToPrevious),NULL);
    }
    void eventMoveToNext()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToNext),NULL);
    }
    void eventSetCurrentByName(FName SettingsName)
    {
        UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms Parms(EC_EventParm);
        Parms.SettingsName=SettingsName;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByName),&Parms);
    }
    void eventSetCurrentByIndex(INT NewIndex)
    {
        UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByIndex),&Parms);
    }
    class UUIDataProvider_Settings* eventGetCurrentProvider()
    {
        UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentProvider),&Parms);
        return Parms.ReturnValue;
    }
    class UOnlineGameSettings* eventGetCurrentGameSettings()
    {
        UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentGameSettings),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventCreateGame(BYTE ControllerIndex)
    {
        UIDataStore_OnlineGameSettings_eventCreateGame_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateGame),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineGameSettings,UUIDataStore_Settings,0|CLASS_Transient,Engine)
private:
	/**
	 * Loads and creates an instance of the registered provider objects for each
	 * registered OnlineGameSettings class
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);
};

class UUIDataStore_PlayerSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_PlayerSettings
    TArrayNoInit<FString> PlayerSettingsProviderClassNames;
    TArrayNoInit<class UClass*> PlayerSettingsProviderClasses;
    TArrayNoInit<class UPlayerSettingsProvider*> PlayerSettings;
    INT PlayerIndex;
    //## END PROPS UIDataStore_PlayerSettings

    class ULocalPlayer* GetPlayerOwner() const;
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner();
    }
    DECLARE_CLASS(UUIDataStore_PlayerSettings,UUIDataStore_Settings,0|CLASS_Transient|CLASS_Config,Engine)
	/* === UIDataStore interface === */
	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIDataStore_SessionSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_SessionSettings
    TArrayNoInit<FString> SessionSettingsProviderClassNames;
    TArrayNoInit<class UClass*> SessionSettingsProviderClasses;
    TArrayNoInit<class USessionSettingsProvider*> SessionSettings;
    //## END PROPS UIDataStore_SessionSettings

    DECLARE_CLASS(UUIDataStore_SessionSettings,UUIDataStore_Settings,0|CLASS_Transient|CLASS_Config,Engine)
	/* === UIDataStore interface === */
	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIDataStore_StringBase : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_StringBase
    //## END PROPS UIDataStore_StringBase

    DECLARE_ABSTRACT_CLASS(UUIDataStore_StringBase,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_StringBase)
};

struct FUIInputKeyData
{
    struct FRawInputKeyEventData InputKeyData;
    FStringNoInit ButtonFontMarkupString;

    /** Constructors */
    FUIInputKeyData() {}
    FUIInputKeyData(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputKeyData));
    }
};

struct FUIDataStoreInputAlias
{
    FName AliasName;
    struct FUIInputKeyData PlatformInputKeys[3];

    /** Constructors */
    FUIDataStoreInputAlias() {}
    FUIDataStoreInputAlias(EEventParm)
    {
        appMemzero(this, sizeof(FUIDataStoreInputAlias));
    }
};

class UUIDataStore_InputAlias : public UUIDataStore_StringBase
{
public:
    //## BEGIN PROPS UIDataStore_InputAlias
protected:
    TArrayNoInit<struct FUIDataStoreInputAlias> InputAliases;
    TMap< FName,INT > InputAliasLookupMap;
public:
    //## END PROPS UIDataStore_InputAlias

    FString GetAliasFontMarkup(FName DesiredAlias,BYTE OverridePlatform=3) const;
    FString GetAliasFontMarkupByIndex(INT AliasIndex,BYTE OverridePlatform=3) const;
    FName GetAliasInputKeyName(FName DesiredAlias,BYTE OverridePlatform=3) const;
    FName GetAliasInputKeyNameByIndex(INT AliasIndex,BYTE OverridePlatform=3) const;
    UBOOL GetAliasInputKeyData(struct FRawInputKeyEventData& out_InputKeyData,FName DesiredAlias,BYTE OverridePlatform=3) const;
    UBOOL GetAliasInputKeyDataByIndex(struct FRawInputKeyEventData& out_InputKeyData,INT AliasIndex,BYTE OverridePlatform=3) const;
    INT FindInputAliasIndex(FName DesiredAlias) const;
    UBOOL HasAliasMappingForPlatform(FName DesiredAlias,BYTE DesiredPlatform) const;
    DECLARE_FUNCTION(execGetAliasFontMarkup)
    {
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FString*)Result=GetAliasFontMarkup(DesiredAlias,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasFontMarkupByIndex)
    {
        P_GET_INT(AliasIndex);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FString*)Result=GetAliasFontMarkupByIndex(AliasIndex,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyName)
    {
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FName*)Result=GetAliasInputKeyName(DesiredAlias,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyNameByIndex)
    {
        P_GET_INT(AliasIndex);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FName*)Result=GetAliasInputKeyNameByIndex(AliasIndex,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyData)
    {
        P_GET_STRUCT_REF(struct FRawInputKeyEventData,out_InputKeyData);
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(UBOOL*)Result=GetAliasInputKeyData(out_InputKeyData,DesiredAlias,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyDataByIndex)
    {
        P_GET_STRUCT_REF(struct FRawInputKeyEventData,out_InputKeyData);
        P_GET_INT(AliasIndex);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(UBOOL*)Result=GetAliasInputKeyDataByIndex(out_InputKeyData,AliasIndex,OverridePlatform);
    }
    DECLARE_FUNCTION(execFindInputAliasIndex)
    {
        P_GET_NAME(DesiredAlias);
        P_FINISH;
        *(INT*)Result=FindInputAliasIndex(DesiredAlias);
    }
    DECLARE_FUNCTION(execHasAliasMappingForPlatform)
    {
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE(DesiredPlatform);
        P_FINISH;
        *(UBOOL*)Result=HasAliasMappingForPlatform(DesiredAlias,DesiredPlatform);
    }
    DECLARE_CLASS(UUIDataStore_InputAlias,UUIDataStore_StringBase,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	/* === UUIDataStore_InputAlias interface === */
	/**
	 * Populates the InputAliasLookupMap based on the elements of the InputAliases array.
	 */
	void InitializeLookupMap();

	/**
	 * @return	the platform that should be used (by default) when retrieving data associated with input aliases
	 */
	EInputPlatformType GetDefaultPlatform() const;

	/* === UUIDataStore interface === */
	/**
	 * Hook for performing any initialization required for this data store.
	 *
	 * This version builds the InputAliasLookupMap based on the elements in the InputAliases array.
	 */
	virtual void InitializeDataStore();

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider
	 *
	 * @param OutFields Filled in with the list of fields supported by its aggregated providers
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * For data stores that are responsible for applying inline style modifications (such as the font, style, and attribute data stores),
	 * parses the data store reference and applies the appropriate style changes.
	 *
	 * @param	MarkupString	a markup string representing a style modification that this data store is aware of; i.e. the name of the font,
	 *							style, or attribute.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if this data store applied a change to StyleData based on the value of MarkupString, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& MarkupString, struct FUIStringNodeModifier& StyleData ) { return TRUE; }

protected:
	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE );
};

struct FUIMenuInputMap
{
    FName FieldName;
    FName Set;
    FStringNoInit MappedText;

    /** Constructors */
    FUIMenuInputMap() {}
    FUIMenuInputMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIMenuInputMap));
    }
};

class UUIDataStore_StringAliasMap : public UUIDataStore_StringBase
{
public:
    //## BEGIN PROPS UIDataStore_StringAliasMap
    TArrayNoInit<struct FUIMenuInputMap> MenuInputMapArray;
    TMap<FName, TMap<FName, INT> > MenuInputSets;
    INT PlayerIndex;
    //## END PROPS UIDataStore_StringAliasMap

    class ULocalPlayer* GetPlayerOwner() const;
    INT FindMappingWithFieldName(const FString& FieldName=TEXT(""),const FString& SetName=TEXT(""));
    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner();
    }
    DECLARE_FUNCTION(execFindMappingWithFieldName)
    {
        P_GET_STR_OPTX(FieldName,TEXT(""));
        P_GET_STR_OPTX(SetName,TEXT(""));
        P_FINISH;
        *(INT*)Result=FindMappingWithFieldName(FieldName,SetName);
    }
    DECLARE_FUNCTION(execGetStringWithFieldName)
    {
        P_GET_STR(FieldName);
        P_GET_STR_REF(MappedString);
        P_FINISH;
        *(INT*)Result=GetStringWithFieldName(FieldName,MappedString);
    }
    DECLARE_CLASS(UUIDataStore_StringAliasMap,UUIDataStore_StringBase,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	* Called when this data store is added to the data store manager's list of active data stores.
	*
	* @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	*							associated with a particular player; NULL if this is a global data store.
	*/
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/**
	 * For data stores that are responsible for applying inline style modifications (such as the font, style, and attribute data stores),
	 * parses the data store reference and applies the appropriate style changes.
	 *
	 * @param	MarkupString	a markup string representing a style modification that this data store is aware of; i.e. the name of the font,
	 *							style, or attribute.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if this data store applied a change to StyleData based on the value of MarkupString, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& MarkupString, struct FUIStringNodeModifier& StyleData ) { return TRUE; }

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === UIDataStore_MenuStringMap interface === */
public:
	/** Return the string representation of the field being queried */
	virtual FString GetStringFromIndex( INT MapArrayIndex );
};

class UUIDataStore_Strings : public UUIDataStore_StringBase
{
public:
    //## BEGIN PROPS UIDataStore_Strings
    TArrayNoInit<class UUIConfigFileProvider*> LocFileProviders;
    //## END PROPS UIDataStore_Strings

    DECLARE_CLASS(UUIDataStore_Strings,UUIDataStore_StringBase,0|CLASS_Transient,Engine)
protected:
	/* === UUIDataStore_Strings interface === */
	/**
	 * Creates an UIConfigFileProvider instance for the loc file specified by FilePathName.
	 *
	 * @return	a pointer to a newly allocated UUIConfigFileProvider instance that contains the data for the specified
	 *			loc file.
	 */
	class UUIConfigFileProvider* CreateLocProvider( const FFilename& FilePathName );

public:
	/* === UIDataStore interface === */
	/**
	 * Loads all .int files and creates UIConfigProviders for each loc file that was loaded.
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString, out_FieldValue);
	}

	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	virtual UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex )
	{
		out_FieldOwner = this;
		out_FieldTag = MarkupString;
		return TRUE;
	}

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct FUISoundCue
{
    FName SoundName;
    class USoundCue* SoundToPlay;

	/** Constructors */
	FUISoundCue() {}
	FUISoundCue(EEventParm)
	{
		appMemzero(this,sizeof(FUISoundCue));
	}

};

class UUISkin : public UUIDataStore
{
public:
    //## BEGIN PROPS UISkin
protected:
    TArrayNoInit<class UUIStyle*> Styles;
    TArrayNoInit<FString> StyleGroups;
    TArrayNoInit<struct FUISoundCue> SoundCues;
public:
    TMap< struct FSTYLE_ID,class UUIStyle* > StyleLookupTable;
    TMap< FName,class UUIStyle* > StyleNameMap;
    TLookupMap<FString> StyleGroupMap;
    TMap< FName,struct FUIMouseCursor > CursorMap;
    TMap< FName,class USoundCue* > SoundCueMap;
    //## END PROPS UISkin

    void GetAvailableStyles(TArray<class UUIStyle*>& out_Styles,UBOOL bIncludeInheritedStyles=TRUE);
    class UUITexture* GetCursorResource(FName CursorName);
    UBOOL AddUISoundCue(FName SoundCueName,class USoundCue* SoundToPlay);
    UBOOL RemoveUISoundCue(FName SoundCueName);
    UBOOL GetUISoundCue(FName SoundCueName,class USoundCue*& out_UISoundCue);
    void GetSkinSoundCues(TArray<struct FUISoundCue>& out_SoundCues);
    UBOOL IsInheritedGroupName(const FString& StyleGroupName) const;
    UBOOL AddStyleGroupName(const FString& StyleGroupName);
    UBOOL RemoveStyleGroupName(const FString& StyleGroupName);
    UBOOL RenameStyleGroup(const FString& OldStyleGroupName,const FString& NewStyleGroupName);
    FString GetStyleGroupAtIndex(INT Index) const;
    INT FindStyleGroupIndex(const FString& StyleGroupName) const;
    void GetStyleGroups(TArray<FString>& StyleGroupArray,UBOOL bIncludeInheritedGroups=TRUE) const;
    DECLARE_FUNCTION(execGetAvailableStyles)
    {
        P_GET_TARRAY_REF(class UUIStyle*,out_Styles);
        P_GET_UBOOL_OPTX(bIncludeInheritedStyles,TRUE);
        P_FINISH;
        GetAvailableStyles(out_Styles,bIncludeInheritedStyles);
    }
    DECLARE_FUNCTION(execGetCursorResource)
    {
        P_GET_NAME(CursorName);
        P_FINISH;
        *(class UUITexture**)Result=GetCursorResource(CursorName);
    }
    DECLARE_FUNCTION(execAddUISoundCue)
    {
        P_GET_NAME(SoundCueName);
        P_GET_OBJECT(USoundCue,SoundToPlay);
        P_FINISH;
        *(UBOOL*)Result=AddUISoundCue(SoundCueName,SoundToPlay);
    }
    DECLARE_FUNCTION(execRemoveUISoundCue)
    {
        P_GET_NAME(SoundCueName);
        P_FINISH;
        *(UBOOL*)Result=RemoveUISoundCue(SoundCueName);
    }
    DECLARE_FUNCTION(execGetUISoundCue)
    {
        P_GET_NAME(SoundCueName);
        P_GET_OBJECT_REF(USoundCue,out_UISoundCue);
        P_FINISH;
        *(UBOOL*)Result=GetUISoundCue(SoundCueName,out_UISoundCue);
    }
    DECLARE_FUNCTION(execGetSkinSoundCues)
    {
        P_GET_TARRAY_REF(struct FUISoundCue,out_SoundCues);
        P_FINISH;
        GetSkinSoundCues(out_SoundCues);
    }
    DECLARE_FUNCTION(execIsInheritedGroupName)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=IsInheritedGroupName(StyleGroupName);
    }
    DECLARE_FUNCTION(execAddStyleGroupName)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=AddStyleGroupName(StyleGroupName);
    }
    DECLARE_FUNCTION(execRemoveStyleGroupName)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=RemoveStyleGroupName(StyleGroupName);
    }
    DECLARE_FUNCTION(execRenameStyleGroup)
    {
        P_GET_STR(OldStyleGroupName);
        P_GET_STR(NewStyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=RenameStyleGroup(OldStyleGroupName,NewStyleGroupName);
    }
    DECLARE_FUNCTION(execGetStyleGroupAtIndex)
    {
        P_GET_INT(Index);
        P_FINISH;
        *(FString*)Result=GetStyleGroupAtIndex(Index);
    }
    DECLARE_FUNCTION(execFindStyleGroupIndex)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(INT*)Result=FindStyleGroupIndex(StyleGroupName);
    }
    DECLARE_FUNCTION(execGetStyleGroups)
    {
        P_GET_TARRAY_REF(FString,StyleGroupArray);
        P_GET_UBOOL_OPTX(bIncludeInheritedGroups,TRUE);
        P_FINISH;
        GetStyleGroups(StyleGroupArray,bIncludeInheritedGroups);
    }
    DECLARE_CLASS(UUISkin,UUIDataStore,0,Engine)
	/* === UUISkin interface === */
	/**
	 * Called when this skin is set to be the UI's active skin.  Initializes all styles and builds the lookup tables.
	 */
	void Initialize();

	/**
	 * Fills the values of the specified maps with the styles contained by this skin and all this skin's archetypes.
	 */
	virtual void InitializeLookupTables( TMap<struct FSTYLE_ID,class UUIStyle*>& out_StyleIdMap, TMap<FName,class UUIStyle*>& out_StyleNameMap, TMap<FName,class USoundCue*>& out_SoundCueMap, TLookupMap<FString>& out_GroupNameMap );

	/**
	 * Creates a new style within this skin.
	 *
	 * @param	StyleClass		the class to use for the new style
	 * @param	StyleTag		the unique tag to use for creating the new style
	 * @param	StyleTemplate	the template to use for the new style
	 * @param	bAddToSkin		TRUE to automatically add this new style to this skin's list of styles
	 */
	virtual UUIStyle* CreateStyle( UClass* StyleClass, FName StyleTag, class UUIStyle* StyleTemplate=NULL, UBOOL bAddToSkin=TRUE );

	/**
	 * Creates a new style using the template provided and replaces its entry in the style lookup tables.
	 * This only works if the outer of the style template is a archetype of the this skin.
	 *
	 * @param	StyleTemplate	the template to use for the new style
	 * @return	Pointer to the style that was created to replace the archetype's style.
	 */
	virtual UUIStyle* ReplaceStyle( class UUIStyle* StyleTemplate );

	/**
	 * Deletes the specified style and replaces its entry in the lookup table with this skin's archetype style.
	 * This only works if the provided style's outer is this skin.
	 *
	 * @return	TRUE if the style was successfully removed.
	 */
	virtual UBOOL DeleteStyle( class UUIStyle* InStyle );

	/**that
	 * Adds the specified style to this skin's list of styles.
	 *
	 * @return	TRUE if the style was successfully added to this skin.
	 */
	virtual UBOOL AddStyle( class UUIStyle* NewStyle );

	/**
	 * Retrieve the style ID associated with a particular style name
	 */
	FSTYLE_ID FindStyleID( FName StyleName ) const;

	/**
	 * Retrieve the style associated with a particular style name
	 */
	UUIStyle* FindStyle( FName StyleName ) const;

	/**
	 * Determines whether the specified style is contained in this skin
	 *
	 * @param	bIncludeInheritedStyles		if FALSE, only returns true if the specified style is in this skin's Styles
	 *										array; otherwise, also returns TRUE if the specified style is contained by
	 *										any base skins of this one.
	 *
	 * @return	TRUE if the specified style is contained by this skin, or one of its base skins
	 */
	UBOOL ContainsStyle( UUIStyle* StyleToSearchFor, UBOOL bIncludeInheritedStyles=FALSE ) const;

	/**
	 * Adds a new mouse cursor resource to this skin.
	 *
	 * @param	CursorTag			the name to use for the mouse cursor.  this will be the name that must be used to retrieve
	 *								this mouse cursor via GetCursorResource()
	 * @param	CursorResource		the mouse cursor to add
	 *
	 * @return	TRUE if the cursor was successfully added to the skin.  FALSE if the resource was invalid or there is already
	 *			another cursor using the specified tag.
	 */
	UBOOL AddCursorResource( FName CursorTag, const FUIMouseCursor& CursorResource );

	/**
	 * Makes any necessary internal changes when this style has been modified
	 *
	 * @param	Style	style in this skin which data has been modified
	 */
	void NotifyStyleModified( class UUIStyle* Style );

	enum EDerivedType
	{
		DERIVETYPE_DirectOnly,
		DERIVETYPE_All,
	};

	enum EStyleSearchType
	{
		SEARCH_SameSkinOnly,
		SEARCH_AnySkin,
	};

	/**
	 * Generate a list of UISkin objects in memory that are derived from the specified skin.
	 */
	static void GetDerivedSkins( const UUISkin* ParentSkin, TArray<UUISkin*>& out_DerivedSkins, EDerivedType DeriveFilter=DERIVETYPE_All );

	/**
	 * Obtains a list of styles that derive from the ParentStyle (i.e. have ParentStyle in their archetype chain)
	 *
	 * @param	ParentStyle		the style to search for archetype references to
	 * @param	DerivedStyles	[out] An array that will be filled with pointers to the derived styles
	 * @param	DeriveType		if DERIVETYPE_DirectOnly, only styles that have ParentStyle as the value for ObjectArchetype will added
	 *							out_DerivedStyles. if DERIVETYPE_All, any style that has ParentStyle anywhere in its archetype chain
	 *							will be added to the list.
	 * @param	SearchType		if SEARCH_SameSkinOnly, only styles contained by this skin will be considered.  if SEARCH_AnySkin, all loaded styles will be considered.
	 */
	void GetDerivedStyles( const UUIStyle* ParentStyle, TArray<UUIStyle*>& out_DerivedStyles, EDerivedType DeriveType, EStyleSearchType SearchType=SEARCH_AnySkin );

	/**
     * Checks if this Tag name is currently used in this Skin
     *
     * @param	Tag		checks if this tag exists in the skin
     */
    UBOOL IsUniqueTag( const FName & Tag);

	/* === UIDataStore interface === */

	/**
	 * Retrieves the tag used for referencing this data store.  Normally corresponds to Tag, but may be different for some special
	 * data stores.
	 *
	 * Always returns "Scenes" in case the skin's Tag is changed.
	 */
	virtual FName GetDataStoreID() const { return TEXT("Styles"); }

	/* === UIDataProvider interface === */
	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }

	/**
	 * Searches for the Style specified and if found changes the node modifier's
	 *
	 * @param	StyleName	the name of the style to apply - must match the StyleTag of a style in this skin (or a base skin).
	 * @param	StyleData	the style data to apply the changes to.
	 *
	 * @return	TRUE if a style was found with the specified StyleName, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& StyleName, struct FUIStringNodeModifier& StyleData );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		this data provider cannot generate string nodes, so the return value is always an empty string.
	 */
	virtual FString GenerateFillerData( const FString& DataTag ) { return TEXT(""); }

	/* === UObject interface === */
	/**
	 * I/O function
	 */
	virtual void Serialize( FArchive& Ar );

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& Objects );

	/**
	 * Called when this object is loaded from an archive.  Fires a callback which notifies the UI editor that this skin
	 * should be re-initialized if it's the active skin.
	 */
	virtual void PostLoad();

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUICustomSkin : public UUISkin
{
public:
    //## BEGIN PROPS UICustomSkin
    TMap< FWIDGET_ID,FSTYLE_ID > WidgetStyleMap;
    //## END PROPS UICustomSkin

    DECLARE_CLASS(UUICustomSkin,UUISkin,0,Engine)

	/**
	 * Deletes the specified style and replaces its entry in the lookup table with this skin's archetype style.
	 * This only works if the provided style's outer is this skin.
	 *
	 * This version of DeleteStyle goes through the WidgetStyleMap and changes any widgets bound to the style being deleted,
	 * to be bound to the archetype's style instead.
	 *
	 * @return	TRUE if the style was successfully removed.
	 */
	virtual UBOOL DeleteStyle( class UUIStyle* InStyle );

	/**
	 * Assigns the style specified to the widget and stores that mapping in the skin's persistent style list.
	 *
	 * @param	Widget		the widget to apply the style to.
	 * @param	StyleID		the STYLEID for the style that should be assigned to the widget
	 */
	void StoreWidgetStyleMapping( class UUIObject* Widget, const struct FSTYLE_ID& StyleID );
};

class UUIDynamicFieldProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDynamicFieldProvider
protected:
    TArrayNoInit<struct FUIProviderScriptFieldValue> PersistentDataFields;
    TArrayNoInit<struct FUIProviderScriptFieldValue> RuntimeDataFields;
    TMap< FName, TMap<FName,TArray<FString> > > PersistentCollectionData;
    TMap< FName, TMap<FName,TArray<FString> > > RuntimeCollectionData;
public:
    //## END PROPS UIDynamicFieldProvider

    virtual void InitializeRuntimeFields();
    virtual UBOOL RemoveField(FName FieldName);
    virtual INT FindFieldIndex(FName FieldName,UBOOL bSearchPersistentFields=FALSE) const;
    virtual UBOOL ClearFields(UBOOL bReinitializeRuntimeFields=TRUE);
    virtual void SavePersistentProviderData();
    virtual UBOOL GetCollectionValueSchema(FName FieldName,TArray<FName>& out_CellTagArray,UBOOL bPersistent=FALSE);
    virtual UBOOL GetCollectionValueArray(FName FieldName,TArray<FString>& out_DataValueArray,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL SetCollectionValueArray(FName FieldName,const TArray<FString>& CollectionValues,UBOOL bClearExisting=TRUE,INT InsertIndex=-1,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL InsertCollectionValue(FName FieldName,const FString& NewValue,INT InsertIndex=-1,UBOOL bPersistent=FALSE,UBOOL bAllowDuplicateValues=FALSE,FName CellTag=NAME_None);
    virtual UBOOL RemoveCollectionValue(FName FieldName,const FString& ValueToRemove,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL RemoveCollectionValueByIndex(FName FieldName,INT ValueIndex,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL ReplaceCollectionValue(FName FieldName,const FString& CurrentValue,const FString& NewValue,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL ReplaceCollectionValueByIndex(FName FieldName,INT ValueIndex,const FString& NewValue,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL ClearCollectionValueArray(FName FieldName,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL GetCollectionValue(FName FieldName,INT ValueIndex,FString& out_Value,UBOOL bPersistent=FALSE,FName CellTag=NAME_None) const;
    virtual INT FindCollectionValueIndex(FName FieldName,const FString& ValueToFind,UBOOL bPersistent=FALSE,FName CellTag=NAME_None) const;
    DECLARE_FUNCTION(execInitializeRuntimeFields)
    {
        P_FINISH;
        InitializeRuntimeFields();
    }
    DECLARE_FUNCTION(execAddField);
    DECLARE_FUNCTION(execRemoveField)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(UBOOL*)Result=RemoveField(FieldName);
    }
    DECLARE_FUNCTION(execFindFieldIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bSearchPersistentFields,FALSE);
        P_FINISH;
        *(INT*)Result=FindFieldIndex(FieldName,bSearchPersistentFields);
    }
    DECLARE_FUNCTION(execClearFields)
    {
        P_GET_UBOOL_OPTX(bReinitializeRuntimeFields,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ClearFields(bReinitializeRuntimeFields);
    }
    DECLARE_FUNCTION(execGetField);
    DECLARE_FUNCTION(execSetField);
    DECLARE_FUNCTION(execSavePersistentProviderData)
    {
        P_FINISH;
        SavePersistentProviderData();
    }
    DECLARE_FUNCTION(execGetCollectionValueSchema)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FName,out_CellTagArray);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=GetCollectionValueSchema(FieldName,out_CellTagArray,bPersistent);
    }
    DECLARE_FUNCTION(execGetCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FString,out_DataValueArray);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=GetCollectionValueArray(FieldName,out_DataValueArray,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execSetCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FString,CollectionValues);
        P_GET_UBOOL_OPTX(bClearExisting,TRUE);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=SetCollectionValueArray(FieldName,CollectionValues,bClearExisting,InsertIndex,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execInsertCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(NewValue);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_UBOOL_OPTX(bAllowDuplicateValues,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=InsertCollectionValue(FieldName,NewValue,InsertIndex,bPersistent,bAllowDuplicateValues,CellTag);
    }
    DECLARE_FUNCTION(execRemoveCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(ValueToRemove);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=RemoveCollectionValue(FieldName,ValueToRemove,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execRemoveCollectionValueByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=RemoveCollectionValueByIndex(FieldName,ValueIndex,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execReplaceCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(CurrentValue);
        P_GET_STR_REF(NewValue);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=ReplaceCollectionValue(FieldName,CurrentValue,NewValue,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execReplaceCollectionValueByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_STR_REF(NewValue);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=ReplaceCollectionValueByIndex(FieldName,ValueIndex,NewValue,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execClearCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=ClearCollectionValueArray(FieldName,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execGetCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_STR_REF(out_Value);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=GetCollectionValue(FieldName,ValueIndex,out_Value,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execFindCollectionValueIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(ValueToFind);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(INT*)Result=FindCollectionValueIndex(FieldName,ValueToFind,bPersistent,CellTag);
    }
    DECLARE_CLASS(UUIDynamicFieldProvider,UUIDataProvider,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UIDynamicFieldProvider interface === */
	/**
	 * Adds a new data field to the list of supported fields.
	 *
	 * @param	FieldName			the name to give the new field
	 * @param	FieldType			the type of data field being added
	 * @param	bPersistent			specify TRUE to add the field to the PersistentDataFields array as well.
	 * @param	out_InsertPosition	allows the caller to find out where the element was inserted
	 *
	 * @return	TRUE if the field was successfully added to the list; FALSE if the a field with that name already existed
	 *			or the specified name was invalid.
	 */
	virtual UBOOL AddField( FName FieldName, BYTE FieldType=0, UBOOL bPersistent=FALSE, INT* out_InsertPosition=NULL );

	/* === UUIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === UObject interface === */
	/**
	 * Serializes the value of the PersistentCollectionData and RuntimeCollectionData members, since they are not supported
	 * by script serialization.
	 */
	virtual void Serialize( FArchive& Ar );
};

struct UIPropertyDataProvider_eventGetCustomPropertyValue_Parms
{
    struct FUIProviderScriptFieldValue PropertyValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIPropertyDataProvider_eventGetCustomPropertyValue_Parms(EEventParm)
    : PropertyValue(EC_EventParm)
    {
    }
};
struct UIPropertyDataProvider_eventCanSupportComplexPropertyType_Parms
{
    class UProperty* UnsupportedProperty;
    UBOOL ReturnValue;
    UIPropertyDataProvider_eventCanSupportComplexPropertyType_Parms(EEventParm)
    {
    }
};
class UUIPropertyDataProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIPropertyDataProvider
    TArrayNoInit<class UClass*> ComplexPropertyTypes;
    FScriptDelegate __CanSupportComplexPropertyType__Delegate;
    //## END PROPS UIPropertyDataProvider

    UBOOL eventGetCustomPropertyValue(struct FUIProviderScriptFieldValue& PropertyValue,INT ArrayIndex=-1)
    {
        UIPropertyDataProvider_eventGetCustomPropertyValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PropertyValue=PropertyValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCustomPropertyValue),&Parms);
        PropertyValue=Parms.PropertyValue;
        return Parms.ReturnValue;
    }
    UBOOL delegateCanSupportComplexPropertyType(class UProperty* UnsupportedProperty)
    {
        UIPropertyDataProvider_eventCanSupportComplexPropertyType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.UnsupportedProperty=UnsupportedProperty;
        ProcessDelegate(ENGINE_CanSupportComplexPropertyType,&__CanSupportComplexPropertyType__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIPropertyDataProvider,UUIDataProvider,0|CLASS_Transient,Engine)
	/* === UUIPropertyDataProvider interface === */
	/**
	 * Returns whether the specified property type is renderable in the UI.
	 *
	 * @param	Property				the property to check
	 * @param	bRequireNativeSupport	TRUE to require the property to be natively supported (i.e. don't check whether it's supported in script).
	 *
	 * @return	TRUE if this property type is something that can be rendered in the UI.
	 *
	 * @note: can't be const it must call into the script VM, where we can't guarantee that the object's state won't be changed.
	 */
	virtual UBOOL IsValidProperty( UProperty* Property, UBOOL bRequireNativeSupport=FALSE );

	/**
	 * Builds a list of UProperties that are flagged for exposure to data stores from the specified class.
	 *
	 * @param	SourceClass		a pointer to a UClass that contains properties which are marked with the "databinding" keyword.
	 *							Must be a child of the class assigned as the value for DataClass.
	 * @param	out_Properties	will contain pointers to the properties of SourceClass which can be exposed to the data store system.
	 */
	void GetProviderDataBindings( UClass* SourceClass, TArray<UProperty*>& out_Properties );
	/**
	 * Wrapper for copying the property value for Prop into the data field value using the appropriate method.
	 *
	 * @param	Prop			the property that is being copied
	 * @param	BaseAddress		pointer to the beginning of the block of data containing the value for the property; for example,
	 *							if the property represents a class member property, you'd pass in 'this' as the value.
	 * @param	ArrayIndex		specifies the index for the value; only relevant for array properties or static arrays
	 * @param	out_FieldValue	receives the property value; tag and type will also be set to the appropriate value.
	 *
	 * @return	TRUE if the value was successfully copied into the output var.  FALSE if the property isn't supported.
	 */
	UBOOL CopyPropertyValueIntoFieldValue( UProperty* Prop, BYTE* BaseDataAddress, INT ArrayIndex, struct FUIProviderFieldValue& out_FieldValue );

protected:
	/**
	 * Creates a UIStringNode_Text using the source and render text specified.
	 *
	 * @param	PropertyPathName	the path name for the property this text node will represent.  This value is set as the
	 *								source text for the text node.
	 * @param	RenderString		the text that should will be rendered by this text node.
	 *
	 * @return	a pointer to UIStringNode_Text which will render the string specified.
	 */
	FUIStringNode_Text* CreateTextNode( const FString& PropertyPathName, const TCHAR* RenderString ) const;

	/**
	 * Creates a UIStringNode_Text using the source and render text specified.
	 *
	 * @param	PropertyPathName	the path name for the property this image node will represent.  This value is set as the
	 *								source text for the image node.
	 * @param	RenderImage			the image that should be rendered by this image node.
	 *
	 * @return	a pointer to UIStringNode_Image which will render the image specified.
	 */
	FUIStringNode_Image* CreateImageNode( const FString& PropertyPathName, USurface* RenderImage ) const;
};

struct UIDynamicDataProvider_eventIsValidDataSourceClass_Parms
{
    class UClass* PotentialDataSourceClass;
    UBOOL ReturnValue;
    UIDynamicDataProvider_eventIsValidDataSourceClass_Parms(EEventParm)
    {
    }
};
struct UIDynamicDataProvider_eventProviderInstanceUnbound_Parms
{
    class UObject* DataSourceInstance;
    UIDynamicDataProvider_eventProviderInstanceUnbound_Parms(EEventParm)
    {
    }
};
struct UIDynamicDataProvider_eventProviderInstanceBound_Parms
{
    class UObject* DataSourceInstance;
    UIDynamicDataProvider_eventProviderInstanceBound_Parms(EEventParm)
    {
    }
};
class UUIDynamicDataProvider : public UUIPropertyDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDynamicDataProvider
    class UClass* DataClass;
    class UObject* DataSource;
    //## END PROPS UIDynamicDataProvider

    UBOOL BindProviderInstance(class UObject* DataSourceInstance);
    UBOOL UnbindProviderInstance();
    DECLARE_FUNCTION(execBindProviderInstance)
    {
        P_GET_OBJECT(UObject,DataSourceInstance);
        P_FINISH;
        *(UBOOL*)Result=BindProviderInstance(DataSourceInstance);
    }
    DECLARE_FUNCTION(execUnbindProviderInstance)
    {
        P_FINISH;
        *(UBOOL*)Result=UnbindProviderInstance();
    }
    UBOOL eventIsValidDataSourceClass(class UClass* PotentialDataSourceClass)
    {
        UIDynamicDataProvider_eventIsValidDataSourceClass_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PotentialDataSourceClass=PotentialDataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidDataSourceClass),&Parms);
        return Parms.ReturnValue;
    }
    void eventProviderInstanceUnbound(class UObject* DataSourceInstance)
    {
        UIDynamicDataProvider_eventProviderInstanceUnbound_Parms Parms(EC_EventParm);
        Parms.DataSourceInstance=DataSourceInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderInstanceUnbound),&Parms);
    }
    void eventProviderInstanceBound(class UObject* DataSourceInstance)
    {
        UIDynamicDataProvider_eventProviderInstanceBound_Parms Parms(EC_EventParm);
        Parms.DataSourceInstance=DataSourceInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderInstanceBound),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDynamicDataProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UUIDynamicDataProvider interface === */
	/**
	 * Determines whether the specified class should be represented by this dynamic data provider.
	 *
	 * @param	PotentialDataSourceClass	a pointer to a UClass that is being considered for binding by this provider.
	 *
	 * @return	TRUE to allow the databinding properties of PotentialDataSourceClass to be displayed in the UI editor's data store browser
	 *			under this data provider.
	 */
	UBOOL IsValidDataSourceClass( UClass* PotentialDataSourceClass );

	/**
	 * Builds an array of classes that are supported by this data provider.  Used in the editor to generate the list of
	 * supported data fields.  Since dynamic data providers are only created during the game, the editor needs a way to
	 * retrieve the list of data field tags that can be bound without requiring instances of this data provider's DataClass to exist.
	 *
	 * @note: only called in the editor!
	 */
	void GetSupportedClasses( TArray<UClass*>& out_Classes );

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );


	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/* === IUIListElementCellProvider interface === */
	/**
	 * Gets the list of data fields (and their localized friendly name) for the fields exposed this provider.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the name/friendly name pairs for all data fields in this provider.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName			the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *								instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UGameInfoDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS GameInfoDataProvider
    class AGameReplicationInfo* GameDataSource;
    //## END PROPS GameInfoDataProvider

    DECLARE_CLASS(UGameInfoDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UGameInfoDataProvider)
};

class UInventoryDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS InventoryDataProvider
    //## END PROPS InventoryDataProvider

    DECLARE_ABSTRACT_CLASS(UInventoryDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInventoryDataProvider)
};

class UPowerupDataProvider : public UInventoryDataProvider
{
public:
    //## BEGIN PROPS PowerupDataProvider
    //## END PROPS PowerupDataProvider

    DECLARE_CLASS(UPowerupDataProvider,UInventoryDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPowerupDataProvider)
};

class UWeaponDataProvider : public UInventoryDataProvider
{
public:
    //## BEGIN PROPS WeaponDataProvider
    //## END PROPS WeaponDataProvider

    DECLARE_CLASS(UWeaponDataProvider,UInventoryDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UWeaponDataProvider)
};

class UCurrentWeaponDataProvider : public UWeaponDataProvider
{
public:
    //## BEGIN PROPS CurrentWeaponDataProvider
    //## END PROPS CurrentWeaponDataProvider

    DECLARE_CLASS(UCurrentWeaponDataProvider,UWeaponDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCurrentWeaponDataProvider)
};

class UPickupDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS PickupDataProvider
    //## END PROPS PickupDataProvider

    DECLARE_CLASS(UPickupDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPickupDataProvider)
};

class UPlayerDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS PlayerDataProvider
    //## END PROPS PlayerDataProvider

    DECLARE_CLASS(UPlayerDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPlayerDataProvider)
};

class UPlayerOwnerDataProvider : public UPlayerDataProvider
{
public:
    //## BEGIN PROPS PlayerOwnerDataProvider
    class UPlayerDataProvider* PlayerData;
    //## END PROPS PlayerOwnerDataProvider

    DECLARE_CLASS(UPlayerOwnerDataProvider,UPlayerDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UTeamDataProvider : public UUIDynamicDataProvider, public IUIListElementProvider
{
public:
    //## BEGIN PROPS TeamDataProvider
    FName PlayerListFieldName;
    TArrayNoInit<class UPlayerDataProvider*> Players;
    //## END PROPS TeamDataProvider

    DECLARE_CLASS(UTeamDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataProvider interface === */
	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );
};

struct FSettingsArrayProvider
{
    INT SettingsId;
    FName SettingsName;
    class UUIDataProvider_SettingsArray* Provider;

    /** Constructors */
    FSettingsArrayProvider() {}
    FSettingsArrayProvider(EEventParm)
    {
        appMemzero(this, sizeof(FSettingsArrayProvider));
    }
};

class UUIDataProvider_Settings : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_Settings
    class USettings* Settings;
    TArrayNoInit<struct FSettingsArrayProvider> SettingsArrayProviders;
    BITFIELD bIsAListRow:1;
    //## END PROPS UIDataProvider_Settings

    DECLARE_CLASS(UUIDataProvider_Settings,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Generates filler data for a given tag. Uses the OnlineDataType to determine
	 * what the hardcoded filler data will look like
	 *
 	 * @param DataTag the tag to generate filler data for
 	 *
	 * @return a string containing example data
	 */
	virtual FString GenerateFillerData(const FString& DataTag);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Gets the list of data fields (and their localized friendly name) for the fields exposed this provider.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the name/friendly name pairs for all data fields in this provider.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

	/**
	 * Binds the new settings object to this provider. Sets the type to instance
	 *
	 * @param NewSettings the new object to bind
	 * @param bIsInList whether to use list handling or not
	 *
	 * @return TRUE if bound ok, FALSE otherwise
	 */
	UBOOL BindSettings(USettings* NewSettings,UBOOL bIsInList = FALSE);
};

struct UIResourceDataProvider_eventInitializeProvider_Parms
{
    UBOOL bIsEditor;
    UIResourceDataProvider_eventInitializeProvider_Parms(EEventParm)
    {
    }
};
class UUIResourceDataProvider : public UUIPropertyDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIResourceDataProvider
    BITFIELD bDataBindingPropertiesOnly:1;
    //## END PROPS UIResourceDataProvider

    void eventInitializeProvider(UBOOL bIsEditor)
    {
        UIResourceDataProvider_eventInitializeProvider_Parms Parms(EC_EventParm);
        Parms.bIsEditor=bIsEditor ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeProvider),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIResourceDataProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
public:
	/* === UUIResourceDataProvider interface === */
	/**
	 * Determine if the specified tag corresponds to a collection or provider collection
	 *
	 * @param	FieldTag				the name of the field to check
	 * @param	out_CollectionProperty	if valid, receives a reference to the property which corresponds to the tag specified.
	 *
	 * @return	TRUE if the specified tag is a static or dynamic array property.
	 */
	virtual UBOOL IsCollectionProperty( FName FieldTag, UProperty** out_CollectionProperty=NULL );

	/**
	 * Gets the list of properties in this class which correspond to arrays.
	 *
	 * @param	out_CollectionProperties	receives the list of array properties
	 *
	 * @return	TRUE if array properties were found.
	 */
	virtual UBOOL GetCollectionProperties( TArray<UProperty*>& out_CollectionProperties );

	/**
	 * Attempts to find a nested data provider given the parameters
	 *
	 * @param	CollectionProperty	the property that potentially holds the reference to the data provider
	 * @param	CollectionIndex		the index into the collection for the data provider to retrieve; if the value is invalid, the default
	 *								object for the property class will be used.
	 * @param	InternalProvider	receives the reference to the provider, if found.
	 *
	 * @return	TRUE if the property held a reference to a data provider (even if a NULL provider was found).
	 */
	virtual UBOOL GetNestedProvider( UProperty* CollectionProperty, INT CollectionIndex, UUIDataProvider*& InternalProvider );

	/* === UUIPropertyDataProvider interface === */
	/**
	 * Returns whether the specified property type is renderable in the UI.
	 *
	 * @param	Property				the property to check
	 * @param	bRequireNativeSupport	TRUE to require the property to be natively supported (i.e. don't check whether it's supported in script).
	 *
	 * @return	TRUE if this property type is something that can be rendered in the UI.
	 *
	 * @note: can't be const it must call into the script VM, where we can't guarantee that the object's state won't be changed.
	 */
	virtual UBOOL IsValidProperty( UProperty* Property, UBOOL bRequireNativeSupport=FALSE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters )
	{
		// we never want our elements to be sorted
		return TRUE;
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_MenuItem : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_MenuItem
    BYTE OptionType GCC_BITFIELD_MAGIC;
    BYTE EditboxAllowedChars;
    TArrayNoInit<FName> OptionSet;
    FStringNoInit DataStoreMarkup;
    FStringNoInit DescriptionMarkup;
    FName RequiredGameMode;
    FStringNoInit FriendlyName;
    FStringNoInit CustomFriendlyName;
    FStringNoInit Description;
    BITFIELD bEditableCombo:1;
    BITFIELD bNumericCombo:1;
    BITFIELD bKeyboardOrMouseOption:1;
    BITFIELD bOnlineOnly:1;
    BITFIELD bOfflineOnly:1;
    BITFIELD bSearchAllInis:1;
    BITFIELD bRemoveOn360:1;
    BITFIELD bRemoveOnPC:1;
    BITFIELD bRemoveOnPS3:1;
    INT EditBoxMaxLength;
    struct FUIRangeData RangeData;
    TArrayNoInit<FName> SchemaCellFields;
    FStringNoInit IniName;
    //## END PROPS UIDataProvider_MenuItem

    virtual UBOOL IsFiltered();
    DECLARE_FUNCTION(execIsFiltered)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFiltered();
    }
    DECLARE_CLASS(UUIDataProvider_MenuItem,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

    NO_DEFAULT_CONSTRUCTOR(UUIDataProvider_MenuItem)
};

class UUIMapSummary : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UIMapSummary
    FStringNoInit MapName;
    FStringNoInit ScreenshotPathName;
    FStringNoInit DisplayName;
    FStringNoInit Description;
    //## END PROPS UIMapSummary

    DECLARE_CLASS(UUIMapSummary,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UUIMapSummary)
};

class UUISettingsProvider : public UUIPropertyDataProvider
{
public:
    //## BEGIN PROPS UISettingsProvider
    FName ProviderTag;
    //## END PROPS UISettingsProvider

    DECLARE_ABSTRACT_CLASS(UUISettingsProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUISettingsProvider)
};

struct PlayerSettingsProvider_eventOnUnregister_Parms
{
    PlayerSettingsProvider_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct PlayerSettingsProvider_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    PlayerSettingsProvider_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UPlayerSettingsProvider : public UUISettingsProvider
{
public:
    //## BEGIN PROPS PlayerSettingsProvider
    //## END PROPS PlayerSettingsProvider

    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        PlayerSettingsProvider_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UPlayerSettingsProvider,UUISettingsProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIDataStore_PlayerSettings)
	/**
	 * Provides the data provider with the player they were just bound to
	 *
	 * @param Player the local player associated with this player settings provider
	 */
	virtual void OnRegister(ULocalPlayer* Player)
	{
		eventOnRegister(Player);
	}

	/**
	 * Tells the provider that the player is no longer valid
	 */
	virtual void OnUnregister(void)
	{
		eventOnUnregister();
	}
};

struct SessionSettingsProvider_eventIsValidDataSourceClass_Parms
{
    class UClass* PotentialDataSourceClass;
    UBOOL ReturnValue;
    SessionSettingsProvider_eventIsValidDataSourceClass_Parms(EEventParm)
    {
    }
};
struct SessionSettingsProvider_eventProviderClientUnbound_Parms
{
    class UClass* DataSourceClass;
    SessionSettingsProvider_eventProviderClientUnbound_Parms(EEventParm)
    {
    }
};
struct SessionSettingsProvider_eventProviderClientBound_Parms
{
    class UClass* DataSourceClass;
    SessionSettingsProvider_eventProviderClientBound_Parms(EEventParm)
    {
    }
};
class USessionSettingsProvider : public UUISettingsProvider
{
public:
    //## BEGIN PROPS SessionSettingsProvider
    class UClass* ProviderClientClass;
    class UClass* ProviderClientMetaClass;
    class UClass* ProviderClient;
    //## END PROPS SessionSettingsProvider

    UBOOL BindProviderClient(class UClass* DataSourceClass);
    UBOOL UnbindProviderClient();
    DECLARE_FUNCTION(execBindProviderClient)
    {
        P_GET_OBJECT(UClass,DataSourceClass);
        P_FINISH;
        *(UBOOL*)Result=BindProviderClient(DataSourceClass);
    }
    DECLARE_FUNCTION(execUnbindProviderClient)
    {
        P_FINISH;
        *(UBOOL*)Result=UnbindProviderClient();
    }
    UBOOL eventIsValidDataSourceClass(class UClass* PotentialDataSourceClass)
    {
        SessionSettingsProvider_eventIsValidDataSourceClass_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PotentialDataSourceClass=PotentialDataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidDataSourceClass),&Parms);
        return Parms.ReturnValue;
    }
    void eventProviderClientUnbound(class UClass* DataSourceClass)
    {
        SessionSettingsProvider_eventProviderClientUnbound_Parms Parms(EC_EventParm);
        Parms.DataSourceClass=DataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderClientUnbound),&Parms);
    }
    void eventProviderClientBound(class UClass* DataSourceClass)
    {
        SessionSettingsProvider_eventProviderClientBound_Parms Parms(EC_EventParm);
        Parms.DataSourceClass=DataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderClientBound),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(USessionSettingsProvider,UUISettingsProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIDataStore_SessionSettings)
	/* === UUIDynamicDataProvider interface === */
	/**
	 * Determines whether the specified class should be represented by this settings data provider.
	 *
	 * @param	PotentialDataSourceClass	a pointer to a UClass that is being considered for binding by this provider.
	 *
	 * @return	TRUE to allow the databinding properties of PotentialDataSourceClass to be displayed in the UI editor's data store browser
	 *			under this data provider.
	 */
	UBOOL IsValidDataSourceClass( UClass* PotentialDataSourceClass );

	/**
	 * Builds an array of classes that are supported by this data provider.  Used in the editor to generate the list of
	 * supported data fields.  Since settings data providers are only created during the game, the editor needs a way to
	 * retrieve the list of data field tags that can be bound without requiring instances of this data provider's DataClass to exist.
	 *
	 * @note: only called in the editor!
	 */
	void GetSupportedClasses( TArray<UClass*>& out_Classes );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct UIResourceCombinationProvider_eventGetCellFieldValue_Parms
{
    FName FieldName;
    FName CellTag;
    INT ListIndex;
    struct FUIProviderFieldValue out_FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetCellFieldValue_Parms(EEventParm)
    : out_FieldValue(EC_EventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetCellFieldType_Parms
{
    FName FieldName;
    FName CellTag;
    BYTE FieldType;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetCellFieldType_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCellTags_Parms
{
    FName FieldName;
    TArray<FName> CellFieldTags;
    TArray<FString> ColumnHeaderDisplayText;
    UIResourceCombinationProvider_eventGetElementCellTags_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCellValueProvider_Parms
{
    FName FieldName;
    INT ListIndex;
    TScriptInterface<class IUIListElementCellProvider> out_ValueProvider;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetElementCellValueProvider_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCellSchemaProvider_Parms
{
    FName FieldName;
    TScriptInterface<class IUIListElementCellProvider> out_SchemaProvider;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetElementCellSchemaProvider_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventIsElementEnabled_Parms
{
    FName FieldName;
    INT CollectionIndex;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventIsElementEnabled_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetListElements_Parms
{
    FName FieldName;
    TArray<INT> out_Elements;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetListElements_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCount_Parms
{
    FName FieldName;
    INT ReturnValue;
    UIResourceCombinationProvider_eventGetElementCount_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementProviderTags_Parms
{
    TArray<FName> ReturnValue;
    UIResourceCombinationProvider_eventGetElementProviderTags_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventInitializeProvider_Parms
{
    UBOOL bIsEditor;
    class UUIResourceDataProvider* InStaticResourceProvider;
    class UUIDataProvider_OnlineProfileSettings* InProfileProvider;
    UIResourceCombinationProvider_eventInitializeProvider_Parms(EEventParm)
    {
    }
};
class UUIResourceCombinationProvider : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIResourceCombinationProvider
    class UUIResourceDataProvider* StaticDataProvider;
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    //## END PROPS UIResourceCombinationProvider

    UBOOL eventGetCellFieldValue(FName FieldName,FName CellTag,INT ListIndex,struct FUIProviderFieldValue& out_FieldValue,INT ArrayIndex=-1)
    {
        UIResourceCombinationProvider_eventGetCellFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.CellTag=CellTag;
        Parms.ListIndex=ListIndex;
        Parms.out_FieldValue=out_FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCellFieldValue),&Parms);
        out_FieldValue=Parms.out_FieldValue;
        return Parms.ReturnValue;
    }
    UBOOL eventGetCellFieldType(FName FieldName,FName CellTag,BYTE& FieldType)
    {
        UIResourceCombinationProvider_eventGetCellFieldType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.CellTag=CellTag;
        Parms.FieldType=FieldType;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCellFieldType),&Parms);
        FieldType=Parms.FieldType;
        return Parms.ReturnValue;
    }
    void eventGetElementCellTags(FName FieldName,TArray<FName>& CellFieldTags,TArray<FString>* ColumnHeaderDisplayText=NULL)
    {
        UIResourceCombinationProvider_eventGetElementCellTags_Parms Parms(EC_EventParm);
        Parms.FieldName=FieldName;
        Parms.CellFieldTags=CellFieldTags;
        if(ColumnHeaderDisplayText){Parms.ColumnHeaderDisplayText=*ColumnHeaderDisplayText;}
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCellTags),&Parms);
        CellFieldTags=Parms.CellFieldTags;
        if ( ColumnHeaderDisplayText ) { *ColumnHeaderDisplayText=Parms.ColumnHeaderDisplayText; }
    }
    UBOOL eventGetElementCellValueProvider(FName FieldName,INT ListIndex,TScriptInterface<class IUIListElementCellProvider>& out_ValueProvider)
    {
        UIResourceCombinationProvider_eventGetElementCellValueProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.ListIndex=ListIndex;
        Parms.out_ValueProvider=out_ValueProvider;
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCellValueProvider),&Parms);
        out_ValueProvider=Parms.out_ValueProvider;
        return Parms.ReturnValue;
    }
    UBOOL eventGetElementCellSchemaProvider(FName FieldName,TScriptInterface<class IUIListElementCellProvider>& out_SchemaProvider)
    {
        UIResourceCombinationProvider_eventGetElementCellSchemaProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.out_SchemaProvider=out_SchemaProvider;
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCellSchemaProvider),&Parms);
        out_SchemaProvider=Parms.out_SchemaProvider;
        return Parms.ReturnValue;
    }
    UBOOL eventIsElementEnabled(FName FieldName,INT CollectionIndex)
    {
        UIResourceCombinationProvider_eventIsElementEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.CollectionIndex=CollectionIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsElementEnabled),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetListElements(FName FieldName,TArray<INT>& out_Elements)
    {
        UIResourceCombinationProvider_eventGetListElements_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.out_Elements=out_Elements;
        ProcessEvent(FindFunctionChecked(ENGINE_GetListElements),&Parms);
        out_Elements=Parms.out_Elements;
        return Parms.ReturnValue;
    }
    INT eventGetElementCount(FName FieldName)
    {
        UIResourceCombinationProvider_eventGetElementCount_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCount),&Parms);
        return Parms.ReturnValue;
    }
    TArray<FName> eventGetElementProviderTags()
    {
        UIResourceCombinationProvider_eventGetElementProviderTags_Parms Parms(EC_EventParm);
        Parms.ReturnValue=TArray<FName>(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementProviderTags),&Parms);
        return Parms.ReturnValue;
    }
    void eventInitializeProvider(UBOOL bIsEditor,class UUIResourceDataProvider* InStaticResourceProvider,class UUIDataProvider_OnlineProfileSettings* InProfileProvider)
    {
        UIResourceCombinationProvider_eventInitializeProvider_Parms Parms(EC_EventParm);
        Parms.bIsEditor=bIsEditor ? FIRST_BITFIELD : FALSE;
        Parms.InStaticResourceProvider=InStaticResourceProvider;
        Parms.InProfileProvider=InProfileProvider;
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeProvider),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIResourceCombinationProvider,UUIDataProvider,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters )
	{
		// we never want our elements to be sorted
		return TRUE;
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct UIScreenObject_eventActivateTrackCompletedDelegates_Parms
{
    class UUIScreenObject* Sender;
    FName AnimName;
    INT TrackTypeMask;
    UIScreenObject_eventActivateTrackCompletedDelegates_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventActivateKeyFrameCompletedDelegates_Parms
{
    class UUIScreenObject* Sender;
    FName AnimName;
    BYTE TrackType;
    UIScreenObject_eventActivateKeyFrameCompletedDelegates_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventUIAnimationEnded_Parms
{
    class UUIScreenObject* Sender;
    FName AnimName;
    INT TrackTypeMask;
    UIScreenObject_eventUIAnimationEnded_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventUIAnimationStarted_Parms
{
    class UUIScreenObject* Sender;
    FName AnimName;
    INT TrackTypeMask;
    UBOOL bSetAnimatingFlag;
    UIScreenObject_eventUIAnimationStarted_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventIsAnimating_Parms
{
    FName AnimationSequenceName;
    UBOOL ReturnValue;
    UIScreenObject_eventIsAnimating_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventClearUIAnimationLoop_Parms
{
    INT SequenceIndex;
    INT TrackTypeMask;
    UIScreenObject_eventClearUIAnimationLoop_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventStopUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeq;
    UBOOL bFinalize;
    INT TrackTypeMask;
    UIScreenObject_eventStopUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventPlayUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeqTemplate;
    BYTE OverrideLoopMode;
    FLOAT PlaybackRate;
    FLOAT InitialPosition;
    UBOOL bSetAnimatingFlag;
    UIScreenObject_eventPlayUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnUIAnim_TrackCompleted_Parms
{
    class UUIScreenObject* Sender;
    FName AnimName;
    INT TrackTypeMask;
    UIScreenObject_eventOnUIAnim_TrackCompleted_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnUIAnim_KeyFrameCompleted_Parms
{
    class UUIScreenObject* Sender;
    FName AnimName;
    BYTE TrackType;
    UIScreenObject_eventOnUIAnim_KeyFrameCompleted_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventActivateFocusHint_Parms
{
    class UUIObject* FocusHintObject;
    UBOOL ReturnValue;
    UIScreenObject_eventActivateFocusHint_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventGetSupportedUIActionKeyNames_Parms
{
    TArray<FName> out_KeyNames;
    UIScreenObject_eventGetSupportedUIActionKeyNames_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventDisablePlayerInput_Parms
{
    BYTE PlayerIndex;
    UBOOL bRecurse;
    UIScreenObject_eventDisablePlayerInput_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventEnablePlayerInput_Parms
{
    BYTE PlayerIndex;
    UBOOL bRecurse;
    UIScreenObject_eventEnablePlayerInput_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventSetVisibility_Parms
{
    UBOOL bIsVisible;
    UIScreenObject_eventSetVisibility_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventIsGamepadConnected_Parms
{
    INT ControllerId;
    UBOOL ReturnValue;
    UIScreenObject_eventIsGamepadConnected_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventIsLoggedIn_Parms
{
    INT ControllerId;
    UBOOL bRequireOnlineLogin;
    UBOOL ReturnValue;
    UIScreenObject_eventIsLoggedIn_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventRemovedFromParent_Parms
{
    class UUIScreenObject* WidgetOwner;
    UIScreenObject_eventRemovedFromParent_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventRemovedChild_Parms
{
    class UUIScreenObject* WidgetOwner;
    class UUIObject* OldChild;
    TArray<class UUIObject*> ExclusionSet;
    UIScreenObject_eventRemovedChild_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventAddedChild_Parms
{
    class UUIScreenObject* WidgetOwner;
    class UUIObject* NewChild;
    UIScreenObject_eventAddedChild_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventPostInitialize_Parms
{
    UIScreenObject_eventPostInitialize_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventInitialized_Parms
{
    UIScreenObject_eventInitialized_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnInitialSceneUpdate_Parms
{
    UIScreenObject_eventOnInitialSceneUpdate_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyVisibilityChanged_Parms
{
    class UUIScreenObject* SourceWidget;
    UBOOL bIsVisible;
    UIScreenObject_eventNotifyVisibilityChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyActiveStateChanged_Parms
{
    class UUIScreenObject* Sender;
    INT PlayerIndex;
    class UUIState* NewlyActiveState;
    class UUIState* PreviouslyActiveState;
    UIScreenObject_eventNotifyActiveStateChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyResolutionChanged_Parms
{
    FVector2D OldViewportsize;
    FVector2D NewViewportSize;
    UIScreenObject_eventNotifyResolutionChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyPositionChanged_Parms
{
    class UUIScreenObject* Sender;
    UIScreenObject_eventNotifyPositionChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnProcessInputAxis_Parms
{
    struct FSubscribedInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnProcessInputAxis_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnProcessInputKey_Parms
{
    struct FSubscribedInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnProcessInputKey_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnRawInputAxis_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnRawInputAxis_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnRawInputKey_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnRawInputKey_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyActiveSkinChanged_Parms
{
    UIScreenObject_eventNotifyActiveSkinChanged_Parms(EEventParm)
    {
    }
};
class UUIScreenObject : public UUIRoot
{
public:
    //## BEGIN PROPS UIScreenObject
    struct FUIScreenValue_Bounds Position;
private:
    FLOAT ZDepth;
    BITFIELD bHidden:1;
public:
    BITFIELD bInitialized:1;
private:
    BITFIELD bNeverFocus:1;
public:
    BITFIELD bSupportsFocusHint:1;
    BITFIELD bOverrideInputOrder:1;
    BITFIELD bAnimating:1;
protected:
    BITFIELD bAnimationPaused:1;
public:
    BITFIELD bSupports3DPrimitives:1;
    TArrayNoInit<class UUIObject*> Children;
    TArrayNoInit<class UClass*> DefaultStates;
    class UClass* InitialState;
    TArrayNoInit<class UUIState*> InactiveStates;
    TArrayNoInit<class UUIState*> StateStack;
    TArrayNoInit<struct FPlayerInteractionData> FocusControls;
    TArrayNoInit<struct FUIFocusPropagationData> FocusPropagation;
    TArrayNoInit<struct FUIAnimSequence> AnimStack;
    INT AnimationCount;
    FLOAT AnimationDebugMultiplier;
    FLOAT Opacity;
    class UUIComp_Event* EventProvider;
    FName FocusedCue;
    FName MouseEnterCue;
    FName NavigateUpCue;
    FName NavigateDownCue;
    FName NavigateLeftCue;
    FName NavigateRightCue;
    TArrayNoInit<FScriptDelegate> KeyFrameCompletedDelegates;
    TArrayNoInit<FScriptDelegate> TrackCompletedDelegates;
    FScriptDelegate __NotifyActiveSkinChanged__Delegate;
    FScriptDelegate __OnRawInputKey__Delegate;
    FScriptDelegate __OnRawInputAxis__Delegate;
    FScriptDelegate __OnProcessInputKey__Delegate;
    FScriptDelegate __OnProcessInputAxis__Delegate;
    FScriptDelegate __NotifyPositionChanged__Delegate;
    FScriptDelegate __NotifyResolutionChanged__Delegate;
    FScriptDelegate __NotifyActiveStateChanged__Delegate;
    FScriptDelegate __NotifyVisibilityChanged__Delegate;
    FScriptDelegate __OnInitialSceneUpdate__Delegate;
    FScriptDelegate __OnUIAnim_KeyFrameCompleted__Delegate;
    FScriptDelegate __OnUIAnim_TrackCompleted__Delegate;
    //## END PROPS UIScreenObject

    void SetZDepth(FLOAT NewZDepth,UBOOL bPropagateToChildren=FALSE);
    virtual void CreatePlayerData(INT PlayerIndex,class ULocalPlayer* AddedPlayer);
    virtual void RemovePlayerData(INT PlayerIndex,class ULocalPlayer* RemovedPlayer);
    virtual void InitializePlayerTracking();
    class ULocalPlayer* GetPlayerOwner(INT PlayerIndex=-1);
    class UUIObject* CreateWidget(class UUIScreenObject* Owner,class UClass* WidgetClass,class UObject* WidgetArchetype=NULL,FName WidgetName=NAME_None);
    class UUIPrefabInstance* InstanceUIPrefab(class UUIPrefab* SourcePrefab,FName PrefabInstanceName=NAME_None,const FVector2D* PlacementLocation=NULL,INT InsertIndex=-1,UBOOL bRenameExisting=TRUE);
    virtual void Initialize(class UUIScene* inOwnerScene,class UUIObject* InOwner=NULL);
    virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=-1,UBOOL bRenameExisting=TRUE);
    TArray<class UUIObject*> RemoveChildren(const TArray<class UUIObject*>& ChildrenToRemove);
    UBOOL ReparentChild(class UUIObject* CurrentChild,class UUIScreenObject* NewParent,INT InsertIndex=-1);
    UBOOL ReparentChildren(const TArray<class UUIObject*>& ChildrenToReparent,class UUIScreenObject* NewParent,INT InsertIndex=-1);
    UBOOL ReplaceChild(class UUIObject* ExistingChild,class UUIObject* NewChild);
    class UUIObject* FindChild(FName WidgetName,UBOOL bRecurse=FALSE) const;
    class UUIObject* FindChildUsingID(struct FWIDGET_ID WidgetID,UBOOL bRecurse=FALSE) const;
    INT FindChildIndex(FName WidgetName) const;
    UBOOL ContainsChild(class UUIObject* Child,UBOOL bRecurse=TRUE) const;
    UBOOL ContainsChildOfClass(class UClass* SearchClass,UBOOL bRecurse=TRUE) const;
    INT GetObjectCount() const;
    virtual UBOOL RebuildNavigationLinks();
    UBOOL GetViewportOffset(FVector2D& out_ViewportOffset) const;
    FLOAT GetViewportScale() const;
    UBOOL GetViewportOrigin(FVector2D& out_ViewportOrigin) const;
    UBOOL GetViewportSize(FVector2D& out_ViewportSize) const;
    FLOAT GetViewportWidth() const;
    FLOAT GetViewportHeight() const;
    FLOAT GetAspectRatio() const;
    void FindEventsOfClass(class UClass* EventClassToFind,TArray<class UUIEvent*>& out_EventInstances,class UUIState* LimitScope=NULL,UBOOL bExactClass=FALSE);
    virtual UBOOL SetEnabled(UBOOL bEnabled,INT PlayerIndex=0);
    class UUIState* GetCurrentState(INT PlayerIndex=-1);
    virtual UBOOL ActivateState(class UUIState* StateToActivate,INT PlayerIndex);
    virtual UBOOL DeactivateState(class UUIState* StateToRemove,INT PlayerIndex);
    virtual UBOOL ConditionalPropagateEnabledState(INT PlayerIndex,UBOOL bForce=FALSE);
    virtual UBOOL IsHoldingCtrl(INT ControllerId);
    virtual UBOOL IsHoldingAlt(INT ControllerId);
    virtual UBOOL IsHoldingShift(INT ControllerId);
    virtual UBOOL FocusFirstControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL FocusLastControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL NextControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL PrevControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL NavigateFocus(class UUIScreenObject* Sender,BYTE Direction,INT PlayerIndex=0,BYTE* bFocusChanged=NULL);
    UBOOL IsNeverFocused() const;
    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    UBOOL CanPropagateFocusFor(class UUIObject* TestChild) const;
    virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL SetFocusToChild(class UUIObject* ChildToFocus=NULL,INT PlayerIndex=0);
    virtual UBOOL KillFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);
    class UUIObject* GetFocusedControl(UBOOL bRecurse=FALSE,INT PlayerIndex=0) const;
    class UUIObject* GetLastFocusedControl(UBOOL bRecurse=FALSE,INT PlayerIndex=0) const;
    void OverrideLastFocusedControl(INT PlayerIndex,class UUIObject* ChildToFocus);
    UBOOL AcceptsPlayerInput(INT PlayerIndex) const;
    INT GetSupportedPlayerCount();
    INT GetBestPlayerIndex() const;
    INT GetBestControllerId() const;
    INT GetPlayerOwnerIndex(UBOOL bRequireValidIndex=TRUE) const;
    void SetPosition(FLOAT NewValue,BYTE Face,BYTE InputType=3,UBOOL bIncludesViewportOrigin=FALSE,UBOOL bResolveChange=TRUE);
    FLOAT GetPosition(BYTE Face,BYTE OutputType=0,UBOOL bIncludeOrigin=FALSE,UBOOL bIgnoreDockPadding=FALSE) const;
    FLOAT GetBounds(BYTE Dimension,BYTE OutputType=0,UBOOL bIgnoreDockPadding=FALSE) const;
    FVector GetPositionVector(UBOOL bIncludeParentPosition=TRUE) const;
    FLOAT ResolveUIExtent(const struct FUIScreenValue_Extent& ExtentToResolve,class UUIScreenObject* OwnerWidget,BYTE OutputType=0) const;
    void GetDockedWidgets(TArray<class UUIObject*>& out_DockedWidgets,BYTE SourceFace=4,BYTE TargetFace=4) const;
    FVector Project(const FVector& CanvasPosition) const;
    FVector DeProject(const FVector& PixelPosition) const;
    FVector4 CanvasToScreen(const FVector& CanvasPosition) const;
    FVector2D ScreenToPixel(const FVector4& ScreenPosition) const;
    FVector4 PixelToScreen(const FVector2D& PixelPosition) const;
    FVector ScreenToCanvas(const FVector4& ScreenPosition) const;
    FVector PixelToCanvas(const FVector2D& PixelPosition) const;
    FMatrix GetCanvasToScreen() const;
    FMatrix GetInverseCanvasToScreen() const;
    FLOAT GetAspectRatioAutoScaleFactor(class UFont* BaseFont=NULL) const;
    virtual UBOOL Anim_GetValue(BYTE AnimationType,struct FUIAnimationRawData& out_CurrentValue) const;
    virtual UBOOL Anim_SetValue(BYTE AnimationType,const struct FUIAnimationRawData& NewValue);
    virtual void TickAnimations(FLOAT DeltaTime);
    INT FindAnimationSequenceIndex(FName SequenceName) const;
    virtual void PlayUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeqTemplate=NULL,BYTE OverrideLoopMode=3,FLOAT PlaybackRate=1.000000,FLOAT InitialPosition=0.000000,UBOOL bSetAnimatingFlag=TRUE);
    virtual void StopUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeq=NULL,UBOOL bFinalize=TRUE,INT TrackTypeMask=0);
    virtual void ClearUIAnimationLoop(INT SequenceIndex,INT TrackTypeMask=0);
    virtual UBOOL IsAnimating(FName AnimationSequenceName=NAME_None);
    void PauseAnimations(UBOOL bPauseAnimation);
    UBOOL IsAnimationPaused() const;
    DECLARE_FUNCTION(execIsInitialized);
    DECLARE_FUNCTION(execIsVisible)
    {
        P_GET_UBOOL_OPTX(bIncludeParents,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsVisible(bIncludeParents);
    }
    DECLARE_FUNCTION(execIsHidden)
    {
        P_GET_UBOOL_OPTX(bIncludeParents,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsHidden(bIncludeParents);
    }
    DECLARE_FUNCTION(execGetZDepth)
    {
        P_FINISH;
        *(FLOAT*)Result=GetZDepth();
    }
    DECLARE_FUNCTION(execSetZDepth)
    {
        P_GET_FLOAT(NewZDepth);
        P_GET_UBOOL_OPTX(bPropagateToChildren,FALSE);
        P_FINISH;
        SetZDepth(NewZDepth,bPropagateToChildren);
    }
    DECLARE_FUNCTION(execCreatePlayerData)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(ULocalPlayer,AddedPlayer);
        P_FINISH;
        CreatePlayerData(PlayerIndex,AddedPlayer);
    }
    DECLARE_FUNCTION(execRemovePlayerData)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(ULocalPlayer,RemovedPlayer);
        P_FINISH;
        RemovePlayerData(PlayerIndex,RemovedPlayer);
    }
    DECLARE_FUNCTION(execInitializePlayerTracking)
    {
        P_FINISH;
        InitializePlayerTracking();
    }
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner(PlayerIndex);
    }
    DECLARE_FUNCTION(execPlayUISound);
    DECLARE_FUNCTION(execCreateWidget)
    {
        P_GET_OBJECT(UUIScreenObject,Owner);
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_OBJECT_OPTX(UObject,WidgetArchetype,NULL);
        P_GET_NAME_OPTX(WidgetName,NAME_None);
        P_FINISH;
        *(class UUIObject**)Result=CreateWidget(Owner,WidgetClass,WidgetArchetype,WidgetName);
    }
    DECLARE_FUNCTION(execInstanceUIPrefab)
    {
        P_GET_OBJECT(UUIPrefab,SourcePrefab);
        P_GET_NAME_OPTX(PrefabInstanceName,NAME_None);
        P_GET_STRUCT_OPTX_REF(FVector2D,PlacementLocation,FVector2D(EC_EventParm));
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bRenameExisting,TRUE);
        P_FINISH;
        *(class UUIPrefabInstance**)Result=InstanceUIPrefab(SourcePrefab,PrefabInstanceName,pPlacementLocation ? &PlacementLocation : NULL,InsertIndex,bRenameExisting);
    }
    DECLARE_FUNCTION(execInitialize)
    {
        P_GET_OBJECT(UUIScene,inOwnerScene);
        P_GET_OBJECT_OPTX(UUIObject,InOwner,NULL);
        P_FINISH;
        Initialize(inOwnerScene,InOwner);
    }
    DECLARE_FUNCTION(execInsertChild)
    {
        P_GET_OBJECT(UUIObject,NewChild);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bRenameExisting,TRUE);
        P_FINISH;
        *(INT*)Result=InsertChild(NewChild,InsertIndex,bRenameExisting);
    }
    DECLARE_FUNCTION(execRemoveChild);
    DECLARE_FUNCTION(execRemoveChildren)
    {
        P_GET_TARRAY(class UUIObject*,ChildrenToRemove);
        P_FINISH;
        *(TArray<class UUIObject*>*)Result=RemoveChildren(ChildrenToRemove);
    }
    DECLARE_FUNCTION(execReparentChild)
    {
        P_GET_OBJECT(UUIObject,CurrentChild);
        P_GET_OBJECT(UUIScreenObject,NewParent);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=ReparentChild(CurrentChild,NewParent,InsertIndex);
    }
    DECLARE_FUNCTION(execReparentChildren)
    {
        P_GET_TARRAY(class UUIObject*,ChildrenToReparent);
        P_GET_OBJECT(UUIScreenObject,NewParent);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=ReparentChildren(ChildrenToReparent,NewParent,InsertIndex);
    }
    DECLARE_FUNCTION(execReplaceChild)
    {
        P_GET_OBJECT(UUIObject,ExistingChild);
        P_GET_OBJECT(UUIObject,NewChild);
        P_FINISH;
        *(UBOOL*)Result=ReplaceChild(ExistingChild,NewChild);
    }
    DECLARE_FUNCTION(execFindChild)
    {
        P_GET_NAME(WidgetName);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        *(class UUIObject**)Result=FindChild(WidgetName,bRecurse);
    }
    DECLARE_FUNCTION(execFindChildUsingID)
    {
        P_GET_STRUCT(struct FWIDGET_ID,WidgetID);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        *(class UUIObject**)Result=FindChildUsingID(WidgetID,bRecurse);
    }
    DECLARE_FUNCTION(execFindChildIndex)
    {
        P_GET_NAME(WidgetName);
        P_FINISH;
        *(INT*)Result=FindChildIndex(WidgetName);
    }
    DECLARE_FUNCTION(execContainsChild)
    {
        P_GET_OBJECT(UUIObject,Child);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ContainsChild(Child,bRecurse);
    }
    DECLARE_FUNCTION(execContainsChildOfClass)
    {
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ContainsChildOfClass(SearchClass,bRecurse);
    }
    DECLARE_FUNCTION(execGetChildren);
    DECLARE_FUNCTION(execGetObjectCount)
    {
        P_FINISH;
        *(INT*)Result=GetObjectCount();
    }
    DECLARE_FUNCTION(execGetDockClients);
    DECLARE_FUNCTION(execRequestSceneUpdate);
    DECLARE_FUNCTION(execRequestFormattingUpdate);
    DECLARE_FUNCTION(execRequestSceneInputMaskUpdate)
    {
        P_FINISH;
        RequestSceneInputMaskUpdate();
    }
    DECLARE_FUNCTION(execRequestPrimitiveReview);
    DECLARE_FUNCTION(execRebuildNavigationLinks)
    {
        P_FINISH;
        *(UBOOL*)Result=RebuildNavigationLinks();
    }
    DECLARE_FUNCTION(execGetViewportOffset)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportOffset);
        P_FINISH;
        *(UBOOL*)Result=GetViewportOffset(out_ViewportOffset);
    }
    DECLARE_FUNCTION(execGetViewportScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetViewportScale();
    }
    DECLARE_FUNCTION(execGetViewportOrigin)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportOrigin);
        P_FINISH;
        *(UBOOL*)Result=GetViewportOrigin(out_ViewportOrigin);
    }
    DECLARE_FUNCTION(execGetViewportSize)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportSize);
        P_FINISH;
        *(UBOOL*)Result=GetViewportSize(out_ViewportSize);
    }
    DECLARE_FUNCTION(execGetViewportWidth)
    {
        P_FINISH;
        *(FLOAT*)Result=GetViewportWidth();
    }
    DECLARE_FUNCTION(execGetViewportHeight)
    {
        P_FINISH;
        *(FLOAT*)Result=GetViewportHeight();
    }
    DECLARE_FUNCTION(execGetAspectRatio)
    {
        P_FINISH;
        *(FLOAT*)Result=GetAspectRatio();
    }
    DECLARE_FUNCTION(execActivateEventByClass);
    DECLARE_FUNCTION(execFindEventsOfClass)
    {
        P_GET_OBJECT(UClass,EventClassToFind);
        P_GET_TARRAY_REF(class UUIEvent*,out_EventInstances);
        P_GET_OBJECT_OPTX(UUIState,LimitScope,NULL);
        P_GET_UBOOL_OPTX(bExactClass,FALSE);
        P_FINISH;
        FindEventsOfClass(EventClassToFind,out_EventInstances,LimitScope,bExactClass);
    }
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bEnabled);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetEnabled(bEnabled,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetCurrentState)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class UUIState**)Result=GetCurrentState(PlayerIndex);
    }
    DECLARE_FUNCTION(execHasActiveStateOfClass);
    DECLARE_FUNCTION(execActivateState)
    {
        P_GET_OBJECT(UUIState,StateToActivate);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=ActivateState(StateToActivate,PlayerIndex);
    }
    DECLARE_FUNCTION(execActivateStateByClass);
    DECLARE_FUNCTION(execDeactivateState)
    {
        P_GET_OBJECT(UUIState,StateToRemove);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=DeactivateState(StateToRemove,PlayerIndex);
    }
    DECLARE_FUNCTION(execDeactivateStateByClass);
    DECLARE_FUNCTION(execConditionalPropagateEnabledState)
    {
        P_GET_INT(PlayerIndex);
        P_GET_UBOOL_OPTX(bForce,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ConditionalPropagateEnabledState(PlayerIndex,bForce);
    }
    DECLARE_FUNCTION(execIsHoldingCtrl)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingCtrl(ControllerId);
    }
    DECLARE_FUNCTION(execIsHoldingAlt)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingAlt(ControllerId);
    }
    DECLARE_FUNCTION(execIsHoldingShift)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingShift(ControllerId);
    }
    DECLARE_FUNCTION(execFocusFirstControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=FocusFirstControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execFocusLastControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=FocusLastControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execNextControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=NextControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execPrevControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=PrevControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execNavigateFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_BYTE(Direction);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_GET_BYTE_OPTX_REF(bFocusChanged,0);
        P_FINISH;
        *(UBOOL*)Result=NavigateFocus(Sender,Direction,PlayerIndex,pbFocusChanged ? &bFocusChanged : NULL);
    }
    DECLARE_FUNCTION(execIsNeverFocused)
    {
        P_FINISH;
        *(UBOOL*)Result=IsNeverFocused();
    }
    DECLARE_FUNCTION(execCanAcceptFocus)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=CanAcceptFocus(PlayerIndex);
    }
    DECLARE_FUNCTION(execCanPropagateFocusFor)
    {
        P_GET_OBJECT(UUIObject,TestChild);
        P_FINISH;
        *(UBOOL*)Result=CanPropagateFocusFor(TestChild);
    }
    DECLARE_FUNCTION(execSetFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetFocus(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execSetFocusToChild)
    {
        P_GET_OBJECT_OPTX(UUIObject,ChildToFocus,NULL);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetFocusToChild(ChildToFocus,PlayerIndex);
    }
    DECLARE_FUNCTION(execKillFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=KillFocus(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetFocusedControl)
    {
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(class UUIObject**)Result=GetFocusedControl(bRecurse,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetLastFocusedControl)
    {
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(class UUIObject**)Result=GetLastFocusedControl(bRecurse,PlayerIndex);
    }
    DECLARE_FUNCTION(execOverrideLastFocusedControl)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(UUIObject,ChildToFocus);
        P_FINISH;
        OverrideLastFocusedControl(PlayerIndex,ChildToFocus);
    }
    DECLARE_FUNCTION(execIsEnabled);
    DECLARE_FUNCTION(execIsDisabled);
    DECLARE_FUNCTION(execIsFocused);
    DECLARE_FUNCTION(execIsActive);
    DECLARE_FUNCTION(execIsPressed);
    DECLARE_FUNCTION(execIsRuntimeInstance)
    {
        P_FINISH;
        *(UBOOL*)Result=IsRuntimeInstance();
    }
    DECLARE_FUNCTION(execAcceptsPlayerInput)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=AcceptsPlayerInput(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetInputMask)
    {
        P_GET_UBOOL_OPTX(bInheritedMaskOnly,FALSE);
        P_GET_UBOOL_OPTX(bOverrideMaskOnly,FALSE);
        P_FINISH;
        *(BYTE*)Result=GetInputMask(bInheritedMaskOnly,bOverrideMaskOnly);
    }
    DECLARE_FUNCTION(execSetInputMask)
    {
        P_GET_BYTE(NewInputMask);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_GET_UBOOL_OPTX(bForcedOverride,FALSE);
        P_FINISH;
        SetInputMask(NewInputMask,bRecurse,bForcedOverride);
    }
    DECLARE_FUNCTION(execGetActivePlayerCount);
    DECLARE_FUNCTION(execGetSupportedPlayerCount)
    {
        P_FINISH;
        *(INT*)Result=GetSupportedPlayerCount();
    }
    DECLARE_FUNCTION(execGetBestPlayerIndex)
    {
        P_FINISH;
        *(INT*)Result=GetBestPlayerIndex();
    }
    DECLARE_FUNCTION(execGetBestControllerId)
    {
        P_FINISH;
        *(INT*)Result=GetBestControllerId();
    }
    DECLARE_FUNCTION(execGetPlayerOwnerIndex)
    {
        P_GET_UBOOL_OPTX(bRequireValidIndex,TRUE);
        P_FINISH;
        *(INT*)Result=GetPlayerOwnerIndex(bRequireValidIndex);
    }
    DECLARE_FUNCTION(execInvalidatePosition)
    {
        P_GET_BYTE(Face);
        P_FINISH;
        InvalidatePosition(Face);
    }
    DECLARE_FUNCTION(execInvalidateAllPositions)
    {
        P_GET_UBOOL_OPTX(bIgnoreDockedFaces,TRUE);
        P_FINISH;
        InvalidateAllPositions(bIgnoreDockedFaces);
    }
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewValue);
        P_GET_BYTE(Face);
        P_GET_BYTE_OPTX(InputType,3);
        P_GET_UBOOL_OPTX(bIncludesViewportOrigin,FALSE);
        P_GET_UBOOL_OPTX(bResolveChange,TRUE);
        P_FINISH;
        SetPosition(NewValue,Face,InputType,bIncludesViewportOrigin,bResolveChange);
    }
    DECLARE_FUNCTION(execGetPosition)
    {
        P_GET_BYTE(Face);
        P_GET_BYTE_OPTX(OutputType,0);
        P_GET_UBOOL_OPTX(bIncludeOrigin,FALSE);
        P_GET_UBOOL_OPTX(bIgnoreDockPadding,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetPosition(Face,OutputType,bIncludeOrigin,bIgnoreDockPadding);
    }
    DECLARE_FUNCTION(execGetBounds)
    {
        P_GET_BYTE(Dimension);
        P_GET_BYTE_OPTX(OutputType,0);
        P_GET_UBOOL_OPTX(bIgnoreDockPadding,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetBounds(Dimension,OutputType,bIgnoreDockPadding);
    }
    DECLARE_FUNCTION(execGetPositionVector)
    {
        P_GET_UBOOL_OPTX(bIncludeParentPosition,TRUE);
        P_FINISH;
        *(FVector*)Result=GetPositionVector(bIncludeParentPosition);
    }
    DECLARE_FUNCTION(execResolveUIExtent)
    {
        P_GET_STRUCT_REF(struct FUIScreenValue_Extent,ExtentToResolve);
        P_GET_OBJECT(UUIScreenObject,OwnerWidget);
        P_GET_BYTE_OPTX(OutputType,0);
        P_FINISH;
        *(FLOAT*)Result=ResolveUIExtent(ExtentToResolve,OwnerWidget,OutputType);
    }
    DECLARE_FUNCTION(execGetDockedWidgets)
    {
        P_GET_TARRAY_REF(class UUIObject*,out_DockedWidgets);
        P_GET_BYTE_OPTX(SourceFace,4);
        P_GET_BYTE_OPTX(TargetFace,4);
        P_FINISH;
        GetDockedWidgets(out_DockedWidgets,SourceFace,TargetFace);
    }
    DECLARE_FUNCTION(execProject)
    {
        P_GET_STRUCT_REF(FVector,CanvasPosition);
        P_FINISH;
        *(FVector*)Result=Project(CanvasPosition);
    }
    DECLARE_FUNCTION(execDeProject)
    {
        P_GET_STRUCT_REF(FVector,PixelPosition);
        P_FINISH;
        *(FVector*)Result=DeProject(PixelPosition);
    }
    DECLARE_FUNCTION(execCanvasToScreen)
    {
        P_GET_STRUCT_REF(FVector,CanvasPosition);
        P_FINISH;
        *(FVector4*)Result=CanvasToScreen(CanvasPosition);
    }
    DECLARE_FUNCTION(execScreenToPixel)
    {
        P_GET_STRUCT_REF(FVector4,ScreenPosition);
        P_FINISH;
        *(FVector2D*)Result=ScreenToPixel(ScreenPosition);
    }
    DECLARE_FUNCTION(execPixelToScreen)
    {
        P_GET_STRUCT_REF(FVector2D,PixelPosition);
        P_FINISH;
        *(FVector4*)Result=PixelToScreen(PixelPosition);
    }
    DECLARE_FUNCTION(execScreenToCanvas)
    {
        P_GET_STRUCT_REF(FVector4,ScreenPosition);
        P_FINISH;
        *(FVector*)Result=ScreenToCanvas(ScreenPosition);
    }
    DECLARE_FUNCTION(execPixelToCanvas)
    {
        P_GET_STRUCT_REF(FVector2D,PixelPosition);
        P_FINISH;
        *(FVector*)Result=PixelToCanvas(PixelPosition);
    }
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=GetCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=GetInverseCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetAspectRatioAutoScaleFactor)
    {
        P_GET_OBJECT_OPTX(UFont,BaseFont,NULL);
        P_FINISH;
        *(FLOAT*)Result=GetAspectRatioAutoScaleFactor(BaseFont);
    }
    DECLARE_FUNCTION(execGetWidgetPathName);
    DECLARE_FUNCTION(execAnim_GetValue)
    {
        P_GET_BYTE(AnimationType);
        P_GET_STRUCT_REF(struct FUIAnimationRawData,out_CurrentValue);
        P_FINISH;
        *(UBOOL*)Result=Anim_GetValue(AnimationType,out_CurrentValue);
    }
    DECLARE_FUNCTION(execAnim_SetValue)
    {
        P_GET_BYTE(AnimationType);
        P_GET_STRUCT_REF(struct FUIAnimationRawData,NewValue);
        P_FINISH;
        *(UBOOL*)Result=Anim_SetValue(AnimationType,NewValue);
    }
    DECLARE_FUNCTION(execAnimGetCurrentPPSettings);
    DECLARE_FUNCTION(execTickAnimations)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        TickAnimations(DeltaTime);
    }
    DECLARE_FUNCTION(execFindAnimationSequenceIndex)
    {
        P_GET_NAME(SequenceName);
        P_FINISH;
        *(INT*)Result=FindAnimationSequenceIndex(SequenceName);
    }
    DECLARE_FUNCTION(execPlayUIAnimation)
    {
        P_GET_NAME(AnimName);
        P_GET_OBJECT_OPTX(UUIAnimationSeq,AnimSeqTemplate,NULL);
        P_GET_BYTE_OPTX(OverrideLoopMode,3);
        P_GET_FLOAT_OPTX(PlaybackRate,1.000000);
        P_GET_FLOAT_OPTX(InitialPosition,0.000000);
        P_GET_UBOOL_OPTX(bSetAnimatingFlag,TRUE);
        P_FINISH;
        PlayUIAnimation(AnimName,AnimSeqTemplate,OverrideLoopMode,PlaybackRate,InitialPosition,bSetAnimatingFlag);
    }
    DECLARE_FUNCTION(execStopUIAnimation)
    {
        P_GET_NAME(AnimName);
        P_GET_OBJECT_OPTX(UUIAnimationSeq,AnimSeq,NULL);
        P_GET_UBOOL_OPTX(bFinalize,TRUE);
        P_GET_INT_OPTX(TrackTypeMask,0);
        P_FINISH;
        StopUIAnimation(AnimName,AnimSeq,bFinalize,TrackTypeMask);
    }
    DECLARE_FUNCTION(execClearUIAnimationLoop)
    {
        P_GET_INT(SequenceIndex);
        P_GET_INT_OPTX(TrackTypeMask,0);
        P_FINISH;
        ClearUIAnimationLoop(SequenceIndex,TrackTypeMask);
    }
    DECLARE_FUNCTION(execIsAnimating)
    {
        P_GET_NAME_OPTX(AnimationSequenceName,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=IsAnimating(AnimationSequenceName);
    }
    DECLARE_FUNCTION(execPauseAnimations)
    {
        P_GET_UBOOL(bPauseAnimation);
        P_FINISH;
        PauseAnimations(bPauseAnimation);
    }
    DECLARE_FUNCTION(execIsAnimationPaused)
    {
        P_FINISH;
        *(UBOOL*)Result=IsAnimationPaused();
    }
    void eventActivateTrackCompletedDelegates(class UUIScreenObject* Sender,FName AnimName,INT TrackTypeMask)
    {
        UIScreenObject_eventActivateTrackCompletedDelegates_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.AnimName=AnimName;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateTrackCompletedDelegates),&Parms);
    }
    void eventActivateKeyFrameCompletedDelegates(class UUIScreenObject* Sender,FName AnimName,BYTE TrackType)
    {
        UIScreenObject_eventActivateKeyFrameCompletedDelegates_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.AnimName=AnimName;
        Parms.TrackType=TrackType;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateKeyFrameCompletedDelegates),&Parms);
    }
    void eventUIAnimationEnded(class UUIScreenObject* Sender,FName AnimName,INT TrackTypeMask)
    {
        UIScreenObject_eventUIAnimationEnded_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.AnimName=AnimName;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessEvent(FindFunctionChecked(ENGINE_UIAnimationEnded),&Parms);
    }
    void eventUIAnimationStarted(class UUIScreenObject* Sender,FName AnimName,INT TrackTypeMask,UBOOL bSetAnimatingFlag=TRUE)
    {
        UIScreenObject_eventUIAnimationStarted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.AnimName=AnimName;
        Parms.TrackTypeMask=TrackTypeMask;
        Parms.bSetAnimatingFlag=bSetAnimatingFlag ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_UIAnimationStarted),&Parms);
    }
    UBOOL eventIsAnimating(FName AnimationSequenceName=NAME_None)
    {
        UIScreenObject_eventIsAnimating_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimationSequenceName=AnimationSequenceName;
        ProcessEvent(FindFunctionChecked(ENGINE_IsAnimating),&Parms);
        return Parms.ReturnValue;
    }
    void eventClearUIAnimationLoop(INT SequenceIndex,INT TrackTypeMask=0)
    {
        UIScreenObject_eventClearUIAnimationLoop_Parms Parms(EC_EventParm);
        Parms.SequenceIndex=SequenceIndex;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessEvent(FindFunctionChecked(ENGINE_ClearUIAnimationLoop),&Parms);
    }
    void eventStopUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeq=NULL,UBOOL bFinalize=TRUE,INT TrackTypeMask=0)
    {
        UIScreenObject_eventStopUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeq=AnimSeq;
        Parms.bFinalize=bFinalize ? FIRST_BITFIELD : FALSE;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessEvent(FindFunctionChecked(ENGINE_StopUIAnimation),&Parms);
    }
    void eventPlayUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeqTemplate=NULL,BYTE OverrideLoopMode=3,FLOAT PlaybackRate=1.000000,FLOAT InitialPosition=0.000000,UBOOL bSetAnimatingFlag=TRUE)
    {
        UIScreenObject_eventPlayUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeqTemplate=AnimSeqTemplate;
        Parms.OverrideLoopMode=OverrideLoopMode;
        Parms.PlaybackRate=PlaybackRate;
        Parms.InitialPosition=InitialPosition;
        Parms.bSetAnimatingFlag=bSetAnimatingFlag ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayUIAnimation),&Parms);
    }
    void delegateOnUIAnim_TrackCompleted(class UUIScreenObject* Sender,FName AnimName,INT TrackTypeMask)
    {
        UIScreenObject_eventOnUIAnim_TrackCompleted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.AnimName=AnimName;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessDelegate(ENGINE_OnUIAnim_TrackCompleted,&__OnUIAnim_TrackCompleted__Delegate,&Parms);
    }
    void delegateOnUIAnim_KeyFrameCompleted(class UUIScreenObject* Sender,FName AnimName,BYTE TrackType)
    {
        UIScreenObject_eventOnUIAnim_KeyFrameCompleted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.AnimName=AnimName;
        Parms.TrackType=TrackType;
        ProcessDelegate(ENGINE_OnUIAnim_KeyFrameCompleted,&__OnUIAnim_KeyFrameCompleted__Delegate,&Parms);
    }
    UBOOL eventActivateFocusHint(class UUIObject* FocusHintObject)
    {
        UIScreenObject_eventActivateFocusHint_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FocusHintObject=FocusHintObject;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateFocusHint),&Parms);
        return Parms.ReturnValue;
    }
    void eventGetSupportedUIActionKeyNames(TArray<FName>& out_KeyNames)
    {
        UIScreenObject_eventGetSupportedUIActionKeyNames_Parms Parms(EC_EventParm);
        Parms.out_KeyNames=out_KeyNames;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSupportedUIActionKeyNames),&Parms);
        out_KeyNames=Parms.out_KeyNames;
    }
    void eventDisablePlayerInput(BYTE PlayerIndex,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventDisablePlayerInput_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_DisablePlayerInput),&Parms);
    }
    void eventEnablePlayerInput(BYTE PlayerIndex,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventEnablePlayerInput_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnablePlayerInput),&Parms);
    }
    void eventSetVisibility(UBOOL bIsVisible)
    {
        UIScreenObject_eventSetVisibility_Parms Parms(EC_EventParm);
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetVisibility),&Parms);
    }
    UBOOL eventIsGamepadConnected(INT ControllerId=255)
    {
        UIScreenObject_eventIsGamepadConnected_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_IsGamepadConnected),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsLoggedIn(INT ControllerId=255,UBOOL bRequireOnlineLogin=FALSE)
    {
        UIScreenObject_eventIsLoggedIn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.bRequireOnlineLogin=bRequireOnlineLogin ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsLoggedIn),&Parms);
        return Parms.ReturnValue;
    }
    void eventRemovedFromParent(class UUIScreenObject* WidgetOwner)
    {
        UIScreenObject_eventRemovedFromParent_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovedFromParent),&Parms);
    }
    void eventRemovedChild(class UUIScreenObject* WidgetOwner,class UUIObject* OldChild,const TArray<class UUIObject*>& ExclusionSet=TArray<class UUIObject*>(EC_EventParm))
    {
        UIScreenObject_eventRemovedChild_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        Parms.OldChild=OldChild;
        Parms.ExclusionSet=ExclusionSet;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovedChild),&Parms);
    }
    void eventAddedChild(class UUIScreenObject* WidgetOwner,class UUIObject* NewChild)
    {
        UIScreenObject_eventAddedChild_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        Parms.NewChild=NewChild;
        ProcessEvent(FindFunctionChecked(ENGINE_AddedChild),&Parms);
    }
    void eventPostInitialize()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostInitialize),NULL);
    }
    void eventInitialized()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Initialized),NULL);
    }
    void delegateOnInitialSceneUpdate()
    {
        ProcessDelegate(ENGINE_OnInitialSceneUpdate,&__OnInitialSceneUpdate__Delegate,NULL);
    }
    void delegateNotifyVisibilityChanged(class UUIScreenObject* SourceWidget,UBOOL bIsVisible)
    {
        UIScreenObject_eventNotifyVisibilityChanged_Parms Parms(EC_EventParm);
        Parms.SourceWidget=SourceWidget;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_NotifyVisibilityChanged,&__NotifyVisibilityChanged__Delegate,&Parms);
    }
    void delegateNotifyActiveStateChanged(class UUIScreenObject* Sender,INT PlayerIndex,class UUIState* NewlyActiveState,class UUIState* PreviouslyActiveState=NULL)
    {
        UIScreenObject_eventNotifyActiveStateChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        Parms.NewlyActiveState=NewlyActiveState;
        Parms.PreviouslyActiveState=PreviouslyActiveState;
        ProcessDelegate(ENGINE_NotifyActiveStateChanged,&__NotifyActiveStateChanged__Delegate,&Parms);
    }
    void delegateNotifyResolutionChanged(const FVector2D& OldViewportsize,const FVector2D& NewViewportSize)
    {
        UIScreenObject_eventNotifyResolutionChanged_Parms Parms(EC_EventParm);
        Parms.OldViewportsize=OldViewportsize;
        Parms.NewViewportSize=NewViewportSize;
        ProcessDelegate(ENGINE_NotifyResolutionChanged,&__NotifyResolutionChanged__Delegate,&Parms);
    }
    void delegateNotifyPositionChanged(class UUIScreenObject* Sender)
    {
        UIScreenObject_eventNotifyPositionChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_NotifyPositionChanged,&__NotifyPositionChanged__Delegate,&Parms);
    }
    UBOOL delegateOnProcessInputAxis(const struct FSubscribedInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnProcessInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnProcessInputAxis,&__OnProcessInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnProcessInputKey(const struct FSubscribedInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnProcessInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnProcessInputKey,&__OnProcessInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnRawInputAxis(const struct FInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnRawInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnRawInputAxis,&__OnRawInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnRawInputKey(const struct FInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnRawInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnRawInputKey,&__OnRawInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateNotifyActiveSkinChanged()
    {
        ProcessDelegate(ENGINE_NotifyActiveSkinChanged,&__NotifyActiveSkinChanged__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIScreenObject,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/**
	 * Returns the UIScreenObject that owns this widget.
	 */
	virtual UUIScreenObject* GetParent() const { return NULL; }

	/**
	 * Returns the UIObject that owns this widget, or NULL if this screen object
	 * doesn't have an owner (such as UIScenes)
	 */
	virtual UUIObject* GetOwner() const PURE_VIRTUAL(UUIScreenObject::GetOwner,return NULL;);

	/**
	 * Get the scene that owns this widget.  If this is a UIScene, returns a pointer to itself.
	 */
	virtual UUIScene* GetScene() PURE_VIRTUAL(UUIScreenObject::GetScene,return NULL;);

	/**
	 * Get the scene that owns this widget.  If this is a UIScene, returns a pointer to itself.
	 */
	virtual const UUIScene* GetScene() const PURE_VIRTUAL(const UUIScreenObject::GetScene,return NULL;);

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const PURE_VIRTUAL(UUIScreenObject::GetTag,return NAME_None;);

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const PURE_VIRTUAL(UUIScreenObject::GetWidgetPathName,return TEXT(""););

	/**
	 * Returns the default parent to use when placing widgets using the UI editor.  This widget is used when placing
	 * widgets by dragging their outline using the mouse, for example.
	 *
	 * @return	a pointer to the widget that will contain newly placed widgets when a specific parent widget has not been
	 *			selected by the user.
	 */
	virtual UUIScreenObject* GetEditorDefaultParentWidget();

	/**
	 * Returns whether this screen object has been initialized
	 */
	UBOOL IsInitialized() const		{ return bInitialized; }

	/**
	 * Accessor for retrieving the PostProcessSettings struct used for interpolating PP effects.
	 *
	 * @param	CurrentSettings		receives the current PostProcessSettings that should be used for PP effect animation.
	 *
	 * @return	TRUE if this widget supports animation of post-processing and filled in the value of CurrentSettings.
	 */
	virtual UBOOL AnimGetCurrentPPSettings( FPostProcessSettings*& CurrentSettings ) PURE_VIRTUAL(UUIScreenObject::AnimGetCurrentPPSettings,return FALSE;);

	/**
	 * Determines whether to change the Outer of this widget if the widget's Owner doesn't match it's Outer.
	 */
	virtual UBOOL RequiresParentForOuter() const { return TRUE; }

	/**
	 * Determines whether this scene processes axis input events.
	 *
	 * @param	bProcessAxisInput	receives the flags for whether axis input is needed for each player.
	 * @param	NavAliases			list of input aliases that correspond to axis navigation
	 * @param	AxisInputKeys		list of input keys that are associated with axis input.
	 *
	 * @return	TRUE if axis input is supported by all active players (can stop checking children, for example)
	 */
	virtual UBOOL CheckAxisInputSupport( UBOOL* bProcessAxisInput[UCONST_MAX_SUPPORTED_GAMEPADS], TLookupMap<FName>& NavAliases, TLookupMap<FName>& AxisInputKeys ) const;

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged			if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE ) {}

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate() PURE_VIRTUAL(UUIScreenObject::RequestFormattingUpdate,);

	/**
	 * Flag the scene to recalculate its PlayerInputMask at the beginning of the next tick.
	 */
	virtual void RequestSceneInputMaskUpdate() PURE_VIRTUAL(UUIScreenObject::RequestSceneInputMaskUpdate,);

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage ) PURE_VIRTUAL(UUIScreenObject::RequestPrimitiveReview,);

	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged();

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Iterates through the DefaultStates array checking that InactiveStates contains at least one instance of each
	 * DefaultState.  If no instances are found, one is created and added to the InactiveStates array.
	 */
	virtual void CreateDefaultStates();

	/**
	 * Checks that this screen object has an InitialState and contains a UIState_Enabled (or child class) in its
	 * InactiveStates array.  If any of the required states are missing, creates them.
	 */
	virtual void ValidateRequiredStates();

	/**
	 * Returns only those states [from the InactiveStates array] which were instanced from an entry in the DefaultStates array.
	 */
	void GetInstancedStates( TMap<UClass*,UUIState*>& out_Instances );

	/**
	 * Creates a new UIState instance based on the specified template and adds the new state to this widget's list of
	 * InactiveStates.
	 *
	 * @param	StateTemplate	the state to use as the template for the new state
	 *
	 * @return	the state instance that was created
	 */
	class UUIState* AddSupportedState( UUIState* StateTemplate );

	/**
	 * Activates the configured initial state for this widget.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player to activate this initial state for
	 */
	void ActivateInitialState( INT PlayerIndex );

	/**
	 * Determine whether there are any active states of the specified class
	 *
	 * @param	StateClass	the class to search for
	 * @param	PlayerIndex	the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 *
	 * @return	TRUE if there is at least one active state of the class specified
	 */
	UBOOL HasActiveStateOfClass( UClass* StateClass, INT PlayerIndex, INT* StateIndex=NULL ) const;

	/**
	 * Alternate version of ActivateState that activates the first state in the InactiveStates array with the specified class
	 * that isn't already in the StateStack
	 */
	UBOOL ActivateStateByClass(class UClass* StateToActivate,INT PlayerIndex,class UUIState** StateThatWasAdded=NULL);

	/**
	 * Iterates up the parent chain, calling the NotifyActiveStateChanged delegate for any parent widgets that are handling that delegate.
	 *
	 * @param	PlayerIndex				the index [into the GamePlayers array] for the player that activated this state.
	 * @param	NewlyActiveState		the state that is now active
	 * @param	PreviouslyActiveState	the state that used the be the widget's currently active state.
	 */
	void PropagateStateChangeNotification(INT PlayerIndex, class UUIState* NewlyActiveState, class UUIState* PreviouslyActiveState);

	/**
	 * Returns TRUE if this widget has a UIState_Enabled object in its StateStack and the state has been activated for the specified PlayerIndex.
	 *
	 * @param	PlayerIndex			the index of the player to check
	 * @param	StateIndex			if specified, will be set to the index of the last state in the list of active states that
	 *								has the class specified
	 * @param	bCheckOwnerChain	by default, the owner chain is checked as well; specify FALSE to override this behavior.
	 */
	UBOOL IsEnabled( INT PlayerIndex, INT* StateIndex=NULL, UBOOL bCheckOwnerChain=TRUE ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Disabled object in its StateStack and the state has been activated for the specified PlayerIndex.
	 *
	 * @param	PlayerIndex			the index of the player to check
	 * @param	StateIndex			if specified, will be set to the index of the last state in the list of active states that
	 *								has the class specified
	 * @param	bCheckOwnerChain	by default, the owner chain is checked as well; specify FALSE to override this behavior.
	 */
	UBOOL IsDisabled( INT PlayerIndex, INT* StateIndex=NULL, UBOOL bCheckOwnerChain=TRUE ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Focused object in its StateStack and the state has been activated for the specified PlayerIndex.
	 *
	 * @param	PlayerIndex			the index of the player to check
	 * @param	StateIndex			if specified, will be set to the index of the last state in the list of active states that
	 *								has the class specified
	 */
	UBOOL IsFocused( INT PlayerIndex, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Active object in its StateStack and the state has been activated for the specified PlayerIndex.
	 *
	 * @param	PlayerIndex			the index of the player to check
	 * @param	StateIndex			if specified, will be set to the index of the last state in the list of active states that
	 *								has the class specified
	 */
	UBOOL IsActive( INT PlayerIndex, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Pressed object in its StateStack and the state has been activated for the specified PlayerIndex.
	 *
	 * @param	PlayerIndex			the index of the player to check
	 * @param	StateIndex			if specified, will be set to the index of the last state in the list of active states that
	 *								has the class specified
	 */
	UBOOL IsPressed( INT PlayerIndex, INT* StateIndex=NULL ) const;

	/**
	 * Determines whether this widget is contained a scene that has been instanced at runtime.
	 *
	 * @retun	FALSE if this widget is contained in a scene from a content package; TRUE if this widget is contained within a scene
	 *			that has been created from scratch or opened at runtime.
	 */
	UBOOL IsRuntimeInstance() const
	{
		return GetOutermost() == GetTransientPackage();
	}

	/**
	 * Gets the value of this widget's PlayerInputMask.
	 *
	 * @param	bInheritedMaskOnly		specify TRUE to return only the mask that was set by this widget's owner scene.
	 * @param	bOverrideMaskOnly		specify TRUE to return only the mask that was set manually for this widget, in which case whatever
	 *									value was passed for bInheritedMaskOnly is ignored.
	 *
	 * @return	a bitmask representing the indices of the players that this widget accepts input from; If both bInheritedMaskOnly
	 *			and bOverrideMaskOnly are FALSE, returns the override mask if there is one, otherwise the inherited mask.
	 */
	virtual BYTE GetInputMask( UBOOL bInheritedMaskOnly=FALSE, UBOOL bOverrideMaskOnly=FALSE ) const PURE_VIRTUAL(UUIScreenObject::GetInputMask,return INDEX_NONE;)

	/**
	 * Changes the player input mask for this control, which controls which players this control will accept input from.
	 *
	 * @param	NewInputMask	the new mask that should be assigned to this control
	 * @param	bRecurse		if TRUE, calls SetInputMask on all child controls as well.
	 * @param	bForcedOverride	indicates that the specified input mask should override any input mask inherited from the owning scene
	 */
	virtual void SetInputMask( BYTE NewInputMask, UBOOL bRecurse=TRUE, UBOOL bForcedOverride=FALSE );

	/**
	 * Changes the specified preview state on the screen object's StateStack.
	 *
	 * @param	StateToActivate		the new preview state
	 *
	 * @return	TRUE if the state was successfully changed to the new preview state.  FALSE if couldn't change
	 *			to the new state or the specified state already exists in the screen object's list of active states
	 */
	virtual UBOOL ActivatePreviewState(UUIState *StateToActivate);

	/**
	 * Alternate version of DeactivateState that deactivates the last state in the StateStack array that has the specified class.
	 */
	UBOOL DeactivateStateByClass(class UClass* StateToRemove,INT PlayerIndex,class UUIState** StateThatWasRemoved=NULL);

	/**
	 * Activate the event of the specified class.
	 *
	 * @param	PlayerIndex				the index of the player that activated this event
	 * @param	EventClassToActivate	specifies the event class that should be activated.  If there is more than one instance
	 *									of a particular event class in this screen object's list of events, all instances will
	 *									be activated in the order in which they occur in the event provider's list.
	 * @param	InEventActivator		an optional object that can be used for various purposes in UIEvents
	 * @param	bActivateImmediately	TRUE to activate the event immediately, causing its output operations to also be processed immediately.
	 * @param	IndicesToActivate		Indexes into this UIEvent's Output array to activate.  If not specified, all output links
	 *									will be activated
	 * @param	out_ActivatedEvents		filled with the event instances that were activated.
	 */
	void ActivateEventByClass(INT PlayerIndex,class UClass* EventClassToActivate,class UObject* InEventActivator=NULL,UBOOL bActivateImmediately=0,const TArray<INT>* IndicesToActivate=NULL,TArray<class UUIEvent*>* out_ActivatedEvents=NULL);

private:
	/**
	 * Wrapper for ActivateEventByClass; called when an event is activated by one of our children and is being propagated upwards.  In cases where
	 * there are multiple child classes of the specified class, only those event classes which have TRUE for the value of bPropagateEvents are
	 * activated.
	 *
	 * @param	PlayerIndex				the index of the player that activated this event
	 * @param	EventClassToActivate	specifies the event class that should be activated.  If there is more than one instance
	 *									of a particular event class in this screen object's list of events, all instances will
	 *									be activated in the order in which they occur in the event provider's list.
	 * @param	InEventActivator		the object that the event was originally generated for.
	 * @param	bActivateImmediately	TRUE to activate the event immediately, causing its output operations to also be processed immediately.
	 * @param	IndicesToActivate		Indexes into this UIEvent's Output array to activate.  If not specified, all output links
	 *									will be activated
	 * @param	out_ActivatedEvents		filled with the event instances that were activated.
	 */
	void ChildEventActivated( INT PlayerIndex,class UClass* EventClassToActivate,class UObject* InEventActivator,UBOOL bActivateImmediately=0,const TArray<INT>* IndicesToActivate=NULL,TArray<class UUIEvent*>* out_ActivatedEvents=NULL );

public:
	// Wrappers for primary menu states
	/**
	 * @param	bIncludeParents		specify TRUE to check the visibility of parent widgets as well
	 *
	 * @return	TRUE if this widget is visible.
	 */
	UBOOL IsVisible( UBOOL bIncludeParents=FALSE ) const;

	/**
	 * @param	bIncludeParents		specify TRUE to check the visibility of parent widgets as well
	 *
	 * @return	TRUE if this widget is hidden.
	 */
	UBOOL IsHidden( UBOOL bIncludeParents=FALSE ) const;

	/**
	 * Accessor for private variable.
	 *
	 * @return	the current value of ZDepth for this widget.
	 */
	FLOAT GetZDepth() const
	{
		return ZDepth;
	}

	/**
	 * @return Returns TRUE if this widget can be resized, repositioned, or rotated, FALSE otherwise.
	 */
	virtual UBOOL IsTransformable() const
	{
		return TRUE;
	}

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const PURE_VIRTUAL(UUIScreenObject::GetNumResolvedFaces,return 0;);

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const PURE_VIRTUAL(UUIScreenObject::HasPositionBeenResolved,return FALSE;);

	/**
	 * Calculates the closest sibling for each child, per face, and assigns that widget as the navigation target for that face.
	 *
	 * @return	TRUE if any navigation links were created.
	 */
	virtual UBOOL GenerateAutoNavigationLinks();

	/**
	 * Calculates the ideal tab index for all children of this widget and assigns the tab index to the child widget, unless
	 * that widget's tab index has been specifically set by the designer.
	 */
	virtual void GenerateAutomaticTabIndexes();

	/**
	 * Assigns values to the links which are used for navigating through this widget using the keyboard.  Sets the first and
	 * last focus targets for this widget as well as the next/prev focus targets for all children of this widget.
	 *
	 * @return	TRUE if any sibling navigation links were created.
	 */
	virtual UBOOL RebuildKeyboardNavigationLinks();

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE ) {}

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Changes this widget's position to the specified value.
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bIncludesViewportOrigin
	 *							TRUE indicates that the value is relative to the 0,0 on the screen (or absolute position); FALSE to indicate
	 *							the value is relative to the viewport's origin.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bIncludesViewportOrigin=FALSE, UBOOL bClampValues=FALSE );

	/**
	 * @param Point	Point to check against the renderbounds of the object.
	 * @return Whether or not this screen object contains the point passed in within its renderbounds.
	 */
	virtual UBOOL ContainsPoint(const FVector2D& Point) const;

	/**
	 * Marks the position for the specified face as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	void InvalidatePosition( BYTE Face );

	/**
	 * Marks the position for all faces as out of sync with the RenderBounds values
	 *
	 * @param	bIgnoreDockedFaces	indicates whether faces that are docked should be skipped
	 */
	void InvalidateAllPositions( UBOOL bIgnoreDockedFaces=TRUE );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face ) PURE_VIRTUAL(UUIScreenObject::InvalidatePositionDependencies,);

public:
	/**
	 * Plays the sound cue associated with the specified name;  simple wrapper method for calling UIInteraction::PlayUISound
	 *
	 * @param	SoundCueName	the name of the UISoundCue to play; should corresond to one of the values of the UISoundCueNames array.
	 * @param	PlayerIndex		allows the caller to indicate which player controller should be used to play the sound cue.  For the most
	 *							part, all sounds can be played by the first player, regardless of who generated the play sound event.
	 *
	 * @return	TRUE if the sound cue specified was found in the currently active skin, even if there was no actual USoundCue associated
	 *			with that UISoundCue.
	 */
	static UBOOL PlayUISound( FName SoundCueName, INT PlayerIndex=0 );

	/**
	 * Routing event for the input we received.  This function first sees if there are any kismet actions that are bound to the
	 * input.  If not, it passes the input to the widget's default input event handler.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	UBOOL HandleInputKeyEvent( const FInputEventParameters& EventParms );

	/**
	 * Remove an existing child widget from this widget's children
	 *
	 * @param	ExistingChild	the widget to remove
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 *
	 * @return	TRUE if the child was successfully removed from the list, or if the child was not contained by this widget
	 *			FALSE if the child could not be removed from this widget's child list.
	 */
	UBOOL RemoveChild(class UUIObject* ExistingChild, TArray<class UUIObject*>* ExclusionSet=NULL );

	/**
	 * DEPRECATED.  Use PreInitialSceneUpdate instead.
	 */
	virtual void PreRenderCallback();

	/**
	 * Called at the beginning of the first scene update and propagated to all widgets in the scene.  Provides classes with
	 * an opportunity to initialize anything that couldn't be setup earlier due to lack of a viewport.
	 *
	 * Calling functions such as GetViewportSize() or GetPosition() aren't guaranteed to work until this function has been called.
	 */
	virtual void PreInitialSceneUpdate();

	/**
	 * Called at the end of the first scene update and propagated to all widgets in the scene.  Provides classes with
	 * an opportunity to intialize anything that was dependent on child widgets, etc.
	 */
	virtual void PostInitialSceneUpdate();

	/**
	 * Attach and initialize any 3D primitives for this widget and its children.
	 *
	 * @param	CanvasScene		the scene to use for attaching 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void Render_Children( FCanvas* Canvas, EUIPostProcessGroup UIPostProcessGroup );

	/**
	 * Routes the call to UpdateWidgetPrimitives to all children of this widget.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateChildPrimitives( FCanvasScene* Canvas );

	/**
	 * Gets a list of all children contained in this screen object.
	 *
	 * @param	bRecurse		if FALSE, result will only contain widgets from this screen object's Children array
	 *							if TRUE, result will contain all children of this screen object, including their children.
	 * @param	ExclusionSet	if specified, any widgets contained in this array will not be added to the output array.
	 *
	 * @return	an array of widgets contained by this screen object.
	 */
	TArray<class UUIObject*> GetChildren( UBOOL bRecurse=FALSE, TArray<class UUIObject*>* ExclusionSet=NULL ) const;

	/**
	 * Gets a list of all children contained in this screen object.
	 *
	 * @param	out_Children	receives the list of child widgets.
	 * @param	bRecurse		if FALSE, result will only contain widgets from this screen object's Children array
	 *							if TRUE, result will contain all children of this screen object, including their children.
	 * @param	ExclusionSet	if specified, any widgets contained in this array will not be added to the output array.
	 *
	 * @return	an array of widgets contained by this screen object.
	 */
	void GetChildren( TArray<class UUIObject*>& out_Children, UBOOL bRecurse=FALSE, TArray<class UUIObject*>* ExclusionSet=NULL ) const;

	/**
	 * Returns all objects which are docked to this one.
	 *
	 * @param	DockClients					If specified, receives the list of objects docked to this one.  Do not pass a value if you only
	 *										wish to know the number of objects docked to this one.
	 * @param	bDirectDockClientsOnly		by default, only returns widgets that are docked to this widget directly;  Specify FALSE to also
	 *										include widgets which are docked to this widget indirectly (i.e. through more than one docking
	 *										link.  Caution: this can cause a performance hit if there are a large number of widgets in the scene.
	 * @param	TargetFace					if specified, returns only those widgets that are docked to the specified face on this widget.
	 * @param	SourceFace					if specified, returns only those widgets that have the specified face docked to this widget.
	 *
	 * @return	the number of widgets docked to this one.
	 */
	INT GetDockClients( TArray<UUIObject*>* DockClients=NULL, UBOOL bDirectDockClientsOnly=TRUE, /*EUIWidgetFace*/BYTE TargetFace=UIFACE_MAX, /*EUIWidgetFace*/BYTE SourceFace=UIFACE_MAX ) const;

	/**
	 * Generates a list of widgets that have the bEnableSceneUpdateNotifications flag set.
	 */
	void GetSceneUpdateNotificationSubscribers( TArray<UUIObject*>& out_Subscribers ) const;

	/**
	 * Wrapper for AttachFocusHint which first calls into script to allow script the chance to override native handling of the focus hint.
	 */
	void ActivateFocusHint();

	/**
	 * Applies animations to this widget's members, and decrements the animation sequence's counter.
	 *
	 * @param	DeltaTime		the time (in seconds) since the last frame began
	 * @param	AnimSeqRef		the animation sequence to update.
	 *
	 * @return	TRUE if the animation is complete.
	 */
	UBOOL UpdateAnimation( FLOAT DeltaTime, FUIAnimSequence& AnimSeqRef );

protected:
	/**
	 * Activates the focus hint widget for this object; child classes which override this method should set the position of the focus hint
	 * as well as any other properties necessary for correctly displaying the focus hint for this widget.
	 *
	 * @param	FocusHintObject		reference to the widget that supplies the focus hint.
	 *
	 * @return	TRUE if the focus hint object was initialized / repositioned by this widget; FALSE if this widget doesn't support focus hints.
	 */
	virtual UBOOL AttachFocusHint( class UUIObject* FocusHintObject ) { return FALSE; }

	/**
	 * Wrapper for rendering a single child of this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	Child	the child to render
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 *
	 * @note: this method is non-virtual for speed.  If you need to override this method, feel free to make it virtual.
	 */
	void Render_Child( FCanvas* Canvas, class UUIObject* Child, EUIPostProcessGroup UIPostProcessGroup );

	/**
	 * Sees if there are any kismet actions that are responding to the input we received.  If so, execute the action
	 * that is currently bound to the event we just received.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessActions( const FInputEventParameters& EventParms );

	/**
	 * Determines whether this widget should process the specified input event + state.  If the widget is configured
	 * to respond to this combination of input key/state, any actions associated with this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

	/**
	 * Determines whether this widget should process the specified axis input event (mouse/joystick movement).
	 * If the widget is configured to respond to this axis input event, any actions associated with
	 * this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Activates any actions assigned to the specified character in this widget's input processor.
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Unicode key.
	 *
	 * @param	PlayerIndex		index [into the Engine.GamePlayers array] of the player that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	virtual UBOOL ProcessInputChar( INT PlayerIndex, TCHAR Character );

	/**
	 * Converts an input key name (e.g. KEY_Enter) to a UI action key name (UIKEY_Clicked)
	 *
	 * @param	EventParms		the parameters for the input event
	 * @param	out_UIKeyName	will be set to the UI action key name that is mapped to the specified input key name.
	 * @param	WidgetClass		allows callers to override the class used for translating the key; if not specified, uses the current class.
	 *
	 * @return	TRUE if InputKeyName was successfully converted into a UI action key name.
	 */
	UBOOL TranslateKey( const FInputEventParameters& EventParms, FName& out_UIKeyName, UClass* WidgetClass=NULL );

	/**
	 * Generates an array of indexes, which correspond to indexes into the Engine.GamePlayers array for the players that
	 * this control accepts input from.
	 */
	void GetInputMaskPlayerIndexes( TArray<INT>& out_Indexes ) const;

	/**
	 * Generates a list of any children of this widget which are of a class that has been deprecated, recursively.
	 */
	void FindDeprecatedWidgets( TArray<UUIScreenObject*>& out_DeprecatedWidgets );

protected:
	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.  This version removes any NULL entries from the Children array.
	 */
	virtual void PostLoad();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for UIScreenObjects is handled by the UIPrefab/UIPrefabInstance code, so this version just
	 * skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		the array of objects which have this object in their ObjectArchetype chain and will be affected by the change.
	 *								Objects which have this object as their direct ObjectArchetype are removed from the list once they're processed.
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		the array of objects which have this object in their ObjectArchetype chain and will be affected by the change.
	 *								Objects which have this object as their direct ObjectArchetype are removed from the list once they're processed.
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Called just after a property in this object's archetype is modified, immediately after this object has been de-serialized
	 * from the archetype propagation archive.
	 *
	 * Allows objects to perform reinitialization specific to being de-serialized from an FArchetypePropagationArc and
	 * reinitialized against an archetype. Only called for instances of archetypes, where the archetype has the RF_ArchetypeObject flag.
	 */
	virtual void PostSerializeFromPropagationArchive();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 */
	virtual void PostEditImport();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is a UIPrefabInstance or a child of a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;

	/**
	 * Determines whether this UIScreenObject is contained by a UIPrefab.
	 *
	 * @param	OwningPrefab	if specified, will be filled in with a reference to the UIPrefab which contains this
	 *							widget, if this widget is in fact contained in a UIPrefab
	 */
	UBOOL IsInUIPrefab( class UUIPrefab** OwningPrefab=NULL ) const;
};

#define UCONST_CONTEXTMENU_BINDING_INDEX 101
#define UCONST_TOOLTIP_BINDING_INDEX 100
#define UCONST_FIRST_DEFAULT_DATABINDING_INDEX 100

struct UIObject_eventOnContextMenuItemSelected_Parms
{
    class UUIContextMenu* ContextMenu;
    INT PlayerIndex;
    INT ItemIndex;
    UIObject_eventOnContextMenuItemSelected_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnCloseContextMenu_Parms
{
    class UUIContextMenu* ContextMenu;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnCloseContextMenu_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnOpenContextMenu_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    class UUIContextMenu* CustomContextMenu;
    UBOOL ReturnValue;
    UIObject_eventOnOpenContextMenu_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnQueryToolTip_Parms
{
    class UUIObject* Sender;
    class UUIToolTip* CustomToolTip;
    UBOOL ReturnValue;
    UIObject_eventOnQueryToolTip_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnDoubleClick_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnDoubleClick_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnClicked_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnClicked_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressRelease_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressRelease_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressRepeat_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressRepeat_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressed_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressed_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnRefreshSubscriberValue_Parms
{
    class UUIObject* Sender;
    INT BindingIndex;
    UBOOL ReturnValue;
    UIObject_eventOnRefreshSubscriberValue_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnValueChanged_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    UIObject_eventOnValueChanged_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPostSceneUpdate_Parms
{
    class UUIObject* Sender;
    UIObject_eventOnPostSceneUpdate_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPreSceneUpdate_Parms
{
    class UUIObject* Sender;
    UIObject_eventOnPreSceneUpdate_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnCreate_Parms
{
    class UUIObject* CreatedWidget;
    class UUIScreenObject* CreatorContainer;
    UIObject_eventOnCreate_Parms(EEventParm)
    {
    }
};
class UUIObject : public UUIScreenObject
{
public:
    //## BEGIN PROPS UIObject
    struct FWIDGET_ID WidgetID;
    FName WidgetTag;
    class UUIObject* Owner;
    class UUIScene* OwnerScene;
    struct FUIStyleReference PrimaryStyle;
    BYTE PlayerInputMask;
    BYTE MaskPostProcess;
    struct FUINavigationData NavigationTargets;
    INT TabIndex;
    struct FUIDockingSet DockTargets;
    FLOAT RenderBounds[4];
    FVector2D RenderBoundsVertices[4];
    struct FUIRotation Rotation;
    FVector RenderOffset;
private:
    INT PrivateFlags;
public:
    struct FUIDataStoreBinding ToolTip;
    struct FUIDataStoreBinding ContextMenuData;
    class UUIObject* AnimationParent;
    TArrayNoInit<TScriptInterface<class IUIStyleResolver> > StyleSubscribers;
private:
    BITFIELD bEnableActiveCursorUpdates:1;
public:
    BITFIELD bSupportsPrimaryStyle:1;
    BITFIELD bEnableSceneUpdateNotifications:1;
    BITFIELD bDebugShowBounds:1;
    FColor DebugBoundsColor;
    FScriptDelegate __OnCreate__Delegate;
    FScriptDelegate __OnPreSceneUpdate__Delegate;
    FScriptDelegate __OnPostSceneUpdate__Delegate;
    FScriptDelegate __OnValueChanged__Delegate;
    FScriptDelegate __OnRefreshSubscriberValue__Delegate;
    FScriptDelegate __OnPressed__Delegate;
    FScriptDelegate __OnPressRepeat__Delegate;
    FScriptDelegate __OnPressRelease__Delegate;
    FScriptDelegate __OnClicked__Delegate;
    FScriptDelegate __OnDoubleClick__Delegate;
    FScriptDelegate __OnQueryToolTip__Delegate;
    FScriptDelegate __OnOpenContextMenu__Delegate;
    FScriptDelegate __OnCloseContextMenu__Delegate;
    FScriptDelegate __OnContextMenuItemSelected__Delegate;
    //## END PROPS UIObject

    void SetDefaultDataBinding(const FString& MarkupText,INT BindingIndex);
    FString GetDefaultDataBinding(INT BindingIndex) const;
    UBOOL ResolveDefaultDataBinding(INT BindingIndex);
    void GetDefaultDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearDefaultDataBinding(INT BindingIndex);
    virtual FString GenerateSceneDataStoreMarkup(const FString& Group=TEXT("ContextMenuItems")) const;
    FString GetToolTipValue();
    UBOOL HasTransform(UBOOL bIncludeParentTransforms=TRUE) const;
    void SetAnchorPosition(FVector NewAnchorPosition,BYTE InputType=1);
    void RotateWidget(FRotator NewRotationAmount,UBOOL bAccumulateRotation=FALSE);
    void UpdateRotationMatrix();
    FVector GetAnchorPosition(UBOOL bRelativeToWidget=TRUE,UBOOL bPixelSpace=FALSE) const;
    FMatrix GenerateTransformMatrix(UBOOL bIncludeParentTransforms=TRUE) const;
    FMatrix GetRotationMatrix(UBOOL bIncludeParentRotations=TRUE) const;
    virtual void NotifyValueChanged(INT PlayerIndex=-1,INT NotifyFlags=0);
    UBOOL IsContainedBy(class UUIObject* TestWidget);
    virtual UBOOL SetDockTarget(BYTE SourceFace,class UUIScreenObject* Target,BYTE TargetFace);
    virtual UBOOL SetDockPadding(BYTE SourceFace,FLOAT PaddingValue,BYTE PaddingInputType=0,UBOOL bModifyPaddingScaleType=FALSE);
    UBOOL SetDockParameters(BYTE SourceFace,class UUIScreenObject* Target,BYTE TargetFace,FLOAT PaddingValue,BYTE PaddingInputType=0,UBOOL bModifyPaddingScaleType=FALSE);
    UBOOL GetDockParameters(BYTE SourceFace,class UUIScreenObject*& TargetWidget,BYTE& TargetFace,FLOAT& TargetPadding) const;
    UBOOL IsDockedTo(const class UUIScreenObject* TargetWidget,BYTE SourceFace=4,BYTE TargetFace=4) const;
    UBOOL SetNavigationTarget(BYTE Face,class UUIObject* NewNavTarget);
    UBOOL SetForcedNavigationTarget(BYTE Face,class UUIObject* NavTarget,UBOOL bIsNullOverride=FALSE);
    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    UBOOL IsPrivateBehaviorSet(INT Behavior) const;
    void SetPrivateBehavior(INT Behavior,UBOOL Value,UBOOL bRecurse=FALSE);
    virtual void SetActiveCursorUpdate(UBOOL bShouldReceiveCursorUpdates);
    UBOOL NeedsActiveCursorUpdates() const;
    void GetPositionExtents(FLOAT& MinX,FLOAT& MaxX,FLOAT& MinY,FLOAT& MaxY,UBOOL bIncludeRotation=FALSE,UBOOL bIncludeOrigin=FALSE) const;
    FLOAT GetPositionExtent(BYTE Face,UBOOL bIncludeRotation=FALSE,UBOOL bIncludeOrigin=FALSE) const;
    void AddStyleSubscriber(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    void RemoveStyleSubscriber(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    INT FindStyleSubscriberIndex(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    INT FindStyleSubscriberIndexById(FName StyleSubscriberId);
    UBOOL SetWidgetStyleByName(FName StyleResolverTagToSet,FName StyleFriendlyName);
    DECLARE_FUNCTION(execSetDefaultDataBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT(BindingIndex);
        P_FINISH;
        SetDefaultDataBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(FString*)Result=GetDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execResolveDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(UBOOL*)Result=ResolveDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execGetDefaultDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetDefaultDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        ClearDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execGenerateSceneDataStoreMarkup)
    {
        P_GET_STR_OPTX(Group,TEXT("ContextMenuItems"));
        P_FINISH;
        *(FString*)Result=GenerateSceneDataStoreMarkup(Group);
    }
    DECLARE_FUNCTION(execGetToolTipValue)
    {
        P_FINISH;
        *(FString*)Result=GetToolTipValue();
    }
    DECLARE_FUNCTION(execHasTransform)
    {
        P_GET_UBOOL_OPTX(bIncludeParentTransforms,TRUE);
        P_FINISH;
        *(UBOOL*)Result=HasTransform(bIncludeParentTransforms);
    }
    DECLARE_FUNCTION(execSetAnchorPosition)
    {
        P_GET_STRUCT(FVector,NewAnchorPosition);
        P_GET_BYTE_OPTX(InputType,1);
        P_FINISH;
        SetAnchorPosition(NewAnchorPosition,InputType);
    }
    DECLARE_FUNCTION(execRotateWidget)
    {
        P_GET_STRUCT(FRotator,NewRotationAmount);
        P_GET_UBOOL_OPTX(bAccumulateRotation,FALSE);
        P_FINISH;
        RotateWidget(NewRotationAmount,bAccumulateRotation);
    }
    DECLARE_FUNCTION(execUpdateRotationMatrix)
    {
        P_FINISH;
        UpdateRotationMatrix();
    }
    DECLARE_FUNCTION(execGetAnchorPosition)
    {
        P_GET_UBOOL_OPTX(bRelativeToWidget,TRUE);
        P_GET_UBOOL_OPTX(bPixelSpace,FALSE);
        P_FINISH;
        *(FVector*)Result=GetAnchorPosition(bRelativeToWidget,bPixelSpace);
    }
    DECLARE_FUNCTION(execGenerateTransformMatrix)
    {
        P_GET_UBOOL_OPTX(bIncludeParentTransforms,TRUE);
        P_FINISH;
        *(FMatrix*)Result=GenerateTransformMatrix(bIncludeParentTransforms);
    }
    DECLARE_FUNCTION(execGetRotationMatrix)
    {
        P_GET_UBOOL_OPTX(bIncludeParentRotations,TRUE);
        P_FINISH;
        *(FMatrix*)Result=GetRotationMatrix(bIncludeParentRotations);
    }
    DECLARE_FUNCTION(execNotifyValueChanged)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_GET_INT_OPTX(NotifyFlags,0);
        P_FINISH;
        NotifyValueChanged(PlayerIndex,NotifyFlags);
    }
    DECLARE_FUNCTION(execIsContainedBy)
    {
        P_GET_OBJECT(UUIObject,TestWidget);
        P_FINISH;
        *(UBOOL*)Result=IsContainedBy(TestWidget);
    }
    DECLARE_FUNCTION(execSetDockTarget)
    {
        P_GET_BYTE(SourceFace);
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_BYTE(TargetFace);
        P_FINISH;
        *(UBOOL*)Result=SetDockTarget(SourceFace,Target,TargetFace);
    }
    DECLARE_FUNCTION(execSetDockPadding)
    {
        P_GET_BYTE(SourceFace);
        P_GET_FLOAT(PaddingValue);
        P_GET_BYTE_OPTX(PaddingInputType,0);
        P_GET_UBOOL_OPTX(bModifyPaddingScaleType,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetDockPadding(SourceFace,PaddingValue,PaddingInputType,bModifyPaddingScaleType);
    }
    DECLARE_FUNCTION(execSetDockParameters)
    {
        P_GET_BYTE(SourceFace);
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_BYTE(TargetFace);
        P_GET_FLOAT(PaddingValue);
        P_GET_BYTE_OPTX(PaddingInputType,0);
        P_GET_UBOOL_OPTX(bModifyPaddingScaleType,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetDockParameters(SourceFace,Target,TargetFace,PaddingValue,PaddingInputType,bModifyPaddingScaleType);
    }
    DECLARE_FUNCTION(execGetDockParameters)
    {
        P_GET_BYTE(SourceFace);
        P_GET_OBJECT_REF(UUIScreenObject,TargetWidget);
        P_GET_BYTE_REF(TargetFace);
        P_GET_FLOAT_REF(TargetPadding);
        P_FINISH;
        *(UBOOL*)Result=GetDockParameters(SourceFace,TargetWidget,TargetFace,TargetPadding);
    }
    DECLARE_FUNCTION(execIsDockedTo)
    {
        P_GET_OBJECT(UUIScreenObject,TargetWidget);
        P_GET_BYTE_OPTX(SourceFace,4);
        P_GET_BYTE_OPTX(TargetFace,4);
        P_FINISH;
        *(UBOOL*)Result=IsDockedTo(TargetWidget,SourceFace,TargetFace);
    }
    DECLARE_FUNCTION(execSetNavigationTarget)
    {
        P_GET_BYTE(Face);
        P_GET_OBJECT(UUIObject,NewNavTarget);
        P_FINISH;
        *(UBOOL*)Result=SetNavigationTarget(Face,NewNavTarget);
    }
    DECLARE_FUNCTION(execSetForcedNavigationTarget)
    {
        P_GET_BYTE(Face);
        P_GET_OBJECT(UUIObject,NavTarget);
        P_GET_UBOOL_OPTX(bIsNullOverride,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetForcedNavigationTarget(Face,NavTarget,bIsNullOverride);
    }
    DECLARE_FUNCTION(execIsPrivateBehaviorSet)
    {
        P_GET_INT(Behavior);
        P_FINISH;
        *(UBOOL*)Result=IsPrivateBehaviorSet(Behavior);
    }
    DECLARE_FUNCTION(execSetPrivateBehavior)
    {
        P_GET_INT(Behavior);
        P_GET_UBOOL(Value);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        SetPrivateBehavior(Behavior,Value,bRecurse);
    }
    DECLARE_FUNCTION(execSetActiveCursorUpdate)
    {
        P_GET_UBOOL(bShouldReceiveCursorUpdates);
        P_FINISH;
        SetActiveCursorUpdate(bShouldReceiveCursorUpdates);
    }
    DECLARE_FUNCTION(execNeedsActiveCursorUpdates)
    {
        P_FINISH;
        *(UBOOL*)Result=NeedsActiveCursorUpdates();
    }
    DECLARE_FUNCTION(execGetPositionExtents)
    {
        P_GET_FLOAT_REF(MinX);
        P_GET_FLOAT_REF(MaxX);
        P_GET_FLOAT_REF(MinY);
        P_GET_FLOAT_REF(MaxY);
        P_GET_UBOOL_OPTX(bIncludeRotation,FALSE);
        P_GET_UBOOL_OPTX(bIncludeOrigin,FALSE);
        P_FINISH;
        GetPositionExtents(MinX,MaxX,MinY,MaxY,bIncludeRotation,bIncludeOrigin);
    }
    DECLARE_FUNCTION(execGetPositionExtent)
    {
        P_GET_BYTE(Face);
        P_GET_UBOOL_OPTX(bIncludeRotation,FALSE);
        P_GET_UBOOL_OPTX(bIncludeOrigin,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetPositionExtent(Face,bIncludeRotation,bIncludeOrigin);
    }
    DECLARE_FUNCTION(execAddStyleSubscriber)
    {
        P_GET_TINTERFACE(IUIStyleResolver,Subscriber);
        P_FINISH;
        AddStyleSubscriber(Subscriber);
    }
    DECLARE_FUNCTION(execRemoveStyleSubscriber)
    {
        P_GET_TINTERFACE(IUIStyleResolver,Subscriber);
        P_FINISH;
        RemoveStyleSubscriber(Subscriber);
    }
    DECLARE_FUNCTION(execFindStyleSubscriberIndex)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        *(INT*)Result=FindStyleSubscriberIndex(Subscriber);
    }
    DECLARE_FUNCTION(execFindStyleSubscriberIndexById)
    {
        P_GET_NAME(StyleSubscriberId);
        P_FINISH;
        *(INT*)Result=FindStyleSubscriberIndexById(StyleSubscriberId);
    }
    DECLARE_FUNCTION(execSetWidgetStyleByName)
    {
        P_GET_NAME(StyleResolverTagToSet);
        P_GET_NAME(StyleFriendlyName);
        P_FINISH;
        *(UBOOL*)Result=SetWidgetStyleByName(StyleResolverTagToSet,StyleFriendlyName);
    }
    void delegateOnContextMenuItemSelected(class UUIContextMenu* ContextMenu,INT PlayerIndex,INT ItemIndex)
    {
        UIObject_eventOnContextMenuItemSelected_Parms Parms(EC_EventParm);
        Parms.ContextMenu=ContextMenu;
        Parms.PlayerIndex=PlayerIndex;
        Parms.ItemIndex=ItemIndex;
        ProcessDelegate(ENGINE_OnContextMenuItemSelected,&__OnContextMenuItemSelected__Delegate,&Parms);
    }
    UBOOL delegateOnCloseContextMenu(class UUIContextMenu* ContextMenu,INT PlayerIndex)
    {
        UIObject_eventOnCloseContextMenu_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ContextMenu=ContextMenu;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnCloseContextMenu,&__OnCloseContextMenu__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnOpenContextMenu(class UUIObject* Sender,INT PlayerIndex,class UUIContextMenu*& CustomContextMenu)
    {
        UIObject_eventOnOpenContextMenu_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        Parms.CustomContextMenu=CustomContextMenu;
        ProcessDelegate(ENGINE_OnOpenContextMenu,&__OnOpenContextMenu__Delegate,&Parms);
        CustomContextMenu=Parms.CustomContextMenu;
        return Parms.ReturnValue;
    }
    UBOOL delegateOnQueryToolTip(class UUIObject* Sender,class UUIToolTip*& CustomToolTip)
    {
        UIObject_eventOnQueryToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.CustomToolTip=CustomToolTip;
        ProcessDelegate(ENGINE_OnQueryToolTip,&__OnQueryToolTip__Delegate,&Parms);
        CustomToolTip=Parms.CustomToolTip;
        return Parms.ReturnValue;
    }
    void delegateOnDoubleClick(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnDoubleClick_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnDoubleClick,&__OnDoubleClick__Delegate,&Parms);
    }
    UBOOL delegateOnClicked(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnClicked_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnClicked,&__OnClicked__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnPressRelease(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressRelease_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressRelease,&__OnPressRelease__Delegate,&Parms);
    }
    void delegateOnPressRepeat(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressRepeat_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressRepeat,&__OnPressRepeat__Delegate,&Parms);
    }
    void delegateOnPressed(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressed_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressed,&__OnPressed__Delegate,&Parms);
    }
    UBOOL delegateOnRefreshSubscriberValue(class UUIObject* Sender,INT BindingIndex)
    {
        UIObject_eventOnRefreshSubscriberValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.BindingIndex=BindingIndex;
        ProcessDelegate(ENGINE_OnRefreshSubscriberValue,&__OnRefreshSubscriberValue__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnValueChanged(class UUIObject* Sender,INT PlayerIndex)
    {
        UIObject_eventOnValueChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnValueChanged,&__OnValueChanged__Delegate,&Parms);
    }
    void delegateOnPostSceneUpdate(class UUIObject* Sender)
    {
        UIObject_eventOnPostSceneUpdate_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_OnPostSceneUpdate,&__OnPostSceneUpdate__Delegate,&Parms);
    }
    void delegateOnPreSceneUpdate(class UUIObject* Sender)
    {
        UIObject_eventOnPreSceneUpdate_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_OnPreSceneUpdate,&__OnPreSceneUpdate__Delegate,&Parms);
    }
    void delegateOnCreate(class UUIObject* CreatedWidget,class UUIScreenObject* CreatorContainer)
    {
        UIObject_eventOnCreate_Parms Parms(EC_EventParm);
        Parms.CreatedWidget=CreatedWidget;
        Parms.CreatorContainer=CreatorContainer;
        ProcessDelegate(ENGINE_OnCreate,&__OnCreate__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIObject,UUIScreenObject,0|CLASS_Config,Engine)
	/* === UUIObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) {}

	/**
	 * Updates 3D primitives for this widget.
	 *
	 * @param	CanvasScene		the scene to use for updating any 3D primitives
	 */
	virtual void UpdateWidgetPrimitives( FCanvasScene* CanvasScene ) {}

	/**
	 * Allow the widget to do any special rendering after its children have been rendered.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void PostRender_Widget( FCanvas* Canvas );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 * Child classes should override this method when objects need to be added to the StyleSubscribers array
	 */
	virtual void InitializeStyleSubscribers() {}

	/**
	 * Assigns the style for this widget for the property provided and refreshes the widget's styles.
	 *
	 * @param	NewStyle		the new style to assign to this widget
	 * @param	StyleProperty	The style property we are modifying.
	 * @param	ArrayIndex		if the style property corresponds to an array index, specified the array index to apply the style to
	 *
	 * @return	TRUE if the style was successfully applied to this widget.
	 */
	UBOOL SetWidgetStyle( class UUIStyle* NewStyle, FStyleReferenceId StyleProperty=FStyleReferenceId(), INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the style references contained by this widget from the currently active skin.
	 *
	 * @param	bClearExistingValue		if TRUE, style references will be invalidated first.
	 * @param	StyleProperty			if specified, only the style reference corresponding to the specified property
	 *									will be resolved; otherwise, all style references will be resolved.
	 *
	 * @return	TRUE if all style references were successfully resolved.
	 */
	UBOOL ResolveStyles( UBOOL bClearExistingValue, FStyleReferenceId StyleProperty=FStyleReferenceId() );

protected:
	friend class UUISkin;

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( class UUIStyle* ResolvedStyle, const FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:
	/**
	 * Retrieves the list of UIStyleReferences contained by this widget class.  Used to refresh the style data for all style
	 * references contained by this widget whenever the active skin or menu state is changed.
	 *
	 * @param	out_StyleReferences		a map of style property references to UIStyleReference values for the style references contained by this class and
	 *									its StyleSubscribers
	 * @param	TargetStyleRef			if specified, only style references associated with the value specified will be added to the map.
	 * @param	SearchObject			the object to search for style reference properties in; if NULL, searches only in this object; specify INVALID_OBJECT to
	 *									search in this object as well as all subscribed style resolvers
	 */
	void GetStyleReferences( TMultiMap<FStyleReferenceId,FUIStyleReference*>& out_StyleReferences, FStyleReferenceId TargetStyleRef=FStyleReferenceId(), UObject* SearchObject=NULL );

	/**
	 * Retrieves the list of UIStyleReference properties contained by this widget class.
	 *
	 * @param	out_StyleReferences		a list of the style references contained by this class
	 * @param	SearchObject			the object to search for style reference properties in; if NULL, searches only in this object; specify INVALID_OBJECT to
	 *									search in this object as well as all subscribed style resolvers
	 */
	void GetStyleReferenceProperties( TArray<FStyleReferenceId>& out_StyleProperties, UObject* SearchObject=NULL );

	/**
	 * Retrieves the list of data store bindings contained by this widget class.
	 *
	 * @param	out_DataBindings		a map of data binding property name to UIDataStoreBinding values for the data bindings contained by this class
	 * @param	TargetPropertyName		if specified, only data bindings associated with the property specified will be added to the map.
	 */
	void GetDataBindings( TMultiMap<FName,FUIDataStoreBinding*>& out_DataBindings, const FName TargetPropertyName=NAME_None );

	/**
	 * Retrieves the list of UIDataStoreBinding properties contained by this widget class.
	 *
	 * @param	out_DataBindingProperties	a list of the data store binding properties contained by this class
	 */
	void GetDataBindingProperties( TArray<class UProperty*>& out_DataBindingProperties );

	/**
	 * Determines whether the specified data binding property should be displayed in the list of data bindings in this
	 * widget's data binding context menu.  Called only in the editor.
	 *
	 * @param	DataBindingProperty		a data binding property from this class
	 *
	 * @return	TRUE if this property should be included in the data binding context menu for this widget; FALSE if not.
	 */
	virtual UBOOL AllowDataBindingProperty( UProperty* DataBindingProperty ) const { return TRUE; }

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState=NULL );

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle );

	/**
	 * Verifies that this widget has a valid WIDGET_ID, and generates one if it doesn't.
	 */
	void ValidateWidgetID();

	/**
	 * @param Point	Point to check against the renderbounds of the object.
	 * @return Whether or not this screen object contains the point passed in within its renderbounds.
	 */
	virtual UBOOL ContainsPoint(const FVector2D& Point) const;

	/**
	 * Projects the vertices made from all faces of this widget and stores the results in the RenderBoundsVertices array.
	 *
	 * @param	bRecursive	specify TRUE to propagate this call to all children of this widget.
	 */
	void UpdateRenderBoundsVertices( UBOOL bRecursive=TRUE );

	/* === UUIScreenObject interface === */
	/**
	 * Returns the UIScreenObject that owns this widget.
	 */
	virtual UUIScreenObject* GetParent() const
	{
		return Owner != NULL ? Owner : (UUIScreenObject*)OwnerScene;
	}

	/**
	 * Returns the UIObject that owns this widget.
	 */
	virtual UUIObject* GetOwner() const			{ return Owner; }

	/**
	 * Get the scene that owns this widget.
	 */
	virtual UUIScene* GetScene() 				{ return OwnerScene; }

	/**
	 * Get the scene that owns this widget.
	 */
	virtual const UUIScene* GetScene() const	{ return OwnerScene; }

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const				{ return WidgetTag; }

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const;

	/** get the currently active skin */
	class UUISkin* GetActiveSkin() const;

	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Notification that this widget's parent is about to remove this widget from its children array.  Allows the widget
	 * to clean up any references to the old parent.
	 *
	 * @param	WidgetOwner		the screen object that this widget was removed from.
	 * @param	ExclusionSet	allows the caller to specify a group of widgets which should not have inter-references (i.e. references
	 *							to other objects in the set)
	 */
	virtual void NotifyRemovedFromParent( UUIScreenObject* WidgetOwner, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged();

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Called from UGameUISceneClient::UpdateMousePosition; provides a hook for widgets to respond to the precise cursor
	 * position.  Only called on the scene's ActiveControl if the ActiveControl's bEnableActiveCursorUpdates is TRUE and
	 * the mouse is currently over the widget.
	 *
	 * @param	MousePos	the current position of the mouse, in absolute screen pixels.
	 */
	virtual void NotifyMouseOver( const FVector2D& MousePos ) {}

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Iterates through the DefaultStates array checking that InactiveStates contains at least one instance of each
	 * DefaultState.  If no instances are found, one is created and added to the InactiveStates array.
	 *
	 * This version handles NOT instancing states that shouldn't be instances (such as the focused state if bNeverFocus == true)
	 */
	virtual void CreateDefaultStates();

	/**
	 * Verifies that this widget only contains instances of the focused state if it is eligible to receive focus.
	 *
	 * @param	bInstanceIfMissing	if this widget is eligible to receive focus and contains the focused state in its
	 *								DefaultStates array but not in the InactiveStates array, will instance the state and add it.
	 */
	void ValidateFocusStateInstances( UBOOL bInstanceIfMissing=TRUE );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Determines whether this widget should process the specified input event + state.  If the widget is configured
	 * to respond to this combination of input key/state, any actions associated with this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate();

	/**
	 * Flag the scene to recalculate its PlayerInputMask at the beginning of the next tick.
	 */
	virtual void RequestSceneInputMaskUpdate();

	/**
	 * Flag the scene to recalculate the value of bSupportsRotation during the next tick.
	 */
	void RequestRotationSupportUpdate() const;

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage );

	/**
	 * Sets the actual navigation target for the specified face.  If the new value is different from the current value,
	 * requests the owning scene to update the navigation links for the entire scene.
	 *
	 * @param	Face			the face to set the navigation link for
	 * @param	NewNavTarget	the widget to set as the link for the specified face
	 *
	 * @return	TRUE if the nav link was successfully set.
	 */
	virtual UBOOL SetNavigationTarget( UUIObject* LeftTarget, UUIObject* TopTarget, UUIObject* RightTarget, UUIObject* BottomTarget );

	/**
	 * Sets the designer-specified navigation target for the specified face.  When navigation links for the scene are rebuilt,
	 * the designer-specified navigation target will always override any auto-calculated targets.  If the new value is different from the current value,
	 * requests the owning scene to update the navigation links for the entire scene.
	 *
	 * @param	Face				the face to set the navigation link for
	 * @param	NavTarget			the widget to set as the link for the specified face
	 * @param	bIsNullOverride		if NavTarget is NULL, specify TRUE to indicate that this face's nav target should not
	 *								be automatically calculated.
	 *
	 * @return	TRUE if the nav link was successfully set.
	 */
	virtual UBOOL SetForcedNavigationTarget( UUIObject* LeftTarget, UUIObject* TopTarget, UUIObject* RightTarget, UUIObject* BottomTarget );

	/**
	 * Gets the navigation target for the specified face.  If a designer-specified nav target is set for the specified face,
	 * that object is returned.
	 *
	 * @param	Face		the face to get the nav target for
	 * @param	LinkType	specifies which navigation link type to return.
	 *							NAVLINK_MAX: 		return the designer specified navigation target, if set; otherwise returns the auto-generated navigation target
	 *							NAVLINK_Automatic:	return the auto-generated navigation target, even if the designer specified nav target is set
	 *							NAVLINK_Manual:		return the designer specified nav target, even if it isn't set
	 *
	 * @return	a pointer to a widget that will be the navigation target for the specified direction, or NULL if there is
	 *			no nav target for that face.
	 */
	UUIObject* GetNavigationTarget( EUIWidgetFace Face, ENavigationLinkType LinkType=NAVLINK_MAX ) const;

	/**
	 * Determines if the specified widget is a valid candidate for being the nav target for the specified face of this widget.
	 *
	 * @param	Face			the face that we'd be assigning NewNavTarget to
	 * @param	NewNavTarget	the widget that we'd like to make the nav target for that face
	 *
	 * @return	TRUE if NewNavTarget is allowed to be the navigation target for the specified face of this widget.
	 */
	virtual UBOOL IsValidNavigationTarget( EUIWidgetFace Face, UUIObject* NewNavTarget ) const;

	/**
	 * Determines whether the specified widget can be set as a docking target for the specified face.
	 *
	 * @param	SourceFace		the face on this widget that the potential dock source
	 * @param	Target			the potential docking target
	 * @param	TargetFace		the face on the target widget that we want to check for
	 *
	 * @return	TRUE if a docking link can be safely established between SourceFace and TargetFace.
	 */
	UBOOL IsValidDockTarget( EUIWidgetFace SourceFace, UUIObject* Target, EUIWidgetFace TargetFace );

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	void UpdateScene();

	/**
	 * Called immediately before and after the scene perform an update.  Only called if bEnableSceneUpdateNotifications
	 * is set to TRUE on this widget.
	 *
	 * Default implementation simply calls the script delegates.
	 */
	virtual void PreSceneUpdate();
	virtual void PostSceneUpdate();

	/**
	 * Retrieves the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to retrieve
	 * @param	out_CurrentValue	receives the current data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_GetValue( BYTE AnimationType, FUIAnimationRawData& out_CurrentValue ) const;
	/**
	 * Updates the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to set
	 * @param	out_CurrentValue	contains the updated data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_SetValue( BYTE AnimationType, const FUIAnimationRawData& NewValue );

	/**
	 * Accessor for retrieving the PostProcessSettings struct used for interpolating PP effects.
	 *
	 * @param	CurrentSettings		receives the current PostProcessSettings that should be used for PP effect animation.
	 *
	 * @return	TRUE if this widget supports animation of post-processing and filled in the value of CurrentSettings.
	 */
	virtual UBOOL AnimGetCurrentPPSettings( FPostProcessSettings*& CurrentSettings )
	{
		return FALSE;
	}

	/**
	 * Adds docking nodes for all faces of this widget to the specified scene
	 *
	 * @param	DockingStack	the docking stack to add this widget's docking.  Generally the scene's DockingStack.
	 *
	 * @return	TRUE if docking nodes were successfully added for all faces of this widget.
	 */
	virtual UBOOL AddDockingLink( TLookupMap<FUIDockingNode>& DockingStack );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	INT GetNumResolvedFaces() const;

	/**
	 * @return	TRUE if all faces in this widget are resolved.
	 */
	UBOOL HasResolvedAllFaces() const
	{
		return GetNumResolvedFaces() == UIFACE_MAX;
	}

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const
	{
		return DockTargets.IsResolved(Face);
	}

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Adds the specified state to the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new state for the widget
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivateState( class UUIState* StateToActivate, INT PlayerIndex );

	/**
	 * Changes the specified preview state on the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new preview state for the widget to apply within the Editor
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new preview state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivatePreviewState( class UUIState* StateToActivate );

	/**
	 * Removes the specified state from the screen object's state stack and refreshes the widget's style using the new state.
	 *
	 * @param	StateToRemove	the state to be removed
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the state was successfully removed, or if the state didn't exist in the widget's list of states;
	 *			false if the state overrode the request to be removed
	 */
	virtual UBOOL DeactivateState( class UUIState* StateToRemove, INT PlayerIndex );

	/**
	 * Propagates the enabled state of this widget to its child widgets, if the widget has the PRIVATE_PropageteState flag set.
	 *
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bForce			specify TRUE to propagate the enabled state even if this widget doesn't have the PropagateState flag set.
	 *
	 * @return	TRUE if child widget states were set successfully.
	 */
	virtual UBOOL ConditionalPropagateEnabledState( INT PlayerIndex, UBOOL bForce=FALSE );

	/**
	 * Activates the tooltip associated with this widget.  Called when this widget (or one of its Children) becomes
	 * the scene client's ActiveControl.  If this widget doesn't support tool-tips or does not have a valid tool-tip
	 * binding, the call is propagated upwards to the parent widget.
	 *
	 * @return	a pointer to the tool-tip that was activated.  This value will be stored in the scene's ActiveToolTip member.
	 */
	class UUIToolTip* ActivateToolTip();

	/**
	 * Activates the context menu for this widget, if it has one.  Called when the user right-clicks (or whatever input key
	 * is configured to activate the ShowContextMenu UI input alias) while this widget (or one of its Children) is the
	 * scene client's ActiveControl.
	 *
	 * @return	a pointer to the context menu that was activated.  This value will be stored in the scene's ActiveContextMenu member.
	 */
	class UUIContextMenu* ActivateContextMenu( INT PlayerIndex );

protected:
	/**
	 * Activates the focus hint widget for this object; child classes which override this method should set the position of the focus hint
	 * as well as any other properties necessary for correctly displaying the focus hint for this widget.
	 *
	 * @param	FocusHintObject		reference to the widget that supplies the focus hint.
	 *
	 * @return	TRUE if the focus hint object was initialized / repositioned by this widget; FALSE if this widget doesn't support focus hints.
	 */
	virtual UBOOL AttachFocusHint( class UUIObject* FocusHintObject );

public:

	/**
	 * Gets the value of this widget's PlayerInputMask.
	 *
	 * @param	bInheritedMaskOnly		specify TRUE to return only the mask that was set by this widget's owner scene.
	 * @param	bOverrideMaskOnly		specify TRUE to return only the mask that was set manually for this widget, in which case whatever
	 *									value was passed for bInheritedMaskOnly is ignored.
	 *
	 * @return	a bitmask representing the indices of the players that this widget accepts input from; If both bInheritedMaskOnly
	 *			and bOverrideMaskOnly are FALSE, returns the override mask if there is one, otherwise the inherited mask.
	 */
	virtual BYTE GetInputMask( UBOOL bInheritedMaskOnly=FALSE, UBOOL bOverrideMaskOnly=FALSE ) const;

	/**
	 * Changes the player input mask for this control, which controls which players this control will accept input from.
	 *
	 * @param	NewInputMask	the new mask that should be assigned to this control
	 * @param	bRecurse		if TRUE, calls SetInputMask on all child controls as well.
	 * @param	bForcedOverride	by default, the widget's PlayerInputMask is only changed if it still matches the default value.
	 */
	virtual void SetInputMask( BYTE NewInputMask, UBOOL bRecurse=TRUE, UBOOL bForcedOverride=FALSE );

	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.
	 *
	 * This version converts the deprecated PRIVATE_DisallowReparenting flag to PRIVATE_EditorNoReparent, if set.
	 */
	virtual void PostLoad();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 */
	virtual void PostEditImport();

	/**
	 * Called after this widget is renamed; ensures that the widget's tag matches the name of the widget.
	 */
	virtual void PostRename();
};

#define UCONST_ConsolePromptText TEXT("(> ")

class UConsoleEntry : public UUIObject
{
public:
    //## BEGIN PROPS ConsoleEntry
    class UUILabel* ConsolePromptLabel;
    class UUIImage* ConsolePromptBackground;
    class UUIEditBox* InputBox;
    class UUIImage* LowerConsoleBorder;
    class UUIImage* UpperConsoleBorder;
    INT CursorPosition;
    BITFIELD bRenderCursor:1;
    //## END PROPS ConsoleEntry

    DECLARE_CLASS(UConsoleEntry,UUIObject,0|CLASS_Config,Engine)
	/**
	 * Initializes the button and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) {}	// do nothing

	/**
	 * Perform any additional rendering after this widget's children have been rendered.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void PostRender_Widget( FCanvas* Canvas );
};

class UUIButton : public UUIObject
{
public:
    //## BEGIN PROPS UIButton
    class UUIComp_DrawImage* BackgroundImageComponent;
    FName ClickedCue;
    //## END PROPS UIButton

    DECLARE_CLASS(UUIButton,UUIObject,0|CLASS_Config,Engine)
	/* === UIButton interface === */
	/**
	 * Changes the background image for this button, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetImage( class USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Render this button.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:
	/**
	 * Handles input events for this button.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated ButtonBackground,
	 * Coordinates, and PrimaryStyle properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUICheckbox : public UUIButton, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UICheckbox
    FName CheckedCue;
    FName UncheckedCue;
    struct FUIDataStoreBinding ValueDataSource;
    class UUIComp_DrawImage* CheckedImageComponent;
    BITFIELD bIsChecked:1;
    //## END PROPS UICheckbox

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    virtual void SetValue(UBOOL bShouldBeChecked,INT PlayerIndex=-1);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_UBOOL(bShouldBeChecked);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        SetValue(bShouldBeChecked,PlayerIndex);
    }
    DECLARE_CLASS(UUICheckbox,UUIButton,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIScreenObject interface === */
	/**
	 * Render this checkbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Changes the checked image for this checkbox, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetCheckImage( class USurface* NewImage );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the CheckedImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

protected:

	/**
	 * Handles input events for this checkbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated CheckedImage,
	 * CheckCoordinates, and CheckedStyle properties over to the CheckedImageComponent.
	 */
	virtual void PostLoad();
};

struct UILabelButton_eventGetCaption_Parms
{
    FString ReturnValue;
    UILabelButton_eventGetCaption_Parms(EEventParm)
    {
    }
};
class UUILabelButton : public UUIButton, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UILabelButton
    struct FUIDataStoreBinding CaptionDataSource;
    class UUIComp_DrawString* StringRenderComponent;
    //## END PROPS UILabelButton

    virtual void SetCaption(const FString& NewText);
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetCaption)
    {
        P_GET_STR(NewText);
        P_FINISH;
        SetCaption(NewText);
    }
    DECLARE_FUNCTION(execSetTextAlignment)
    {
        P_GET_BYTE(Horizontal);
        P_GET_BYTE(Vertical);
        P_FINISH;
        SetTextAlignment(Horizontal,Vertical);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    FString eventGetCaption()
    {
        UILabelButton_eventGetCaption_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetCaption),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUILabelButton,UUIButton,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bIncludesViewportOrigin
	 *							TRUE indicates that the value is relative to the 0,0 on the screen (or absolute position); FALSE to indicate
	 *							the value is relative to the viewport's origin.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bIncludesViewportOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bIncludesViewportOrigin, bClampValues);
	}

	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates the PrimaryStyle for this label over to the label's component.
	 */
	virtual void PostLoad();
};

struct UICalloutButton_eventGenerateCompleteCaptionMarkup_Parms
{
    FName InputAlias;
    FString ReturnValue;
    UICalloutButton_eventGenerateCompleteCaptionMarkup_Parms(EEventParm)
    {
    }
};
struct UICalloutButton_eventGetCalloutMarkupString_Parms
{
    FName AlternateInputAlias;
    FString ReturnValue;
    UICalloutButton_eventGetCalloutMarkupString_Parms(EEventParm)
    {
    }
};
struct UICalloutButton_eventGetCalloutDataStoreName_Parms
{
    FName ReturnValue;
    UICalloutButton_eventGetCalloutDataStoreName_Parms(EEventParm)
    {
    }
};
struct UICalloutButton_eventSetInputAlias_Parms
{
    FName NewInputAlias;
    UBOOL ReturnValue;
    UICalloutButton_eventSetInputAlias_Parms(EEventParm)
    {
    }
};
class UUICalloutButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UICalloutButton
    FStringNoInit DefaultMarkupStringTemplate;
    FName CalloutDataStoreTag;
    FName InputAliasTag;
    BYTE IconAlignment;
    BITFIELD bSupportsButtonRepeat:1 GCC_BITFIELD_MAGIC;
    BITFIELD bPlayErrorSoundWhenDisabled:1;
    //## END PROPS UICalloutButton

    class UUIDataStore_InputAlias* GetCalloutDataStore(class ULocalPlayer* AlternatePlayer=NULL);
    void SetInputTag(FName NewInputAlias);
    UBOOL SubscribeToInputProxy(class UUIEvent_CalloutButtonInputProxy* InputProxy,UBOOL bUpdateProxyOutputLinks=TRUE,INT PlayerIndex=-1);
    UBOOL UnsubscribeFromInputProxy(class UUIEvent_CalloutButtonInputProxy* InputProxy,UBOOL bUpdateProxyOutputLinks=TRUE,INT PlayerIndex=-1);
    virtual UBOOL OnReceivedInputKey(const struct FInputEventParameters& EventParms);
    DECLARE_FUNCTION(execGetCalloutDataStore)
    {
        P_GET_OBJECT_OPTX(ULocalPlayer,AlternatePlayer,NULL);
        P_FINISH;
        *(class UUIDataStore_InputAlias**)Result=GetCalloutDataStore(AlternatePlayer);
    }
    DECLARE_FUNCTION(execSetInputTag)
    {
        P_GET_NAME(NewInputAlias);
        P_FINISH;
        SetInputTag(NewInputAlias);
    }
    DECLARE_FUNCTION(execSubscribeToInputProxy)
    {
        P_GET_OBJECT(UUIEvent_CalloutButtonInputProxy,InputProxy);
        P_GET_UBOOL_OPTX(bUpdateProxyOutputLinks,TRUE);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SubscribeToInputProxy(InputProxy,bUpdateProxyOutputLinks,PlayerIndex);
    }
    DECLARE_FUNCTION(execUnsubscribeFromInputProxy)
    {
        P_GET_OBJECT(UUIEvent_CalloutButtonInputProxy,InputProxy);
        P_GET_UBOOL_OPTX(bUpdateProxyOutputLinks,TRUE);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=UnsubscribeFromInputProxy(InputProxy,bUpdateProxyOutputLinks,PlayerIndex);
    }
    DECLARE_FUNCTION(execOnReceivedInputKey)
    {
        P_GET_STRUCT_REF(struct FInputEventParameters,EventParms);
        P_FINISH;
        *(UBOOL*)Result=OnReceivedInputKey(EventParms);
    }
    FString eventGenerateCompleteCaptionMarkup(FName InputAlias=NAME_None)
    {
        UICalloutButton_eventGenerateCompleteCaptionMarkup_Parms Parms(EC_EventParm);
        Parms.InputAlias=InputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateCompleteCaptionMarkup),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGetCalloutMarkupString(FName AlternateInputAlias=NAME_None)
    {
        UICalloutButton_eventGetCalloutMarkupString_Parms Parms(EC_EventParm);
        Parms.AlternateInputAlias=AlternateInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCalloutMarkupString),&Parms);
        return Parms.ReturnValue;
    }
    FName eventGetCalloutDataStoreName()
    {
        UICalloutButton_eventGetCalloutDataStoreName_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NAME_None;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCalloutDataStoreName),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetInputAlias(FName NewInputAlias)
    {
        UICalloutButton_eventSetInputAlias_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInputAlias=NewInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_SetInputAlias),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUICalloutButton,UUILabelButton,0|CLASS_Config,Engine)
	/* === UUIObject interface === */
	/**
	 * Adds the specified state to the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new state for the widget
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivateState( class UUIState* StateToActivate, INT PlayerIndex );

	/**
	 * Changes the player input mask for this control, which controls which players this control will accept input from.
	 *
	 * @param	NewInputMask	the new mask that should be assigned to this control
	 * @param	bRecurse		if TRUE, calls SetInputMask on all child controls as well.
	 * @param	bForcedOverride	by default, the widget's PlayerInputMask is only changed if it still matches the default value.
	 */
	virtual void SetInputMask( BYTE NewInputMask, UBOOL bRecurse=TRUE, UBOOL bForcedOverride=FALSE );

	/** === UIDataStoreSubscriber interface === */
	/**
	 * Sets the data store binding for this object to the text specified.
	 *
	 * @param	MarkupText			a markup string which resolves to data exposed by a data store.  The expected format is:
	 *								<DataStoreTag:DataFieldTag>
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 */
	virtual void SetDataStoreBinding( const FString& MarkupText, INT BindingIndex=INDEX_NONE );

	/**
	 * Sets the data store binding for this object to the text specified.
	 *
	 * @param	MarkupText			a markup string which resolves to data exposed by a data store.  The expected format is:
	 *								<DataStoreTag:DataFieldTag>
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 */
	virtual UBOOL RefreshSubscriberValue( INT BindingIndex=INDEX_NONE );

	/* === UObject interface === */
//	/**
//	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
//	 */
//	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );
//
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

struct UITabButton_eventIsActivationAllowed_Parms
{
    class UUITabButton* Sender;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UITabButton_eventIsActivationAllowed_Parms(EEventParm)
    {
    }
};
class UUITabButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UITabButton
    class UUITabPage* TabPage;
    FScriptDelegate __IsActivationAllowed__Delegate;
    //## END PROPS UITabButton

    virtual UBOOL CanActivateButton(INT PlayerIndex);
    DECLARE_FUNCTION(execCanActivateButton)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=CanActivateButton(PlayerIndex);
    }
    DECLARE_FUNCTION(execIsTargeted);
    UBOOL delegateIsActivationAllowed(class UUITabButton* Sender,INT PlayerIndex)
    {
        UITabButton_eventIsActivationAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_IsActivationAllowed,&__IsActivationAllowed__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUITabButton,UUILabelButton,0|CLASS_Config,Engine)
	/* === UUITabButton interface === */
	/**
	 * Returns TRUE if this widget has a UIState_TargetedTab object in its StateStack
	 *
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsTargeted( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/* === UUIScreenObject interface === */
	/**
	 * Called when this widget is created.  Copies the style data from the owning tab control into this button's
	 * string and image rendering components, then calls InitializeStyleSubscribers.  This is necessary because tab control
	 * manages the styles for tab buttons - initialization of the style data is handled by the tab control for existing tab
	 * buttons, but for new tab buttons being added to the tab control we need to perform this step ourselves.
	 */
	virtual void Created( UUIScreenObject* Creator );

protected:
	/**
	 * Handles input events for this button.
	 *
	 * This version ignores input if the tab button's owner doesn't allow targetting mode.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

};

class UUIToggleButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UIToggleButton
    struct FUIDataStoreBinding ValueDataSource;
    BITFIELD bIsChecked:1;
    class UUIComp_DrawString* CheckedStringRenderComponent;
    class UUIComp_DrawImage* CheckedBackgroundImageComponent;
    //## END PROPS UIToggleButton

    virtual void SetCaption(const FString& NewText);
    void SetValue(UBOOL bShouldBeChecked,INT PlayerIndex=-1);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_UBOOL(bShouldBeChecked);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        SetValue(bShouldBeChecked,PlayerIndex);
    }
    DECLARE_CLASS(UUIToggleButton,UUILabelButton,0|CLASS_Config,Engine)
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @param	BindingIndex		indicates which data store binding should be modified.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);
	/**
	 * Retrieves the list of data stores bound by this subscriber.
	 *
	 * @param	out_BoundDataStores		receives the array of data stores that subscriber is bound to.
	 */
	virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
	/**
	 * Notifies this subscriber to unbind itself from all bound data stores
	 */
	virtual void ClearBoundDataStores();
	/** Saves the value for this subscriber. */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);

protected:

	/**
	 * Handles input events for this checkbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUINumericEditBoxButton : public UUIButton
{
public:
    //## BEGIN PROPS UINumericEditBoxButton
    //## END PROPS UINumericEditBoxButton

    DECLARE_CLASS(UUINumericEditBoxButton,UUIButton,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUINumericEditBoxButton)
};

class UUIOptionListButton : public UUIButton
{
public:
    //## BEGIN PROPS UIOptionListButton
    //## END PROPS UIOptionListButton

    void UpdateButtonState(INT PlayerIndex=-1);
    DECLARE_FUNCTION(execUpdateButtonState)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        UpdateButtonState(PlayerIndex);
    }
    DECLARE_CLASS(UUIOptionListButton,UUIButton,0|CLASS_Config,Engine)
    DECLARE_WITHIN(UUIOptionListBase)
    NO_DEFAULT_CONSTRUCTOR(UUIOptionListButton)
};

class UUIScrollbarButton : public UUIButton
{
public:
    //## BEGIN PROPS UIScrollbarButton
    //## END PROPS UIScrollbarButton

    DECLARE_CLASS(UUIScrollbarButton,UUIButton,0|CLASS_Config,Engine)
    DECLARE_WITHIN(UUIScrollbar)
    NO_DEFAULT_CONSTRUCTOR(UUIScrollbarButton)
};

struct UIScrollbarMarkerButton_eventOnButtonDragged_Parms
{
    class UUIScrollbarMarkerButton* Sender;
    INT PlayerIndex;
    UIScrollbarMarkerButton_eventOnButtonDragged_Parms(EEventParm)
    {
    }
};
class UUIScrollbarMarkerButton : public UUIScrollbarButton
{
public:
    //## BEGIN PROPS UIScrollbarMarkerButton
    FScriptDelegate __OnButtonDragged__Delegate;
    //## END PROPS UIScrollbarMarkerButton

    void delegateOnButtonDragged(class UUIScrollbarMarkerButton* Sender,INT PlayerIndex)
    {
        UIScrollbarMarkerButton_eventOnButtonDragged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnButtonDragged,&__OnButtonDragged__Delegate,&Parms);
    }
    DECLARE_CLASS(UUIScrollbarMarkerButton,UUIScrollbarButton,0|CLASS_Config,Engine)
	/* === UUIObject interface === */
	/**
	 * Function overwritten to autoposition the scrollbar within the owner widget
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/* === UUIScreenObject interface === */
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

	/**
	 * Determines whether this widget should process the specified axis input event (mouse/joystick movement).
	 * If the widget is configured to respond to this axis input event, any actions associated with
	 * this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );
};

#define UCONST_COMBO_CAPTION_DATABINDING_INDEX 1
#define UCONST_INDEX_CHANGED_NOTIFY_MASK 0x2
#define UCONST_TEXT_CHANGED_NOTIFY_MASK 0x1

struct UIComboBox_eventHideList_Parms
{
    INT PlayerIndex;
    UIComboBox_eventHideList_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventShowList_Parms
{
    INT PlayerIndex;
    UIComboBox_eventShowList_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventCreateCustomComboList_Parms
{
    class UUIComboBox* ListOwner;
    class UUIList* ReturnValue;
    UIComboBox_eventCreateCustomComboList_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventCreateCustomComboButton_Parms
{
    class UUIComboBox* ButtonOwner;
    class UUIToggleButton* ReturnValue;
    UIComboBox_eventCreateCustomComboButton_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventCreateCustomComboEditbox_Parms
{
    class UUIComboBox* EditboxOwner;
    class UUIEditBox* ReturnValue;
    UIComboBox_eventCreateCustomComboEditbox_Parms(EEventParm)
    {
    }
};
class UUIComboBox : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIComboBox
    class UClass* ComboEditboxClass;
    class UClass* ComboButtonClass;
    class UClass* ComboListClass;
    class UUIEditBox* ComboEditbox;
    class UUIToggleButton* ComboButton;
    class UUIList* ComboList;
    class UUIComp_DrawCaption* CaptionRenderComponent;
    class UUIComp_DrawImage* BackgroundRenderComponent;
    struct FUIDataStoreBinding CaptionDataSource;
    FName OpenList;
    FName DecrementCue;
    BITFIELD bDockListToButton:1;
    FScriptDelegate __CreateCustomComboEditbox__Delegate;
    FScriptDelegate __CreateCustomComboButton__Delegate;
    FScriptDelegate __CreateCustomComboList__Delegate;
    //## END PROPS UIComboBox

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    void eventHideList(INT PlayerIndex=0)
    {
        UIComboBox_eventHideList_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_HideList),&Parms);
    }
    void eventShowList(INT PlayerIndex=0)
    {
        UIComboBox_eventShowList_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowList),&Parms);
    }
    class UUIList* delegateCreateCustomComboList(class UUIComboBox* ListOwner)
    {
        UIComboBox_eventCreateCustomComboList_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ListOwner=ListOwner;
        ProcessDelegate(ENGINE_CreateCustomComboList,&__CreateCustomComboList__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIToggleButton* delegateCreateCustomComboButton(class UUIComboBox* ButtonOwner)
    {
        UIComboBox_eventCreateCustomComboButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ButtonOwner=ButtonOwner;
        ProcessDelegate(ENGINE_CreateCustomComboButton,&__CreateCustomComboButton__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIEditBox* delegateCreateCustomComboEditbox(class UUIComboBox* EditboxOwner)
    {
        UIComboBox_eventCreateCustomComboEditbox_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.EditboxOwner=EditboxOwner;
        ProcessDelegate(ENGINE_CreateCustomComboEditbox,&__CreateCustomComboEditbox__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIComboBox,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIComboBox interface === */
	/**
	 * Creates the support controls which make up the combo box - the list, button, and editbox.
	 */
	virtual void CreateInternalControls();

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Called whenever the selected item is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

protected:
	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/**
	 * Activates the focused state for this widget and sets it to be the focused control of its parent (if applicable)
	 *
	 * @param	Sender		Control that called SetFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the specified child of this widget.
	 *
	 * @param	ChildToFocus	the child to set focus to.  If not specified, attempts to set focus to the most elibible child,
	 *							as determined by navigation links and FocusPropagation values.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL SetFocusToChild(class UUIObject* ChildToFocus=NULL,INT PlayerIndex=0);

	/**
	 * Deactivates the focused state for this widget.
	 *
	 * @param	Sender			the control that called KillFocus.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL KillFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);


	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * Creates the components of this combobox, if necessary.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Assigns values to the links which are used for navigating through this widget using the keyboard.  Sets the first and
	 * last focus targets for this widget as well as the next/prev focus targets for all children of this widget.
	 *
	 * @return	TRUE if any sibling navigation links were created.
	 */
	virtual UBOOL RebuildKeyboardNavigationLinks();

	/**
	 * Adds the specified face to the DockingStack, along with any dependencies that face might have.
	 *
	 * This version routes the call to the CaptionRenderComponent, if applicable.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Render this widget.  This version routes the render call to the draw components, if applicable.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

protected:
	/**
	 * Handles input events for this slider.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUIContainer : public UUIObject
{
public:
    //## BEGIN PROPS UIContainer
    class UUIComp_AutoAlignment* AutoAlignment;
    //## END PROPS UIContainer

    DECLARE_CLASS(UUIContainer,UUIObject,0|CLASS_Config,Engine)
	/* === UUIScreenObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) {}

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

struct UICalloutButtonPanel_eventCanButtonAcceptFocus_Parms
{
    FName InputAliasTag;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventCanButtonAcceptFocus_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventContainsButton_Parms
{
    FName ButtonInputAlias;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventContainsButton_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventFindButtonIndex_Parms
{
    FName ButtonInputAlias;
    INT ReturnValue;
    UICalloutButtonPanel_eventFindButtonIndex_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventFindButton_Parms
{
    FName ButtonInputAlias;
    class UUICalloutButton* ReturnValue;
    UICalloutButtonPanel_eventFindButton_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventEnableButton_Parms
{
    FName ButtonInputAlias;
    INT PlayerIndex;
    UBOOL bEnableButton;
    UBOOL bUpdateButtonVisibility;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventEnableButton_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventShowButton_Parms
{
    FName ButtonInputAlias;
    UBOOL bShowButton;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventShowButton_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventSetButtonCallback_Parms
{
    FName ButtonInputAlias;
    FScriptDelegate NewClickHandler;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventSetButtonCallback_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventSetButtonInputAlias_Parms
{
    FName ButtonInputAlias;
    FName NewButtonInputAlias;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventSetButtonInputAlias_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventSetButtonCaption_Parms
{
    FName ButtonInputAlias;
    FString NewButtonCaption;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventSetButtonCaption_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventRemoveAllButtons_Parms
{
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventRemoveAllButtons_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventRemoveButtonByAlias_Parms
{
    FName ButtonInputAlias;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventRemoveButtonByAlias_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventRemoveButton_Parms
{
    class UUICalloutButton* ButtonToRemove;
    UBOOL ReturnValue;
    UICalloutButtonPanel_eventRemoveButton_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventInsertButton_Parms
{
    class UUICalloutButton* NewButton;
    INT ReturnValue;
    UICalloutButtonPanel_eventInsertButton_Parms(EEventParm)
    {
    }
};
struct UICalloutButtonPanel_eventSynchronizeInputAliases_Parms
{
    UICalloutButtonPanel_eventSynchronizeInputAliases_Parms(EEventParm)
    {
    }
};
class UUICalloutButtonPanel : public UUIContainer
{
public:
    //## BEGIN PROPS UICalloutButtonPanel
    class UUICalloutButton* ButtonTemplate;
    TArrayNoInit<class UUICalloutButton*> CalloutButtons;
    BYTE ButtonBarOrientation;
    BYTE ButtonLayout;
    struct FUIScreenValue_Extent ButtonPadding[2];
    TMap< FName,FName > ButtonInputKeyMappings;
    TArrayNoInit<FName> CalloutButtonAliases;
    BITFIELD bGeneratingInitialButtons:1;
    BITFIELD bSupportsButtonRepeat:1;
private:
    BITFIELD bRefreshButtonDocking:1;
public:
    //## END PROPS UICalloutButtonPanel

    void GetAvailableCalloutButtonAliases(TArray<FName>& AvailableAliases,class ULocalPlayer* PlayerOwner=NULL);
    virtual class UUICalloutButton* CreateCalloutButton(FName ButtonInputAlias,FName ButtonName=NAME_None,UBOOL bInsertChild=TRUE);
    class UUIEvent_CalloutButtonInputProxy* GetCalloutInputProxy(UBOOL bCreateIfNecessary=FALSE);
    virtual INT FindBestInsertionIndex(class UUICalloutButton* ButtonToInsert,UBOOL bSearchChildrenArray=FALSE);
    void RequestButtonDockingUpdate(UBOOL bImmediately=FALSE);
    DECLARE_FUNCTION(execGetAvailableCalloutButtonAliases)
    {
        P_GET_TARRAY_REF(FName,AvailableAliases);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        GetAvailableCalloutButtonAliases(AvailableAliases,PlayerOwner);
    }
    DECLARE_FUNCTION(execCreateCalloutButton)
    {
        P_GET_NAME(ButtonInputAlias);
        P_GET_NAME_OPTX(ButtonName,NAME_None);
        P_GET_UBOOL_OPTX(bInsertChild,TRUE);
        P_FINISH;
        *(class UUICalloutButton**)Result=CreateCalloutButton(ButtonInputAlias,ButtonName,bInsertChild);
    }
    DECLARE_FUNCTION(execGetCalloutInputProxy)
    {
        P_GET_UBOOL_OPTX(bCreateIfNecessary,FALSE);
        P_FINISH;
        *(class UUIEvent_CalloutButtonInputProxy**)Result=GetCalloutInputProxy(bCreateIfNecessary);
    }
    DECLARE_FUNCTION(execFindBestInsertionIndex)
    {
        P_GET_OBJECT(UUICalloutButton,ButtonToInsert);
        P_GET_UBOOL_OPTX(bSearchChildrenArray,FALSE);
        P_FINISH;
        *(INT*)Result=FindBestInsertionIndex(ButtonToInsert,bSearchChildrenArray);
    }
    DECLARE_FUNCTION(execRequestButtonDockingUpdate)
    {
        P_GET_UBOOL_OPTX(bImmediately,FALSE);
        P_FINISH;
        RequestButtonDockingUpdate(bImmediately);
    }
    UBOOL eventCanButtonAcceptFocus(FName InputAliasTag,INT PlayerIndex=0)
    {
        UICalloutButtonPanel_eventCanButtonAcceptFocus_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InputAliasTag=InputAliasTag;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_CanButtonAcceptFocus),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventContainsButton(FName ButtonInputAlias)
    {
        UICalloutButtonPanel_eventContainsButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_ContainsButton),&Parms);
        return Parms.ReturnValue;
    }
    INT eventFindButtonIndex(FName ButtonInputAlias)
    {
        UICalloutButtonPanel_eventFindButtonIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ButtonInputAlias=ButtonInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_FindButtonIndex),&Parms);
        return Parms.ReturnValue;
    }
    class UUICalloutButton* eventFindButton(FName ButtonInputAlias)
    {
        UICalloutButtonPanel_eventFindButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ButtonInputAlias=ButtonInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_FindButton),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventEnableButton(FName ButtonInputAlias,INT PlayerIndex=0,UBOOL bEnableButton=TRUE,UBOOL bUpdateButtonVisibility=TRUE)
    {
        UICalloutButtonPanel_eventEnableButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bEnableButton=bEnableButton ? FIRST_BITFIELD : FALSE;
        Parms.bUpdateButtonVisibility=bUpdateButtonVisibility ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnableButton),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShowButton(FName ButtonInputAlias,UBOOL bShowButton=TRUE)
    {
        UICalloutButtonPanel_eventShowButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        Parms.bShowButton=bShowButton ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowButton),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetButtonCallback(FName ButtonInputAlias,FScriptDelegate NewClickHandler)
    {
        UICalloutButtonPanel_eventSetButtonCallback_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        Parms.NewClickHandler=NewClickHandler;
        ProcessEvent(FindFunctionChecked(ENGINE_SetButtonCallback),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetButtonInputAlias(FName ButtonInputAlias,FName NewButtonInputAlias)
    {
        UICalloutButtonPanel_eventSetButtonInputAlias_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        Parms.NewButtonInputAlias=NewButtonInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_SetButtonInputAlias),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetButtonCaption(FName ButtonInputAlias,const FString& NewButtonCaption)
    {
        UICalloutButtonPanel_eventSetButtonCaption_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        Parms.NewButtonCaption=NewButtonCaption;
        ProcessEvent(FindFunctionChecked(ENGINE_SetButtonCaption),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveAllButtons()
    {
        UICalloutButtonPanel_eventRemoveAllButtons_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveAllButtons),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveButtonByAlias(FName ButtonInputAlias)
    {
        UICalloutButtonPanel_eventRemoveButtonByAlias_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonInputAlias=ButtonInputAlias;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveButtonByAlias),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveButton(class UUICalloutButton* ButtonToRemove)
    {
        UICalloutButtonPanel_eventRemoveButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ButtonToRemove=ButtonToRemove;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveButton),&Parms);
        return Parms.ReturnValue;
    }
    INT eventInsertButton(class UUICalloutButton* NewButton)
    {
        UICalloutButtonPanel_eventInsertButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.NewButton=NewButton;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertButton),&Parms);
        return Parms.ReturnValue;
    }
    void eventSynchronizeInputAliases()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SynchronizeInputAliases),NULL);
    }
    DECLARE_CLASS(UUICalloutButtonPanel,UUIContainer,0|CLASS_Config,Engine)
	/* === UUICalloutButtonPanel interface === */
	/**
	 * Set up the docking links between the callout buttons.
	 */
	virtual void SetupDockingRelationships();

	/* === UUIObject interface === */
	/**
	 * Called immediately before the scene perform an update.  Recalculates the docking relationships between this panel's
	 * buttons.
	 */
	virtual void PreSceneUpdate();

	/**
	 * Called immediately after the scene perform an update.  Positions buttons when the layout mode is centered.
	 */
	virtual void PostSceneUpdate();

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/* === UObject interface === */
//	/**
//	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
//	 */
//	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
//
//	/**
//	 * Called after this object has been completely de-serialized.
//	 */
//	virtual void PostLoad();

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version syncs the CalloutButtonAliases array with the tags of the buttons currently in the CalloutButtons
	 * array, then calls SaveConfig() to publish these tags to the .ini.
	 */
	virtual void PreSave();

	/**
	 * Serializer - this version serializes the lookup map during transactions.
	 */
	virtual void Serialize( FArchive& Ar );
};

struct FCornerSizes
{
    FLOAT TopLeft[2];
    FLOAT TopRight[2];
    FLOAT BottomLeft[2];
    FLOAT BottomRight[2];
    FLOAT TopHeight;
    FLOAT BottomHeight;
    FLOAT CenterLeftWidth;
    FLOAT CenterRightWidth;

    /** Constructors */
    FCornerSizes() {}
    FCornerSizes(EEventParm)
    {
        appMemzero(this, sizeof(FCornerSizes));
    }
};

class UUIFrameBox : public UUIContainer
{
public:
    //## BEGIN PROPS UIFrameBox
    class UUIComp_DrawImage* BackgroundImageComponent[9];
    struct FCornerSizes BackgroundCornerSizes;
    //## END PROPS UIFrameBox

    DECLARE_CLASS(UUIFrameBox,UUIContainer,0|CLASS_Config,Engine)
	/* === UIPanel interface === */
	/**
	 * Changes the background image for one of the image components.
	 *
	 * @param	ImageToSet		The image component we are going to set the image for.
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetBackgroundImage( EFrameBoxImage ImageToSet, class USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Render this button.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUIPanel : public UUIContainer
{
public:
    //## BEGIN PROPS UIPanel
    class UUIComp_DrawImage* BackgroundImageComponent;
    BITFIELD bEnforceClipping:1;
    //## END PROPS UIPanel

    DECLARE_CLASS(UUIPanel,UUIContainer,0|CLASS_Config,Engine)
	/* === UIPanel interface === */
	/**
	 * Changes the background image for this button, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetBackgroundImage( class USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * This version sets a clip mask on the canvas while the children are being rendered.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void Render_Children( FCanvas* Canvas, EUIPostProcessGroup UIPostProcessGroup );


	/**
	 * Render this button.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated PanelBackground,
	 * Coordinates, and PrimaryStyle properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUISafeRegionPanel : public UUIContainer
{
public:
    //## BEGIN PROPS UISafeRegionPanel
    BYTE RegionType;
    FLOAT RegionPercentages[2];
    BITFIELD bForce4x3AspectRatio:1;
    BITFIELD bUseFullRegionIn4x3:1;
    BITFIELD bPrimarySafeRegion:1;
    //## END PROPS UISafeRegionPanel

    DECLARE_CLASS(UUISafeRegionPanel,UUIContainer,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Called at the beginning of the first scene update and propagated to all widgets in the scene.  Provides classes with
	 * an opportunity to initialize anything that couldn't be setup earlier due to lack of a viewport.
	 *
	 * This version sets the scene's PrimarySafeRegionPanel value to this panel if bPrimarySafeRegion is TRUE
	 */
	virtual void PreInitialSceneUpdate();

	/**
	 * Initializes the panel and sets its position to match the safe region.
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * @return Returns TRUE if this widget can be resized, repositioned, or rotated, FALSE otherwise.
	 */
	virtual UBOOL IsTransformable() const
	{
		return FALSE;
	}

	/**
	 * Performs the actual alignment
	 */
	virtual void AlignPanel();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

struct UIScrollFrame_eventScrollZoneClicked_Parms
{
    class UUIScrollbar* Sender;
    FLOAT PositionPerc;
    INT PlayerIndex;
    UIScrollFrame_eventScrollZoneClicked_Parms(EEventParm)
    {
    }
};
class UUIScrollFrame : public UUIContainer
{
public:
    //## BEGIN PROPS UIScrollFrame
    class UUIComp_DrawImage* StaticBackgroundImage;
    class UUIScrollbar* ScrollbarHorizontal;
    class UUIScrollbar* ScrollbarVertical;
    struct FUIScreenValue_Extent HorizontalClientRegion;
    struct FUIScreenValue_Extent VerticalClientRegion;
private:
    FVector2D ClientRegionPosition;
    FLOAT FrameBounds[4];
public:
    BITFIELD bRefreshScrollbars:1;
    BITFIELD bRecalculateClientRegion:1;
    //## END PROPS UIScrollFrame

    void RefreshScrollbars(UBOOL bImmediately=FALSE);
    void ReapplyFormatting(UBOOL bImmediately=FALSE);
    UBOOL ScrollRegion(class UUIScrollbar* Sender,FLOAT PositionChange,UBOOL bPositionMaxed=FALSE);
    UBOOL SetClientRegionPosition(BYTE Orientation,FLOAT NewPosition);
    UBOOL SetClientRegionPositionVector(FVector2D NewPosition);
    FLOAT GetClientRegionPosition(BYTE Orientation) const;
    FLOAT GetClientRegionSize(BYTE Orientation) const;
    FVector2D GetClientRegionPositionVector() const;
    FVector2D GetClientRegionSizeVector() const;
    virtual void GetClipRegion(FLOAT& MinX,FLOAT& MinY,FLOAT& MaxX,FLOAT& MaxY) const;
    FLOAT GetVisibleRegionPercentage(BYTE Orientation) const;
    DECLARE_FUNCTION(execRefreshScrollbars)
    {
        P_GET_UBOOL_OPTX(bImmediately,FALSE);
        P_FINISH;
        RefreshScrollbars(bImmediately);
    }
    DECLARE_FUNCTION(execReapplyFormatting)
    {
        P_GET_UBOOL_OPTX(bImmediately,FALSE);
        P_FINISH;
        ReapplyFormatting(bImmediately);
    }
    DECLARE_FUNCTION(execScrollRegion)
    {
        P_GET_OBJECT(UUIScrollbar,Sender);
        P_GET_FLOAT(PositionChange);
        P_GET_UBOOL_OPTX(bPositionMaxed,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ScrollRegion(Sender,PositionChange,bPositionMaxed);
    }
    DECLARE_FUNCTION(execSetClientRegionPosition)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewPosition);
        P_FINISH;
        *(UBOOL*)Result=SetClientRegionPosition(Orientation,NewPosition);
    }
    DECLARE_FUNCTION(execSetClientRegionPositionVector)
    {
        P_GET_STRUCT(FVector2D,NewPosition);
        P_FINISH;
        *(UBOOL*)Result=SetClientRegionPositionVector(NewPosition);
    }
    DECLARE_FUNCTION(execGetClientRegionPosition)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(FLOAT*)Result=GetClientRegionPosition(Orientation);
    }
    DECLARE_FUNCTION(execGetClientRegionSize)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(FLOAT*)Result=GetClientRegionSize(Orientation);
    }
    DECLARE_FUNCTION(execGetClientRegionPositionVector)
    {
        P_FINISH;
        *(FVector2D*)Result=GetClientRegionPositionVector();
    }
    DECLARE_FUNCTION(execGetClientRegionSizeVector)
    {
        P_FINISH;
        *(FVector2D*)Result=GetClientRegionSizeVector();
    }
    DECLARE_FUNCTION(execGetClipRegion)
    {
        P_GET_FLOAT_REF(MinX);
        P_GET_FLOAT_REF(MinY);
        P_GET_FLOAT_REF(MaxX);
        P_GET_FLOAT_REF(MaxY);
        P_FINISH;
        GetClipRegion(MinX,MinY,MaxX,MaxY);
    }
    DECLARE_FUNCTION(execGetVisibleRegionPercentage)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(FLOAT*)Result=GetVisibleRegionPercentage(Orientation);
    }
    void eventScrollZoneClicked(class UUIScrollbar* Sender,FLOAT PositionPerc,INT PlayerIndex)
    {
        UIScrollFrame_eventScrollZoneClicked_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PositionPerc=PositionPerc;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ScrollZoneClicked),&Parms);
    }
    DECLARE_CLASS(UUIScrollFrame,UUIContainer,0|CLASS_Config,Engine)
	/* === UUIScrollFrame interface === */
	/**
	 * Changes the background image for this scroll frame, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the scroll frame's background image
	 */
	void SetBackgroundImage( USurface* NewBackgroundImage );

	/**
	 * Determines the size of the region necessary to contain all children of this widget
	 *
	 * @param	RegionSize	if specified, will be set to the size of the client region (in pixels) post-calculation.
	 *
	 * @note: OK to make virtual if necessary
	 */
	void CalculateClientRegion( FVector2D* RegionSize=NULL );

protected:

	/**
	 * Calculates and applies scrollbar positions, visibility, marker size, etc.
	 */
	virtual void ResolveScrollbars();

	/**
	 * Ensures that this scrollframe has valid scrollbars and that the scrollbars' states are correct (i.e. correct
	 * Outer, ObjectArchetype, part of the Children array, etc.)
	 */
	virtual void ValidateScrollbars();

public:

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/* === UUIScreenObject interface === */
	/**
	 * Initializes the buttons and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Insert a widget at the specified location.  This version routes the call to the ClientPanel if the widget is not
	 * eligible to be a child of this scroll frame.
	 *
	 * @param	NewChild		the widget to insert
	 * @param	InsertIndex		the position to insert the widget.  If not specified, the widget is insert at the end of
	 *							the list
	 * @param	bRenameExisting	controls what happens if there is another widget in this widget's Children list with the same tag as NewChild.
	 *							if TRUE, renames the existing widget giving a unique transient name.
	 *							if FALSE, does not add NewChild to the list and returns FALSE.
	 *
	 * @return	the position that that the child was inserted in, or INDEX_NONE if the widget was not inserted
	 */
	virtual INT InsertChild( UUIObject* NewChild, INT InsertIndex=INDEX_NONE, UBOOL bRenameExisting=TRUE );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

protected:

	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

public:

	/**
	 * Render this scroll frame.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * This version sets a clip mask on the canvas while the children are being rendered.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void Render_Children( FCanvas* Canvas, EUIPostProcessGroup UIPostProcessGroup );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after duplication & serialization and before PostLoad.
	 * This version fixes up the scrollbar references for UIScrollFrame archetypes.
	 */
	virtual void PostDuplicate();

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated Background,
	 * BackgroundCoordinates, and PrimaryStyle properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

#define UCONST_TABPAGE_DESCRIPTION_DATABINDING_INDEX 1
#define UCONST_TABPAGE_CAPTION_DATABINDING_INDEX 0

struct UITabPage_eventLinkToTabButton_Parms
{
    class UUITabButton* NewButton;
    class UUITabControl* TabControl;
    UBOOL ReturnValue;
    UITabPage_eventLinkToTabButton_Parms(EEventParm)
    {
    }
};
struct UITabPage_eventCreateTabButton_Parms
{
    class UUITabControl* TabControl;
    class UUITabButton* ReturnValue;
    UITabPage_eventCreateTabButton_Parms(EEventParm)
    {
    }
};
struct UITabPage_eventActivatePage_Parms
{
    INT PlayerIndex;
    UBOOL bActivate;
    UBOOL bTakeFocus;
    UBOOL ReturnValue;
    UITabPage_eventActivatePage_Parms(EEventParm)
    {
    }
};
class UUITabPage : public UUIContainer, public IUIDataStoreSubscriber
{
public:
    //## BEGIN PROPS UITabPage
    class UClass* ButtonClass;
    class UUITabButton* TabButton;
    struct FUIDataStoreBinding ButtonCaption;
    struct FUIDataStoreBinding ButtonToolTip;
    struct FUIDataStoreBinding PageDescription;
    //## END PROPS UITabPage

    class UUITabControl* GetOwnerTabControl() const;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    DECLARE_FUNCTION(execGetOwnerTabControl)
    {
        P_FINISH;
        *(class UUITabControl**)Result=GetOwnerTabControl();
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    UBOOL eventLinkToTabButton(class UUITabButton* NewButton,class UUITabControl* TabControl)
    {
        UITabPage_eventLinkToTabButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewButton=NewButton;
        Parms.TabControl=TabControl;
        ProcessEvent(FindFunctionChecked(ENGINE_LinkToTabButton),&Parms);
        return Parms.ReturnValue;
    }
    class UUITabButton* eventCreateTabButton(class UUITabControl* TabControl)
    {
        UITabPage_eventCreateTabButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.TabControl=TabControl;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateTabButton),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivatePage(INT PlayerIndex,UBOOL bActivate,UBOOL bTakeFocus=TRUE)
    {
        UITabPage_eventActivatePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bActivate=bActivate ? FIRST_BITFIELD : FALSE;
        Parms.bTakeFocus=bTakeFocus ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivatePage),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUITabPage,UUIContainer,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UIScreenObject interface === */
	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

struct UIEditBox_eventOnSubmitText_Parms
{
    class UUIEditBox* Sender;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIEditBox_eventOnSubmitText_Parms(EEventParm)
    {
    }
};
class UUIEditBox : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIEditBox
    struct FUIDataStoreBinding DataSource;
    class UUIComp_DrawStringEditbox* StringRenderComponent;
    class UUIComp_DrawImage* BackgroundImageComponent;
    FStringNoInit InitialValue;
    BITFIELD bReadOnly:1;
    BITFIELD bPasswordMode:1;
    INT MaxCharacters;
    BYTE CharacterSet;
    FScriptDelegate __OnSubmitText__Delegate;
    //## END PROPS UIEditBox

    void SetValue(const FString& NewText,INT PlayerIndex=0,UBOOL bSkipNotification=FALSE);
    FString GetValue(UBOOL bReturnUserText=TRUE) const;
    virtual INT CalculateCaretPositionFromCursorLocation(INT PlayerIndex=0) const;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(NewText);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_GET_UBOOL_OPTX(bSkipNotification,FALSE);
        P_FINISH;
        SetValue(NewText,PlayerIndex,bSkipNotification);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnUserText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnUserText);
    }
    DECLARE_FUNCTION(execCalculateCaretPositionFromCursorLocation)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(INT*)Result=CalculateCaretPositionFromCursorLocation(PlayerIndex);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    UBOOL delegateOnSubmitText(class UUIEditBox* Sender,INT PlayerIndex)
    {
        UIEditBox_eventOnSubmitText_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnSubmitText,&__OnSubmitText__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIEditBox,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIEditBox interface === */
	/**
	 * Changes the background image for this widget, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetBackgroundImage( class USurface* NewImage );

	/**
	 * Called whenever the user presses enter while this editbox is focused.  Activated the SubmitText kismet event and calls the
	 * OnSubmitText delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 */
	virtual void NotifySubmitText( INT PlayerIndex=INDEX_NONE );

protected:
	/**
	 * Processes special characters that affect the editbox but aren't displayed in the text field, such
	 * as arrow keys, backspace, delete, etc.
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Character key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE if the character was processed, FALSE if it wasn't one a special character.
	 */
	virtual UBOOL ProcessControlChar( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Determine whether the specified character should be displayed in the text field.
	 */
	virtual UBOOL IsValidCharacter( TCHAR Character ) const;

	/**
	 * Calculates the position of the first non-alphanumeric character that appears before the specified caret position.
	 *
	 * @param	StartingPosition	the location [index into UserText] to start searching.  If not specified, the
	 *								current caret position is used.  The character located at StartingPosition will
	 *								NOT be considered in the search.
	 *
	 * @return	an index into UserText for the location of the first non-alphanumeric character that appears
	 *			before the current caret position, or 0 if the beginning of the string is reached first.
	 */
	virtual INT FindPreviousCaretJumpPosition( INT StartingPosition=INDEX_NONE ) const;

	/**
	 * Calculates the position of the first non-alphanumeric character that appears after the current caret position.
	 *
	 * @param	StartingPosition	the location [index into UserText] to start searching.  If not specified, the
	 *								current caret position is used.  The character located at StartingPosition will
	 *								NOT be considered in the search.
	 *
	 * @return	an index into UserText for the location of the first non-alphanumeric character that appears
	 *			after the current caret position, or the length of the string if the end of the string is reached first.
	 */
	virtual INT FindNextCaretJumpPosition( INT StartingPosition=INDEX_NONE ) const;

public:
	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Called whenever the editbox's text is modified.  Activates the TextValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Render this editbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	void Render_Widget( FCanvas* Canvas );

protected:
	/* === UUIScreenObject interface === */
	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Processes input axis movement. Only called while the editbox is in the pressed state; updates the selection region
	 * according to the current mouse position.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );

public:

	/**
	 * Initializes the button and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bIncludesViewportOrigin
	 *							TRUE indicates that the value is relative to the 0,0 on the screen (or absolute position); FALSE to indicate
	 *							the value is relative to the viewport's origin.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bIncludesViewportOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bIncludesViewportOrigin, bClampValues);
	}

	/**
	 * Adds the specified character to the editbox's text field, if the text field is currently eligible to receive
	 * new characters
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Unicode key.
	 *
	 * @param	PlayerIndex		index [into the Engine.GamePlayers array] of the player that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	virtual UBOOL ProcessInputChar( INT PlayerIndex, TCHAR Character );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated EditBoxBackground
	 * and Coordinates properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUINumericEditBox : public UUIEditBox
{
public:
    //## BEGIN PROPS UINumericEditBox
    struct FUIStyleReference IncrementStyle;
    struct FUIStyleReference DecrementStyle;
    class UUINumericEditBoxButton* IncrementButton;
    class UUINumericEditBoxButton* DecrementButton;
    struct FUIRangeData NumericValue;
    INT DecimalPlaces;
    struct FUIScreenValue_Bounds IncButton_Position;
    struct FUIScreenValue_Bounds DecButton_Position;
    //## END PROPS UINumericEditBox

    void IncrementValue(class UUIScreenObject* Sender,INT PlayerIndex);
    void DecrementValue(class UUIScreenObject* Sender,INT PlayerIndex);
    UBOOL SetNumericValue(FLOAT NewValue,UBOOL bForceRefreshString=FALSE);
    FLOAT GetNumericValue() const;
    DECLARE_FUNCTION(execIncrementValue)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        IncrementValue(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDecrementValue)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DecrementValue(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execSetNumericValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bForceRefreshString,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetNumericValue(NewValue,bForceRefreshString);
    }
    DECLARE_FUNCTION(execGetNumericValue)
    {
        P_FINISH;
        *(FLOAT*)Result=GetNumericValue();
    }
    DECLARE_CLASS(UUINumericEditBox,UUIEditBox,0|CLASS_Config,Engine)
	/**
	 * Initializes the buttons and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

	/**
	 * Render this editbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	void Render_Widget( FCanvas* Canvas );

	/**
	 * Called whenever the user presses enter while this editbox is focused.  Activated the SubmitText kismet event and calls the
	 * OnSubmitText delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 */
	virtual void NotifySubmitText( INT PlayerIndex=INDEX_NONE );

	/**
	 * Evaluates the value string of the string component to verify that it is a legit numeric value.
	 */
	UBOOL ValidateNumericInputString();

	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @param	BindingIndex		indicates which data store binding should be modified.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/**
	 * Retrieves the list of data stores bound by this subscriber.
	 *
	 * @param	out_BoundDataStores		receives the array of data stores that subscriber is bound to.
	 */
	virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);

	/** Saves the value for this subscriber. */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);

protected:

	/**
	 * Determine whether the specified character should be displayed in the text field.
	 */
	virtual UBOOL IsValidCharacter( TCHAR Character ) const;

	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

};

class UUIImage : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIImage
    struct FUIDataStoreBinding ImageDataSource;
    class UUIComp_DrawImage* ImageComponent;
    //## END PROPS UIImage

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_CLASS(UUIImage,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/*=== UUIImage interface === */
	/**
	 * Changes this UIImage's Image to the specified surface, creating a wrapper for the surface
	 * (if necessary) and applies the current ImageStyle to the new wrapper.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetValue( USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the ImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	// UUIScreenObject interface.
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Retrieves the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to retrieve
	 * @param	out_CurrentValue	receives the current data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_GetValue( BYTE AnimationType, FUIAnimationRawData& out_CurrentValue ) const;
	/**
	 * Updates the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to set
	 * @param	out_CurrentValue	contains the updated data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_SetValue( BYTE AnimationType, const FUIAnimationRawData& NewValue );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated Image & Coordinates
	 * properties over to the ImageComponent.
	 */
	virtual void PostLoad();
};

class UUILabel : public UUIObject, public IUIDataStoreSubscriber, public IUIStringRenderer
{
public:
    //## BEGIN PROPS UILabel
    struct FUIDataStoreBinding DataSource;
    class UUIComp_DrawString* StringRenderComponent;
    class UUIComp_DrawImage* LabelBackground;
    //## END PROPS UILabel

    void SetValue(const FString& NewText);
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(NewText);
        P_FINISH;
        SetValue(NewText);
    }
    DECLARE_FUNCTION(execSetTextAlignment)
    {
        P_GET_BYTE(Horizontal);
        P_GET_BYTE(Vertical);
        P_FINISH;
        SetTextAlignment(Horizontal,Vertical);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_CLASS(UUILabel,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
    virtual UObject* GetUObjectInterfaceUIStringRenderer(){return this;}
	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bIncludesViewportOrigin
	 *							TRUE indicates that the value is relative to the 0,0 on the screen (or absolute position); FALSE to indicate
	 *							the value is relative to the viewport's origin.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bIncludesViewportOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bIncludesViewportOrigin, bClampValues);
	}

	/**
	 * Retrieves the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to retrieve
	 * @param	out_CurrentValue	receives the current data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_GetValue( BYTE AnimationType, FUIAnimationRawData& out_CurrentValue ) const;
	/**
	 * Updates the current value for some data currently being interpolated by this widget.
	 *
	 * @param	AnimationType		the type of animation data to set
	 * @param	out_CurrentValue	contains the updated data value; animation type determines which of the fields holds the actual data value.
	 *
	 * @return	TRUE if the widget supports the animation type specified.
	 */
	virtual UBOOL Anim_SetValue( BYTE AnimationType, const FUIAnimationRawData& NewValue );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates the PrimaryStyle for this label over to the label's component.
	 */
	virtual void PostLoad();
};

struct UIToolTip_eventCanShowToolTip_Parms
{
    class UUIToolTip* Sender;
    UBOOL ReturnValue;
    UIToolTip_eventCanShowToolTip_Parms(EEventParm)
    {
    }
};
struct UIToolTip_eventDeactivateToolTip_Parms
{
    UBOOL ReturnValue;
    UIToolTip_eventDeactivateToolTip_Parms(EEventParm)
    {
    }
};
struct UIToolTip_eventActivateToolTip_Parms
{
    class UUIToolTip* Sender;
    class UUIToolTip* ReturnValue;
    UIToolTip_eventActivateToolTip_Parms(EEventParm)
    {
    }
};
class UUIToolTip : public UUILabel
{
public:
    //## BEGIN PROPS UIToolTip
    BITFIELD bPendingPositionUpdate:1;
    BITFIELD bResolveToolTipPosition:1;
    BITFIELD bFollowCursor:1;
    BITFIELD bAutoHideOnInput:1;
    FLOAT SecondsActive;
    FScriptDelegate __ActivateToolTip__Delegate;
    FScriptDelegate __DeactivateToolTip__Delegate;
    FScriptDelegate __CanShowToolTip__Delegate;
    //## END PROPS UIToolTip

    class UUIToolTip* BeginTracking();
    UBOOL EndTracking();
    void UpdateToolTipPosition();
    DECLARE_FUNCTION(execBeginTracking)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=BeginTracking();
    }
    DECLARE_FUNCTION(execEndTracking)
    {
        P_FINISH;
        *(UBOOL*)Result=EndTracking();
    }
    DECLARE_FUNCTION(execUpdateToolTipPosition)
    {
        P_FINISH;
        UpdateToolTipPosition();
    }
    UBOOL delegateCanShowToolTip(class UUIToolTip* Sender)
    {
        UIToolTip_eventCanShowToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_CanShowToolTip,&__CanShowToolTip__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateDeactivateToolTip()
    {
        UIToolTip_eventDeactivateToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessDelegate(ENGINE_DeactivateToolTip,&__DeactivateToolTip__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIToolTip* delegateActivateToolTip(class UUIToolTip* Sender)
    {
        UIToolTip_eventActivateToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_ActivateToolTip,&__ActivateToolTip__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIToolTip,UUILabel,0|CLASS_Config,Engine)
	/** === UUIToolTip interface === */
	/**
	 * Updates SecondsActive, hiding or showing the tooltip when appropriate.
	 */
	virtual void TickToolTip( FLOAT DeltaTime );

	/**
	 * Sets this tool-tip's displayed text to the resolved value of the specified data store binding.
	 */
	virtual void LinkBinding( struct FUIDataStoreBinding* ToolTipBinding );

	/**
	 * Resolves the tool tip's Position values into pixel values and formats the tool tip string, if bPendingPositionUpdate is TRUE.
	 */
	virtual void ResolveToolTipPosition();

	/**
	 * Determines the best X position for the tooltip, based on the tool-tip's width and the current mouse position
	 */
	FLOAT GetIdealLeft() const;

	/**
	 * Determines the best Y position for the tooltip, based on the tool-tip's height and the current mouse position
	 */
	FLOAT GetIdealTop() const;

	/**
	 * Calculates the best possible Y location for the tool-tip, ensuring this position is above the current mouse position.
	 */
	FLOAT CalculateBestPositionAboveCursor() const;

	/**
	 * Calculates the best possible Y location for the tool-tip, ensuring this position is below the current mouse position.
	 */
	FLOAT CalculateBestPositionBelowCursor() const;

	/** === UUIScreenObject interface === */
	/**
	 * Overridden to prevent any of this widget's inherited methods or components from triggering a scene update, as tooltip
	 * positions are updated differently.
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );
};

struct FCellHitDetectionInfo
{
    INT HitColumn;
    INT HitRow;
    INT ResizeColumn;
    INT ResizeRow;

		/** Constructors */
		FCellHitDetectionInfo() {}
		FCellHitDetectionInfo(EEventParm)
		{
			appMemzero(this, sizeof(FCellHitDetectionInfo));
		}
	
};

#define UCONST_ResizeBufferPixels 5

struct UIList_eventIsValueChangeNotificationEnabled_Parms
{
    UBOOL ReturnValue;
    UIList_eventIsValueChangeNotificationEnabled_Parms(EEventParm)
    {
    }
};
struct UIList_eventDisableValueChangeNotification_Parms
{
    UIList_eventDisableValueChangeNotification_Parms(EEventParm)
    {
    }
};
struct UIList_eventEnableValueChangeNotification_Parms
{
    UIList_eventEnableValueChangeNotification_Parms(EEventParm)
    {
    }
};
struct UIList_eventIsSetIndexEnabled_Parms
{
    UBOOL ReturnValue;
    UIList_eventIsSetIndexEnabled_Parms(EEventParm)
    {
    }
};
struct UIList_eventDisableSetIndex_Parms
{
    UIList_eventDisableSetIndex_Parms(EEventParm)
    {
    }
};
struct UIList_eventEnableSetIndex_Parms
{
    UIList_eventEnableSetIndex_Parms(EEventParm)
    {
    }
};
struct UIList_eventDecrementAllMutexes_Parms
{
    UBOOL bDispatchUpdates;
    UIList_eventDecrementAllMutexes_Parms(EEventParm)
    {
    }
};
struct UIList_eventIncrementAllMutexes_Parms
{
    UIList_eventIncrementAllMutexes_Parms(EEventParm)
    {
    }
};
struct UIList_eventAllMutexesDisabled_Parms
{
    UBOOL ReturnValue;
    UIList_eventAllMutexesDisabled_Parms(EEventParm)
    {
    }
};
struct UIList_eventOnOverrideListElementState_Parms
{
    class UUIList* Sender;
    INT ElementIndex;
    BYTE CurrentState;
    BYTE NewElementState;
    BYTE ReturnValue;
    UIList_eventOnOverrideListElementState_Parms(EEventParm)
    {
    }
};
struct UIList_eventShouldDisableElement_Parms
{
    class UUIList* Sender;
    INT ElementIndex;
    UBOOL ReturnValue;
    UIList_eventShouldDisableElement_Parms(EEventParm)
    {
    }
};
struct UIList_eventOnListElementsSorted_Parms
{
    class UUIList* Sender;
    UIList_eventOnListElementsSorted_Parms(EEventParm)
    {
    }
};
struct UIList_eventOnSubmitSelection_Parms
{
    class UUIList* Sender;
    INT PlayerIndex;
    UIList_eventOnSubmitSelection_Parms(EEventParm)
    {
    }
};
class UUIList : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIList
    struct FUIScreenValue_Extent RowHeight;
    struct FUIScreenValue_Extent MinColumnSize;
    struct FUIScreenValue_Extent ColumnWidth;
    struct FUIScreenValue_Extent HeaderCellPadding;
    struct FUIScreenValue_Extent HeaderElementSpacing;
    struct FUIScreenValue_Extent CellSpacing;
    struct FUIScreenValue_Extent CellPadding;
    INT Index;
    INT TopIndex;
    INT MaxVisibleItems;
protected:
    INT ColumnCount;
    INT RowCount;
public:
    BYTE ColumnAutoSizeMode;
    BYTE RowAutoSizeMode;
    BYTE CellLinkType;
    BYTE WrapType;
    BITFIELD bEnableMultiSelect:1 GCC_BITFIELD_MAGIC;
    BITFIELD bEnableVerticalScrollbar:1;
    BITFIELD bInitializeScrollbars:1;
    BITFIELD bAllowDisabledItemSelection:1;
    BITFIELD bSingleClickSubmission:1;
private:
    BITFIELD bUpdateItemUnderCursor:1;
    BITFIELD bHoverStateOverridesSelected:1;
    BITFIELD bForceFullPageDisplay:1;
public:
    BITFIELD bAllowColumnResizing:1;
    BITFIELD bDisplayDataBindings:1;
    BITFIELD bSortingList:1;
    class UUIScrollbar* VerticalScrollbar;
    struct FUIStyleReference GlobalCellStyle[4];
    struct FUIStyleReference ColumnHeaderStyle;
    struct FUIStyleReference ColumnHeaderBackgroundStyle[3];
    struct FUIStyleReference ItemOverlayStyle[4];
    INT ResizeColumn;
    INT SetIndexMutex;
    INT ValueChangeNotificationMutex;
    struct FUIDataStoreBinding DataSource;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    TArrayNoInit<INT> Items;
private:
    TArrayNoInit<INT> SelectedItems;
public:
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_ListElementSorter* SortComponent;
    class UUIComp_ListPresenterBase* CellDataComponent;
    FName SubmitDataSuccessCue;
    FName SubmitDataFailedCue;
    FName DecrementIndexCue;
    FName IncrementIndexCue;
    FName SortAscendingCue;
    FName SortDescendingCue;
    FScriptDelegate __OnSubmitSelection__Delegate;
    FScriptDelegate __OnListElementsSorted__Delegate;
    FScriptDelegate __ShouldDisableElement__Delegate;
    FScriptDelegate __OnOverrideListElementState__Delegate;
    //## END PROPS UIList

    UBOOL ScrollVertical(class UUIScrollbar* Sender,FLOAT PositionChange,UBOOL bPositionMaxed=FALSE);
    virtual INT RemoveElement(INT ElementToRemove);
    virtual INT GetItemCount() const;
    virtual INT GetMaxVisibleElementCount() const;
    INT GetMaxNumVisibleRows() const;
    INT GetMaxNumVisibleColumns() const;
    INT GetTotalRowCount() const;
    INT GetTotalColumnCount() const;
    void SetColumnCount(INT NewColumnCount);
    void SetRowCount(INT NewRowCount);
    virtual FLOAT GetColumnWidth(INT ColumnIndex=-1,UBOOL bColHeader=FALSE,UBOOL bReturnUnformattedValue=FALSE) const;
    virtual FLOAT GetRowHeight(INT RowIndex=-1,UBOOL bColHeader=FALSE,UBOOL bReturnUnformattedValue=FALSE) const;
    virtual FVector2D GetClientRegion() const;
    virtual INT CalculateIndexFromCursorLocation(UBOOL bRequireValidIndex=TRUE) const;
    virtual INT GetResizeColumn(struct FCellHitDetectionInfo* ClickedCell=NULL) const;
    TArray<INT> GetSelectedItems() const;
    INT GetCurrentItem() const;
    FString GetElementValue(INT ElementIndex,INT CellIndex=-1) const;
    UBOOL SetElementCellState(INT ElementIndex,BYTE NewElementState);
    BYTE GetElementCellState(INT ElementIndex) const;
    INT FindItemIndex(const FString& ItemValue,INT CellIndex=-1) const;
    virtual UBOOL SetIndex(INT NewIndex,UBOOL bClampValue=TRUE,UBOOL bSkipNotification=FALSE);
    virtual UBOOL NavigateIndex(UBOOL bIncrementIndex,UBOOL bFullPage,UBOOL bHorizontalNavigation);
    virtual UBOOL SetTopIndex(INT NewTopIndex,UBOOL bClampValue=TRUE);
    UBOOL IsElementEnabled(INT ElementIndex);
    UBOOL IsElementSelected(INT ElementIndex) const;
    UBOOL CanSelectElement(INT ElementIndex);
    void SetHotTracking(UBOOL bShouldUpdateItemUnderCursor);
    UBOOL IsHotTrackingEnabled() const;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    UBOOL IsElementAutoSizingEnabled() const;
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execScrollVertical)
    {
        P_GET_OBJECT(UUIScrollbar,Sender);
        P_GET_FLOAT(PositionChange);
        P_GET_UBOOL_OPTX(bPositionMaxed,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ScrollVertical(Sender,PositionChange,bPositionMaxed);
    }
    DECLARE_FUNCTION(execRemoveElement)
    {
        P_GET_INT(ElementToRemove);
        P_FINISH;
        *(INT*)Result=RemoveElement(ElementToRemove);
    }
    DECLARE_FUNCTION(execGetItemCount)
    {
        P_FINISH;
        *(INT*)Result=GetItemCount();
    }
    DECLARE_FUNCTION(execGetMaxVisibleElementCount)
    {
        P_FINISH;
        *(INT*)Result=GetMaxVisibleElementCount();
    }
    DECLARE_FUNCTION(execGetMaxNumVisibleRows)
    {
        P_FINISH;
        *(INT*)Result=GetMaxNumVisibleRows();
    }
    DECLARE_FUNCTION(execGetMaxNumVisibleColumns)
    {
        P_FINISH;
        *(INT*)Result=GetMaxNumVisibleColumns();
    }
    DECLARE_FUNCTION(execGetTotalRowCount)
    {
        P_FINISH;
        *(INT*)Result=GetTotalRowCount();
    }
    DECLARE_FUNCTION(execGetTotalColumnCount)
    {
        P_FINISH;
        *(INT*)Result=GetTotalColumnCount();
    }
    DECLARE_FUNCTION(execSetColumnCount)
    {
        P_GET_INT(NewColumnCount);
        P_FINISH;
        SetColumnCount(NewColumnCount);
    }
    DECLARE_FUNCTION(execSetRowCount)
    {
        P_GET_INT(NewRowCount);
        P_FINISH;
        SetRowCount(NewRowCount);
    }
    DECLARE_FUNCTION(execGetColumnWidth)
    {
        P_GET_INT_OPTX(ColumnIndex,-1);
        P_GET_UBOOL_OPTX(bColHeader,FALSE);
        P_GET_UBOOL_OPTX(bReturnUnformattedValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetColumnWidth(ColumnIndex,bColHeader,bReturnUnformattedValue);
    }
    DECLARE_FUNCTION(execGetRowHeight)
    {
        P_GET_INT_OPTX(RowIndex,-1);
        P_GET_UBOOL_OPTX(bColHeader,FALSE);
        P_GET_UBOOL_OPTX(bReturnUnformattedValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetRowHeight(RowIndex,bColHeader,bReturnUnformattedValue);
    }
    DECLARE_FUNCTION(execGetClientRegion)
    {
        P_FINISH;
        *(FVector2D*)Result=GetClientRegion();
    }
    DECLARE_FUNCTION(execCalculateIndexFromCursorLocation)
    {
        P_GET_UBOOL_OPTX(bRequireValidIndex,TRUE);
        P_FINISH;
        *(INT*)Result=CalculateIndexFromCursorLocation(bRequireValidIndex);
    }
    DECLARE_FUNCTION(execGetResizeColumn)
    {
        P_GET_STRUCT_OPTX_REF(struct FCellHitDetectionInfo,ClickedCell,FCellHitDetectionInfo(EC_EventParm));
        P_FINISH;
        *(INT*)Result=GetResizeColumn(pClickedCell ? &ClickedCell : NULL);
    }
    DECLARE_FUNCTION(execGetSelectedItems)
    {
        P_FINISH;
        *(TArray<INT>*)Result=GetSelectedItems();
    }
    DECLARE_FUNCTION(execGetCurrentItem)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentItem();
    }
    DECLARE_FUNCTION(execGetElementValue)
    {
        P_GET_INT(ElementIndex);
        P_GET_INT_OPTX(CellIndex,-1);
        P_FINISH;
        *(FString*)Result=GetElementValue(ElementIndex,CellIndex);
    }
    DECLARE_FUNCTION(execSetElementCellState)
    {
        P_GET_INT(ElementIndex);
        P_GET_BYTE(NewElementState);
        P_FINISH;
        *(UBOOL*)Result=SetElementCellState(ElementIndex,NewElementState);
    }
    DECLARE_FUNCTION(execGetElementCellState)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(BYTE*)Result=GetElementCellState(ElementIndex);
    }
    DECLARE_FUNCTION(execFindItemIndex)
    {
        P_GET_STR(ItemValue);
        P_GET_INT_OPTX(CellIndex,-1);
        P_FINISH;
        *(INT*)Result=FindItemIndex(ItemValue,CellIndex);
    }
    DECLARE_FUNCTION(execSetIndex)
    {
        P_GET_INT(NewIndex);
        P_GET_UBOOL_OPTX(bClampValue,TRUE);
        P_GET_UBOOL_OPTX(bSkipNotification,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetIndex(NewIndex,bClampValue,bSkipNotification);
    }
    DECLARE_FUNCTION(execNavigateIndex)
    {
        P_GET_UBOOL(bIncrementIndex);
        P_GET_UBOOL(bFullPage);
        P_GET_UBOOL(bHorizontalNavigation);
        P_FINISH;
        *(UBOOL*)Result=NavigateIndex(bIncrementIndex,bFullPage,bHorizontalNavigation);
    }
    DECLARE_FUNCTION(execSetTopIndex)
    {
        P_GET_INT(NewTopIndex);
        P_GET_UBOOL_OPTX(bClampValue,TRUE);
        P_FINISH;
        *(UBOOL*)Result=SetTopIndex(NewTopIndex,bClampValue);
    }
    DECLARE_FUNCTION(execIsElementEnabled)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(UBOOL*)Result=IsElementEnabled(ElementIndex);
    }
    DECLARE_FUNCTION(execIsElementSelected)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(UBOOL*)Result=IsElementSelected(ElementIndex);
    }
    DECLARE_FUNCTION(execCanSelectElement)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(UBOOL*)Result=CanSelectElement(ElementIndex);
    }
    DECLARE_FUNCTION(execSetHotTracking)
    {
        P_GET_UBOOL(bShouldUpdateItemUnderCursor);
        P_FINISH;
        SetHotTracking(bShouldUpdateItemUnderCursor);
    }
    DECLARE_FUNCTION(execIsHotTrackingEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsHotTrackingEnabled();
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execIsElementAutoSizingEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsElementAutoSizingEnabled();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    UBOOL eventIsValueChangeNotificationEnabled()
    {
        UIList_eventIsValueChangeNotificationEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValueChangeNotificationEnabled),&Parms);
        return Parms.ReturnValue;
    }
    void eventDisableValueChangeNotification()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_DisableValueChangeNotification),NULL);
    }
    void eventEnableValueChangeNotification()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_EnableValueChangeNotification),NULL);
    }
    UBOOL eventIsSetIndexEnabled()
    {
        UIList_eventIsSetIndexEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsSetIndexEnabled),&Parms);
        return Parms.ReturnValue;
    }
    void eventDisableSetIndex()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_DisableSetIndex),NULL);
    }
    void eventEnableSetIndex()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_EnableSetIndex),NULL);
    }
    void eventDecrementAllMutexes(UBOOL bDispatchUpdates=FALSE)
    {
        UIList_eventDecrementAllMutexes_Parms Parms(EC_EventParm);
        Parms.bDispatchUpdates=bDispatchUpdates ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_DecrementAllMutexes),&Parms);
    }
    void eventIncrementAllMutexes()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_IncrementAllMutexes),NULL);
    }
    UBOOL eventAllMutexesDisabled()
    {
        UIList_eventAllMutexesDisabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_AllMutexesDisabled),&Parms);
        return Parms.ReturnValue;
    }
    BYTE delegateOnOverrideListElementState(class UUIList* Sender,INT ElementIndex,BYTE CurrentState,BYTE NewElementState)
    {
        UIList_eventOnOverrideListElementState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.ElementIndex=ElementIndex;
        Parms.CurrentState=CurrentState;
        Parms.NewElementState=NewElementState;
        ProcessDelegate(ENGINE_OnOverrideListElementState,&__OnOverrideListElementState__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateShouldDisableElement(class UUIList* Sender,INT ElementIndex)
    {
        UIList_eventShouldDisableElement_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.ElementIndex=ElementIndex;
        ProcessDelegate(ENGINE_ShouldDisableElement,&__ShouldDisableElement__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnListElementsSorted(class UUIList* Sender)
    {
        UIList_eventOnListElementsSorted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_OnListElementsSorted,&__OnListElementsSorted__Delegate,&Parms);
    }
    void delegateOnSubmitSelection(class UUIList* Sender,INT PlayerIndex=0)
    {
        UIList_eventOnSubmitSelection_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnSubmitSelection,&__OnSubmitSelection__Delegate,&Parms);
    }
    DECLARE_CLASS(UUIList,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	friend class UUIComp_ListPresenterBase;
//	friend class UUIComp_ListPresenter;

	/* === UUIList interface === */
	/**
	 * Resolves DataSource into the list element provider that it references.
	 *
	 * @return	a pointer to the list element provider indicated by DataSource, or NULL if it couldn't be resolved.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider();

	/**
	 * Changes the data binding for the specified cell index.
	 *
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader		the string that should be displayed in the column header for this cell.
	 * @param	BindingIndex		the column or row to bind this data field to.  If BindingIndex is greater than the number
	 *								schema cells, empty schema cells will be added to meet the number required to place the data
	 *								at BindingIndex.
	 *								If a value of INDEX_NONE is specified, the cell binding will only occur if there are no other
	 *								schema cells bound to that data field.  In this case, a new schema cell will be appended and
	 *								it will be bound to the data field specified.
	 */
	UBOOL SetCellBinding( FName CellDataBinding, const FString& ColumnHeader, INT BindingIndex );

	/**
	 * Inserts a new schema cell at the specified index and assigns the data binding.
	 *
	 * @param	InsertIndex			the column/row to insert the schema cell; must be a valid index.
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
	 *
	 * @return	TRUE if the schema cell was successfully inserted into the list
	 */
	UBOOL InsertSchemaCell( INT InsertIndex, FName CellDataBinding, const FString& ColumnHeader );

	/**
	 * Retrieves the name of the binding for the specified location in the schema.
	 *
	 * @param	BindingIndex	the index for the cell/column to get the binding for
	 *
	 * @return	the value assigned to the schema cell at the specified location, or NAME_None if the binding index is invalid.
	 */
	FName GetCellBinding( INT BindingIndex ) const;

	/**
	 * Removes all schema cells which are bound to the specified data field.
	 *
	 * @return	TRUE if one or more schema cells were successfully removed.
	 */
	UBOOL ClearCellBinding( FName CellDataBinding );

	/**
	 * Removes schema cells at the location specified.  If the list's columns are linked, this index should correspond to
	 * the column that should be removed; if the list's rows are linked, this index should correspond to the row that should
	 * be removed.
	 *
	 * @return	TRUE if the schema cell at BindingIndex was successfully removed.
	 */
	UBOOL ClearCellBinding( INT BindingIndex );

	/**
	 * Returns the menu state that should be used for rendering the specified element.  By default, returns the list's current
	 * menu state, but might return a different menu state in some special cases (for example, when specific elements should be
	 * rendered as though they were disabled)
	 *
	 * @param	ElementIndex	the index into the Items array for the element to retrieve the menu state for.
	 *
	 * @return	a pointer to the menu state that should be used for rendering the specified element; should correspond to one of the elements
	 *			of the UIList's InactiveStates array.
	 */
	UUIState* GetElementMenuState( INT ElementIndex );

	/**
	 * Refreshes the data for this list from the data store bound via DataSource.
	 *
	 * @param	bResolveDataSource	if TRUE, re-resolves DataSource into DataProvider prior to refilling the list's data
	 *
	 * @return	TRUE if the list data was successfully loaded; FALSE if the data source couldn't be resolved or it didn't
	 *			contain the data indicated by SourceData
	 */
	virtual UBOOL RefreshListData( UBOOL bResolveDataSource=FALSE );

	/**
	 * Retrieves the list of elements from the data provider and adds them to the list.
	 *
	 * @return	TRUE if the list was successfully populated.
	 */
	virtual UBOOL PopulateListElements();

	/**
	 * Inserts a new element into the list at the specified index
	 *
	 * @param	ElementToInsert		the index [into the data provider's data source array] of the element to insert.
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the element.  If the value is
	 *								not a valid index, the element will be added to the end of the list.
	 * @param	bSkipSorting		specify TRUE to prevent the list from being resorted after this element is added (useful when
	 *								adding items in bulk).
	 *
	 * @return	the index where the new element was inserted, or INDEX_NONE if the element wasn't added to the list.
	 */
	virtual INT InsertElement( INT ElementToInsert, INT InsertIndex=INDEX_NONE, UBOOL bSkipSorting=FALSE );

	/**
	 * Removes the element located at the specified index from the list.
	 *
	 * @param	RemovalIndex	the index for the element that should be removed from the list
	 *
	 * @return	the index [into the Items array] for the element that was removed, or INDEX_NONE if the element wasn't
	 *			part of the list.
	 */
	virtual INT RemoveElementAtIndex( INT RemovalIndex );

	/**
	 * Inserts multiple elements into the list at the specified index
	 *
	 * @param	ElementsToInsert	the elements to insert into the list
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the elements.  If the value is
	 *								not a valid index, the elements will be added to the end of the list.  Elements will be added
	 *								in the order they appear in the array, so ElementsToInsert(0) will be inserted at InsertIndex,
	 *								ElementsToInsert(1) will be inserted at InsertIndex+1, etc.
	 * @param	bSkipSorting		specify TRUE to prevent the list from being resorted after this element is added (useful when
	 *								adding items in bulk).
	 *
	 * @return	the number of elements that were added to the list
	 */
	virtual INT InsertElements( const TArray<INT>& ElementsToInsert, INT InsertIndex=INDEX_NONE, UBOOL bSkipSorting=FALSE );

	/**
	 * Removes the specified elements from the list.
	 *
	 * @param	ElementsToRemove	the elements to remove from the list (make sure this parameter creates a copy of the array, so
	 *								that the removal algorithm works correctly; i.e. don't change this to a const& for performance or something)
	 *
	 * @return	the number of elements that were removed from the list
	 */
	virtual INT RemoveElements( const TArray<INT>& ElementsToRemove );

	/**
	 * Clears all elements from the list.
	 */
	virtual void ClearElements();

	/**
	 * Moves the specified element by the specified number of items.
	 *
	 * @param	ElementToMove	the element to move. This is not an index into the Items array; rather, it is the value of an element
	 *							in the Items array, which corresponds to an index into data store collection this list is bound to.
	 * @param	MoveCount		the number of items to move the element.
	 *
	 * @param	TRUE if the element was moved successfully; FALSE otherwise
	 */
	virtual UBOOL MoveElement( INT ElementToMove, INT MoveCount );

	/**
	 * Moves the element at the specified index by the specified number of items.
	 *
	 * @param	ElementIndex	the index for the element to move.
	 * @param	MoveCount		the number of items to move the element.
	 *
	 * @param	TRUE if the element was moved successfully; FALSE otherwise
	 */
	virtual UBOOL MoveElementAtIndex( INT ElementIndex, INT MoveCount );

	/**
	 * Swaps the elements specified, reversing their positions in the Items array.
	 *
	 * @param	ElementA	the first element to swap. This is not an index into the Items array; rather, it is the value of an element
	 *						in the Items array, which corresponds to an index into data store collection this list is bound to.
	 * @param	ElementB	the second element to swap. This is not an index into the Items array; rather, it is the value of an element
	 *						in the Items array, which corresponds to an index into data store collection this list is bound to.
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElementsByValue( INT ElementA, INT ElementB );

	/**
	 * Swaps the values at the specified indexes, reversing their positions in the Items array.
	 *
	 * @param	IndexA	the index into the Items array for the first element to swap
	 * @param	IndexB	the index into the Items array for the second element to swap
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElementsByIndex( INT IndexA, INT IndexB );

	/**
	 * Finds the index for the element specified
	 *
	 * @param	ElementToFind	the element to search for
	 *
	 * @return	the index [into the Items array] for the element specified, or INDEX_NONE if the element wasn't
	 *			part of the list.
	 */
	virtual INT FindElementIndex( INT ElementToFind ) const;

	/**
	 * Calculates the row/column location of the cursor.
	 *
	 * @param	HitLocation		the point to use for calculating the hit information.
	 * @param	out_HitInfo		receives the results of the calculation.  The row/column that was hit does not necessarily
	 *							correspond to an actual item in the list (i.e. the row/column may be higher than the actual
	 *							number of rows or columns).
	 *
	 * @return	TRUE if HitLocation was located inside this list.
	 */
	virtual UBOOL CalculateCellFromPosition( const FIntPoint& HitLocation, FCellHitDetectionInfo& out_HitInfo ) const;

	/**
	 *	Initializes the vertical and horizontal scrollbars for the current state of the List
	 */
	void InitializeScrollbars();

	/**
	 *	Sets up the positions of scrollbar markers according to which items are currently visible
	 */
	void UpdateScrollbars();

	/**
	 * Activates the focus hint widget for this object; child classes which override this method should set the position of the focus hint
	 * as well as any other properties necessary for correctly displaying the focus hint for this widget.
	 *
	 * @param	FocusHintObject		reference to the widget that supplies the focus hint.
	 *
	 * @return	TRUE if the focus hint object was initialized / repositioned by this widget; FALSE if this widget doesn't support focus hints.
	 */
	virtual UBOOL AttachFocusHint( class UUIObject* FocusHintObject );

	/**
	 * Updates the visibility and position of the selection hint to appear next to the currently selected item
	 */
	virtual void UpdateSelectionHint( UUIObject* FocusHintObject=NULL );

public:
	/**
	 * Determines whether elements should render the names of the fields they're bound to.
	 *
	 * @return	TRUE if list elements should render the names for the data fields they're bound to, FALSE
	 *			if list elements should render the actual data for the list element they're associated with.
	 */
	UBOOL ShouldRenderDataBindings() const;

	/**
	 * Wrapper for calculating the amount of additional room the list needs at the top to render headers or other things.
	 */
	virtual FLOAT GetHeaderSize() const;

	/**
	 * Sets the selection state of the specified element.
	 *
	 * @param	ElementIndex	the index of the element to change selection state for
	 * @param	bSelected		TRUE to select the element, FALSE to unselect the element.
	 */
	void SelectElement( INT ElementIndex, UBOOL bSelected=TRUE );

	/**
	 * Called when the list's index has changed.
	 *
	 * @param	PreviousIndex	the list's Index before it was changed
	 * @param	PlayerIndex		the index of the player associated with this index change.
	 */
	virtual void NotifyIndexChanged( INT PreviousIndex, INT PlayerIndex );

	/**
	 * Called when the list's top item has changed
	 *
	 * @param	PreviousIndex	the list's TopIndex before it was changed
	 * @param	PlayerIndex		the index of the player that generated this change
	 */
	void NotifyTopIndexChanged( INT PreviousTopIndex, INT PlayerIndex );

	/**
	 * Called when the number of elements in this list is changed.
	 *
	 * @param	PreviousNumberOfItems	the number of items previously in the list
	 * @param	PlayerIndex				the index of the player that generated this change.
	 */
	void NotifyItemCountChanged( INT PreviousNumberOfItems, INT PlayerIndex );

	/**
	 * Called whenever the user chooses an item while this list is focused.  Activates the SubmitSelection kismet event and calls
	 * the OnSubmitSelection delegate.
	 */
	virtual void NotifySubmitSelection( INT PlayerIndex );

	/**
	 * Called after this list's elements have been sorted.  Synchronizes the list's Items array to the data component's elements array.
	 */
	virtual void NotifyListElementsSorted();

	/**
	 * Changes whether this list renders colum headers or not.  Only applicable if the owning list's CellLinkType is LINKED_Columns
	 */
	void EnableColumnHeaderRendering(UBOOL bShouldRenderColHeaders=TRUE)
	{
		if ( CellDataComponent != NULL )
		{
			CellDataComponent->EnableColumnHeaderRendering(bShouldRenderColHeaders);
		}
	}

	/**
	 * Returns whether this list should render column headers
	 */
	UBOOL ShouldRenderColumnHeaders() const
	{
		if ( CellDataComponent != NULL )
		{
			return CellDataComponent->ShouldRenderColumnHeaders();
		}

		return FALSE;
	}

	/**
	 * Renders the list's background image, if assigned.
	 */
	virtual void RenderBackgroundImage( FCanvas* Canvas, const FRenderParameters& Parameters );

	/* === UUIObject interface === */
	/**
	 * Render this list.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called from UGameUISceneClient::UpdateMousePosition; provides a hook for widgets to respond to the precise cursor
	 * position.  Only called on the scene's ActiveControl if the ActiveControl's bEnableActiveCursorUpdates is TRUE and
	 * the mouse is currently over the widget.
	 *
	 * This version ensures that the element under the mouse is in the proper cell state, if bTrackMouse is true.
	 */
	virtual void NotifyMouseOver( const FVector2D& MousePos );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Change the value of bEnableActiveCursorUpdates to the specified value.
	 */
	virtual void SetActiveCursorUpdate( UBOOL bShouldReceiveCursorUpdates );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

protected:

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( class UUIStyle* ResolvedStyle, const FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState=NULL );

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle );

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * Initializes the value of bDisplayDataBindings based on whether we're in the game or not.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( class UUIScene* inOwnerScene, class UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Removes the specified state from the screen object's state stack.
	 *
	 * @param	StateToRemove	the state to be removed
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the state was successfully removed, or if the state didn't exist in the widget's list of states;
	 *			false if the state overrode the request to be removed
	 */
	virtual UBOOL DeactivateState( UUIState* StateToRemove, INT PlayerIndex );

protected:
	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

	/**
	 * Processes input axis movement. Only called while the list is in the pressed state; resizes a column if ResizeColumn
	 * is a valid value.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const FSubscribedInputEventParameters& EventParms );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a member property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Copies the values from the deprecated SelectionOverlayStyle property into the appropriate element of the ItemOverlayStyle array.
	 */
	virtual void PostLoad();
};

struct FContextMenuItem
{
    class UUIContextMenu* OwnerMenu;
    struct FContextMenuItem* ParentItem;
    BYTE ItemType;
    FString ItemText;
    INT ItemId;

    /** Constructors */
    FContextMenuItem()
    : OwnerMenu(NULL)
    , ItemType(0)
    , ItemId(0)
    {}
    FContextMenuItem(EEventParm)
    {
        appMemzero(this, sizeof(FContextMenuItem));
    }
};

struct UIContextMenu_eventFindMenuItemIndex_Parms
{
    class UUIObject* Widget;
    FString ItemToFind;
    INT ReturnValue;
    UIContextMenu_eventFindMenuItemIndex_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventGetMenuItem_Parms
{
    class UUIObject* Widget;
    INT IndexToGet;
    FString out_MenuItem;
    UBOOL ReturnValue;
    UIContextMenu_eventGetMenuItem_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventGetAllMenuItems_Parms
{
    class UUIObject* Widget;
    TArray<FString> out_MenuItems;
    UBOOL ReturnValue;
    UIContextMenu_eventGetAllMenuItems_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventRemoveMenuItemAtIndex_Parms
{
    class UUIObject* Widget;
    INT IndexToRemove;
    UBOOL ReturnValue;
    UIContextMenu_eventRemoveMenuItemAtIndex_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventRemoveMenuItem_Parms
{
    class UUIObject* Widget;
    FString ItemToRemove;
    UBOOL ReturnValue;
    UIContextMenu_eventRemoveMenuItem_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventClearMenuItems_Parms
{
    class UUIObject* Widget;
    UBOOL ReturnValue;
    UIContextMenu_eventClearMenuItems_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventInsertMenuItem_Parms
{
    class UUIObject* Widget;
    FString Item;
    INT InsertIndex;
    UBOOL bAllowDuplicates;
    UBOOL ReturnValue;
    UIContextMenu_eventInsertMenuItem_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventSetMenuItems_Parms
{
    class UUIObject* Widget;
    TArray<FString> NewMenuItems;
    UBOOL bClearExisting;
    INT InsertIndex;
    UBOOL ReturnValue;
    UIContextMenu_eventSetMenuItems_Parms(EEventParm)
    {
    }
};
class UUIContextMenu : public UUIList
{
public:
    //## BEGIN PROPS UIContextMenu
    class UUIObject* InvokingWidget;
    TArrayNoInit<struct FContextMenuItem> MenuItems;
    BITFIELD bResolvePosition:1;
    //## END PROPS UIContextMenu

    UBOOL IsActiveContextMenu() const;
    UBOOL Open(INT PlayerIndex=0);
    UBOOL Close(INT PlayerIndex=0);
    DECLARE_FUNCTION(execIsActiveContextMenu)
    {
        P_FINISH;
        *(UBOOL*)Result=IsActiveContextMenu();
    }
    DECLARE_FUNCTION(execOpen)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=Open(PlayerIndex);
    }
    DECLARE_FUNCTION(execClose)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=Close(PlayerIndex);
    }
    INT eventFindMenuItemIndex(class UUIObject* Widget,const FString& ItemToFind)
    {
        UIContextMenu_eventFindMenuItemIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.ItemToFind=ItemToFind;
        ProcessEvent(FindFunctionChecked(ENGINE_FindMenuItemIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetMenuItem(class UUIObject* Widget,INT IndexToGet,FString& out_MenuItem)
    {
        UIContextMenu_eventGetMenuItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        Parms.IndexToGet=IndexToGet;
        Parms.out_MenuItem=out_MenuItem;
        ProcessEvent(FindFunctionChecked(ENGINE_GetMenuItem),&Parms);
        out_MenuItem=Parms.out_MenuItem;
        return Parms.ReturnValue;
    }
    UBOOL eventGetAllMenuItems(class UUIObject* Widget,TArray<FString>& out_MenuItems)
    {
        UIContextMenu_eventGetAllMenuItems_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        Parms.out_MenuItems=out_MenuItems;
        ProcessEvent(FindFunctionChecked(ENGINE_GetAllMenuItems),&Parms);
        out_MenuItems=Parms.out_MenuItems;
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveMenuItemAtIndex(class UUIObject* Widget,INT IndexToRemove)
    {
        UIContextMenu_eventRemoveMenuItemAtIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        Parms.IndexToRemove=IndexToRemove;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveMenuItemAtIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveMenuItem(class UUIObject* Widget,const FString& ItemToRemove)
    {
        UIContextMenu_eventRemoveMenuItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        Parms.ItemToRemove=ItemToRemove;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveMenuItem),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventClearMenuItems(class UUIObject* Widget)
    {
        UIContextMenu_eventClearMenuItems_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        ProcessEvent(FindFunctionChecked(ENGINE_ClearMenuItems),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInsertMenuItem(class UUIObject* Widget,const FString& Item,INT InsertIndex=-1,UBOOL bAllowDuplicates=FALSE)
    {
        UIContextMenu_eventInsertMenuItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        Parms.Item=Item;
        Parms.InsertIndex=InsertIndex;
        Parms.bAllowDuplicates=bAllowDuplicates ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertMenuItem),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetMenuItems(class UUIObject* Widget,const TArray<FString>& NewMenuItems,UBOOL bClearExisting=TRUE,INT InsertIndex=-1)
    {
        UIContextMenu_eventSetMenuItems_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Widget=Widget;
        Parms.NewMenuItems=NewMenuItems;
        Parms.bClearExisting=bClearExisting ? FIRST_BITFIELD : FALSE;
        Parms.InsertIndex=InsertIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMenuItems),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIContextMenu,UUIList,0|CLASS_Config,Engine)
	/**
	 * Resolves this context menu's position into actual pixel values.
	 */
	virtual void ResolveContextMenuPosition();

	/** === UUIList interface === */
	/**
	 * Called whenever the user chooses an item while this list is focused.  Activates the SubmitSelection kismet event and calls
	 * the OnSubmitSelection delegate.
	 */
	virtual void NotifySubmitSelection( INT PlayerIndex );

	/* === UIObject interface === */
protected:
	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Handles input events for this context menu.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/** === UUIScreenObject interface === */
	/**
	 * Overridden to prevent any of this widget's inherited methods or components from triggering a scene update, as context menu
	 * positions are updated differently.
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );
};

class UUINavigationList : public UUIList
{
public:
    //## BEGIN PROPS UINavigationList
    //## END PROPS UINavigationList

    DECLARE_CLASS(UUINavigationList,UUIList,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUINavigationList)
};

class UUIObjectList : public UUIList
{
public:
    //## BEGIN PROPS UIObjectList
    //## END PROPS UIObjectList

    class UUIObject* GetElementObjectValue(INT ElementIndex,INT CellIndex=-1) const;
    DECLARE_FUNCTION(execGetElementObjectValue)
    {
        P_GET_INT(ElementIndex);
        P_GET_INT_OPTX(CellIndex,-1);
        P_FINISH;
        *(class UUIObject**)Result=GetElementObjectValue(ElementIndex,CellIndex);
    }
    DECLARE_CLASS(UUIObjectList,UUIList,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIObjectList)
};

class UUIMeshWidget : public UUIObject
{
public:
    //## BEGIN PROPS UIMeshWidget
    class UStaticMeshComponent* Mesh;
    //## END PROPS UIMeshWidget

    DECLARE_CLASS(UUIMeshWidget,UUIObject,0|CLASS_Config,Engine)
	/* === UUIObject interface === */
	/**
	 * Updates 3D primitives for this widget.
	 *
	 * @param	CanvasScene		the scene to use for updating any 3D primitives
	 */
	virtual void UpdateWidgetPrimitives( FCanvasScene* CanvasScene );

	/* === UUIScreenObject interface === */
	/**
	 * Attach and initialize any 3D primitives for this widget and its children.
	 *
	 * @param	CanvasScene		the scene to use for attaching 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );
};

#define UCONST_UIKEY_MoveCursorRight UIKEY_MoveCursorRight
#define UCONST_UIKEY_MoveCursorLeft UIKEY_MoveCursorLeft

struct UIOptionListBase_eventCreateCustomIncrementButton_Parms
{
    class UUIOptionListBase* ButtonOwner;
    class UUIOptionListButton* ReturnValue;
    UIOptionListBase_eventCreateCustomIncrementButton_Parms(EEventParm)
    {
    }
};
struct UIOptionListBase_eventCreateCustomDecrementButton_Parms
{
    class UUIOptionListBase* ButtonOwner;
    class UUIOptionListButton* ReturnValue;
    UIOptionListBase_eventCreateCustomDecrementButton_Parms(EEventParm)
    {
    }
};
class UUIOptionListBase : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIOptionListBase
    struct FUIStyleReference DecrementStyle;
    struct FUIStyleReference IncrementStyle;
    class UUIOptionListButton* DecrementButton;
    class UUIOptionListButton* IncrementButton;
    class UClass* OptionListButtonClass;
    struct FUIScreenValue_Extent ButtonSpacing;
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawString* StringRenderComponent;
    FName IncrementCue;
    FName DecrementCue;
    BITFIELD bWrapOptions:1;
    struct FUIDataStoreBinding DataSource;
    FScriptDelegate __CreateCustomDecrementButton__Delegate;
    FScriptDelegate __CreateCustomIncrementButton__Delegate;
    //## END PROPS UIOptionListBase

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    virtual UBOOL HasPrevValue() const;
    virtual UBOOL HasNextValue() const;
    virtual void OnMoveSelectionLeft(INT PlayerIndex);
    virtual void OnMoveSelectionRight(INT PlayerIndex);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execHasPrevValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasPrevValue();
    }
    DECLARE_FUNCTION(execHasNextValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasNextValue();
    }
    DECLARE_FUNCTION(execOnMoveSelectionLeft)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        OnMoveSelectionLeft(PlayerIndex);
    }
    DECLARE_FUNCTION(execOnMoveSelectionRight)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        OnMoveSelectionRight(PlayerIndex);
    }
    class UUIOptionListButton* delegateCreateCustomIncrementButton(class UUIOptionListBase* ButtonOwner)
    {
        UIOptionListBase_eventCreateCustomIncrementButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ButtonOwner=ButtonOwner;
        ProcessDelegate(ENGINE_CreateCustomIncrementButton,&__CreateCustomIncrementButton__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIOptionListButton* delegateCreateCustomDecrementButton(class UUIOptionListBase* ButtonOwner)
    {
        UIOptionListBase_eventCreateCustomDecrementButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ButtonOwner=ButtonOwner;
        ProcessDelegate(ENGINE_CreateCustomDecrementButton,&__CreateCustomDecrementButton__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIOptionListBase,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
protected:
	/* === UUIOptionListBase interface === */
	/**
	 * Updates the string component with the current value of the optionlist.
	 */
	virtual void UpdateStringComponent() PURE_VIRTUAL(UUIOptionListBase::UpdateStringComponent,);

public:
	/**
	 * Creates the support controls which make up the list button - the left button and the right button.
	 */
	virtual void CreateInternalControls();

	/**
	 * Sends the appropriate event when the NotifyValueChanged function is called.
	 */
	virtual void ActivateEventOnNotifyValueChanged( INT PlayerIndex, INT NotifyFlags ) {}

	/* === UUIObject interface === */
	/**
	 * Called whenever the value of the slider is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Render this button.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

	/* === UUIScreenObject interface === */
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UObject interface === */
	/**
	 * Called just before just object is saved to disk.  Clears all references to the internal buttons.
	 */
	virtual void PreSave();

	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUINumericOptionList : public UUIOptionListBase
{
public:
    //## BEGIN PROPS UINumericOptionList
    struct FUIRangeData RangeValue;
    //## END PROPS UINumericOptionList

    UBOOL SetValue(FLOAT NewValue,UBOOL bPercentageValue=FALSE);
    FLOAT GetValue(UBOOL bPercentageValue=FALSE) const;
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetValue(NewValue,bPercentageValue);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetValue(bPercentageValue);
    }
    DECLARE_CLASS(UUINumericOptionList,UUIOptionListBase,0|CLASS_Config,Engine)
protected:
	/* === UUIOptionListBase interface === */
	/**
	 * Updates the string component with the current value of the optionlist.
	 */
	virtual void UpdateStringComponent();

public:
	/**
	 * @return	TRUE if the user is allowed to decrement the value of this widget
	 */
	virtual UBOOL HasPrevValue() const;
	/**
	 * @return	TRUE if the user is allowed to increment the value of this widget
	 */
	virtual UBOOL HasNextValue() const;

	/** Moves the current selection to the left. */
	virtual void OnMoveSelectionLeft(INT PlayerIndex);

	/** Moves the current selection to the right. */
	virtual void OnMoveSelectionRight(INT PlayerIndex);

	/**
	* Sends the appropriate event when the NotifyValueChanged function is called.
	*/
	virtual void ActivateEventOnNotifyValueChanged( INT PlayerIndex, INT NotifyFlags );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/* === UUIDataStoreSubscriber interface === */
	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/* === UUIDataStorePublisher interface === */
	/**
	 * Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.
	 *
	 * @param	out_BoundDataStores	contains the array of data stores that widgets have saved values to.  Each widget that
	 *								implements this method should add its resolved data store to this array after data values have been
	 *								published.  Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called
	 *								on all data stores in this array.
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);
};

struct UIOptionList_eventOnIsCurrValueValid_Parms
{
    UBOOL ReturnValue;
    UIOptionList_eventOnIsCurrValueValid_Parms(EEventParm)
    {
    }
};
class UUIOptionList : public UUIOptionListBase
{
public:
    //## BEGIN PROPS UIOptionList
    INT CurrentIndex;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    FScriptDelegate __OnIsCurrValueValid__Delegate;
    //## END PROPS UIOptionList

    UBOOL GetListValue(INT ListIndex,FString& OutValue);
    virtual void SetPrevValue();
    virtual void SetNextValue();
    virtual UBOOL IsCurrValueValid();
    virtual INT GetCurrentIndex() const;
    virtual void SetCurrentIndex(INT NewIndex);
    DECLARE_FUNCTION(execGetListValue)
    {
        P_GET_INT(ListIndex);
        P_GET_STR_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetListValue(ListIndex,OutValue);
    }
    DECLARE_FUNCTION(execSetPrevValue)
    {
        P_FINISH;
        SetPrevValue();
    }
    DECLARE_FUNCTION(execSetNextValue)
    {
        P_FINISH;
        SetNextValue();
    }
    DECLARE_FUNCTION(execIsCurrValueValid)
    {
        P_FINISH;
        *(UBOOL*)Result=IsCurrValueValid();
    }
    DECLARE_FUNCTION(execGetCurrentIndex)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentIndex();
    }
    DECLARE_FUNCTION(execSetCurrentIndex)
    {
        P_GET_INT(NewIndex);
        P_FINISH;
        SetCurrentIndex(NewIndex);
    }
    UBOOL delegateOnIsCurrValueValid()
    {
        UIOptionList_eventOnIsCurrValueValid_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessDelegate(ENGINE_OnIsCurrValueValid,&__OnIsCurrValueValid__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIOptionList,UUIOptionListBase,0|CLASS_Config,Engine)
	/**
	 * Resolves DataSource into the list element provider that it references.
	 */
	virtual void ResolveListElementProvider();

protected:
	/* === UUIOptionList interface === */
	/** @return Returns the number of possible values for the field we are bound to. */
	INT GetNumValues() const;

	/* === UUIOptionListBase interface === */
	/**
	 * Updates the string component with the current value of the optionlist.
	 */
	virtual void UpdateStringComponent();

public:
	/**
	 * @return	TRUE if the user is allowed to decrement the value of this widget
	 */
	virtual UBOOL HasPrevValue() const;
	/**
	 * @return	TRUE if the user is allowed to increment the value of this widget
	 */
	virtual UBOOL HasNextValue() const;

	/** Moves the current selection to the left. */
	virtual void OnMoveSelectionLeft(INT PlayerIndex);

	/** Moves the current selection to the right. */
	virtual void OnMoveSelectionRight(INT PlayerIndex);

	/**
	* Sends the appropriate event when the NotifyValueChanged function is called.
	*/
	virtual void ActivateEventOnNotifyValueChanged( INT PlayerIndex, INT NotifyFlags );

	/* === UUIDataStoreSubscriber interface === */
	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/* === UUIDataStorePublisher interface === */
	/**
	 * Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.
	 *
	 * @param	out_BoundDataStores	contains the array of data stores that widgets have saved values to.  Each widget that
	 *								implements this method should add its resolved data store to this array after data values have been
	 *								published.  Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called
	 *								on all data stores in this array.
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);
};

struct FArchetypeInstancePair
{
    class UUIObject* WidgetArchetype;
    class UUIObject* WidgetInstance;
    FLOAT ArchetypeBounds[4];
    FLOAT InstanceBounds[4];

		/** Constructors */
		FArchetypeInstancePair()
		: WidgetArchetype(NULL), WidgetInstance(NULL)
		{
			appMemzero(ArchetypeBounds, sizeof(ArchetypeBounds));
			appMemzero(InstanceBounds, sizeof(InstanceBounds));
		}

		FArchetypeInstancePair( UUIObject* InArchetype, UUIObject* InInstance )
		: WidgetArchetype(InArchetype), WidgetInstance(InInstance)
		{
			appMemzero(ArchetypeBounds, sizeof(ArchetypeBounds));
			appMemzero(InstanceBounds, sizeof(InstanceBounds));
		}

		/** Comparison operators */
		inline UBOOL operator==( const FArchetypeInstancePair& Other ) const
		{
			return appMemcmp(this, &Other, sizeof(FArchetypeInstancePair)) == 0;
		}
		inline UBOOL operator!=( const FArchetypeInstancePair& Other ) const
		{
			return appMemcmp(this, &Other, sizeof(FArchetypeInstancePair)) != 0;
		}

		/** To allow this struct to be used as the key in a TMap */
		friend inline DWORD GetTypeHash( const FArchetypeInstancePair& Pair )
		{
			return PointerHash(Pair.WidgetArchetype, PointerHash(Pair.WidgetInstance));
		}
	
};

class UUIPrefab : public UUIObject
{
public:
    //## BEGIN PROPS UIPrefab
    INT PrefabVersion;
private:
    INT InternalPrefabVersion;
public:
    class UTexture2D* PrefabPreview;
    INT ModificationCounter;
    struct FUIScreenValue_Extent OriginalWidth;
    struct FUIScreenValue_Extent OriginalHeight;
    //## END PROPS UIPrefab

    DECLARE_CLASS(UUIPrefab,UUIObject,0|CLASS_Config,Engine)
	/* === UUIPrefab interface === */
	/**
	 * Creates archetypes for the specified widgets and adds the archetypes to this UIPrefab.
	 *
	 * @param	WidgetPairs				[in]	the widgets to create archetypes for, along with their screen positions (in pixels)
	 *									[out]	receives the list of archetypes that were created from the WidgetInstances
	 *
	 * @return	TRUE if archetypes were created and added to this UI archetype successfully.  FALSE if this UIPrefab
	 *			is not an archetype, if the widgets specified are already archetypes, or couldn't other
	 *			be created.
	 */
	UBOOL CreateWidgetArchetypes( TArray<struct FArchetypeInstancePair>& WidgetPairs, const FBox& BoundingRegion );

	/**
	 * Generates a name for the widget specified in the format 'WidgetClass_Arc_##', where ## corresponds to the number of widgets of that
	 * class already contained by this wrapper (though not completely representative, since other widget of that class may have been previously
	 * removed).
	 *
	 * @param	WidgetTypeCounts	contains the number of widgets of each class contained by this wrapper
	 * @param	WidgetInstance		the widget class to generate a unique archetype name for
	 *
	 * @return	a widget archetype name guaranteed to be unique within the scope of this wrapper.
	 */
	FName GenerateUniqueArchetypeName( TMap<UClass*,INT>& WidgetTypeCounts, UClass* WidgetClass ) const;

	/**
	 * Creates an instance of this UIPrefab; does NOT add the new UIPrefabInstance to the specified DestinationOwner's
	 * Children array.
	 *
	 * @param	DestinationOwner	the widget to use as the parent for the new PrefabInstance
	 * @param	DestinationName		the name to use for the new PrefabInstance.
	 *
	 * @return	a pointer to a UIPrefabInstance created from this UIPrefab
	 */
	class UUIPrefabInstance* InstancePrefab( UUIScreenObject* DestinationOwner, FName DestinationName );

	/**
	 * Notifies all instances of this UIPrefab to serialize their current property values against this UIPrefab.
	 * Called just before something is modified in a widget contained in this UIPrefab.
	 */
	void SavePrefabInstances();

	/**
	 * Notifies all instances of this UIPrefab to re-initialize and reload their property data.  Called just after
	 * something is modified in a widget contained in this UIPrefab.
	 */
	void LoadPrefabInstances();

	/**
	 * Remaps object references within the specified set of objects.  Iterates through the specified map, applying an
	 * FReplaceObjectReferences archive to each value in the map, using the map itself as the replacement map.
	 *
	 * @param	ReplacementMap		map of archetype => instances or instances => archetypes to use for replacing object
	 *								references
	 * @param	bNullPrivateRefs	should we null references to any private objects
	 * @param	SourceObjects		if specified, applies the replacement archive on these objects instead of the values (objects)
	 *								in the ReplacementMap.
	 */
	static void ConvertObjectReferences( TMap<UObject*,UObject*>& ReplacementMap, UBOOL bNullPrivateRefs, TArray<UObject*>* SourceObjects=NULL );

	/**
	 * Determines whether the widget is allowed to be added to a UI prefab.
	 *
	 * @param	Widget	the widget to check
	 *
	 * @return	TRUE if this widget is allowed to be added to a UI prefab.
	 */
	static UBOOL SupportsWidgetType( UUIObject* Widget );

	/* === UIObject interface === */
	/**
	 * UIPrefabs don't render anything.
	 */
	virtual void Render_Widget(FCanvas*) {}

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Determines whether to change the Outer of this widget if the widget's Owner doesn't match it's Outer.
	 */
	virtual UBOOL RequiresParentForOuter() const { return FALSE; }

	/**
	 * Returns the default parent to use when placing widgets using the UI editor.  This widget is used when placing
	 * widgets by dragging their outline using the mouse, for example.
	 *
	 * @return	a pointer to the widget that will contain newly placed widgets when a specific parent widget has not been
	 *			selected by the user.
	 */
	virtual UUIScreenObject* GetEditorDefaultParentWidget();

	/* === UObject interface === */
	/**
	 * Called just before just object is saved to disk.  Updates the value of InternalPrefabVersion to match PrefabVersion,
	 * and prevents the sequence objects contained in this prefab from being marked RF_NotForServer|RF_NotForClient.
	 */
	virtual void PreSave();

	/**
	 * Note that the object has been modified.  If we are currently recording into the
	 * transaction buffer (undo/redo), save a copy of this object into the buffer and
	 * marks the package as needing to be saved.
	 *
	 * @param	bAlwaysMarkDirty	if TRUE, marks the package dirty even if we aren't
	 *								currently recording an active undo/redo transaction
	 */
	virtual void Modify( UBOOL bAlwaysMarkDirty=FALSE );

	/**
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser.
	 *
	 * This version prints the number of widgets contained in this prefab.
	 */
	virtual FString GetDesc();

	/**
	 * Builds a list of UIPrefabInstances which have this UIPrefab as their SourcePrefab.
	 *
	 * @param	Instances	receives the list of UIPrefabInstances which have this UIPrefab as their SourcePrefab.
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Increments the value of ModificationCounter.  If the previous value was 0, calls SavePrefabInstances.
	 * Called just before something is modified in a widget contained in this UIPrefab.
	 *
	 * @param	AffectedObjects		ignored
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Decrements the value of ModificationCounter.  If the new value is 0, calls LoadPrefabInstances.
	 * Called just after something is modified in a widget contained in this UIPrefab.
	 *
	 * @param	AffectedObjects		ignored
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );
};

class UUIPrefabInstance : public UUIObject
{
public:
    //## BEGIN PROPS UIPrefabInstance
    class UUIPrefab* SourcePrefab;
    INT PrefabInstanceVersion;
    TMap< UObject*,UObject* > ArchetypeToInstanceMap;
    INT PI_PackageVersion;
    INT PI_LicenseePackageVersion;
    INT PI_DataOffset;
    TArrayNoInit<BYTE> PI_Bytes;
    TArrayNoInit<class UObject*> PI_CompleteObjects;
    TArrayNoInit<class UObject*> PI_ReferencedObjects;
    TArrayNoInit<FString> PI_SavedNames;
    TMap< UObject*,INT > PI_ObjectMap;
    //## END PROPS UIPrefabInstance

    void DetachFromSourcePrefab();
    DECLARE_FUNCTION(execDetachFromSourcePrefab)
    {
        P_FINISH;
        DetachFromSourcePrefab();
    }
    DECLARE_CLASS(UUIPrefabInstance,UUIObject,0|CLASS_Config,Engine)
	/* === UIPrefabInstance interface === */
	/**
	 * Convert this prefab instance to look like the Prefab archetype version of it (by changing object refs to archetype refs and
	 * converting positions to local space). Then serialise it, so we only get things that are unique to this instance. We store this
	 * archive in the PrefabInstance.
	 */
	void SavePrefabDifferences();

private:
	/**
	 * Generates a list of all widget and sequence archetypes contained in the specified parent which have never been instanced into this
	 * UIPrefabInstance (and thus, have been newly added since this UIPrefabInstance was last saved), recursively.
	 *
	 * @param	ParentArchetype			a pointer to a widget archetype; must be contained within this UIPrefabInstance's SourcePrefab.
	 * @param	NewWidgetArchetypes		receives the list of archetype widgets contained within ParentArchetype which have never been instanced into this
	 *									UIPrefabInstance.
	 * @param	NewSequenceArchetypes	receives the list of sequence object archetypes contained within ParentArchetype which do not exist in this UIPrefabInstance;
	 *									will not include sequence objects contained in widgets that are also newly added.
	 */
	void FindNewArchetypes( class UUIObject* ParentArchetype, TArray<class UUIObject*>& NewWidgetArchetypes, TArray<class USequenceObject*>& NewSequenceArchetypes );

	/**
	 * Helper method for recursively finding sequence archetype objects which have been added since this UIPrefabInstance was last updated.
	 *
	 * @param	ParentArchetype			a pointer to a widget archetype; must be contained within this UIPrefabInstance's SourcePrefab.
	 * @param	SequenceToCheck			the sequence to search for new archetypes in
	 * @param	NewSequenceArchetypes	receives the list of sequence object archetypes which do not exist in this UIPrefabInstance
	 */
	void FindNewSequenceArchetypes( class UUIObject* ParentArchetype, class USequence* SequenceToCheck, TArray<class USequenceObject*>& NewSequenceArchetypes );

public:

	/**
	 * Reinitializes this UIPrefabInstance against its SourcePrefab.  The main purpose of this function (over standard archetype propagation)
	 * is to convert all inter-object references within the PrefabInstance into references to their archetypes.  This is the only way that
	 * changes to object references in a UIPrefab can be propagated to UIPrefabInstances, since otherwise the UIPrefabInstance would serialize
	 * those object references.
	 *
	 * This will destroy/create objects as necessary.
	 */
	void UpdateUIPrefabInstance();

	/**
	 * Iterates through the ArchetypeToInstanceMap and verifies that the archetypes for each of this PrefabInstance's actors exist.
	 * For any actors contained by this PrefabInstance that do not have a corresponding archetype, removes the actor from the
	 * ArchetypeToInstanceMap.  This is normally caused by adding a new actor to a PrefabInstance, updating the source Prefab, then loading
	 * a new map without first saving the package containing the updated Prefab.  When the original map is reloaded, though it contains
	 * an entry for the newly added actor, the source Prefab's linker does not contain an entry for the corresponding archetype.
	 *
	 * @return	TRUE if one or more archetypes were NULL; FALSE if each pair in the ArchetypeToInstanceMap was a valid 'Key'
	 */
	UBOOL HasMissingArchetypes();

	/** Copy information to a FUIPrefabUpdateArc from this PrefabInstance for updating a PrefabInstance with. */
	void CopyToArchive(FUIPrefabUpdateArc* InArc);

	/** Copy information from a FUIPrefabUpdateArc into this PrefabInstance for saving etc. */
	void CopyFromArchive( const FUIPrefabUpdateArc* InArc );

	/* === UIObject interface === */
	/**
	 * UIArchetype wrappers don't render anything.
	 */
	virtual void Render_Widget(FCanvas*) {}

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/* === UObject interface === */
	virtual void			Serialize(FArchive& Ar);
	virtual void			PreSave();

#if REQUIRES_SAMECLASS_ARCHETYPE
	/**
	 * Provides PrefabInstance & UIPrefabInstanc objects with a way to override incorrect behavior in ConditionalPostLoad()
	 * until different-class archetypes are supported.
	 *
	 * @fixme - temporary hack; correct fix would be to support archetypes of a different class
	 *
	 * @return	pointer to an object instancing graph to use for logic in ConditionalPostLoad().
	 */
	virtual struct FObjectInstancingGraph* GetCustomPostLoadInstanceGraph();
#endif

	/**
	 * Serializes the unrealscript property data located at Data.  When saving, only saves those properties which differ from the corresponding
	 * value in the specified 'DiffObject' (usually the object's archetype).
	 *
	 * @param	Ar				the archive to use for serialization
	 * @param	DiffObject		the object to use for determining which properties need to be saved (delta serialization);
	 *							if not specified, the ObjectArchetype is used
	 * @param	DefaultsCount	maximum number of bytes to consider for delta serialization; any properties which have an Offset+ElementSize greater
	 *							that this value will NOT use delta serialization when serializing data;
	 *							if not specified, the result of DiffObject->GetClass()->GetPropertiesSize() will be used.
	 */
	virtual void SerializeScriptProperties( FArchive& Ar, UObject* DiffObject=NULL, INT DiffCount=0 ) const;

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIProgressBar : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIProgressBar
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawImage* FillImageComponent;
    class UUIComp_DrawImage* OverlayImageComponent;
    BITFIELD bDrawOverlay:1;
    struct FUIDataStoreBinding DataSource;
    struct FUIRangeData ProgressBarValue;
    BYTE ProgressBarOrientation;
    //## END PROPS UIProgressBar

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    UBOOL SetValue(FLOAT NewValue,UBOOL bPercentageValue=FALSE);
    FLOAT GetValue(UBOOL bPercentageValue=FALSE) const;
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetValue(NewValue,bPercentageValue);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetValue(bPercentageValue);
    }
    DECLARE_CLASS(UUIProgressBar,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIProgressBar interface === */
	/**
	 * Changes the background image for this progressbar, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the progressbar's background image
	 */
	void SetBackgroundImage( class USurface* NewBarImage );

	/**
	 * Changes the fill image for this progressbar, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewFillImage		the new surface to use for the progressbar's marker
	 */
	void SetFillImage( class USurface* NewFillImage );

	/**
	 * Changes the overlay image for this progressbar, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewOverlayImage		the new surface to use for the progressbar's overlay image
	 */
	void SetOverlayImage( class USurface* NewOverlayImage );

	/**
	 * Returns the pixel extent of the progressbar fill based on the current progressbar value
	 */
	FLOAT GetBarFillExtent();

	/* === UIObject interface === */
	/**
	 * Called whenever the value of the progressbar is modified.  Activates the ProgressBarValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the image components (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Render this progressbar.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated image values
	 * over to the corresponding components.
	 */
	virtual void PostLoad();
};

struct UIScrollbar_eventOnClickedScrollZone_Parms
{
    class UUIScrollbar* Sender;
    FLOAT PositionPerc;
    INT PlayerIndex;
    UIScrollbar_eventOnClickedScrollZone_Parms(EEventParm)
    {
    }
};
struct UIScrollbar_eventOnScrollActivity_Parms
{
    class UUIScrollbar* Sender;
    FLOAT PositionChange;
    UBOOL bPositionMaxed;
    UBOOL ReturnValue;
    UIScrollbar_eventOnScrollActivity_Parms(EEventParm)
    {
    }
};
class UUIScrollbar : public UUIObject
{
public:
    //## BEGIN PROPS UIScrollbar
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIScrollbarButton* IncrementButton;
    class UUIScrollbarButton* DecrementButton;
    class UUIScrollbarMarkerButton* MarkerButton;
    struct FUIStyleReference IncrementStyle;
    struct FUIStyleReference DecrementStyle;
    struct FUIStyleReference MarkerStyle;
private:
    FLOAT NudgeValue;
public:
    FLOAT NudgeMultiplier;
private:
    FLOAT NudgePercent;
    FLOAT MarkerPosPercent;
    FLOAT MarkerSizePercent;
public:
    struct FUIScreenValue_Extent BarWidth;
    struct FUIScreenValue_Extent MinimumMarkerSize;
    struct FUIScreenValue_Extent ButtonsExtent;
    BYTE ScrollbarOrientation;
    BITFIELD bAddCornerPadding:1 GCC_BITFIELD_MAGIC;
    BITFIELD bInitializeMarker:1;
    struct FUIScreenValue_Position MousePosition;
    FLOAT MousePositionDelta;
    FScriptDelegate __OnScrollActivity__Delegate;
    FScriptDelegate __OnClickedScrollZone__Delegate;
    //## END PROPS UIScrollbar

    FLOAT GetMarkerButtonPosition() const;
    FLOAT GetScrollZoneWidth() const;
    void SetMarkerSize(FLOAT SizePercentage);
    void SetMarkerPosition(FLOAT PositionPercentage);
    void SetNudgeSizePercent(FLOAT NudgePercentage);
    void SetNudgeSizePixels(FLOAT NudgePixels);
    void EnableCornerPadding(UBOOL FlagValue);
    void ScrollIncrement(class UUIScreenObject* Sender,INT PlayerIndex);
    void ScrollDecrement(class UUIScreenObject* Sender,INT PlayerIndex);
    void DragScrollBegin(class UUIScreenObject* Sender,INT PlayerIndex);
    void DragScrollEnd(class UUIScreenObject* Sender,INT PlayerIndex);
    void DragScroll(class UUIScrollbarMarkerButton* Sender,INT PlayerIndex);
    DECLARE_FUNCTION(execGetMarkerButtonPosition)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMarkerButtonPosition();
    }
    DECLARE_FUNCTION(execGetScrollZoneExtent);
    DECLARE_FUNCTION(execGetScrollZoneWidth)
    {
        P_FINISH;
        *(FLOAT*)Result=GetScrollZoneWidth();
    }
    DECLARE_FUNCTION(execSetMarkerSize)
    {
        P_GET_FLOAT(SizePercentage);
        P_FINISH;
        SetMarkerSize(SizePercentage);
    }
    DECLARE_FUNCTION(execSetMarkerPosition)
    {
        P_GET_FLOAT(PositionPercentage);
        P_FINISH;
        SetMarkerPosition(PositionPercentage);
    }
    DECLARE_FUNCTION(execSetNudgeSizePercent)
    {
        P_GET_FLOAT(NudgePercentage);
        P_FINISH;
        SetNudgeSizePercent(NudgePercentage);
    }
    DECLARE_FUNCTION(execSetNudgeSizePixels)
    {
        P_GET_FLOAT(NudgePixels);
        P_FINISH;
        SetNudgeSizePixels(NudgePixels);
    }
    DECLARE_FUNCTION(execEnableCornerPadding)
    {
        P_GET_UBOOL(FlagValue);
        P_FINISH;
        EnableCornerPadding(FlagValue);
    }
    DECLARE_FUNCTION(execScrollIncrement)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        ScrollIncrement(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execScrollDecrement)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        ScrollDecrement(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDragScrollBegin)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DragScrollBegin(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDragScrollEnd)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DragScrollEnd(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDragScroll)
    {
        P_GET_OBJECT(UUIScrollbarMarkerButton,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DragScroll(Sender,PlayerIndex);
    }
    void delegateOnClickedScrollZone(class UUIScrollbar* Sender,FLOAT PositionPerc,INT PlayerIndex)
    {
        UIScrollbar_eventOnClickedScrollZone_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PositionPerc=PositionPerc;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnClickedScrollZone,&__OnClickedScrollZone__Delegate,&Parms);
    }
    UBOOL delegateOnScrollActivity(class UUIScrollbar* Sender,FLOAT PositionChange,UBOOL bPositionMaxed=FALSE)
    {
        UIScrollbar_eventOnScrollActivity_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Sender=Sender;
        Parms.PositionChange=PositionChange;
        Parms.bPositionMaxed=bPositionMaxed ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnScrollActivity,&__OnScrollActivity__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIScrollbar,UUIObject,0|CLASS_Config,Engine)
	/* === UUIScrollbar interface === */
	/**
	 * Changes the background image for this slider.
	 *
	 * @param	NewBarImage		the new surface to use for the slider's background image
	 */
	void SetBackgroundImage( USurface* NewBackgroundImage );

	/**
	 * Returns the size of the scroll-zone (the region between the decrement and increment buttons), along the same orientation as the scrollbar.
	 *
	 * @param	ScrollZoneStart	receives the value of the location of the beginning of the scroll zone, in pixels relative to the scrollbar.
	 *
	 * @return	the height (if the scrollbar's orientation is vertical) or width (if horizontal) of the region between the
	 *			increment and decrement buttons, in pixels.
	 *
	 * @note: noexport for handling the optional out parameter correctly.
	 */
	FLOAT GetScrollZoneExtent( FLOAT* ScrollZoneStart=NULL ) const;

	/**
	 * Verifies that marker can be moved by the given PositionChange value. If the PositionChange is too large
	 * and would cause the marker to extend beyond the increment or decrement buttons, then it will be clamped to a
	 * value by which will the marker can move and not extend beyond its bar region
	 */
	FLOAT GetClampedPositionChange(FLOAT PositionChange);

	/** Simple accessors */
	FLOAT GetNudgeValue() const			{ return NudgeValue; }
	FLOAT GetNudgePercent() const		{ return NudgePercent; }
	FLOAT GetMarkerPosPercent() const	{ return MarkerPosPercent; }
	FLOAT GetMarkerSizePercent() const	{ return MarkerSizePercent; }

	/**
	 * Returns TRUE if the inner faces of the decrement and increment buttons have both been resolved.
	 */
	UBOOL CanResolveScrollZoneExtent() const;

	/**
	 * Calls RefreshMarker() if the increment/decrement buttons' positions aren't up-to-date.
	 *
	 * @return	TRUE if RefreshMarker() was called.
	 */
	UBOOL ConditionalRefreshMarker();

	/**
	 * Sets a private flag to refresh the bound of the scrollbar
	 */
	void RefreshMarker();

	/**
	 * Resolves all marker-related percentage values (marker position, marker size, etc.) into actual pixels and applies these values to
	 * the marker widget.
	 *
	 * @param	bForceResolve	default behavior is to require bInitializeMarker to be TRUE; specify TRUE to ignore the value of bInitializeMarker
	 */
	virtual void ResolveAllMarkerValues( UBOOL bForceResolve=FALSE );

	/**
	 *	Shifts the position of the marker button by the amount specified, clamps the PositionChange if it would extend the marker pass the increment/decrement buttons
	 *  the direction of shift is based on the sign of the PositionChange and the ScrollbarOrientation setting
	 *
	 *  @param	PositionChange	the amount of pixels that the marker widget will be shifted by, supply
	 *                          negative value to shift marker in opposite direction
	 */
	void UpdateMarkerPosition(FLOAT PositionChange);

	/**
	 * Sets up marker button position based on the value of MarkerPosPercent
	 */
	void ResolveMarkerPosition();

	/**
	 * Sets up marker button bounds based on the value of MarkerSizePercent
	 */
	void ResolveMarkerSize();

	/**
	 * Resolves the NudgeValue into actual pixels
	 */
	void ResolveNudgeSize();

	/**
	 * Responsible for handling of the marker dragging, it reads mouse position and slides the marker in the
	 * appropriate direction
	 */
	void ProcessDragging();

	/**
	 * Responsible for handling paging which is invoked by mouse clicks on the empty bar space
	 */
	void ScrollZoneClicked( const struct FInputEventParameters& EventParms );

	/**
	 * Function overwritten to autoposition the scrollbar within the owner widget
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Render this scrollbar.
	 *
	 * @param	RI	the FRenderInterface to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreInitialSceneUpdate();

protected:

	/**
	 * Initializes the button and creates the bar image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the image components (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Sets up dock links between the scrollbar and its owner widget as well as child buttons of scrollbar.
	 * Docking links are used as a mechanism to autoposition the UUIScrollbar within its owner widget
	 *
	 * @param	bResetLinks		seting flag to TRUE will cause all existing links to be refreshed
	 */
	void SetupDocLinks( UBOOL bResetLinks = FALSE );

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated background
	 * image properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUISlider : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UISlider
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawImage* SliderBarImageComponent;
    class UUIComp_DrawImage* MarkerImageComponent;
    struct FUIDataStoreBinding DataSource;
    class UUIComp_DrawStringSlider* CaptionRenderComponent;
    struct FUIRangeData SliderValue;
    BITFIELD bRenderCaption:1;
    BYTE SliderOrientation GCC_BITFIELD_MAGIC;
    struct FUIScreenValue_Extent BarSize;
    struct FUIScreenValue_Extent MarkerHeight;
    struct FUIScreenValue_Extent MarkerWidth;
    FName IncrementCue;
    FName DecrementCue;
    //## END PROPS UISlider

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    UBOOL SetValue(FLOAT NewValue,UBOOL bPercentageValue=FALSE);
    FLOAT GetValue(UBOOL bPercentageValue=FALSE) const;
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execNotifyDataStoreValueUpdated)
    {
        P_GET_OBJECT(UUIDataStore,SourceDataStore);
        P_GET_UBOOL(bValuesInvalidated);
        P_GET_NAME(PropertyTag);
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_INT(ArrayIndex);
        P_FINISH;
        NotifyDataStoreValueUpdated(SourceDataStore,bValuesInvalidated,PropertyTag,SourceProvider,ArrayIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetValue(NewValue,bPercentageValue);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetValue(bPercentageValue);
    }
    DECLARE_CLASS(UUISlider,UUIObject,0|CLASS_Config,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUISlider interface === */
	/**
	 * Changes the background image for this slider, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the slider's background image
	 */
	void SetBackgroundImage( class USurface* NewBarImage );

	/**
	 * Changes the bar image for this slider, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the slider's bar image
	 */
	void SetBarImage( class USurface* NewBarImage );

	/**
	 * Changes the marker image for this slider, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewMarkerImage		the new surface to use for the slider's marker
	 */
	void SetMarkerImage( class USurface* NewMarkerImage );

	/**
	 * Returns the screen location (along the axis of the slider) for the marker, in absolute pixels.
	 */
	FLOAT GetMarkerPosition();

	/**
	 * Retrieves the location of the mouse within the bounding region of this slider, in percentage of the
	 * slider width (if orientation is horizontal) or height (if vertical).
	 *
	 * @param	out_Percentage	a value between 0.0 and 1.0 representing the percentage of the slider's size for the current
	 *							position of the mouse cursor.
	 *
	 * @return	TRUE if the cursor is within the bounding region of this slider.
	 */
	UBOOL GetCursorPosition( FLOAT& out_Percentage );

	/* === UUIObject interface === */
	/**
	 * Called whenever the value of the slider is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the image components (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Initializes the button and creates the bar image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Render this slider.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:
	/**
	 * Handles input events for this slider.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

	/**
	 * Processes input axis movement. Only called while the slider is in the pressed state; handles adjusting the slider
	 * value and moving the marker to the appropriate position.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Transfers the old individual range values to the new UIRangeData struct and migrates values for the deprecated image values
	 * over to the corresponding components.
	 */
	virtual void PostLoad();
};

struct UITabControl_eventEnableTabPage_Parms
{
    class UUITabPage* PageToEnable;
    INT PlayerIndex;
    UBOOL bEnablePage;
    UBOOL bActivatePage;
    UBOOL bFocusPage;
    UBOOL ReturnValue;
    UITabControl_eventEnableTabPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventActivatePreviousPage_Parms
{
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL bAllowWrapping;
    UBOOL ReturnValue;
    UITabControl_eventActivatePreviousPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventActivateNextPage_Parms
{
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL bAllowWrapping;
    UBOOL ReturnValue;
    UITabControl_eventActivateNextPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventActivatePage_Parms
{
    class UUITabPage* PageToActivate;
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL ReturnValue;
    UITabControl_eventActivatePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventReplacePage_Parms
{
    class UUITabPage* ExistingPage;
    class UUITabPage* NewPage;
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL ReturnValue;
    UITabControl_eventReplacePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventRemovePage_Parms
{
    class UUITabPage* PageToRemove;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UITabControl_eventRemovePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventInsertPage_Parms
{
    class UUITabPage* PageToInsert;
    INT PlayerIndex;
    INT InsertIndex;
    UBOOL bActivateImmediately;
    UBOOL ReturnValue;
    UITabControl_eventInsertPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventPrivateActivatePage_Parms
{
    class UUITabPage* PageToActivate;
    INT PlayerIndex;
    UITabControl_eventPrivateActivatePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventOnPageRemoved_Parms
{
    class UUITabControl* Sender;
    class UUITabPage* OldPage;
    INT PlayerIndex;
    UITabControl_eventOnPageRemoved_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventOnPageInserted_Parms
{
    class UUITabControl* Sender;
    class UUITabPage* NewPage;
    INT PlayerIndex;
    UITabControl_eventOnPageInserted_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventOnPageActivated_Parms
{
    class UUITabControl* Sender;
    class UUITabPage* NewlyActivePage;
    INT PlayerIndex;
    UITabControl_eventOnPageActivated_Parms(EEventParm)
    {
    }
};
class UUITabControl : public UUIObject
{
public:
    //## BEGIN PROPS UITabControl
protected:
    TArrayNoInit<class UUITabPage*> Pages;
public:
    class UUITabPage* ActivePage;
    class UUITabPage* PendingPage;
    BYTE TabDockFace;
    BYTE TabSizeMode;
    struct FUIScreenValue_Extent TabButtonSize;
    struct FUIScreenValue_Extent TabButtonPadding[2];
    struct FUIStyleReference TabButtonBackgroundStyle;
    struct FUIStyleReference TabButtonCaptionStyle;
    BITFIELD bAllowPagePreviews:1;
    BITFIELD bUpdateLayout:1;
    FName ActivateTabCue;
    FScriptDelegate __OnPageActivated__Delegate;
    FScriptDelegate __OnPageInserted__Delegate;
    FScriptDelegate __OnPageRemoved__Delegate;
    //## END PROPS UITabControl

    void RequestLayoutUpdate();
    INT GetPageCount() const;
    class UUITabPage* GetPageAtIndex(INT PageIndex) const;
    class UUITabButton* FindTargetedTab(INT PlayerIndex) const;
    virtual class UUITabPage* CreateTabPage(class UClass* TabPageClass,class UUITabPage* PagePrefab=NULL);
    DECLARE_FUNCTION(execRequestLayoutUpdate)
    {
        P_FINISH;
        RequestLayoutUpdate();
    }
    DECLARE_FUNCTION(execGetPageCount)
    {
        P_FINISH;
        *(INT*)Result=GetPageCount();
    }
    DECLARE_FUNCTION(execGetPageAtIndex)
    {
        P_GET_INT(PageIndex);
        P_FINISH;
        *(class UUITabPage**)Result=GetPageAtIndex(PageIndex);
    }
    DECLARE_FUNCTION(execFindTargetedTab)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(class UUITabButton**)Result=FindTargetedTab(PlayerIndex);
    }
    DECLARE_FUNCTION(execCreateTabPage)
    {
        P_GET_OBJECT(UClass,TabPageClass);
        P_GET_OBJECT_OPTX(UUITabPage,PagePrefab,NULL);
        P_FINISH;
        *(class UUITabPage**)Result=CreateTabPage(TabPageClass,PagePrefab);
    }
    UBOOL eventEnableTabPage(class UUITabPage* PageToEnable,INT PlayerIndex,UBOOL bEnablePage=TRUE,UBOOL bActivatePage=FALSE,UBOOL bFocusPage=TRUE)
    {
        UITabControl_eventEnableTabPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PageToEnable=PageToEnable;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bEnablePage=bEnablePage ? FIRST_BITFIELD : FALSE;
        Parms.bActivatePage=bActivatePage ? FIRST_BITFIELD : FALSE;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnableTabPage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivatePreviousPage(INT PlayerIndex,UBOOL bFocusPage=TRUE,UBOOL bAllowWrapping=TRUE)
    {
        UITabControl_eventActivatePreviousPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        Parms.bAllowWrapping=bAllowWrapping ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivatePreviousPage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivateNextPage(INT PlayerIndex,UBOOL bFocusPage=TRUE,UBOOL bAllowWrapping=TRUE)
    {
        UITabControl_eventActivateNextPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        Parms.bAllowWrapping=bAllowWrapping ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateNextPage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivatePage(class UUITabPage* PageToActivate,INT PlayerIndex,UBOOL bFocusPage=TRUE)
    {
        UITabControl_eventActivatePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PageToActivate=PageToActivate;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivatePage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventReplacePage(class UUITabPage* ExistingPage,class UUITabPage* NewPage,INT PlayerIndex,UBOOL bFocusPage=TRUE)
    {
        UITabControl_eventReplacePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ExistingPage=ExistingPage;
        Parms.NewPage=NewPage;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ReplacePage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemovePage(class UUITabPage* PageToRemove,INT PlayerIndex)
    {
        UITabControl_eventRemovePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PageToRemove=PageToRemove;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovePage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInsertPage(class UUITabPage* PageToInsert,INT PlayerIndex,INT InsertIndex=-1,UBOOL bActivateImmediately=TRUE)
    {
        UITabControl_eventInsertPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PageToInsert=PageToInsert;
        Parms.PlayerIndex=PlayerIndex;
        Parms.InsertIndex=InsertIndex;
        Parms.bActivateImmediately=bActivateImmediately ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertPage),&Parms);
        return Parms.ReturnValue;
    }
    void eventPrivateActivatePage(class UUITabPage* PageToActivate,INT PlayerIndex)
    {
        UITabControl_eventPrivateActivatePage_Parms Parms(EC_EventParm);
        Parms.PageToActivate=PageToActivate;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_PrivateActivatePage),&Parms);
    }
    void delegateOnPageRemoved(class UUITabControl* Sender,class UUITabPage* OldPage,INT PlayerIndex)
    {
        UITabControl_eventOnPageRemoved_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.OldPage=OldPage;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPageRemoved,&__OnPageRemoved__Delegate,&Parms);
    }
    void delegateOnPageInserted(class UUITabControl* Sender,class UUITabPage* NewPage,INT PlayerIndex)
    {
        UITabControl_eventOnPageInserted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.NewPage=NewPage;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPageInserted,&__OnPageInserted__Delegate,&Parms);
    }
    void delegateOnPageActivated(class UUITabControl* Sender,class UUITabPage* NewlyActivePage,INT PlayerIndex)
    {
        UITabControl_eventOnPageActivated_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.NewlyActivePage=NewlyActivePage;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPageActivated,&__OnPageActivated__Delegate,&Parms);
    }
    DECLARE_CLASS(UUITabControl,UUIObject,0|CLASS_Config,Engine)
	/* === UITabControl interface === */
	/**
	 * Positions and resizes the tab buttons according the tab control's configuration.
	 */
	virtual void ReapplyLayout();

protected:
	/**
	 * Set up the docking links between the tab control, buttons, and pages, based on the TabDockFace.
	 */
	virtual void SetupDockingRelationships();

public:
	/* === UIObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Adds docking nodes for all faces of this widget to the specified scene
	 *
	 * @param	DockingStack	the docking stack to add this widget's docking.  Generally the scene's DockingStack.
	 *
	 * @return	TRUE if docking nodes were successfully added for all faces of this widget.
	 */
	virtual UBOOL AddDockingLink( TLookupMap<struct FUIDockingNode>& DockingStack );

	/**
	 * Adds the specified face to the DockingStack for the specified widget.
	 *
	 * This version ensures that the tab buttons faces (and thus, the size of their captions) have already been resolved
	 * Only relevant when the TabSizeMode is TAST_Fill, because we must make sure that all buttons are at least wide enough
	 * to fit the largest caption of the group.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TLookupMap<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Called when a style reference is resolved successfully.  Applies the TabButtonCaptionStyle and TabButtonBackgroundStyle
	 * to the tab buttons.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StylePropertyId			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StylePropertyId, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:
	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

	/**
	 * Activates the focused state for this widget and sets it to be the focused control of its parent (if applicable)
	 *
	 * @param	Sender		Control that called SetFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the first focus target within this container.
	 *
	 * @param	Sender	the widget that generated the focus change.  if NULL, this widget generated the focus change.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if focus was successfully propagated to the first focus target within this container.
	 */
	virtual UBOOL FocusFirstControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the last focus target within this container.
	 *
	 * @param	Sender			the widget that generated the focus change.  if NULL, this widget generated the focus change.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if focus was successfully propagated to the last focus target within this container.
	 */
	virtual UBOOL FocusLastControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the next control in the tab order (relative to Sender) for widget.  If Sender is the last control in
	 * the tab order, propagates the call upwards to this widget's parent widget.
	 *
	 * @param	Sender			the widget to use as the base for determining which control to focus next
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if we successfully set focus to the next control in tab order.  FALSE if Sender was the last eligible
	 *			child of this widget or we couldn't otherwise set focus to another control.
	 */
	virtual UBOOL NextControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the previous control in the tab order (relative to Sender) for widget.  If Sender is the first control in
	 * the tab order, propagates the call upwards to this widget's parent widget.
	 *
	 * @param	Sender			the widget to use as the base for determining which control to focus next
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if we successfully set focus to the previous control in tab order.  FALSE if Sender was the first eligible
	 *			child of this widget or we couldn't otherwise set focus to another control.
	 */
	virtual UBOOL PrevControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the widget bound to the navigation link for specified direction of the Sender.  This function
	 * is used for navigation between controls in scenes that support unbound (i.e. any direction) navigation.
	 *
	 * @param	Sender		Control that called NavigateFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	Direction 		the direction to navigate focus.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 * @param	bFocusChanged	TRUE if the focus was changed
	 *
	 * @return	TRUE if the navigation event was handled successfully.
	 */
	virtual UBOOL NavigateFocus(class UUIScreenObject* Sender,BYTE Direction,INT PlayerIndex=0,BYTE* bFocusChanged=NULL);

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

protected:
	/**
	 * Handles input events for this widget.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

struct UIScene_eventCloseScene_Parms
{
    class UUIScene* SceneToClose;
    UBOOL bCloseChildScenes;
    UBOOL bForceCloseImmediately;
    UBOOL ReturnValue;
    UIScene_eventCloseScene_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOpenScene_Parms
{
    class UUIScene* SceneToOpen;
    class ULocalPlayer* ScenePlayerOwner;
    BYTE ForcedPriority;
    UBOOL bSkipAnimation;
    FScriptDelegate SceneDelegate;
    class UUIScene* ReturnValue;
    UIScene_eventOpenScene_Parms(EEventParm)
    {
    }
};
struct UIScene_eventCalculateInputMask_Parms
{
    UIScene_eventCalculateInputMask_Parms(EEventParm)
    {
    }
};
struct UIScene_eventSceneDeactivated_Parms
{
    UIScene_eventSceneDeactivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventSceneActivated_Parms
{
    UBOOL bInitialActivation;
    UIScene_eventSceneActivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventGetFocusHint_Parms
{
    UBOOL bQueryOnly;
    class UUIObject* ReturnValue;
    UIScene_eventGetFocusHint_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnQueryEndAnimation_EnableInput_Parms
{
    FName AnimationSequenceName;
    INT TrackTypeMask;
    UBOOL ReturnValue;
    UIScene_eventOnQueryEndAnimation_EnableInput_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnQueryBeginAnimation_DisableInput_Parms
{
    FName AnimationSequenceName;
    INT TrackTypeMask;
    UBOOL ReturnValue;
    UIScene_eventOnQueryBeginAnimation_DisableInput_Parms(EEventParm)
    {
    }
};
struct UIScene_eventShouldModulateBackgroundAlpha_Parms
{
    FLOAT AlphaModulationPercent;
    UBOOL ReturnValue;
    UIScene_eventShouldModulateBackgroundAlpha_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnTopSceneChanged_Parms
{
    class UUIScene* NewTopScene;
    UIScene_eventOnTopSceneChanged_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnQueryCloseSceneAllowed_Parms
{
    class UUIScene* SceneToDeactivate;
    UBOOL bCloseChildScenes;
    UBOOL bForcedClose;
    UBOOL ReturnValue;
    UIScene_eventOnQueryCloseSceneAllowed_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnSceneDeactivated_Parms
{
    class UUIScene* DeactivatedScene;
    UIScene_eventOnSceneDeactivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnSceneActivated_Parms
{
    class UUIScene* ActivatedScene;
    UBOOL bInitialActivation;
    UIScene_eventOnSceneActivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventGetSceneInputModeOverride_Parms
{
    BYTE ReturnValue;
    UIScene_eventGetSceneInputModeOverride_Parms(EEventParm)
    {
    }
};
class UUIScene : public UUIScreenObject
{
public:
    //## BEGIN PROPS UIScene
    FName SceneTag;
    class UUISceneClient* SceneClient;
    class USceneDataStore* SceneData;
    class ULocalPlayer* PlayerOwner;
private:
    class UUIToolTip* ActiveToolTip;
    class UUIToolTip* StandardToolTip;
public:
    class UClass* DefaultToolTipClass;
    class UUIContextMenu* ActiveContextMenu;
private:
    class UUIContextMenu* StandardContextMenu;
public:
    class UClass* DefaultContextMenuClass;
    class UUISkin* SceneSkin;
    class UUISafeRegionPanel* PrimarySafeRegionPanel;
    TLookupMap<FUIDockingNode> DockingStack;
    TArrayNoInit<class UUIObject*> RenderStack;
    TArrayNoInit<TScriptInterface<class IUITickableObject> > TickableObjects;
    TArrayNoInit<class UUIScreenObject*> AnimatingObjects;
    TMap<FName,FInputEventSubscription> InputSubscriptions[4];
    INT LastPlayerIndex;
    BITFIELD bUpdateDockingStack:1;
    BITFIELD bUpdateScenePositions:1;
    BITFIELD bUpdateNavigationLinks:1;
    BITFIELD bUpdatePrimitiveUsage:1;
    BITFIELD bRefreshWidgetStyles:1;
    BITFIELD bRefreshStringFormatting:1;
    BITFIELD bRecalculateInputMask:1;
    BITFIELD bPerformedInitialUpdate:1;
    BITFIELD bResolvingScenePositions:1;
    BITFIELD bUsesPrimitives:1;
    BITFIELD bSupportsNavigation:1;
    BITFIELD bReevaluateRotationSupport:1;
    BITFIELD bSupportsRotation:1;
    BITFIELD bDisplayCursor:1;
    BITFIELD bRenderParentScenes:1;
    BITFIELD bAlwaysRenderScene:1;
    BITFIELD bPauseGameWhileActive:1;
    BITFIELD bExemptFromAutoClose:1;
    BITFIELD bCloseOnLevelChange:1;
    BITFIELD bSaveSceneValuesOnClose:1;
    BITFIELD bEnableScenePostProcessing:1;
    BITFIELD bEnableSceneDepthTesting:1;
    BITFIELD bRequiresNetwork:1;
    BITFIELD bRequiresOnlineService:1;
    BITFIELD bMenuLevelRestoresScene:1;
    BITFIELD bFlushPlayerInput:1;
    BITFIELD bCaptureMatchedInput:1;
    BITFIELD bDisableWorldRendering:1;
    BITFIELD bAnimationBlockingInput:1;
    INT UpdateSceneFeedbackLoopCount;
    INT SceneStackPriority;
    class UTexture2D* ScenePreview;
    BYTE PlayerInputMask;
private:
    BYTE SceneInputMode;
protected:
    BYTE SceneRenderMode;
public:
    BYTE ScenePostProcessGroup;
    class UPostProcessChain* UIPostProcessForeground;
    class UPostProcessChain* UIPostProcessBackground;
    struct FPostProcessSettings CurrentBackgroundSettings;
    struct FPostProcessSettings CurrentForegroundSettings;
    FVector2D CurrentViewportSize;
    FName SceneAnimation_Open;
    FName SceneAnimation_Close;
    FName SceneAnimation_LoseFocus;
    FName SceneAnimation_RegainingFocus;
    FName SceneAnimation_RegainedFocus;
    FName SceneOpenedCue;
    FName SceneClosedCue;
    class UUILayerBase* SceneLayerRoot;
    FScriptDelegate __GetSceneInputModeOverride__Delegate;
    FScriptDelegate __OnSceneActivated__Delegate;
    FScriptDelegate __OnSceneDeactivated__Delegate;
    FScriptDelegate __OnQueryCloseSceneAllowed__Delegate;
    FScriptDelegate __OnTopSceneChanged__Delegate;
    FScriptDelegate __ShouldModulateBackgroundAlpha__Delegate;
    FScriptDelegate __OnQueryBeginAnimation_DisableInput__Delegate;
    FScriptDelegate __OnQueryEndAnimation_EnableInput__Delegate;
    //## END PROPS UIScene

    void RebuildDockingStack();
    void ResolveScenePositions();
    UBOOL RegisterTickableObject(const TScriptInterface<class IUITickableObject>& ObjectToRegister,INT InsertIndex=-1);
    UBOOL UnregisterTickableObject(const TScriptInterface<class IUITickableObject>& ObjectToRemove);
    INT FindTickableObjectIndex(const TScriptInterface<class IUITickableObject>& ObjectToFind) const;
    class USceneDataStore* GetSceneDataStore();
    void LoadSceneDataValues();
    void SaveSceneDataValues(UBOOL bUnbindSubscribers=FALSE);
    void UnbindSubscribers();
    class UUIDataStore* ResolveDataStore(FName DataStoreTag,class ULocalPlayer* InPlayerOwner=NULL);
    class UUIScene* GetNextScene(UBOOL bRequireMatchingPlayerOwner=TRUE,UBOOL bIgnoreUnfocusedScenes=FALSE);
    class UUIScene* GetPreviousScene(UBOOL bRequireMatchingPlayerOwner=TRUE,UBOOL bIgnoreUnfocusedScenes=FALSE);
    UBOOL ShouldRenderParentScenes() const;
    void SetSceneInputMode(BYTE NewInputMode);
    class AWorldInfo* GetWorldInfo();
    UBOOL IsSceneActive(UBOOL bTopmostScene=FALSE) const;
    class UUIToolTip* GetDefaultToolTip();
    class UUIContextMenu* GetDefaultContextMenu();
    class UUIToolTip* GetActiveToolTip() const;
    UBOOL SetActiveToolTip(class UUIToolTip* NewToolTip);
    class UUIContextMenu* GetActiveContextMenu() const;
    UBOOL SetActiveContextMenu(class UUIContextMenu* NewContextMenu,INT PlayerIndex);
    void LogDockingStack() const;
    DECLARE_FUNCTION(execForceImmediateSceneUpdate);
    DECLARE_FUNCTION(execRebuildDockingStack)
    {
        P_FINISH;
        RebuildDockingStack();
    }
    DECLARE_FUNCTION(execResolveScenePositions)
    {
        P_FINISH;
        ResolveScenePositions();
    }
    DECLARE_FUNCTION(execRegisterTickableObject)
    {
        P_GET_TINTERFACE(IUITickableObject,ObjectToRegister);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RegisterTickableObject(ObjectToRegister,InsertIndex);
    }
    DECLARE_FUNCTION(execUnregisterTickableObject)
    {
        P_GET_TINTERFACE(IUITickableObject,ObjectToRemove);
        P_FINISH;
        *(UBOOL*)Result=UnregisterTickableObject(ObjectToRemove);
    }
    DECLARE_FUNCTION(execFindTickableObjectIndex)
    {
        P_GET_TINTERFACE(IUITickableObject,ObjectToFind);
        P_FINISH;
        *(INT*)Result=FindTickableObjectIndex(ObjectToFind);
    }
    DECLARE_FUNCTION(execGetSceneDataStore)
    {
        P_FINISH;
        *(class USceneDataStore**)Result=GetSceneDataStore();
    }
    DECLARE_FUNCTION(execLoadSceneDataValues)
    {
        P_FINISH;
        LoadSceneDataValues();
    }
    DECLARE_FUNCTION(execSaveSceneDataValues)
    {
        P_GET_UBOOL_OPTX(bUnbindSubscribers,FALSE);
        P_FINISH;
        SaveSceneDataValues(bUnbindSubscribers);
    }
    DECLARE_FUNCTION(execUnbindSubscribers)
    {
        P_FINISH;
        UnbindSubscribers();
    }
    DECLARE_FUNCTION(execResolveDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,InPlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=ResolveDataStore(DataStoreTag,InPlayerOwner);
    }
    DECLARE_FUNCTION(execGetNextScene)
    {
        P_GET_UBOOL_OPTX(bRequireMatchingPlayerOwner,TRUE);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetNextScene(bRequireMatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetPreviousScene)
    {
        P_GET_UBOOL_OPTX(bRequireMatchingPlayerOwner,TRUE);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetPreviousScene(bRequireMatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execShouldRenderParentScenes)
    {
        P_FINISH;
        *(UBOOL*)Result=ShouldRenderParentScenes();
    }
    DECLARE_FUNCTION(execGetScenePostProcessGroup);
    DECLARE_FUNCTION(execSetSceneInputMode)
    {
        P_GET_BYTE(NewInputMode);
        P_FINISH;
        SetSceneInputMode(NewInputMode);
    }
    DECLARE_FUNCTION(execGetSceneInputMode)
    {
        P_GET_UBOOL_OPTX(bMemberValueOnly,FALSE);
        P_FINISH;
        *(BYTE*)Result=GetSceneInputMode(bMemberValueOnly);
    }
    DECLARE_FUNCTION(execGetSceneRenderMode)
    {
        P_FINISH;
        *(BYTE*)Result=GetSceneRenderMode();
    }
    DECLARE_FUNCTION(execSetSceneRenderMode)
    {
        P_GET_BYTE(NewRenderMode);
        P_FINISH;
        SetSceneRenderMode(NewRenderMode);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    DECLARE_FUNCTION(execIsSceneActive)
    {
        P_GET_UBOOL_OPTX(bTopmostScene,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsSceneActive(bTopmostScene);
    }
    DECLARE_FUNCTION(execGetDefaultToolTip)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=GetDefaultToolTip();
    }
    DECLARE_FUNCTION(execGetDefaultContextMenu)
    {
        P_FINISH;
        *(class UUIContextMenu**)Result=GetDefaultContextMenu();
    }
    DECLARE_FUNCTION(execGetActiveToolTip)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=GetActiveToolTip();
    }
    DECLARE_FUNCTION(execSetActiveToolTip)
    {
        P_GET_OBJECT(UUIToolTip,NewToolTip);
        P_FINISH;
        *(UBOOL*)Result=SetActiveToolTip(NewToolTip);
    }
    DECLARE_FUNCTION(execGetActiveContextMenu)
    {
        P_FINISH;
        *(class UUIContextMenu**)Result=GetActiveContextMenu();
    }
    DECLARE_FUNCTION(execSetActiveContextMenu)
    {
        P_GET_OBJECT(UUIContextMenu,NewContextMenu);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=SetActiveContextMenu(NewContextMenu,PlayerIndex);
    }
    DECLARE_FUNCTION(execLogDockingStack)
    {
        P_FINISH;
        LogDockingStack();
    }
    UBOOL eventCloseScene(class UUIScene* SceneToClose=((class UUIScene*)-1),UBOOL bCloseChildScenes=TRUE,UBOOL bForceCloseImmediately=FALSE)
    {
        UIScene_eventCloseScene_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SceneToClose=SceneToClose==INVALID_OBJECT ? this : SceneToClose;
        Parms.bCloseChildScenes=bCloseChildScenes ? FIRST_BITFIELD : FALSE;
        Parms.bForceCloseImmediately=bForceCloseImmediately ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CloseScene),&Parms);
        return Parms.ReturnValue;
    }
    class UUIScene* eventOpenScene(class UUIScene* SceneToOpen,class ULocalPlayer* ScenePlayerOwner=NULL,BYTE ForcedPriority=0,UBOOL bSkipAnimation=FALSE,FScriptDelegate SceneDelegate=FScriptDelegate(EC_EventParm))
    {
        UIScene_eventOpenScene_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.SceneToOpen=SceneToOpen;
        Parms.ScenePlayerOwner=ScenePlayerOwner;
        Parms.ForcedPriority=ForcedPriority;
        Parms.bSkipAnimation=bSkipAnimation ? FIRST_BITFIELD : FALSE;
        Parms.SceneDelegate=SceneDelegate;
        ProcessEvent(FindFunctionChecked(ENGINE_OpenScene),&Parms);
        return Parms.ReturnValue;
    }
    void eventCalculateInputMask()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CalculateInputMask),NULL);
    }
    void eventSceneDeactivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SceneDeactivated),NULL);
    }
    void eventSceneActivated(UBOOL bInitialActivation)
    {
        UIScene_eventSceneActivated_Parms Parms(EC_EventParm);
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SceneActivated),&Parms);
    }
    class UUIObject* eventGetFocusHint(UBOOL bQueryOnly=FALSE)
    {
        UIScene_eventGetFocusHint_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.bQueryOnly=bQueryOnly ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFocusHint),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnQueryEndAnimation_EnableInput(FName AnimationSequenceName,INT TrackTypeMask)
    {
        UIScene_eventOnQueryEndAnimation_EnableInput_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimationSequenceName=AnimationSequenceName;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessDelegate(ENGINE_OnQueryEndAnimation_EnableInput,&__OnQueryEndAnimation_EnableInput__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnQueryBeginAnimation_DisableInput(FName AnimationSequenceName,INT TrackTypeMask)
    {
        UIScene_eventOnQueryBeginAnimation_DisableInput_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimationSequenceName=AnimationSequenceName;
        Parms.TrackTypeMask=TrackTypeMask;
        ProcessDelegate(ENGINE_OnQueryBeginAnimation_DisableInput,&__OnQueryBeginAnimation_DisableInput__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateShouldModulateBackgroundAlpha(FLOAT& AlphaModulationPercent)
    {
        UIScene_eventShouldModulateBackgroundAlpha_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AlphaModulationPercent=AlphaModulationPercent;
        ProcessDelegate(ENGINE_ShouldModulateBackgroundAlpha,&__ShouldModulateBackgroundAlpha__Delegate,&Parms);
        AlphaModulationPercent=Parms.AlphaModulationPercent;
        return Parms.ReturnValue;
    }
    void delegateOnTopSceneChanged(class UUIScene* NewTopScene)
    {
        UIScene_eventOnTopSceneChanged_Parms Parms(EC_EventParm);
        Parms.NewTopScene=NewTopScene;
        ProcessDelegate(ENGINE_OnTopSceneChanged,&__OnTopSceneChanged__Delegate,&Parms);
    }
    UBOOL delegateOnQueryCloseSceneAllowed(class UUIScene* SceneToDeactivate,UBOOL bCloseChildScenes,UBOOL bForcedClose)
    {
        UIScene_eventOnQueryCloseSceneAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.SceneToDeactivate=SceneToDeactivate;
        Parms.bCloseChildScenes=bCloseChildScenes ? FIRST_BITFIELD : FALSE;
        Parms.bForcedClose=bForcedClose ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnQueryCloseSceneAllowed,&__OnQueryCloseSceneAllowed__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnSceneDeactivated(class UUIScene* DeactivatedScene)
    {
        UIScene_eventOnSceneDeactivated_Parms Parms(EC_EventParm);
        Parms.DeactivatedScene=DeactivatedScene;
        ProcessDelegate(ENGINE_OnSceneDeactivated,&__OnSceneDeactivated__Delegate,&Parms);
    }
    void delegateOnSceneActivated(class UUIScene* ActivatedScene,UBOOL bInitialActivation)
    {
        UIScene_eventOnSceneActivated_Parms Parms(EC_EventParm);
        Parms.ActivatedScene=ActivatedScene;
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnSceneActivated,&__OnSceneActivated__Delegate,&Parms);
    }
    BYTE delegateGetSceneInputModeOverride()
    {
        UIScene_eventGetSceneInputModeOverride_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessDelegate(ENGINE_GetSceneInputModeOverride,&__GetSceneInputModeOverride__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIScene,UUIScreenObject,0|CLASS_Config,Engine)
	// UUIScreenObject interface.

	/**
	 * Returns the UIObject that owns this widget, or NULL if this screen object
	 * doesn't have an owner (such as UIScenes)
	 */
	virtual UUIObject* GetOwner() const			{ return NULL; }

	/**
	 * Returns a pointer to this scene.
	 */
	virtual UUIScene* GetScene() 				{ return this; }

	/**
	 * Returns a const pointer to this scene.
	 */
	virtual const UUIScene* GetScene() const	{ return this; }

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const				{ return SceneTag; }

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const	{ return SceneTag.ToString(); }

	/** gets the currently active skin */
	class UUISkin* GetActiveSkin() const;

	/**
	 *	Iterates over all widgets in the scene and forces them to update their style
	 */
	void RefreshWidgetStyles();

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Sets up the focus, input, and any other arrays which contain data that tracked uniquely for each active player.
	 * Ensures that the arrays responsible for managing focus chains are synched up with the Engine.GamePlayers array.
	 *
	 * This version also calls CalculateInputMask to initialize the scene's PlayerInputMask for use by the activation
	 * and initialization events that will be called as the scene is activated.
	 */
	virtual void InitializePlayerTracking();

	/**
	 * Called when a new player has been added to the list of active players (i.e. split-screen join) after the scene
	 * has been activated.
	 *
	 * This version updates the scene's PlayerInputMask to reflect the newly added player.
	 *
	 * @param	PlayerIndex		the index [into the GamePlayers array] where the player was inserted
	 * @param	AddedPlayer		the player that was added
	 */
	virtual void CreatePlayerData( INT PlayerIndex, class ULocalPlayer* AddedPlayer );

	/**
	 * Called when a player has been removed from the list of active players (i.e. split-screen players)
	 *
	 * This version updates the scene's PlayerInputMask to reflect the removed player.
	 *
	 * @param	PlayerIndex		the index [into the GamePlayers array] where the player was located
	 * @param	RemovedPlayer	the player that was removed
	 */
	virtual void RemovePlayerData( INT PlayerIndex, class ULocalPlayer* RemovedPlayer );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Creates and initializes this scene's data store.
	 */
	void CreateSceneDataStore();

	/** Called when this scene is about to be added to the active scenes array */
	void Activate();

	/** Called just after this scene is removed from the active scenes array */
	virtual void Deactivate();

	/**
	 * Notification that this scene becomes the active scene.  Called after other activation methods have been called
	 * and after focus has been set on the scene.
	 *
	 * @param	bInitialActivation		TRUE if this is the first time this scene is being activated; FALSE if this scene has become active
	 *									as a result of closing another scene or manually moving this scene in the stack.
	 */
	virtual void OnSceneActivated( UBOOL bInitialActivation );

	/**
	 * This notification is sent to the topmost scene when a different scene is about to become the topmost scene.
	 * Provides scenes with a single location to perform any cleanup for its children.
	 *
	 * @param	NewTopScene		the scene that is about to become the topmost scene.
	 */
	virtual void NotifyTopSceneChanged( UUIScene* NewTopScene );

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const
	{
		return bUpdateScenePositions == TRUE ? 0 : UIFACE_MAX;
	}

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const
	{
		return bUpdateScenePositions == FALSE;
	}

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Immediately rebuilds the navigation links between the children of this screen object and recalculates the child that should
	 * be the first & last focused control.
	 *
	 * @return	TRUE if navigation links were created between any children of this widget.
	 */
	virtual UBOOL RebuildNavigationLinks();

	/**
	 * Determines whether this scene processes axis input events.
	 *
	 * @param	bProcessAxisInput	receives the flags for whether axis input is needed for each player.
	 * @param	NavAliases			list of input aliases that correspond to axis navigation
	 * @param	AxisInputKeys		list of input keys that are associated with axis input.
	 *
	 * @return	TRUE if axis input is supported by all active players (can stop checking children, for example)
	 */
	virtual UBOOL CheckAxisInputSupport( UBOOL* bProcessAxisInput[UCONST_MAX_SUPPORTED_GAMEPADS], TLookupMap<FName>& NavAliases, TLookupMap<FName>& AxisInputKeys ) const;

	/**
	 * Gets the value of this widget's PlayerInputMask.
	 *
	 * @param	bInheritedMaskOnly		ignored
	 * @param	bOverrideMaskOnly		ignored
	 *
	 * @return	a bitmask representing the indices of the players that this scene accepts input from.
	 */
	virtual BYTE GetInputMask( UBOOL bInheritedMaskOnly=FALSE, UBOOL bOverrideMaskOnly=FALSE ) const
	{
		return PlayerInputMask;
	}

	/**
	 * Changes the player input mask for this control, which controls which players this control will accept input from.
	 *
	 * @param	NewInputMask	the new mask that should be assigned to this control
	 * @param	bRecurse		if TRUE, calls SetInputMask on all child controls as well.
	 * @param	bForcedOverride	by default, the widget's PlayerInputMask is only changed if it still matches the default value.
	 */
	virtual void SetInputMask( BYTE NewInputMask, UBOOL bRecurse=TRUE, UBOOL bForcedOverride=FALSE );

	/**
	 * Accessor for retrieving the scene's configured post-process group.
	 *
	 * @return	the post-process group that this scene is configured to use.
	 */
	virtual EUIPostProcessGroup GetScenePostProcessGroup() const;

	/**
	 * Retrieve the post process chain that should be rendered for the UIScene given the post process group
	 *
	 * @param	InUIPostProcessGroup	the type of post processing currently being applied; only scenes with a compatible ScenePostProcessGroup
	 *									will return a valid value.
	 * @param	PPSettings				receives the value of the scene's current post-process settings.
	 *
	 * @return	the post-process chain associated with this scene, if the scene's ScenePostProcessGroup matches the value specified.
	 */
	virtual const class UPostProcessChain* GetPostProcessChain( EUIPostProcessGroup InUIPostProcessGroup/*, FPostProcessSettings** PPSettings=NULL*/ ) const;

	/**
	 * Accessor for retrieving the PostProcessSettings struct used for interpolating PP effects.
	 *
	 * @param	CurrentSettings		receives the current PostProcessSettings that should be used for PP effect animation.
	 *
	 * @return	TRUE if this widget supports animation of post-processing and filled in the value of CurrentSettings.
	 */
	virtual UBOOL AnimGetCurrentPPSettings( FPostProcessSettings*& CurrentSettings );
protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/* == UUIScene interface == */

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE )
	{
		bUpdateDockingStack = bUpdateDockingStack || bDockingStackChanged;
		bUpdateScenePositions = bUpdateScenePositions || bPositionsChanged;
		bUpdateNavigationLinks = bUpdateNavigationLinks || bNavLinksOutdated;
		bRefreshWidgetStyles = bRefreshWidgetStyles || bWidgetStylesChanged;
	}

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate()
	{
		bRefreshStringFormatting = TRUE;
	}

	/**
	 * Flag the scene to recalculate its PlayerInputMask at the beginning of the next tick.
	 */
	virtual void RequestSceneInputMaskUpdate()
	{
		bRecalculateInputMask = TRUE;
	}

	/**
	 * Flag the scene to recalculate the value of bSupportsRotation during the next tick.
	 */
	void RequestRotationSupportUpdate()
	{
		bReevaluateRotationSupport = TRUE;
	}

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage );

	/**
	 * Accessor for retrieving the scene's input mode.
	 *
	 * @param	bMemberValueOnly	specify TRUE to skip calling the delegate and immediately return the value of SceneInputMode
	 *
	 * @return	if the scene's GetSceneInputModeOverride delegate is set, returns the result from that.  Otherwise, the value of this scene's
	 *			SceneInputMode.
	 */
	EScreenInputMode GetSceneInputMode( UBOOL bMemberValueOnly=FALSE );

	/**
	 * Accessor for retrieving the scene's render mode.  Forces render mode to be SPLITRENDER_FullScreen
	 *
	 * @param	bMemberValueOnly	specify TRUE to return the value of SceneRenderMode, ignoring any logic that could potentially alter
	 *								the return value (like being in a cinematic or something)
	 *
	 * @return	the value of this scene's SceneRenderMode member.
	 */
	ESplitscreenRenderMode GetSceneRenderMode( UBOOL bMemberValueOnly=FALSE ) const;

	/**
	 * Accessor for changing the value of this scene's SceneRenderMode var.
	 */
	void SetSceneRenderMode( /*ESplitscreenRenderMode*/BYTE NewRenderMode )
	{
		check(NewRenderMode<SPLITRENDER_MAX);
		SceneRenderMode = NewRenderMode;
	}

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	void UpdateScene();

	/**
	 * @return	TRUE if the scene will perform any updates.
	 */
	UBOOL RequiresUpdate() const;

	/**
	 * Updates the value of bUsesPrimitives.
	 */
	virtual void UpdatePrimitiveUsage();

	/**
	 * Called at the beginning of the first scene update and propagated to all widgets in the scene.  Provides classes with
	 * an opportunity to initialize anything that couldn't be setup earlier due to lack of a viewport.
	 *
	 * Calling functions such as GetViewportSize() or GetPosition() aren't guaranteed to work until this function has been called.
	 */
	virtual void PreInitialSceneUpdate();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting( UBOOL bRequestSceneUpdate=TRUE );

	/**
	 * Iterates over all widgets in the scene to determine whether any have a non-zero value for Rotation.  Child classes could override
	 * this method to e.g. force rotation support to be always on or off.
	 */
	virtual void RecalculateRotationSupport();

	/**
	 * Called once per frame to update the scene's state.
	 *
	 * @param	DeltaTime	the time since the last Tick call
	 */
	virtual void Tick( FLOAT DeltaTime );

	/**
	 * Updates the sequences for this scene and its child widgets.
	 *
	 * @param	DeltaTime	the time since the last call to TickSequence.
	 */
	void TickSequence( FLOAT DeltaTime );

	/**
	 * Provides scenes with a way to alter the amount of transparency to use when rendering parent scenes.
	 *
	 * @param	AlphaModulationPercent	the value that will be used for modulating the alpha when rendering the scene below this one.
	 *
	 * @return	TRUE if alpha modulation should be applied when rendering the scene below this one.
	 */
	virtual UBOOL ShouldModulateBackgroundAlpha( FLOAT& AlphaModulationPercent );

	/**
	 * Renders this scene.
	 *
	 * @param	Canvas	the canvas to use for rendering the scene
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void Render_Scene( FCanvas* Canvas, EUIPostProcessGroup UIPostProcessGroup );

	/**
	 * Renders all special overlays for this scene, such as context menus or tooltips.
	 *
	 * @param	Canvas	the canvas to use for rendering the overlays
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void RenderSceneOverlays( FCanvas* Canvas, EUIPostProcessGroup UIPostProcessGroup  );

	/**
	 * Updates all 3D primitives in this scene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateScenePrimitives( FCanvasScene* CanvasScene );

	/**
	 * Adds the specified widget to the list of subscribers for the specified input key
	 *
	 * @param	InputKey	the key that the widget wants to subscribe to
	 * @param	Handler		the widget to add to the list of subscribers
	 * @param	PlayerIndex	the index of the player to register the input events for
	 *
	 * @return	TRUE if the widget was successfully added to the subscribers list
	 */
	UBOOL SubscribeInputEvent( FName InputKey, UUIScreenObject* Handler, INT PlayerIndex );

	/**
	 * Removes the specified widget from the list of subscribers for the specified input key
	 *
	 * @param	InputKey		the key that the widget wants to unsubscribe for
	 * @param	Handler			the widget to remove from the list of subscribers
	 * @param	PlayerIndex		the index of the player to unregister the input events for
	 * @param	bForcedRemoval	specify TRUE to ignore whether the specified player index is in the list of indices that this scene
	 *							supports input for.  Necessary to remove stale input subscriptions for players that have been
	 *							removed.
	 *
	 * @return	TRUE if the widget was successfully removed from the subscribers list
	 */
	UBOOL UnsubscribeInputEvent( FName InputKey, UUIScreenObject* Handler, INT PlayerIndex, UBOOL bForcedRemoval=FALSE );

	/**
	 * Retrieve the list of input event subscribers for the specified input key and player index.
	 *
	 * @param	InputKey				the input key name to retrieve subscribers for
	 * @param	PlayerIndex				the index for the player to retrieve subscribed controls for
	 * @param	out_SubscribersList		filled with the controls that respond to the specified input key for the specified player
	 *
	 * @return	TRUE if an input subscription was found for the specified input key and player index, FALSE otherwise.
	 */
	UBOOL GetInputEventSubscribers( FName InputKey, INT PlayerIndex, FInputEventSubscription** out_SubscriberList );

protected:
	/**
	 * Wrapper function for converting the controller Id specified into a PlayerIndex and grabbing the scene's input mode.
	 *
	 * @param	ControllerId			the gamepad id of the player that generated the input event
	 * @param	out_ScreenInputMode		set to this scene's input mode
	 * @param	out_PlayerIndex			the Engine.GamePlayers index for the player with the gamepad id specified.
	 *
	 * @return	TRUE if this scene can process input for the gamepad id specified, or FALSE if this scene should ignore
	 *			and swallow this input
	 */
	UBOOL PreprocessInput( INT ControllerId, EScreenInputMode& out_ScreenInputMode, INT& out_PlayerIndex );

	/**
	 * Processes key events for the scene itself.
	 *
	 * Only called if this scene is in the InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Allow this scene the chance to respond to an input event.
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Key				name of the key which an event occured for.
	 * @param	Event			the type of event which occured.
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Allow this scene the chance to respond to an input axis event (mouse movement)
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Key				name of the key which an event occured for.
	 * @param	Delta 			the axis movement delta.
	 * @param	DeltaTime		seconds since the last axis update.
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad=FALSE);

	/**
	 * Allow this scene to respond to an input char event.
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	UBOOL InputChar(INT ControllerId,TCHAR Character);

	/**
	 * Determines whether the current docking relationships between the widgets in this scene are valid.
	 *
	 * @return	TRUE if all docking nodes were added to the list.  FALSE if any recursive docking relationships were detected.
	 */
	UBOOL ValidateDockingStack() const;

	/* === UObject interface === */
	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostEditImport();

	/**
	 * Called after this scene is renamed.
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostRename();

	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostDuplicate();

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version determines determines which sequences in this scene contains sequence ops that are capable of executing logic,
	 * and marks sequence objects with the RF_NotForClient|RF_NotForServer if the op isn't linked to anything.
	 */
	virtual void PreSave();

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIPrefabScene : public UUIScene, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UIPrefabScene
    //## END PROPS UIPrefabScene

    DECLARE_CLASS(UUIPrefabScene,UUIScene,0|CLASS_Transient|CLASS_Config,Engine)
	/* === UUIScene interface === */
	/* === FCallbackEventDevice interface === */
	/**
	 * Handles validating that this scene's UIPrefab is still a valid widget after each undo is performed.
	 */
	virtual void Send( ECallbackEventType InType );

	/* === UUIScreenObject interface === */
	/**
	 * Notification that this scene becomes the active scene.  Called after other activation methods have been called
	 * and after focus has been set on the scene.
	 *
	 * This version registers this UIPrefabScene as an observer for CALLBACK_Undo events.
	 *
	 * @param	bInitialActivation		TRUE if this is the first time this scene is being activated; FALSE if this scene has become active
	 *									as a result of closing another scene or manually moving this scene in the stack.
	 */
	virtual void OnSceneActivated( UBOOL bInitialActivation );

	/**
	 * Called just after this scene is removed from the active scenes array; unregisters this scene as an observer for undo callbacks.
	 */
	virtual void Deactivate();

	/**
	 * Insert a widget at the specified location
	 *
	 * @param	NewChild		the widget to insert; it must be a UIPrefab.
	 * @param	InsertIndex		unused
	 * @param	bRenameExisting	unused
	 *
	 * @return	the position that that the child was inserted in, or INDEX_NONE if the widget was not inserted
	 */
	virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=INDEX_NONE,UBOOL bRenameExisting=TRUE);

	/**
	 * Returns the default parent to use when placing widgets using the UI editor.  This widget is used when placing
	 * widgets by dragging their outline using the mouse, for example.
	 *
	 * @return	a pointer to the widget that will contain newly placed widgets when a specific parent widget has not been
	 *			selected by the user.
	 */
	virtual UUIScreenObject* GetEditorDefaultParentWidget();

	/* === UObject interface === */

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version overrides the UIScene version to NOT call CalculateSequenceLoadFlags (that's handled by each UIPrefab).
	 */
	virtual void PreSave();
};

struct GameUISceneClient_eventSynchronizePlayers_Parms
{
    INT MaxPlayersAllowed;
    UBOOL bAllowJoins;
    UBOOL bAllowRemoval;
    GameUISceneClient_eventSynchronizePlayers_Parms(EEventParm)
    {
    }
};
struct GameUISceneClient_eventCanShowToolTips_Parms
{
    UBOOL ReturnValue;
    GameUISceneClient_eventCanShowToolTips_Parms(EEventParm)
    {
    }
};
struct GameUISceneClient_eventPauseGame_Parms
{
    UBOOL bDesiredPauseState;
    INT PlayerIndex;
    GameUISceneClient_eventPauseGame_Parms(EEventParm)
    {
    }
};
class UGameUISceneClient : public UUISceneClient
{
public:
    //## BEGIN PROPS GameUISceneClient
protected:
    TArrayNoInit<class UUIScene*> ActiveScenes;
public:
    class UUITexture* CurrentMouseCursor;
    BITFIELD bRenderCursor:1;
    BITFIELD bUpdateInputProcessingStatus:1;
    BITFIELD bUpdateCursorRenderStatus:1;
    BITFIELD bUpdateSceneViewportSizes:1;
    BITFIELD bEnableDebugInput:1;
    BITFIELD bRenderDebugInfo:1;
    BITFIELD bRenderDebugInfoAtTop:1;
    BITFIELD bRenderActiveControlInfo:1;
    BITFIELD bRenderFocusedControlInfo:1;
    BITFIELD bRenderTargetControlInfo:1;
    BITFIELD bSelectVisibleTargetsOnly:1;
    BITFIELD bInteractiveMode:1;
    BITFIELD bDisplayFullPaths:1;
    BITFIELD bShowWidgetPath:1;
    BITFIELD bShowRenderBounds:1;
    BITFIELD bShowCurrentState:1;
    BITFIELD bShowMousePos:1;
    BITFIELD bRestrictActiveControlToFocusedScene:1;
    BITFIELD bCaptureUnprocessedInput:1;
    BITFIELD bSynchronizePlayers:1;
    BITFIELD bKillRestoreMenuProgression:1;
    BITFIELD bDebugResolveScene:1;
    BITFIELD bBlockSceneUpdates:1;
    BITFIELD bBlockUpdatesAfterStackModification:1;
    FLOAT LatestDeltaTime;
    DOUBLE DoubleClickStartTime;
    FIntPoint DoubleClickStartPosition;
    class UTexture* DefaultUITexture[3];
    TMap<INT,TArray<FName> > InitialPressedKeys;
    class UClass* MessageBoxClass;
    FLOAT OverlaySceneAlphaModulation;
    class UUIScreenObject* DebugTarget;
    TArrayNoInit<class UUIAnimationSeq*> AnimSequencePool;
    //## END PROPS GameUISceneClient

    BYTE GetCurrentNetMode();
    class UUIScene* GetTransientScene() const;
    class UUIObject* CreateTransientWidget(class UClass* WidgetClass,FName WidgetTag,class UUIObject* Owner=NULL);
    class UUIScene* FindSceneByTag(FName SceneTag,class ULocalPlayer* SceneOwner=NULL) const;
    INT FindSceneIndex(const class UUIScene* SceneToFind) const;
    class UUIScene* GetSceneAtIndex(INT SceneIndex) const;
    INT FindSceneIndexByTag(FName SceneTag,class ULocalPlayer* SceneOwner=NULL) const;
    INT GetActiveSceneCount(class ULocalPlayer* MatchingPlayerOwner=NULL,UBOOL bIgnoreUnfocusedScenes=FALSE) const;
    class UUIScene* GetActiveScene(class ULocalPlayer* MatchingPlayerOwner=NULL,UBOOL bIgnoreUnfocusedScenes=FALSE) const;
    class UUIScene* GetPreviousScene(const class UUIScene* SourceScene,UBOOL bRequireMatchingPlayerOwner=TRUE,UBOOL bIgnoreUnfocusedScenes=FALSE) const;
    class UUIScene* GetPreviousSceneFromIndex(INT StartingSceneIndex,class ULocalPlayer* MatchingPlayerOwner=NULL,UBOOL bIgnoreUnfocusedScenes=FALSE) const;
    class UUIScene* GetPreviousInputProcessingScene(const class UUIScene* SourceScene,UBOOL bIgnoreUnfocusedScenes=TRUE) const;
    class UUIScene* GetNextScene(const class UUIScene* SourceScene,UBOOL bRequireMatchingPlayerOwner=TRUE,UBOOL bIgnoreUnfocusedScenes=FALSE) const;
    class UUIScene* GetNextSceneFromIndex(INT StartingSceneIndex,class ULocalPlayer* MatchingPlayerOwner=NULL,UBOOL bIgnoreUnfocusedScenes=FALSE) const;
    void RequestInputProcessingUpdate();
    void RequestCursorRenderUpdate();
    UBOOL CanUnpauseInternalUI();
    virtual UBOOL SetActiveControl(class UUIObject* NewActiveControl);
    class UUIAnimationSeq* FindUIAnimation(FName NameOfSequence) const;
    DECLARE_FUNCTION(execGetCurrentNetMode)
    {
        P_FINISH;
        *(BYTE*)Result=GetCurrentNetMode();
    }
    DECLARE_FUNCTION(execGetTransientScene)
    {
        P_FINISH;
        *(class UUIScene**)Result=GetTransientScene();
    }
    DECLARE_FUNCTION(execCreateScene);
    DECLARE_FUNCTION(execCreateTransientWidget)
    {
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_NAME(WidgetTag);
        P_GET_OBJECT_OPTX(UUIObject,Owner,NULL);
        P_FINISH;
        *(class UUIObject**)Result=CreateTransientWidget(WidgetClass,WidgetTag,Owner);
    }
    DECLARE_FUNCTION(execFindSceneByTag)
    {
        P_GET_NAME(SceneTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_FINISH;
        *(class UUIScene**)Result=FindSceneByTag(SceneTag,SceneOwner);
    }
    DECLARE_FUNCTION(execFindSceneIndex)
    {
        P_GET_OBJECT(UUIScene,SceneToFind);
        P_FINISH;
        *(INT*)Result=FindSceneIndex(SceneToFind);
    }
    DECLARE_FUNCTION(execGetSceneAtIndex)
    {
        P_GET_INT(SceneIndex);
        P_FINISH;
        *(class UUIScene**)Result=GetSceneAtIndex(SceneIndex);
    }
    DECLARE_FUNCTION(execFindSceneIndexByTag)
    {
        P_GET_NAME(SceneTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_FINISH;
        *(INT*)Result=FindSceneIndexByTag(SceneTag,SceneOwner);
    }
    DECLARE_FUNCTION(execGetActiveSceneCount)
    {
        P_GET_OBJECT_OPTX(ULocalPlayer,MatchingPlayerOwner,NULL);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(INT*)Result=GetActiveSceneCount(MatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetActiveScene)
    {
        P_GET_OBJECT_OPTX(ULocalPlayer,MatchingPlayerOwner,NULL);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetActiveScene(MatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetPreviousScene)
    {
        P_GET_OBJECT(UUIScene,SourceScene);
        P_GET_UBOOL_OPTX(bRequireMatchingPlayerOwner,TRUE);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetPreviousScene(SourceScene,bRequireMatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetPreviousSceneFromIndex)
    {
        P_GET_INT(StartingSceneIndex);
        P_GET_OBJECT_OPTX(ULocalPlayer,MatchingPlayerOwner,NULL);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetPreviousSceneFromIndex(StartingSceneIndex,MatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetPreviousInputProcessingScene)
    {
        P_GET_OBJECT(UUIScene,SourceScene);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,TRUE);
        P_FINISH;
        *(class UUIScene**)Result=GetPreviousInputProcessingScene(SourceScene,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetNextScene)
    {
        P_GET_OBJECT(UUIScene,SourceScene);
        P_GET_UBOOL_OPTX(bRequireMatchingPlayerOwner,TRUE);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetNextScene(SourceScene,bRequireMatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execGetNextSceneFromIndex)
    {
        P_GET_INT(StartingSceneIndex);
        P_GET_OBJECT_OPTX(ULocalPlayer,MatchingPlayerOwner,NULL);
        P_GET_UBOOL_OPTX(bIgnoreUnfocusedScenes,FALSE);
        P_FINISH;
        *(class UUIScene**)Result=GetNextSceneFromIndex(StartingSceneIndex,MatchingPlayerOwner,bIgnoreUnfocusedScenes);
    }
    DECLARE_FUNCTION(execAllActiveScenes);
    DECLARE_FUNCTION(execRequestInputProcessingUpdate)
    {
        P_FINISH;
        RequestInputProcessingUpdate();
    }
    DECLARE_FUNCTION(execRequestCursorRenderUpdate)
    {
        P_FINISH;
        RequestCursorRenderUpdate();
    }
    DECLARE_FUNCTION(execCanUnpauseInternalUI)
    {
        P_FINISH;
        *(UBOOL*)Result=CanUnpauseInternalUI();
    }
    DECLARE_FUNCTION(execSetActiveControl)
    {
        P_GET_OBJECT(UUIObject,NewActiveControl);
        P_FINISH;
        *(UBOOL*)Result=SetActiveControl(NewActiveControl);
    }
    DECLARE_FUNCTION(execFindUIAnimation)
    {
        P_GET_NAME(NameOfSequence);
        P_FINISH;
        *(class UUIAnimationSeq**)Result=FindUIAnimation(NameOfSequence);
    }
    void eventSynchronizePlayers(INT MaxPlayersAllowed=4,UBOOL bAllowJoins=TRUE,UBOOL bAllowRemoval=TRUE)
    {
        GameUISceneClient_eventSynchronizePlayers_Parms Parms(EC_EventParm);
        Parms.MaxPlayersAllowed=MaxPlayersAllowed;
        Parms.bAllowJoins=bAllowJoins ? FIRST_BITFIELD : FALSE;
        Parms.bAllowRemoval=bAllowRemoval ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SynchronizePlayers),&Parms);
    }
    UBOOL eventCanShowToolTips()
    {
        GameUISceneClient_eventCanShowToolTips_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CanShowToolTips),&Parms);
        return Parms.ReturnValue;
    }
    void eventPauseGame(UBOOL bDesiredPauseState,INT PlayerIndex=0)
    {
        GameUISceneClient_eventPauseGame_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_PauseGame),&Parms);
    }
    DECLARE_CLASS(UGameUISceneClient,UUISceneClient,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UUIInteraction)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* =======================================
		UUISceneClient interface
	======================================= */
	/**
	 * Performs any initialization for the UISceneClient.
	 *
	 * @param	InitialSkin		UISkin that should be set to the initial ActiveSkin
	 */
	virtual void InitializeClient( UUISkin* InitialSkin );

	/**
	 * Changes the active skin to the skin specified, initializes the skin and performs all necessary cleanup and callbacks.
	 * This method should only be called from script.
	 *
	 * @param	NewActiveScene	The skin to activate
	 *
	 * @return	TRUE if the skin was successfully changed.
	 */
	virtual UBOOL ChangeActiveSkin( UUISkin* NewActiveSkin );

	/**
	 * Refreshes all existing UI elements with the styles from the currently active skin.
	 */
	virtual void OnActiveSkinChanged();

	/**
	 * Called when the UI controller receives a CALLBACK_ViewportResized notification.
	 *
	 * @param	SceneViewport	the viewport that was resized
	 */
	virtual void NotifyViewportResized( FViewport* SceneViewport );

	/**
	 * Retrieves the point of origin for the viewport for the scene specified.  This should always be 0,0 during the game,
	 * but may be different in the UI editor if the editor window is configured to have a gutter around the viewport.
	 *
	 * @param	out_ViewportOrigin	[out] will be filled in with the position of the starting point of the viewport.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOrigin( const UUIScene* Scene, FVector2D& out_ViewportOrigin );

	/**
	 * Retrieves the size of the viewport for the scene specified.
	 *
	 * @param	out_ViewportSize	[out] will be filled in with the width & height that the scene should use as the viewport size
	 *
	 * @return	TRUE if the viewport size was successfully retrieved
	 */
	virtual UBOOL GetViewportSize( const UUIScene* Scene, FVector2D& out_ViewportSize );

	/**
	 * Recalculates the matrix used for projecting local coordinates into screen (normalized device)
	 * coordinates.  This method should be called anytime the viewport size or origin changes.
	 */
	virtual void UpdateCanvasToScreen();

	/**
	 * Process an input event which interacts with the in-game scene debugging overlays
	 *
	 * @param	Key		the key that was pressed
	 * @param	Event	the type of event received
	 *
	 * @return	TRUE if the input event was processed; FALSE otherwise.
	 */
	UBOOL DebugInputKey( FName Key, EInputEvent Event );

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/* =======================================
		UGameUISceneClient interface
	======================================= */
	/**
	 * Creates the scene that will be used to contain transient widgets that are created in unrealscript
	 */
	void CreateTransientScene();

	/**
	 * Creates a new instance of the scene class specified.
	 *
	 * @param	SceneTemplate	the template to use for the new scene
	 * @param	InOuter			the outer for the scene
	 * @param	SceneTag		if specified, the scene will be given this tag when created
	 * @param	SceneClass		the class to use for creating the new scene; if not specified, uses the SceneTemplate's class
	 *
	 * @return	a UIScene instance of the class specified
	 */
	 UUIScene* CreateScene( UUIScene* SceneTemplate, UObject* InOuter, FName SceneTag=NAME_None, UClass* SceneClass=NULL );

	/**
	 * Determines which widget is currently under the mouse cursor by performing hit tests against bounding regions.
	 */
	void UpdateActiveControl();

	/**
	 * Resets the time and mouse position values used for simulating double-click events to the current value or invalid values.
	 */
	void ResetDoubleClickTracking( UBOOL bClearValues );

	/**
	 * Checks the current time and mouse position to determine whether a double-click event should be simulated.
	 */
	UBOOL ShouldSimulateDoubleClick() const;

	/**
	 * Determines whether the any active scenes process axis input.
	 *
	 * @param	bProcessAxisInput	receives the flags for whether axis input is needed for each player.
	 */
	virtual void CheckAxisInputSupport( UBOOL* bProcessAxisInput[UCONST_MAX_SUPPORTED_GAMEPADS] ) const;

	/**
	 * Set the mouse position to the coordinates specified
	 *
	 * @param	NewX	the X position to move the mouse cursor to (in pixels)
	 * @param	NewY	the Y position to move the mouse cursor to (in pixels)
	 */
	virtual void SetMousePosition( INT NewMouseX, INT NewMouseY );

	/**
	 * Sets the values of MouseX & MouseY to the current position of the mouse
	 */
	virtual void UpdateMousePosition();

	/**
	 * Gets the size (in pixels) of the mouse cursor current in use.
	 *
	 * @return	TRUE if MouseXL/YL were filled in; FALSE if there is no mouse cursor or if the UI is configured to not render a mouse cursor.
	 */
	virtual UBOOL GetCursorSize( FLOAT& MouseXL, FLOAT& MouseYL );

	/**
	 * Called whenever a scene is added or removed from the list of active scenes.  Calls any functions that handle updating the
	 * status of various tracking variables, such as whether the UI is currently capable of processing input.
	 *
	 * @param	PlayerIndex		the index of the player that owns the scene that was just added or removed, or 0 if the scene didn't have
	 *							a player owner.
	 */
	virtual void SceneStackModified( INT PlayerIndex );

	/**
	 * Changes the resource that is currently being used as the mouse cursor.  Called by widgets as they changes states which
	 * affect the mouse cursor
	 *
	 * @param	CursorName	the name of the mouse cursor resource to use.  Should correspond to a name from the active UISkin's
	 *						MouseCursorMap
	 *
	 * @return	TRUE if the cursor was successfully changed.  FALSE if the cursor name was invalid or wasn't found in the current
	 *			skin's MouseCursorMap
	 */
	virtual UBOOL ChangeMouseCursor( FName CursorName );

	/**
	 * Adds the specified scene to the list of active scenes, loading the scene and performing initialization as necessary.
	 *
	 * @param	Scene			the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *							and the copy will be opened instead.
	 * @param	SceneOwner		the player that should be associated with the new scene.  Will be assigned to the scene's
	 *							PlayerOwner property.
	 * @param	OpenedScene		the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *							the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ForcedPriority	overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully opened
	 */
	virtual UBOOL OpenScene( UUIScene* Scene, ULocalPlayer* SceneOwner=NULL, UUIScene** OpenedScene=NULL, BYTE ForcedPriority=UCONST_DEFAULT_SCENE_PRIORITY );

	/**
	 * Instances, initializes, and activates the specified scene, inserting it into the scene stack at the specified location.
	 *
	 * @param	DesiredInsertIndex	the index [into the ActiveScenes array] to insert the scene.  the scene's SceneStackPriority will take precedence over this value.
	 * @param	Scene				the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *								and the copy will be opened instead.
	 * @param	SceneOwner			the player that should be associated with the new scene.  Will be assigned to the scene's
	 *								PlayerOwner property.
	 * @param	OpenedScene			the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *								the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ActualInsertIndex	receives the location where the scene was actually inserted into the scene stack.
	 * @param	ForcedPriority		overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully activated and inserted into the scene stack (although not necessarily at the DesiredSceneIndex)
	 */
	virtual UBOOL InsertScene( INT DesiredInsertIndex, UUIScene* Scene, ULocalPlayer* SceneOwner=NULL, UUIScene** OpenedScene=NULL, INT* ActualInsertIndex=NULL, BYTE ForcedPriority=UCONST_DEFAULT_SCENE_PRIORITY );

	/**
	 * Instances, initializes, and activates a scene, replacing an existing scene's location in the scene stack.  The existing scene will be deactivated and no longer part
	 * of the scene stack.  The location in the scene stack for the new scene instance may be modified if its SceneStackPriority requires the scene stack to be resorted.
	 *
	 * @param	SceneInstanceToReplace	the scene that should be replaced.
	 * @param	SceneToOpen				the scene that will replace the existing scene.  If the scene specified is contained in a content package, the scene will be duplicated and
	 *									the duplicate will be added instead.
	 * @param	SceneOwner				the player that should be associated with the new scene.  Will be assigned to the scene's
	 *									PlayerOwner property.
	 * @param	OpenedScene				the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *									the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ForcedPriority			overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully activated and inserted into the scene stack (although not necessarily at the DesiredSceneIndex)
	 */
	virtual UBOOL ReplaceScene( UUIScene* SceneInstanceToReplace, UUIScene* SceneToOpen, ULocalPlayer* SceneOwner=NULL, UUIScene** OpenedScene=NULL, BYTE ForcedPriority=UCONST_DEFAULT_SCENE_PRIORITY );

	/**
	 * Instances, initializes, and activates a scene, replacing an existing scene's location in the scene stack.  The existing scene will be deactivated and no longer part
	 * of the scene stack.  The location in the scene stack for the new scene instance may be modified if its SceneStackPriority requires the scene stack to be resorted.
	 *
	 * @param	IndexOfSceneToReplace	the index into the stack of scenes for the scene to be replaced.
	 * @param	SceneToOpen				the scene that will replace the existing scene.  If the scene specified is contained in a content package, the scene will be duplicated and
	 *									the duplicate will be added instead.
	 * @param	SceneOwner				the player that should be associated with the new scene.  Will be assigned to the scene's
	 *									PlayerOwner property.
	 * @param	OpenedScene				the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *									the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ForcedPriority			overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully activated and inserted into the scene stack (although not necessarily at the DesiredSceneIndex)
	 */
	virtual UBOOL ReplaceSceneAtIndex( INT IndexOfSceneToReplace, UUIScene* SceneToOpen, ULocalPlayer* SceneOwner=NULL, UUIScene** OpenedScene=NULL, BYTE ForcedPriority=UCONST_DEFAULT_SCENE_PRIORITY );

	/**
	 * Deactivates the specified scene and removes it from the stack of scenes.
	 *
	 * @param	Scene				the scene to deactivate
	 * @param	bCloseChildScenes	normally any scenes which are higher in the stack than the scene being closed are also closed.  Specify
	 *								FALSE To override this behavior.
	 * @param	bForceCloseImmediately
	 *								indicates that the result of calling the scene's OnQueryCloseSceneAllowed delegate should be ignored; used
	 *								when closing all scenes as the result of a map change, for example.
	 *
	 * @return true if the scene was successfully deactivated
	 */
	virtual UBOOL CloseScene( UUIScene* Scene, UBOOL bCloseChildScenes=TRUE, UBOOL bForceCloseImmediately=FALSE );

	/**
	 * Deactivates the scene located at the specified index in the stack of scenes.
	 *
	 * @param	SceneStackIndex		the index in the stack of scenes for the scene that should be deactivated
	 * @param	bCloseChildScenes	normally any scenes which are higher in the stack than the scene being closed are also closed.  Specify
	 *								FALSE To override this behavior.
	 * @param	bForceCloseImmediately
	 *								indicates that the result of calling the scene's OnQueryCloseSceneAllowed delegate should be ignored; used
	 *								when closing all scenes as the result of a map change, for example.
	 *
	 * @return true if the scene was successfully deactivated
	 */
	virtual UBOOL CloseSceneAtIndex( INT SceneStackIndex, UBOOL bCloseChildScenes=TRUE, UBOOL bForceCloseImmediately=FALSE );

	/**
	 * Called once a frame to update the UI's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Render all the active scenes
	 */
	virtual void RenderScenes( FCanvas* Canvas );

	/**
	 * Re-initializes all primitives in the specified scene.  Will occur on the next tick.
	 *
	 * @param	Sender	the scene to re-initialize primitives for.
	 */
	virtual void RequestPrimitiveReinitialization( UUIScene* Sender );

	/**
	 * Gives all UIScenes a chance to create, attach, and/or initialize any primitives contained in the UIScene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void InitializePrimitives( FCanvasScene* CanvasScene );

	/**
	 * Updates 3D primitives for all active scenes
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateActivePrimitives( FCanvasScene* CanvasScene );

private:
	/**
	 * @return	TRUE if the scene meets the conditions defined by the bitmask specified.
	 */
	UBOOL SceneMatchesFilter( DWORD FilterFlagMask, UUIScene* TestScene ) const;

public:
	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=SCENEFILTER_Any ) const;

	/**
	 * Returns whether the specified scene has been fully initialized.  Different from UUIScene::IsInitialized() in that this
	 * method returns true only once all objects related to this scene have been created and initialized (e.g. in the UI editor
	 * only returns TRUE once the editor window for this scene has finished creation).
	 *
	 * @param	Scene	the scene to check.
	 */
	virtual UBOOL IsSceneInitialized( const UUIScene* Scene ) const;

protected:

	/**
	 * Gets the list of scenes that should be rendered.  Some active scenes might not be rendered if scenes later in the
	 * scene stack prevent it, for example.
	 */
	virtual void GetScenesToRender( TArray<UUIScene*>& ScenesToRender );

	/**
	 * Determines whether the scene will become the topmost scene and (if necessary) adjusts the desired stack index and requested priority
	 * if the requested values aren't compatible with the scene client's current state and active scenes.
	 *
	 * @param	SceneToActivate			the scene that is being activated
	 * @param	DesiredStackIndex		the desired location [into the ActiveScenes array] for the new scene.  A value of INDEX_NONE indicates
	 *									that the scene should be added to the top of the stack.  Value will be set to the actual index that the
	 *									scene should be inserted.
	 * @param	DesiredScenePriority	the priority to use for the new scene.  Any scenes with a SceneStackPriority higher than this value
	 *									will remain on top.
	 *
	 * @return	TRUE if the new scene will become the topmost scene.
	 */
	UBOOL ValidateDesiredStackIndex( UUIScene* SceneToActivate, INT& DesiredStackIndex, INT& DesiredStackPriority ) const;

	/**
	 * Adds the specified scene to the list of active scenes.
	 *
	 * @param	SceneToActivate		the scene to activate
	 * @param	DesiredStackIndex	the location in the list of active scenes to put the new scene.  If INDEX_NONE
	 *								is specified, the scene is added to the top of the stack.
	 * @param	ForcedPriority		overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 */
	virtual void ActivateScene( UUIScene* SceneToActivate, INT DesiredStackIndex=INDEX_NONE, BYTE ForcedScenePriority=0 );

	/**
	 * Removes the specified scene from the list of active scenes.  If this scene is not the top-most scene, all
	 * scenes which occur after the specified scene in the ActiveScenes array will be deactivated as well.
	 *
	 * @param	SceneToDeactivate	the scene to remove
	 * @param	bCloseChildScenes	normally any scenes which are higher in the stack than the scene being closed are also closed.  Specify
	 *								FALSE To override this behavior.
	 * @param	bForceCloseImmediately
	 *								indicates that the result of calling the scene's OnQueryCloseSceneAllowed delegate should be ignored; used
	 *								when closing all scenes as the result of a map change, for example.
	 *
	 * @return	TRUE if the scene was successfully removed from the list of active scenes.
	 */
	virtual UBOOL DeactivateScene( UUIScene* SceneToDeactivate, UBOOL bCloseChildScenes=TRUE, UBOOL bForceCloseImmediately=FALSE );

	/**
	 * Searches all scenes to determine if any are configured to display a cursor.  Sets the value of bRenderCursor accordingly.
	 */
	virtual void UpdateCursorRenderStatus();

	/**
	 * Updates the value of UIInteraction.bProcessingInput to reflect whether any scenes are capable of processing input.
	 */
	void UpdateInputProcessingStatus();

	/**
	 * Ensures that the game's paused state is appropriate considering the state of the UI.  If any scenes are active which require
	 * the game to be paused, pauses the game...otherwise, unpauses the game.
	 *
	 * @param	PlayerIndex		the index of the player that owns the scene that was just added or removed, or 0 if the scene didn't have
	 *							a player owner.
	 */
	virtual void UpdatePausedState( INT PlayerIndex );

	/**
	 * Clears the arrays of pressed keys for all local players in the game; used when the UI begins processing input.  Also
	 * updates the InitialPressedKeys maps for all players.
	 */
	void FlushPlayerInput();

	/**
	 * Renders debug information to the screen canvas.
	 */
	virtual void RenderDebugInfo( FCanvas* Canvas );

public:
};

class UUIState_Active : public UUIState
{
public:
    //## BEGIN PROPS UIState_Active
    //## END PROPS UIState_Active

    DECLARE_CLASS(UUIState_Active,UUIState,0,Engine)
	/**
	 * Activate this state for the specified target.  This version ensures that the StackPriority for the Active and
	 * Pressed states have been reset to their default values.
	 *
	 * @param	Target			the widget that is activating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be activated for the specified
	 *			Target or this state was already part of the Target's state stack.
	 */
	virtual UBOOL ActivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Deactivate this state for the specified target.  This version changes the StackPriority on the Active and Pressed states
	 * so that the widget uses the style data from whichever state the widget was previously in.
	 *
	 * @param	Target			the widget that is deactivating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be deactivated for the specified
	 *			Target or this state wasn't part of the Target's state stack.
	 */
	virtual UBOOL DeactivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );
};

class UUIState_Focused : public UUIState
{
public:
    //## BEGIN PROPS UIState_Focused
    //## END PROPS UIState_Focused

    DECLARE_CLASS(UUIState_Focused,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );
};

class UUIState_Pressed : public UUIState
{
public:
    //## BEGIN PROPS UIState_Pressed
    //## END PROPS UIState_Pressed

    DECLARE_CLASS(UUIState_Pressed,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * This version activates the focused state for the widget as well.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIState_TargetedTab : public UUIState
{
public:
    //## BEGIN PROPS UIState_TargetedTab
    //## END PROPS UIState_TargetedTab

    DECLARE_CLASS(UUIState_TargetedTab,UUIState,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIState_TargetedTab)
};

class UUIEditboxString : public UUIString
{
public:
    //## BEGIN PROPS UIEditboxString
    //## END PROPS UIEditboxString

    DECLARE_CLASS(UUIEditboxString,UUIString,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIEditBox)
	/* === UUIString interface === */
protected:
	/**
	 * Hook for adjusting the extents and render text of any nodes prior to applyig formatting data.
	 *
	 * @param	FormatData	contains the precalculated formatting data (available bounding region size, etc.)
	 *
	 * @return	TRUE to indicate that the string has been preclipping (forces UUIString::ApplyFormatting to use UIALIGN_Left
	 *			instead of the configured text clip mode, if the string must be clipped further).
	 */
	virtual UBOOL AdjustNodeExtents( struct FNodeFormattingData& FormatData );

public:
	/**
	 * Parses a string containing optional markup (such as tokens and inline images) and stores the result in Nodes.
	 *
	 * This version replaces the RenderText in all nodes with asterisks if the editbox's bPasswordMode is enabled.
	 *
	 * @param	InputString		A string containing optional markup.
	 * @param	bIgnoreMarkup	if TRUE, does not attempt to process any markup and only one UITextNode is created
	 *
	 * @return	TRUE if the string was successfully parsed into the Nodes array.
	 */
	virtual UBOOL SetValue( const FString& InputString, UBOOL bIgnoreMarkup );
};

class UUIListString : public UUIString
{
public:
    //## BEGIN PROPS UIListString
    //## END PROPS UIListString

    DECLARE_CLASS(UUIListString,UUIString,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIList)
	/* === UIListString interface === */
	void SetValue( struct FUIStringNode* ValueNode );
};

struct UIStyle_Data_eventMatchesStyleData_Parms
{
    const class UUIStyle_Data* OtherStyle;
    UBOOL ReturnValue;
    UIStyle_Data_eventMatchesStyleData_Parms(EEventParm)
    {
    }
};
class UUIStyle_Data : public UUIRoot
{
public:
    //## BEGIN PROPS UIStyle_Data
    FStringNoInit UIEditorControlClass;
    FLinearColor StyleColor;
    FLOAT StylePadding[2];
    BITFIELD bEnabled:1;
    BITFIELD bDirty:1;
    FScriptDelegate __MatchesStyleData__Delegate;
    //## END PROPS UIStyle_Data

    UBOOL delegateMatchesStyleData(const class UUIStyle_Data* OtherStyle)
    {
        UIStyle_Data_eventMatchesStyleData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.OtherStyle=OtherStyle;
        ProcessDelegate(ENGINE_MatchesStyleData,&__MatchesStyleData__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIStyle_Data,UUIRoot,0,Engine)
	/**
	 * Called when this style data object is added to a style.
	 *
	 * @param	the menu state that this style data has been created for.
	 */
	virtual void Created( class UUIState* AssociatedState ) {}

	/**
	 * Resolves any references to other styles contained in this style data object.
	 *
	 * @param	OwnerSkin	the skin that is currently active.
	 */
	virtual void ResolveExternalReferences( class UUISkin* ActiveSkin ) {}

	/**
	 * Allows the style to verify that it contains valid data for all required fields.  Called when the owning style is being initialized, after
	 * external references have been resolved.
	 */
	virtual void ValidateStyleData() {}

	/** Returns the UIStyle object that contains this style data */
	class UUIStyle* GetOwnerStyle() const;

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @return	TRUE if this style's data has been modified, indicating that it should be reapplied to any subscribed widgets.
	 */
	virtual UBOOL IsDirty() const;

	/**
	 * Sets or clears the dirty flag for this style data.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 */
	virtual void SetDirtiness( UBOOL bIsDirty );

	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	OtherStyle	the style to compare this style's values against
	 *
	 * @return	TRUE if all style property values are the same as the other style's or if the other style is same as this one
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

	/** Returns TRUE if this style data references specified style */
	virtual UBOOL IsReferencingStyle(const UUIStyle* Style) const { return FALSE; }
};

struct FStyleDataReference
{
private:
    class UUIStyle* OwnerStyle;
    struct FSTYLE_ID SourceStyleID;
    class UUIStyle* SourceStyle;
    class UUIState* SourceState;
    class UUIStyle_Data* CustomStyleData;
public:

	friend class UUIStyle_Combo;

	/** Constructors */
	FStyleDataReference();
	FStyleDataReference( class UUIStyle* InSourceStyle, class UUIState* InSourceState );

	/** Comparison */
	UBOOL operator ==( const FStyleDataReference& Other ) const;
	UBOOL operator !=( const FStyleDataReference& Other ) const;

	/**
	 * Resolves SourceStyleID from the specified skin and assigns the result to SourceStyle.
	 *
	 * @param	ActiveSkin	the currently active skin.
	 */
	void ResolveSourceStyle( class UUISkin* ActiveSkin );

	/**
	 *	Returns the value of OnwerStyle
	 */
	class UUIStyle* GetOwnerStyle() const { return OwnerStyle; }

	/**
	 * Returns the style data object linked to this reference, if SourceStyle or SourceState are NULL then CustomStyleData will be returned instead
	 */
	class UUIStyle_Data* GetStyleData() const;

	/**
	 * Returns the value of SourceStyle
	 */
	class UUIStyle* GetSourceStyle() const { return SourceStyle; }

	/**
	 * Returns the value of SourceState
	 */
	class UUIState* GetSourceState() const { return SourceState; }

	/**
	 * Returns the value of CustomStyleData
	 */
	class UUIStyle_Data* GetCustomStyleData() const { return CustomStyleData; }

	/**
	 * Changes OwnerStyle to be the style specified
	 */
	void SetOwnerStyle( class UUIStyle* NewStyle ){ OwnerStyle = NewStyle; }

	/**
	 *	Sets The SourceStyle reference, makes sure that SourceState is valid for this style
	 */
	void SafeSetStyle(UUIStyle* Style);

	/**
	 * 	Sets The SourceState reference, makes sure that SourceStyle contains this state
	 */
	void SafeSetState(UUIState* State);

	/**
	 * Changes SourceStyle to the style specified, without checking whether it is valid.
	 */
	void SetSourceStyle( class UUIStyle* NewStyle );

	/**
	 * Changes SourceState to the state specified, without checking whether it is valid.
	 */
	void SetSourceState( class UUIState* NewState );

	/**
	 * Sets CustomStyleData reference
	 */
	void SetCustomStyleData( UUIStyle_Data* CustomData ){ CustomStyleData = CustomData; }

	/**
	 * Enables or disables the custom style data if the OwnerStyle is the outer of the custom data
	 */
	void EnableCustomStyleData( UBOOL BoolFlag );

	/**
	 *	Determines if referenced custom style data is valid.
	 */
	UBOOL IsCustomStyleDataValid() const;

	/**
	 *	Determines if the custom style data is valid and enabled
	 */
	UBOOL IsCustomStyleDataEnabled() const;

	/**
	 * Returns whether the styles referenced are marked as dirty
	 */
	UBOOL IsDirty() const;

};

class UUIStyle_Combo : public UUIStyle_Data
{
public:
    //## BEGIN PROPS UIStyle_Combo
    struct FStyleDataReference ImageStyle;
    struct FStyleDataReference TextStyle;
    //## END PROPS UIStyle_Combo

    class UUIStyle_Text* GetComboTextStyle() const;
    class UUIStyle_Image* GetComboImageStyle() const;
    DECLARE_FUNCTION(execGetComboTextStyle)
    {
        P_FINISH;
        *(class UUIStyle_Text**)Result=GetComboTextStyle();
    }
    DECLARE_FUNCTION(execGetComboImageStyle)
    {
        P_FINISH;
        *(class UUIStyle_Image**)Result=GetComboImageStyle();
    }
    DECLARE_CLASS(UUIStyle_Combo,UUIStyle_Data,0,Engine)
	/**
	 * Called when this style data object is added to a style.
	 *
	 * @param	the menu state that this style data has been created for.
	 */
	virtual void Created( class UUIState* AssociatedState );

	/**
	 * Resolves any references to other styles contained in this style data object.
	 *
	 * @param	OwnerSkin	the skin that is currently active.
	 */
	virtual void ResolveExternalReferences( class UUISkin* ActiveSkin );

	/**
	 * Allows the style to verify that it contains valid data for all required fields.  Called when the owning style is being initialized, after
	 * external references have been resolved.
	 */
	virtual void ValidateStyleData();

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @return	TRUE if this style's data has been modified, indicating that it should be reapplied to any subscribed widgets.
	 */
	virtual UBOOL IsDirty() const;

	/**
	 * Sets or clears the dirty flag for this style data.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 */
	virtual void SetDirtiness( UBOOL bIsDirty );

	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	OtherStyle	the style to compare this style's values against
	 *
	 * @return	TRUE if all style property values are the same as the other style's or if the other style is same as this one
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

	/** Returns TRUE if this style data references specified style */
	virtual UBOOL IsReferencingStyle(const UUIStyle* Style) const;

	/* === UObject interface === */
	/**
	 * Assigns the SourceStyleID property for the style references contained by this combo style, if this style was saved
	 * prior to adding SourceStyleID to UIStyleDataReference
	 */
	virtual void PostLoad();
};

class UUIStyle_Image : public UUIStyle_Data
{
public:
    //## BEGIN PROPS UIStyle_Image
    class USurface* DefaultImage;
    struct FTextureCoordinates Coordinates;
    struct FUIImageAdjustmentData AdjustmentType[2];
    //## END PROPS UIStyle_Image

    DECLARE_CLASS(UUIStyle_Image,UUIStyle_Data,0,Engine)
	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	OtherStyle	the style to compare this style's values against
	 *
	 * @return	TRUE if all style property values are the same as the other style's or if the other style is same as this one
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

};

class UUIStyle_Text : public UUIStyle_Data
{
public:
    //## BEGIN PROPS UIStyle_Text
    class UFont* StyleFont;
    struct FUITextAttributes Attributes;
    BYTE Alignment[2];
    BYTE ClipMode;
    BYTE ClipAlignment;
    struct FTextAutoScaleValue AutoScaling;
    FVector2D Scale;
    FVector2D SpacingAdjust;
    //## END PROPS UIStyle_Text

    DECLARE_CLASS(UUIStyle_Text,UUIStyle_Data,0,Engine)
	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	OtherStyle	the style to compare this style's values against
	 *
	 * @return	TRUE if all style property values are the same as the other style's or if the other style is same as this one
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

	/**
	 * Allows the style to verify that it contains valid data for all required fields.  Called when the owning style is being initialized, after
	 * external references have been resolved.
	 *
	 * This version verifies that this style has a valid font and if not sets the font reference to the default font.
	 */
	virtual void ValidateStyleData();

	/* === UObject interface. === */
	/**
	 * Called after this object has been de-serialized from disk.
	 *
	 * This version propagates CLIP_Scaled and CLIP_ScaledBestFit ClipMode values to the new AutoScaling property
	 */
	virtual void PostLoad();
};

class UUITexture : public UUIRoot
{
public:
    //## BEGIN PROPS UITexture
private:
    struct FUICombinedStyleData ImageStyleData;
public:
    class USurface* ImageTexture;
    //## END PROPS UITexture

    class UUIScreenObject* GetOwnerWidget(class UUIComponent** OwnerComponent=NULL) const;
    void SetImageStyle(class UUIStyle_Image* NewImageStyle);
    UBOOL HasValidStyleData() const;
    DECLARE_FUNCTION(execGetOwnerWidget)
    {
        P_GET_OBJECT_OPTX_REF(UUIComponent,OwnerComponent,NULL);
        P_FINISH;
        *(class UUIScreenObject**)Result=GetOwnerWidget(pOwnerComponent ? &OwnerComponent : NULL);
    }
    DECLARE_FUNCTION(execSetImageStyle)
    {
        P_GET_OBJECT(UUIStyle_Image,NewImageStyle);
        P_FINISH;
        SetImageStyle(NewImageStyle);
    }
    DECLARE_FUNCTION(execHasValidStyleData)
    {
        P_FINISH;
        *(UBOOL*)Result=HasValidStyleData();
    }
    DECLARE_CLASS(UUITexture,UUIRoot,0,Engine)
	/**
	 * Fills in the extent with the size of this texture's material
	 *
	 * @param	Extent	[out] set to the width/height of this texture's material
	 */
	virtual void CalculateExtent( FVector2D& Extent ) const;

	/**
	 * Fills in the extent with the size of this texture's material
	 *
	 * @param	SizeX	[out] filled in with the width this texture's material
	 * @param	SizeY	[out] filled in with the height of this texture's material
	 */
	virtual void CalculateExtent( FLOAT& out_SizeX, FLOAT& out_SizeY ) const;

	/**
	 * Render this UITexture using the parameters specified.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this texture
	 * @param	Parameters	the bounds for the region that this texture can render to.
	 */
	virtual void Render_Texture( FCanvas* Canvas, const FRenderParameters& Parameters );

	/**
	 * Returns the surface associated with this UITexture.
	 */
	USurface* GetSurface() const { return ImageTexture; }

	/**
	 * Copies the style data specified to this UITexture's ImageStyleData.
	 */
	void SetImageStyle( const struct FUICombinedStyleData& NewStyleData );

	/**
	 * Provides read-only access to the style data assigned to this UITexture
	 */
	const struct FUICombinedStyleData& GetImageStyle() const { return ImageStyleData; }

	/**
	 * Utility function for rendering a texture to the screen using DrawTile.  Determines the appropriate overload of DrawTile
	 * to call, depending on the type of surface being rendered, and translates the UV values into percentages as this is what
	 * Canvas expects.
	 *
	 * @param	Canvas			the FCanvas to use for rendering this texture
	 * @param	Surface			the texture to be rendered
	 * @param	StyleData		this is [currently] only used when rendering UTexture surfaces to get the color to use for rendering
	 * @param	X				the horizontal screen location (in pixels) where the image should be rendered
	 * @param	Y				the vertical screen location (in pixels) where the image should be rendered
	 * @param	XL				the width of the region (in pixels) where this image will be rendered
	 * @param	YL				the height of the region (in pixels) where this image will be rendered
	 * @param	U				the horizontal location (in pixels) to begin sampling the texture data
	 * @param	V				the vertical location (in pixels) to begin sampling the texture data
	 * @param	UL				the width (in pixels) of the texture data sampling region
	 * @param	VL				the height (in pixels) of the texture data sampling region
	 */
	static void DrawTile( FCanvas* Canvas, USurface* Surface, const struct FUICombinedStyleData& StyleData,
						 FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL );

	/**
	 * Render the specified image.  If the target region is larger than the image being rendered, the image is stretched by duplicating the pixels at the
	 * images midpoint to fill the additional space.  If the target region is smaller than the image being rendered, the image will be scaled to fit the region.
	 *
	 * @param	Canvas			the FCanvas to use for rendering this texture
	 * @param	Surface			the texture to be rendered
	 * @param	StyleData		used to determine which orientations can be stretched in the image
	 * @param	Parameters		describes the bounds and sample locations for rendering this tile.  See the documentation for DrawTile
	 *							for more details about each individual member.
	 */
	static void DrawTileStretched( FCanvas* Canvas, USurface* Surface, const struct FUICombinedStyleData& StyleData, const FRenderParameters& Parameters );

	/**
	 * Render the specified image.  The protected regions of the image will not be scaled in the directions of their respective dimensions,
	 * i.e. the left protected region will not be scaled in the horizontal dimension with the rest of the image.  The protected regions are
	 * defined by a value that indicates the distance from their respective face to the opposite edge of the region.  The perpendicular
	 * faces of a given protected region extend to the edges of the full image.
	 *
	 * @param	RI				the render interface to use for rendering the image
	 * @param	Surface			the texture to be rendered
	 * @param	StyleData		used to determine which orientations can be stretched in the image
	 * @param	Parameters		describes the bounds and sample locations for rendering this tile.  See the documentation for DrawTile
	 *							for more details about each individual member.
	 */
	static void DrawTileProtectedRegions( FCanvas* Canvas, USurface* Surface, const struct FUICombinedStyleData& StyleData, const FRenderParameters& Parameters );

	/* === UObject interface === */
	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

struct UITickableObjectProxy_eventScriptTick_Parms
{
    FLOAT DeltaTime;
    UITickableObjectProxy_eventScriptTick_Parms(EEventParm)
    {
    }
};
struct UITickableObjectProxy_eventOnScriptTick_Parms
{
    class UUITickableObjectProxy* Sender;
    FLOAT DeltaTime;
    UITickableObjectProxy_eventOnScriptTick_Parms(EEventParm)
    {
    }
};
class UUITickableObjectProxy : public UUIRoot, public IUITickableObject
{
public:
    //## BEGIN PROPS UITickableObjectProxy
    FScriptDelegate __OnScriptTick__Delegate;
    //## END PROPS UITickableObjectProxy

    void eventScriptTick(FLOAT DeltaTime)
    {
        UITickableObjectProxy_eventScriptTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_ScriptTick),&Parms);
    }
    void delegateOnScriptTick(class UUITickableObjectProxy* Sender,FLOAT DeltaTime)
    {
        UITickableObjectProxy_eventOnScriptTick_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.DeltaTime=DeltaTime;
        ProcessDelegate(ENGINE_OnScriptTick,&__OnScriptTick__Delegate,&Parms);
    }
    DECLARE_CLASS(UUITickableObjectProxy,UUIRoot,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUITickableObject(){return this;}
	/**
	 * Called each frame to allow the object to perform work.
	 *
	 * @param	PreviousFrameSeconds	amount of time (in seconds) between the start of this frame and the start of the previous frame.
	 */
	virtual void Tick( FLOAT PreviousFrameSeconds );
};

#endif // !INCLUDED_ENGINE_UIPRIVATE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execFindUIAnimation);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execSetActiveControl);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCanUnpauseInternalUI);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execRequestCursorRenderUpdate);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execRequestInputProcessingUpdate);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execAllActiveScenes);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetNextSceneFromIndex);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetNextScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetPreviousInputProcessingScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetPreviousSceneFromIndex);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetPreviousScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetActiveScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetActiveSceneCount);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execFindSceneIndexByTag);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetSceneAtIndex);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execFindSceneIndex);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execFindSceneByTag);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCreateTransientWidget);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCreateScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetTransientScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetCurrentNetMode);
AUTOGENERATE_FUNCTION(USessionSettingsProvider,-1,execUnbindProviderClient);
AUTOGENERATE_FUNCTION(USessionSettingsProvider,-1,execBindProviderClient);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execGetSequenceLength);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execGetTrackLength);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execGetFrameLength);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execIsValidFrameIndex);
AUTOGENERATE_FUNCTION(UUICalloutButton,-1,execOnReceivedInputKey);
AUTOGENERATE_FUNCTION(UUICalloutButton,-1,execUnsubscribeFromInputProxy);
AUTOGENERATE_FUNCTION(UUICalloutButton,-1,execSubscribeToInputProxy);
AUTOGENERATE_FUNCTION(UUICalloutButton,-1,execSetInputTag);
AUTOGENERATE_FUNCTION(UUICalloutButton,-1,execGetCalloutDataStore);
AUTOGENERATE_FUNCTION(UUICalloutButtonPanel,-1,execRequestButtonDockingUpdate);
AUTOGENERATE_FUNCTION(UUICalloutButtonPanel,-1,execFindBestInsertionIndex);
AUTOGENERATE_FUNCTION(UUICalloutButtonPanel,-1,execGetCalloutInputProxy);
AUTOGENERATE_FUNCTION(UUICalloutButtonPanel,-1,execCreateCalloutButton);
AUTOGENERATE_FUNCTION(UUICalloutButtonPanel,-1,execGetAvailableCalloutButtonAliases);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIComp_DrawComponents,-1,execResetFade);
AUTOGENERATE_FUNCTION(UUIComp_DrawComponents,-1,execPulse);
AUTOGENERATE_FUNCTION(UUIComp_DrawComponents,-1,execFade);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execNotifyResolveStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execGetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execGetImage);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomFormatting);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomPadding);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomCoordinates);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetFormatting);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetPadding);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetCoordinates);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetImage);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execGetAppliedImageStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAutoSizeExtent);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execNotifyResolveStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetFinalStringStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetAppliedStringStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetWrapMode);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomSpacingAdjust);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomScale);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomAutoScaling);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomClipAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomClipMode);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomAttributes);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomFont);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomPadding);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetSpacingAdjust);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetScale);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAutoScaling);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetClipAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetWrapMode);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAttributes);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetFont);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetPadding);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetSubregionAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetSubregionOffset);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetSubregionSize);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execEnableSubregion);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetSubregionAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetSubregionOffset);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetSubregionSize);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execIsSubregionEnabled);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execRefreshValue);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execGetSelectedText);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execGetSelectionRange);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execClearSelection);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execSetSelectionEnd);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execSetSelectionStart);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execSetSelectionRange);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execGetUserTextLength);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execSetUserText);
AUTOGENERATE_FUNCTION(UUIComp_ListElementSorter,-1,execResortItems);
AUTOGENERATE_FUNCTION(UUIComp_ListElementSorter,-1,execSortItems);
AUTOGENERATE_FUNCTION(UUIComp_ListElementSorter,-1,execResetSortColumns);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenter,-1,execFindElementIndex);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execGetMaxElementsPerPage);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execSetMaxElementsPerPage);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execGetElementValue);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execEnableColumnHeaderRendering);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execShouldRenderColumnHeaders);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execShouldAdjustListBounds);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execCalculateAutoSizeColumnWidth);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execCalculateAutoSizeRowHeight);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execGetSchemaCellPosition);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execSetSchemaCellSize);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execGetSchemaCellSize);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execGetSchemaCellCount);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenterBase,-1,execGetCellSchemaProvider);
AUTOGENERATE_FUNCTION(UUIContextMenu,-1,execClose);
AUTOGENERATE_FUNCTION(UUIContextMenu,-1,execOpen);
AUTOGENERATE_FUNCTION(UUIContextMenu,-1,execIsActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIDataProvider,-1,execParseArrayDelimiter);
AUTOGENERATE_FUNCTION(UUIDataProvider,-1,execGetProviderFieldType);
AUTOGENERATE_FUNCTION(UUIDataProvider_MenuItem,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUIDataProvider_PlayerAchievements,-1,execGetTotalGamerScore);
AUTOGENERATE_FUNCTION(UUIDataStore,-1,execOnCommit);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execOnLoginChange);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execFindProviderIndexByFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetProviderFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetResourceProviderFields);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetResourceProviders);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGenerateProviderAccessTag);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execFindProviderTypeIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execFindProviderIndexByFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetProviderFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetResourceProviderFields);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetResourceProviders);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGenerateProviderAccessTag);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execFindProviderTypeIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execHasAliasMappingForPlatform);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execFindInputAliasIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyDataByIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyData);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyNameByIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyName);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasFontMarkupByIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasFontMarkup);
AUTOGENERATE_FUNCTION(UUIDataStore_MenuItems,-1,execGetSet);
AUTOGENERATE_FUNCTION(UUIDataStore_MenuItems,-1,execAppendToSet);
AUTOGENERATE_FUNCTION(UUIDataStore_MenuItems,-1,execClearSet);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineGameSearch,-1,execBuildSearchResults);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineGameSettings,-1,execOnSettingProviderChanged);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlayerData,-1,execOnSettingProviderChanged);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineStats,-1,execSortResultsByRank);
AUTOGENERATE_FUNCTION(UUIDataStore_PlayerSettings,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execFindMappingWithFieldName);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIDynamicDataProvider,-1,execUnbindProviderInstance);
AUTOGENERATE_FUNCTION(UUIDynamicDataProvider,-1,execBindProviderInstance);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execFindCollectionValueIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execClearCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execReplaceCollectionValueByIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execReplaceCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveCollectionValueByIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execInsertCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSetCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValueSchema);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSavePersistentProviderData);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSetField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execClearFields);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execFindFieldIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execAddField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execInitializeRuntimeFields);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execCalculateCaretPositionFromCursorLocation);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIImage,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIImage,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIImage,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIImage,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUIImage,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIImage,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIImage,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabel,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabel,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabel,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUILabel,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUILabel,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabel,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabel,-1,execSetTextAlignment);
AUTOGENERATE_FUNCTION(UUILabel,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSetTextAlignment);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSetCaption);
AUTOGENERATE_FUNCTION(UUIList,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsElementAutoSizingEnabled);
AUTOGENERATE_FUNCTION(UUIList,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIList,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUIList,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsHotTrackingEnabled);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetHotTracking);
AUTOGENERATE_FUNCTION(UUIList,-1,execCanSelectElement);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsElementSelected);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsElementEnabled);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetTopIndex);
AUTOGENERATE_FUNCTION(UUIList,-1,execNavigateIndex);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetIndex);
AUTOGENERATE_FUNCTION(UUIList,-1,execFindItemIndex);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetElementCellState);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetElementCellState);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetElementValue);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetCurrentItem);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetSelectedItems);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetResizeColumn);
AUTOGENERATE_FUNCTION(UUIList,-1,execCalculateIndexFromCursorLocation);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetClientRegion);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetRowHeight);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetColumnWidth);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetRowCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetColumnCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetTotalColumnCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetTotalRowCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetMaxNumVisibleColumns);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetMaxNumVisibleRows);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetMaxVisibleElementCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetItemCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execRemoveElement);
AUTOGENERATE_FUNCTION(UUIList,-1,execScrollVertical);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execGetNumericValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execSetNumericValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execDecrementValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execIncrementValue);
AUTOGENERATE_FUNCTION(UUINumericOptionList,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUINumericOptionList,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetWidgetStyleByName);
AUTOGENERATE_FUNCTION(UUIObject,-1,execFindStyleSubscriberIndexById);
AUTOGENERATE_FUNCTION(UUIObject,-1,execFindStyleSubscriberIndex);
AUTOGENERATE_FUNCTION(UUIObject,-1,execRemoveStyleSubscriber);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAddStyleSubscriber);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetPositionExtent);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetPositionExtents);
AUTOGENERATE_FUNCTION(UUIObject,-1,execNeedsActiveCursorUpdates);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetActiveCursorUpdate);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetPrivateBehavior);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsPrivateBehaviorSet);
AUTOGENERATE_FUNCTION(UUIObject,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetForcedNavigationTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetNavigationTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsDockedTo);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDockParameters);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockParameters);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockPadding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsContainedBy);
AUTOGENERATE_FUNCTION(UUIObject,-1,execNotifyValueChanged);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetRotationMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGenerateTransformMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetAnchorPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execUpdateRotationMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execRotateWidget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetAnchorPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execHasTransform);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetToolTipValue);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGenerateSceneDataStoreMarkup);
AUTOGENERATE_FUNCTION(UUIObject,-1,execClearDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDefaultDataStores);
AUTOGENERATE_FUNCTION(UUIObject,-1,execResolveDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObjectList,-1,execGetElementObjectValue);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execSetCurrentIndex);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execGetCurrentIndex);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execIsCurrValueValid);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execSetNextValue);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execSetPrevValue);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execGetListValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execOnMoveSelectionRight);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execOnMoveSelectionLeft);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execHasNextValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execHasPrevValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIOptionListButton,-1,execUpdateButtonState);
AUTOGENERATE_FUNCTION(UUIPrefabInstance,-1,execDetachFromSourcePrefab);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIScene,-1,execLogDockingStack);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetActiveToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetActiveToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetDefaultContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetDefaultToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execIsSceneActive);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetSceneRenderMode);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetSceneRenderMode);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetSceneInputMode);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetSceneInputMode);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetScenePostProcessGroup);
AUTOGENERATE_FUNCTION(UUIScene,-1,execShouldRenderParentScenes);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetPreviousScene);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetNextScene);
AUTOGENERATE_FUNCTION(UUIScene,-1,execResolveDataStore);
AUTOGENERATE_FUNCTION(UUIScene,-1,execUnbindSubscribers);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSaveSceneDataValues);
AUTOGENERATE_FUNCTION(UUIScene,-1,execLoadSceneDataValues);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetSceneDataStore);
AUTOGENERATE_FUNCTION(UUIScene,-1,execFindTickableObjectIndex);
AUTOGENERATE_FUNCTION(UUIScene,-1,execUnregisterTickableObject);
AUTOGENERATE_FUNCTION(UUIScene,-1,execRegisterTickableObject);
AUTOGENERATE_FUNCTION(UUIScene,-1,execResolveScenePositions);
AUTOGENERATE_FUNCTION(UUIScene,-1,execRebuildDockingStack);
AUTOGENERATE_FUNCTION(UUIScene,-1,execForceImmediateSceneUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsAnimationPaused);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPauseAnimations);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsAnimating);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execClearUIAnimationLoop);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execStopUIAnimation);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPlayUIAnimation);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindAnimationSequenceIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execTickAnimations);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execAnimGetCurrentPPSettings);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execAnim_SetValue);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execAnim_GetValue);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetWidgetPathName);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetAspectRatioAutoScaleFactor);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPixelToCanvas);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execScreenToCanvas);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPixelToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execScreenToPixel);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeProject);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execProject);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetDockedWidgets);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execResolveUIExtent);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPositionVector);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBounds);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetPosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInvalidateAllPositions);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInvalidatePosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPlayerOwnerIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBestControllerId);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBestPlayerIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetSupportedPlayerCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetActivePlayerCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetInputMask);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetInputMask);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execAcceptsPlayerInput);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsRuntimeInstance);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsPressed);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsActive);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsFocused);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsDisabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsEnabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execOverrideLastFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetLastFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execKillFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetFocusToChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanPropagateFocusFor);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsNeverFocused);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execNavigateFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPrevControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execNextControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFocusLastControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFocusFirstControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingShift);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingAlt);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingCtrl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execConditionalPropagateEnabledState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeactivateStateByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeactivateState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateStateByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execHasActiveStateOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetCurrentState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindEventsOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateEventByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetAspectRatio);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportHeight);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportWidth);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportSize);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportOrigin);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportScale);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportOffset);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRebuildNavigationLinks);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestPrimitiveReview);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestSceneInputMaskUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestFormattingUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestSceneUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetDockClients);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetObjectCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execContainsChildOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execContainsChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChildIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChildUsingID);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execReplaceChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execReparentChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execReparentChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemoveChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemoveChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInsertChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInitialize);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInstanceUIPrefab);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCreateWidget);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPlayUISound);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInitializePlayerTracking);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemovePlayerData);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCreatePlayerData);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetZDepth);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetZDepth);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHidden);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsVisible);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsInitialized);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execDragScroll);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execDragScrollEnd);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execDragScrollBegin);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execScrollDecrement);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execScrollIncrement);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execEnableCornerPadding);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetNudgeSizePixels);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetNudgeSizePercent);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetMarkerPosition);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetMarkerSize);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execGetScrollZoneWidth);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execGetScrollZoneExtent);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execGetMarkerButtonPosition);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetVisibleRegionPercentage);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClipRegion);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionSizeVector);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionPositionVector);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionSize);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionPosition);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execSetClientRegionPositionVector);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execSetClientRegionPosition);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execScrollRegion);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execReapplyFormatting);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execRefreshScrollbars);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetStyleGroups);
AUTOGENERATE_FUNCTION(UUISkin,-1,execFindStyleGroupIndex);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetStyleGroupAtIndex);
AUTOGENERATE_FUNCTION(UUISkin,-1,execRenameStyleGroup);
AUTOGENERATE_FUNCTION(UUISkin,-1,execRemoveStyleGroupName);
AUTOGENERATE_FUNCTION(UUISkin,-1,execAddStyleGroupName);
AUTOGENERATE_FUNCTION(UUISkin,-1,execIsInheritedGroupName);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetSkinSoundCues);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetUISoundCue);
AUTOGENERATE_FUNCTION(UUISkin,-1,execRemoveUISoundCue);
AUTOGENERATE_FUNCTION(UUISkin,-1,execAddUISoundCue);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetCursorResource);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetAvailableStyles);
AUTOGENERATE_FUNCTION(UUISlider,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUISlider,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUISlider,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUISlider,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUISlider,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIStyle_Combo,-1,execGetComboImageStyle);
AUTOGENERATE_FUNCTION(UUIStyle_Combo,-1,execGetComboTextStyle);
AUTOGENERATE_FUNCTION(UUITabButton,-1,execIsTargeted);
AUTOGENERATE_FUNCTION(UUITabButton,-1,execCanActivateButton);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execCreateTabPage);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execFindTargetedTab);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execGetPageAtIndex);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execGetPageCount);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execRequestLayoutUpdate);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execNotifyDataStoreValueUpdated);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execGetOwnerTabControl);
AUTOGENERATE_FUNCTION(UUITexture,-1,execHasValidStyleData);
AUTOGENERATE_FUNCTION(UUITexture,-1,execSetImageStyle);
AUTOGENERATE_FUNCTION(UUITexture,-1,execGetOwnerWidget);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execSetCaption);
AUTOGENERATE_FUNCTION(UUIToolTip,-1,execUpdateToolTipPosition);
AUTOGENERATE_FUNCTION(UUIToolTip,-1,execEndTracking);
AUTOGENERATE_FUNCTION(UUIToolTip,-1,execBeginTracking);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_UIPRIVATE_NATIVE_DEFS
#define ENGINE_UIPRIVATE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UConsoleEntry);
DECLARE_NATIVE_TYPE(Engine,UCurrentGameDataStore);
DECLARE_NATIVE_TYPE(Engine,UCurrentWeaponDataProvider);
DECLARE_NATIVE_TYPE(Engine,UGameInfoDataProvider);
DECLARE_NATIVE_TYPE(Engine,UGameUISceneClient);
DECLARE_NATIVE_TYPE(Engine,UInventoryDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPickupDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPlayerDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPlayerOwnerDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPlayerOwnerDataStore);
DECLARE_NATIVE_TYPE(Engine,UPlayerSettingsProvider);
DECLARE_NATIVE_TYPE(Engine,UPowerupDataProvider);
DECLARE_NATIVE_TYPE(Engine,USceneDataStore);
DECLARE_NATIVE_TYPE(Engine,USessionSettingsProvider);
DECLARE_NATIVE_TYPE(Engine,UTeamDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIAnimation);
DECLARE_NATIVE_TYPE(Engine,UUIAnimationSeq);
DECLARE_NATIVE_TYPE(Engine,UUIButton);
DECLARE_NATIVE_TYPE(Engine,UUICalloutButton);
DECLARE_NATIVE_TYPE(Engine,UUICalloutButtonPanel);
DECLARE_NATIVE_TYPE(Engine,UUICheckbox);
DECLARE_NATIVE_TYPE(Engine,UUIComboBox);
DECLARE_NATIVE_TYPE(Engine,UUIComp_AutoAlignment);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ContextMenuListPresenter);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawCaption);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawComponents);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawImage);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawString);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawStringEditbox);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawStringSlider);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListComponentBase);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListElementSorter);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenter);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenterBase);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenterCascade);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenterTree);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ObjectListPresenter);
DECLARE_NATIVE_TYPE(Engine,UUIConfigFileProvider);
DECLARE_NATIVE_TYPE(Engine,UUIConfigProvider);
DECLARE_NATIVE_TYPE(Engine,UUIConfigSectionProvider);
DECLARE_NATIVE_TYPE(Engine,UUIContainer);
DECLARE_NATIVE_TYPE(Engine,UUIContextMenu);
DECLARE_NATIVE_TYPE(Engine,UUICustomSkin);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_MenuItem);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineClanMates);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineFriendMessages);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineFriends);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlinePlayerDataBase);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlinePlayers);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineProfileSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineProfileSettingsArray);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_PlayerAchievements);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_Settings);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_SettingsArray);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Color);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_DynamicResource);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Fonts);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_GameResource);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_GameState);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Gamma);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Images);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_InputAlias);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_MenuItems);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlineGameSearch);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlineGameSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlinePlayerData);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlineStats);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_PlayerSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Registry);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Remote);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_SessionSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Settings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_StringAliasMap);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_StringBase);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Strings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStorePublisher);
DECLARE_NATIVE_TYPE(Engine,UUIDataStoreSubscriber);
DECLARE_NATIVE_TYPE(Engine,UUIDynamicDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIDynamicFieldProvider);
DECLARE_NATIVE_TYPE(Engine,UUIEditBox);
DECLARE_NATIVE_TYPE(Engine,UUIEditboxString);
DECLARE_NATIVE_TYPE(Engine,UUIFrameBox);
DECLARE_NATIVE_TYPE(Engine,UUIImage);
DECLARE_NATIVE_TYPE(Engine,UUILabel);
DECLARE_NATIVE_TYPE(Engine,UUILabelButton);
DECLARE_NATIVE_TYPE(Engine,UUIList);
DECLARE_NATIVE_TYPE(Engine,UUIListElementCellProvider);
DECLARE_NATIVE_TYPE(Engine,UUIListElementProvider);
DECLARE_NATIVE_TYPE(Engine,UUIListString);
DECLARE_NATIVE_TYPE(Engine,UUIMapSummary);
DECLARE_NATIVE_TYPE(Engine,UUIMeshWidget);
DECLARE_NATIVE_TYPE(Engine,UUINavigationList);
DECLARE_NATIVE_TYPE(Engine,UUINumericEditBox);
DECLARE_NATIVE_TYPE(Engine,UUINumericEditBoxButton);
DECLARE_NATIVE_TYPE(Engine,UUINumericOptionList);
DECLARE_NATIVE_TYPE(Engine,UUIObject);
DECLARE_NATIVE_TYPE(Engine,UUIObjectList);
DECLARE_NATIVE_TYPE(Engine,UUIOptionList);
DECLARE_NATIVE_TYPE(Engine,UUIOptionListBase);
DECLARE_NATIVE_TYPE(Engine,UUIOptionListButton);
DECLARE_NATIVE_TYPE(Engine,UUIPanel);
DECLARE_NATIVE_TYPE(Engine,UUIPrefab);
DECLARE_NATIVE_TYPE(Engine,UUIPrefabInstance);
DECLARE_NATIVE_TYPE(Engine,UUIPrefabScene);
DECLARE_NATIVE_TYPE(Engine,UUIProgressBar);
DECLARE_NATIVE_TYPE(Engine,UUIPropertyDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIResourceCombinationProvider);
DECLARE_NATIVE_TYPE(Engine,UUIResourceDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUISafeRegionPanel);
DECLARE_NATIVE_TYPE(Engine,UUIScene);
DECLARE_NATIVE_TYPE(Engine,UUIScreenObject);
DECLARE_NATIVE_TYPE(Engine,UUIScrollbar);
DECLARE_NATIVE_TYPE(Engine,UUIScrollbarButton);
DECLARE_NATIVE_TYPE(Engine,UUIScrollbarMarkerButton);
DECLARE_NATIVE_TYPE(Engine,UUIScrollFrame);
DECLARE_NATIVE_TYPE(Engine,UUISettingsProvider);
DECLARE_NATIVE_TYPE(Engine,UUISkin);
DECLARE_NATIVE_TYPE(Engine,UUISlider);
DECLARE_NATIVE_TYPE(Engine,UUIState_Active);
DECLARE_NATIVE_TYPE(Engine,UUIState_Focused);
DECLARE_NATIVE_TYPE(Engine,UUIState_Pressed);
DECLARE_NATIVE_TYPE(Engine,UUIState_TargetedTab);
DECLARE_NATIVE_TYPE(Engine,UUIStringRenderer);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Combo);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Data);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Image);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Text);
DECLARE_NATIVE_TYPE(Engine,UUIStyleResolver);
DECLARE_NATIVE_TYPE(Engine,UUITabButton);
DECLARE_NATIVE_TYPE(Engine,UUITabControl);
DECLARE_NATIVE_TYPE(Engine,UUITabPage);
DECLARE_NATIVE_TYPE(Engine,UUITexture);
DECLARE_NATIVE_TYPE(Engine,UUITickableObject);
DECLARE_NATIVE_TYPE(Engine,UUITickableObjectProxy);
DECLARE_NATIVE_TYPE(Engine,UUIToggleButton);
DECLARE_NATIVE_TYPE(Engine,UUIToolTip);
DECLARE_NATIVE_TYPE(Engine,UWeaponDataProvider);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_UIPRIVATE \
	UConsoleEntry::StaticClass(); \
	UCurrentGameDataStore::StaticClass(); \
	UCurrentWeaponDataProvider::StaticClass(); \
	UGameInfoDataProvider::StaticClass(); \
	UGameUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUGameUISceneClientNative; \
	UInventoryDataProvider::StaticClass(); \
	UPickupDataProvider::StaticClass(); \
	UPlayerDataProvider::StaticClass(); \
	UPlayerOwnerDataProvider::StaticClass(); \
	UPlayerOwnerDataStore::StaticClass(); \
	UPlayerSettingsProvider::StaticClass(); \
	UPowerupDataProvider::StaticClass(); \
	USceneDataStore::StaticClass(); \
	USessionSettingsProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSessionSettingsProviderNative; \
	UTeamDataProvider::StaticClass(); \
	UUIAnimation::StaticClass(); \
	UUIAnimationSeq::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIAnimationSeqNative; \
	UUIButton::StaticClass(); \
	UUICalloutButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUICalloutButtonNative; \
	UUICalloutButtonPanel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUICalloutButtonPanelNative; \
	UUICheckbox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUICheckboxNative; \
	UUIComboBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComboBoxNative; \
	UUIComp_AutoAlignment::StaticClass(); \
	UUIComp_ContextMenuListPresenter::StaticClass(); \
	UUIComp_DrawCaption::StaticClass(); \
	UUIComp_DrawComponents::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawComponentsNative; \
	UUIComp_DrawImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawImageNative; \
	UUIComp_DrawString::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawStringNative; \
	UUIComp_DrawStringEditbox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawStringEditboxNative; \
	UUIComp_DrawStringSlider::StaticClass(); \
	UUIComp_ListComponentBase::StaticClass(); \
	UUIComp_ListElementSorter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_ListElementSorterNative; \
	UUIComp_ListPresenter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_ListPresenterNative; \
	UUIComp_ListPresenterBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_ListPresenterBaseNative; \
	UUIComp_ListPresenterCascade::StaticClass(); \
	UUIComp_ListPresenterTree::StaticClass(); \
	UUIComp_ObjectListPresenter::StaticClass(); \
	UUIConfigFileProvider::StaticClass(); \
	UUIConfigProvider::StaticClass(); \
	UUIConfigSectionProvider::StaticClass(); \
	UUIContainer::StaticClass(); \
	UUIContextMenu::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIContextMenuNative; \
	UUICustomSkin::StaticClass(); \
	UUIDataProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataProviderNative; \
	UUIDataProvider_MenuItem::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataProvider_MenuItemNative; \
	UUIDataProvider_OnlineClanMates::StaticClass(); \
	UUIDataProvider_OnlineFriendMessages::StaticClass(); \
	UUIDataProvider_OnlineFriends::StaticClass(); \
	UUIDataProvider_OnlinePlayerDataBase::StaticClass(); \
	UUIDataProvider_OnlinePlayers::StaticClass(); \
	UUIDataProvider_OnlineProfileSettings::StaticClass(); \
	UUIDataProvider_OnlineProfileSettingsArray::StaticClass(); \
	UUIDataProvider_PlayerAchievements::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataProvider_PlayerAchievementsNative; \
	UUIDataProvider_Settings::StaticClass(); \
	UUIDataProvider_SettingsArray::StaticClass(); \
	UUIDataStore::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStoreNative; \
	UUIDataStore_Color::StaticClass(); \
	UUIDataStore_DynamicResource::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_DynamicResourceNative; \
	UUIDataStore_Fonts::StaticClass(); \
	UUIDataStore_GameResource::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_GameResourceNative; \
	UUIDataStore_GameState::StaticClass(); \
	UUIDataStore_Gamma::StaticClass(); \
	UUIDataStore_Images::StaticClass(); \
	UUIDataStore_InputAlias::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_InputAliasNative; \
	UUIDataStore_MenuItems::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_MenuItemsNative; \
	UUIDataStore_OnlineGameSearch::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_OnlineGameSearchNative; \
	UUIDataStore_OnlineGameSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_OnlineGameSettingsNative; \
	UUIDataStore_OnlinePlayerData::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_OnlinePlayerDataNative; \
	UUIDataStore_OnlineStats::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_OnlineStatsNative; \
	UUIDataStore_PlayerSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_PlayerSettingsNative; \
	UUIDataStore_Registry::StaticClass(); \
	UUIDataStore_Remote::StaticClass(); \
	UUIDataStore_SessionSettings::StaticClass(); \
	UUIDataStore_Settings::StaticClass(); \
	UUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_StringAliasMapNative; \
	UUIDataStore_StringBase::StaticClass(); \
	UUIDataStore_Strings::StaticClass(); \
	UUIDataStorePublisher::StaticClass(); \
	UUIDataStoreSubscriber::StaticClass(); \
	UUIDynamicDataProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDynamicDataProviderNative; \
	UUIDynamicFieldProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDynamicFieldProviderNative; \
	UUIEditBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIEditBoxNative; \
	UUIEditboxString::StaticClass(); \
	UUIFrameBox::StaticClass(); \
	UUIImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIImageNative; \
	UUILabel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUILabelNative; \
	UUILabelButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUILabelButtonNative; \
	UUIList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIListNative; \
	UUIListElementCellProvider::StaticClass(); \
	UUIListElementProvider::StaticClass(); \
	UUIListString::StaticClass(); \
	UUIMapSummary::StaticClass(); \
	UUIMeshWidget::StaticClass(); \
	UUINavigationList::StaticClass(); \
	UUINumericEditBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUINumericEditBoxNative; \
	UUINumericEditBoxButton::StaticClass(); \
	UUINumericOptionList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUINumericOptionListNative; \
	UUIObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIObjectNative; \
	UUIObjectList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIObjectListNative; \
	UUIOptionList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIOptionListNative; \
	UUIOptionListBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIOptionListBaseNative; \
	UUIOptionListButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIOptionListButtonNative; \
	UUIPanel::StaticClass(); \
	UUIPrefab::StaticClass(); \
	UUIPrefabInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIPrefabInstanceNative; \
	UUIPrefabScene::StaticClass(); \
	UUIProgressBar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIProgressBarNative; \
	UUIPropertyDataProvider::StaticClass(); \
	UUIResourceCombinationProvider::StaticClass(); \
	UUIResourceDataProvider::StaticClass(); \
	UUISafeRegionPanel::StaticClass(); \
	UUIScene::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISceneNative; \
	UUIScreenObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScreenObjectNative; \
	UUIScrollbar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScrollbarNative; \
	UUIScrollbarButton::StaticClass(); \
	UUIScrollbarMarkerButton::StaticClass(); \
	UUIScrollFrame::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScrollFrameNative; \
	UUISettingsProvider::StaticClass(); \
	UUISkin::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISkinNative; \
	UUISlider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISliderNative; \
	UUIState_Active::StaticClass(); \
	UUIState_Focused::StaticClass(); \
	UUIState_Pressed::StaticClass(); \
	UUIState_TargetedTab::StaticClass(); \
	UUIStringRenderer::StaticClass(); \
	UUIStyle_Combo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStyle_ComboNative; \
	UUIStyle_Data::StaticClass(); \
	UUIStyle_Image::StaticClass(); \
	UUIStyle_Text::StaticClass(); \
	UUIStyleResolver::StaticClass(); \
	UUITabButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITabButtonNative; \
	UUITabControl::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITabControlNative; \
	UUITabPage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITabPageNative; \
	UUITexture::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITextureNative; \
	UUITickableObject::StaticClass(); \
	UUITickableObjectProxy::StaticClass(); \
	UUIToggleButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIToggleButtonNative; \
	UUIToolTip::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIToolTipNative; \
	UWeaponDataProvider::StaticClass(); \

#endif // ENGINE_UIPRIVATE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UGameUISceneClient) GEngineUGameUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UGameUISceneClient,execFindUIAnimation)
	MAP_NATIVE(UGameUISceneClient,execSetActiveControl)
	MAP_NATIVE(UGameUISceneClient,execCanUnpauseInternalUI)
	MAP_NATIVE(UGameUISceneClient,execRequestCursorRenderUpdate)
	MAP_NATIVE(UGameUISceneClient,execRequestInputProcessingUpdate)
	MAP_NATIVE(UGameUISceneClient,execAllActiveScenes)
	MAP_NATIVE(UGameUISceneClient,execGetNextSceneFromIndex)
	MAP_NATIVE(UGameUISceneClient,execGetNextScene)
	MAP_NATIVE(UGameUISceneClient,execGetPreviousInputProcessingScene)
	MAP_NATIVE(UGameUISceneClient,execGetPreviousSceneFromIndex)
	MAP_NATIVE(UGameUISceneClient,execGetPreviousScene)
	MAP_NATIVE(UGameUISceneClient,execGetActiveScene)
	MAP_NATIVE(UGameUISceneClient,execGetActiveSceneCount)
	MAP_NATIVE(UGameUISceneClient,execFindSceneIndexByTag)
	MAP_NATIVE(UGameUISceneClient,execGetSceneAtIndex)
	MAP_NATIVE(UGameUISceneClient,execFindSceneIndex)
	MAP_NATIVE(UGameUISceneClient,execFindSceneByTag)
	MAP_NATIVE(UGameUISceneClient,execCreateTransientWidget)
	MAP_NATIVE(UGameUISceneClient,execCreateScene)
	MAP_NATIVE(UGameUISceneClient,execGetTransientScene)
	MAP_NATIVE(UGameUISceneClient,execGetCurrentNetMode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UGameUISceneClient);

NATIVE_INFO(USessionSettingsProvider) GEngineUSessionSettingsProviderNatives[] = 
{ 
	MAP_NATIVE(USessionSettingsProvider,execUnbindProviderClient)
	MAP_NATIVE(USessionSettingsProvider,execBindProviderClient)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USessionSettingsProvider);

NATIVE_INFO(UUIAnimationSeq) GEngineUUIAnimationSeqNatives[] = 
{ 
	MAP_NATIVE(UUIAnimationSeq,execGetSequenceLength)
	MAP_NATIVE(UUIAnimationSeq,execGetTrackLength)
	MAP_NATIVE(UUIAnimationSeq,execGetFrameLength)
	MAP_NATIVE(UUIAnimationSeq,execIsValidFrameIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIAnimationSeq);

NATIVE_INFO(UUICalloutButton) GEngineUUICalloutButtonNatives[] = 
{ 
	MAP_NATIVE(UUICalloutButton,execOnReceivedInputKey)
	MAP_NATIVE(UUICalloutButton,execUnsubscribeFromInputProxy)
	MAP_NATIVE(UUICalloutButton,execSubscribeToInputProxy)
	MAP_NATIVE(UUICalloutButton,execSetInputTag)
	MAP_NATIVE(UUICalloutButton,execGetCalloutDataStore)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUICalloutButton);

NATIVE_INFO(UUICalloutButtonPanel) GEngineUUICalloutButtonPanelNatives[] = 
{ 
	MAP_NATIVE(UUICalloutButtonPanel,execRequestButtonDockingUpdate)
	MAP_NATIVE(UUICalloutButtonPanel,execFindBestInsertionIndex)
	MAP_NATIVE(UUICalloutButtonPanel,execGetCalloutInputProxy)
	MAP_NATIVE(UUICalloutButtonPanel,execCreateCalloutButton)
	MAP_NATIVE(UUICalloutButtonPanel,execGetAvailableCalloutButtonAliases)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUICalloutButtonPanel);

NATIVE_INFO(UUICheckbox) GEngineUUICheckboxNatives[] = 
{ 
	MAP_NATIVE(UUICheckbox,execSetValue)
	MAP_NATIVE(UUICheckbox,execSaveSubscriberValue)
	MAP_NATIVE(UUICheckbox,execClearBoundDataStores)
	MAP_NATIVE(UUICheckbox,execGetBoundDataStores)
	MAP_NATIVE(UUICheckbox,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUICheckbox,execRefreshSubscriberValue)
	MAP_NATIVE(UUICheckbox,execGetDataStoreBinding)
	MAP_NATIVE(UUICheckbox,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUICheckbox);

NATIVE_INFO(UUIComboBox) GEngineUUIComboBoxNatives[] = 
{ 
	MAP_NATIVE(UUIComboBox,execSaveSubscriberValue)
	MAP_NATIVE(UUIComboBox,execClearBoundDataStores)
	MAP_NATIVE(UUIComboBox,execGetBoundDataStores)
	MAP_NATIVE(UUIComboBox,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUIComboBox,execRefreshSubscriberValue)
	MAP_NATIVE(UUIComboBox,execGetDataStoreBinding)
	MAP_NATIVE(UUIComboBox,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComboBox);

NATIVE_INFO(UUIComp_DrawComponents) GEngineUUIComp_DrawComponentsNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawComponents,execResetFade)
	MAP_NATIVE(UUIComp_DrawComponents,execPulse)
	MAP_NATIVE(UUIComp_DrawComponents,execFade)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawComponents);

NATIVE_INFO(UUIComp_DrawImage) GEngineUUIComp_DrawImageNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawImage,execNotifyResolveStyle)
	MAP_NATIVE(UUIComp_DrawImage,execSetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawImage,execGetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawImage,execGetImage)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomFormatting)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomPadding)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomOpacity)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomColor)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomCoordinates)
	MAP_NATIVE(UUIComp_DrawImage,execSetFormatting)
	MAP_NATIVE(UUIComp_DrawImage,execSetPadding)
	MAP_NATIVE(UUIComp_DrawImage,execSetOpacity)
	MAP_NATIVE(UUIComp_DrawImage,execSetColor)
	MAP_NATIVE(UUIComp_DrawImage,execSetCoordinates)
	MAP_NATIVE(UUIComp_DrawImage,execSetImage)
	MAP_NATIVE(UUIComp_DrawImage,execGetAppliedImageStyle)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawImage);

NATIVE_INFO(UUIComp_DrawString) GEngineUUIComp_DrawStringNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawString,execSetAutoSizeExtent)
	MAP_NATIVE(UUIComp_DrawString,execNotifyResolveStyle)
	MAP_NATIVE(UUIComp_DrawString,execSetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawString,execGetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawString,execGetFinalStringStyle)
	MAP_NATIVE(UUIComp_DrawString,execGetAppliedStringStyle)
	MAP_NATIVE(UUIComp_DrawString,execGetWrapMode)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomSpacingAdjust)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomScale)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomAutoScaling)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomClipAlignment)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomClipMode)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomAlignment)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomAttributes)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomFont)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomPadding)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomOpacity)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomColor)
	MAP_NATIVE(UUIComp_DrawString,execSetSpacingAdjust)
	MAP_NATIVE(UUIComp_DrawString,execSetScale)
	MAP_NATIVE(UUIComp_DrawString,execSetAutoScaling)
	MAP_NATIVE(UUIComp_DrawString,execSetClipAlignment)
	MAP_NATIVE(UUIComp_DrawString,execSetWrapMode)
	MAP_NATIVE(UUIComp_DrawString,execSetAlignment)
	MAP_NATIVE(UUIComp_DrawString,execSetAttributes)
	MAP_NATIVE(UUIComp_DrawString,execSetFont)
	MAP_NATIVE(UUIComp_DrawString,execSetPadding)
	MAP_NATIVE(UUIComp_DrawString,execSetOpacity)
	MAP_NATIVE(UUIComp_DrawString,execSetColor)
	MAP_NATIVE(UUIComp_DrawString,execSetSubregionAlignment)
	MAP_NATIVE(UUIComp_DrawString,execSetSubregionOffset)
	MAP_NATIVE(UUIComp_DrawString,execSetSubregionSize)
	MAP_NATIVE(UUIComp_DrawString,execEnableSubregion)
	MAP_NATIVE(UUIComp_DrawString,execGetSubregionAlignment)
	MAP_NATIVE(UUIComp_DrawString,execGetSubregionOffset)
	MAP_NATIVE(UUIComp_DrawString,execGetSubregionSize)
	MAP_NATIVE(UUIComp_DrawString,execIsSubregionEnabled)
	MAP_NATIVE(UUIComp_DrawString,execRefreshValue)
	MAP_NATIVE(UUIComp_DrawString,execGetValue)
	MAP_NATIVE(UUIComp_DrawString,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawString);

NATIVE_INFO(UUIComp_DrawStringEditbox) GEngineUUIComp_DrawStringEditboxNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawStringEditbox,execGetSelectedText)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execGetSelectionRange)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execClearSelection)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execSetSelectionEnd)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execSetSelectionStart)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execSetSelectionRange)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execGetUserTextLength)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execSetUserText)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawStringEditbox);

NATIVE_INFO(UUIComp_ListElementSorter) GEngineUUIComp_ListElementSorterNatives[] = 
{ 
	MAP_NATIVE(UUIComp_ListElementSorter,execResortItems)
	MAP_NATIVE(UUIComp_ListElementSorter,execSortItems)
	MAP_NATIVE(UUIComp_ListElementSorter,execResetSortColumns)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_ListElementSorter);

NATIVE_INFO(UUIComp_ListPresenter) GEngineUUIComp_ListPresenterNatives[] = 
{ 
	MAP_NATIVE(UUIComp_ListPresenter,execFindElementIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_ListPresenter);

NATIVE_INFO(UUIComp_ListPresenterBase) GEngineUUIComp_ListPresenterBaseNatives[] = 
{ 
	MAP_NATIVE(UUIComp_ListPresenterBase,execGetMaxElementsPerPage)
	MAP_NATIVE(UUIComp_ListPresenterBase,execSetMaxElementsPerPage)
	MAP_NATIVE(UUIComp_ListPresenterBase,execGetElementValue)
	MAP_NATIVE(UUIComp_ListPresenterBase,execEnableColumnHeaderRendering)
	MAP_NATIVE(UUIComp_ListPresenterBase,execShouldRenderColumnHeaders)
	MAP_NATIVE(UUIComp_ListPresenterBase,execShouldAdjustListBounds)
	MAP_NATIVE(UUIComp_ListPresenterBase,execCalculateAutoSizeColumnWidth)
	MAP_NATIVE(UUIComp_ListPresenterBase,execCalculateAutoSizeRowHeight)
	MAP_NATIVE(UUIComp_ListPresenterBase,execGetSchemaCellPosition)
	MAP_NATIVE(UUIComp_ListPresenterBase,execSetSchemaCellSize)
	MAP_NATIVE(UUIComp_ListPresenterBase,execGetSchemaCellSize)
	MAP_NATIVE(UUIComp_ListPresenterBase,execGetSchemaCellCount)
	MAP_NATIVE(UUIComp_ListPresenterBase,execGetCellSchemaProvider)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_ListPresenterBase);

NATIVE_INFO(UUIContextMenu) GEngineUUIContextMenuNatives[] = 
{ 
	MAP_NATIVE(UUIContextMenu,execClose)
	MAP_NATIVE(UUIContextMenu,execOpen)
	MAP_NATIVE(UUIContextMenu,execIsActiveContextMenu)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIContextMenu);

NATIVE_INFO(UUIDataProvider) GEngineUUIDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDataProvider,execParseArrayDelimiter)
	MAP_NATIVE(UUIDataProvider,execGetProviderFieldType)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataProvider);

NATIVE_INFO(UUIDataProvider_MenuItem) GEngineUUIDataProvider_MenuItemNatives[] = 
{ 
	MAP_NATIVE(UUIDataProvider_MenuItem,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataProvider_MenuItem);

NATIVE_INFO(UUIDataProvider_PlayerAchievements) GEngineUUIDataProvider_PlayerAchievementsNatives[] = 
{ 
	MAP_NATIVE(UUIDataProvider_PlayerAchievements,execGetTotalGamerScore)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataProvider_PlayerAchievements);

NATIVE_INFO(UUIDataStore) GEngineUUIDataStoreNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore,execOnCommit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore);

NATIVE_INFO(UUIDataStore_DynamicResource) GEngineUUIDataStore_DynamicResourceNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_DynamicResource,execOnLoginChange)
	MAP_NATIVE(UUIDataStore_DynamicResource,execFindProviderIndexByFieldValue)
	MAP_NATIVE(UUIDataStore_DynamicResource,execGetProviderFieldValue)
	MAP_NATIVE(UUIDataStore_DynamicResource,execGetResourceProviderFields)
	MAP_NATIVE(UUIDataStore_DynamicResource,execGetResourceProviders)
	MAP_NATIVE(UUIDataStore_DynamicResource,execGetProviderCount)
	MAP_NATIVE(UUIDataStore_DynamicResource,execGenerateProviderAccessTag)
	MAP_NATIVE(UUIDataStore_DynamicResource,execFindProviderTypeIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_DynamicResource);

NATIVE_INFO(UUIDataStore_GameResource) GEngineUUIDataStore_GameResourceNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_GameResource,execFindProviderIndexByFieldValue)
	MAP_NATIVE(UUIDataStore_GameResource,execGetProviderFieldValue)
	MAP_NATIVE(UUIDataStore_GameResource,execGetResourceProviderFields)
	MAP_NATIVE(UUIDataStore_GameResource,execGetResourceProviders)
	MAP_NATIVE(UUIDataStore_GameResource,execGetProviderCount)
	MAP_NATIVE(UUIDataStore_GameResource,execGenerateProviderAccessTag)
	MAP_NATIVE(UUIDataStore_GameResource,execFindProviderTypeIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_GameResource);

NATIVE_INFO(UUIDataStore_InputAlias) GEngineUUIDataStore_InputAliasNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_InputAlias,execHasAliasMappingForPlatform)
	MAP_NATIVE(UUIDataStore_InputAlias,execFindInputAliasIndex)
	MAP_NATIVE(UUIDataStore_InputAlias,execGetAliasInputKeyDataByIndex)
	MAP_NATIVE(UUIDataStore_InputAlias,execGetAliasInputKeyData)
	MAP_NATIVE(UUIDataStore_InputAlias,execGetAliasInputKeyNameByIndex)
	MAP_NATIVE(UUIDataStore_InputAlias,execGetAliasInputKeyName)
	MAP_NATIVE(UUIDataStore_InputAlias,execGetAliasFontMarkupByIndex)
	MAP_NATIVE(UUIDataStore_InputAlias,execGetAliasFontMarkup)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_InputAlias);

NATIVE_INFO(UUIDataStore_MenuItems) GEngineUUIDataStore_MenuItemsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_MenuItems,execGetSet)
	MAP_NATIVE(UUIDataStore_MenuItems,execAppendToSet)
	MAP_NATIVE(UUIDataStore_MenuItems,execClearSet)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_MenuItems);

NATIVE_INFO(UUIDataStore_OnlineGameSearch) GEngineUUIDataStore_OnlineGameSearchNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineGameSearch,execBuildSearchResults)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_OnlineGameSearch);

NATIVE_INFO(UUIDataStore_OnlineGameSettings) GEngineUUIDataStore_OnlineGameSettingsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineGameSettings,execOnSettingProviderChanged)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_OnlineGameSettings);

NATIVE_INFO(UUIDataStore_OnlinePlayerData) GEngineUUIDataStore_OnlinePlayerDataNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlinePlayerData,execOnSettingProviderChanged)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_OnlinePlayerData);

NATIVE_INFO(UUIDataStore_OnlineStats) GEngineUUIDataStore_OnlineStatsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineStats,execSortResultsByRank)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_OnlineStats);

NATIVE_INFO(UUIDataStore_PlayerSettings) GEngineUUIDataStore_PlayerSettingsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_PlayerSettings,execGetPlayerOwner)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_PlayerSettings);

NATIVE_INFO(UUIDataStore_StringAliasMap) GEngineUUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_StringAliasMap,execGetStringWithFieldName)
	MAP_NATIVE(UUIDataStore_StringAliasMap,execFindMappingWithFieldName)
	MAP_NATIVE(UUIDataStore_StringAliasMap,execGetPlayerOwner)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_StringAliasMap);

NATIVE_INFO(UUIDynamicDataProvider) GEngineUUIDynamicDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDynamicDataProvider,execUnbindProviderInstance)
	MAP_NATIVE(UUIDynamicDataProvider,execBindProviderInstance)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDynamicDataProvider);

NATIVE_INFO(UUIDynamicFieldProvider) GEngineUUIDynamicFieldProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDynamicFieldProvider,execFindCollectionValueIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execClearCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider,execReplaceCollectionValueByIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execReplaceCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execRemoveCollectionValueByIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execRemoveCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execInsertCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execSetCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetCollectionValueSchema)
	MAP_NATIVE(UUIDynamicFieldProvider,execSavePersistentProviderData)
	MAP_NATIVE(UUIDynamicFieldProvider,execSetField)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetField)
	MAP_NATIVE(UUIDynamicFieldProvider,execClearFields)
	MAP_NATIVE(UUIDynamicFieldProvider,execFindFieldIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execRemoveField)
	MAP_NATIVE(UUIDynamicFieldProvider,execAddField)
	MAP_NATIVE(UUIDynamicFieldProvider,execInitializeRuntimeFields)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDynamicFieldProvider);

NATIVE_INFO(UUIEditBox) GEngineUUIEditBoxNatives[] = 
{ 
	MAP_NATIVE(UUIEditBox,execSaveSubscriberValue)
	MAP_NATIVE(UUIEditBox,execClearBoundDataStores)
	MAP_NATIVE(UUIEditBox,execGetBoundDataStores)
	MAP_NATIVE(UUIEditBox,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUIEditBox,execRefreshSubscriberValue)
	MAP_NATIVE(UUIEditBox,execGetDataStoreBinding)
	MAP_NATIVE(UUIEditBox,execSetDataStoreBinding)
	MAP_NATIVE(UUIEditBox,execCalculateCaretPositionFromCursorLocation)
	MAP_NATIVE(UUIEditBox,execGetValue)
	MAP_NATIVE(UUIEditBox,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIEditBox);

NATIVE_INFO(UUIImage) GEngineUUIImageNatives[] = 
{ 
	MAP_NATIVE(UUIImage,execSaveSubscriberValue)
	MAP_NATIVE(UUIImage,execClearBoundDataStores)
	MAP_NATIVE(UUIImage,execGetBoundDataStores)
	MAP_NATIVE(UUIImage,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUIImage,execRefreshSubscriberValue)
	MAP_NATIVE(UUIImage,execGetDataStoreBinding)
	MAP_NATIVE(UUIImage,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIImage);

NATIVE_INFO(UUILabel) GEngineUUILabelNatives[] = 
{ 
	MAP_NATIVE(UUILabel,execClearBoundDataStores)
	MAP_NATIVE(UUILabel,execGetBoundDataStores)
	MAP_NATIVE(UUILabel,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUILabel,execRefreshSubscriberValue)
	MAP_NATIVE(UUILabel,execGetDataStoreBinding)
	MAP_NATIVE(UUILabel,execSetDataStoreBinding)
	MAP_NATIVE(UUILabel,execSetTextAlignment)
	MAP_NATIVE(UUILabel,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUILabel);

NATIVE_INFO(UUILabelButton) GEngineUUILabelButtonNatives[] = 
{ 
	MAP_NATIVE(UUILabelButton,execSaveSubscriberValue)
	MAP_NATIVE(UUILabelButton,execClearBoundDataStores)
	MAP_NATIVE(UUILabelButton,execGetBoundDataStores)
	MAP_NATIVE(UUILabelButton,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUILabelButton,execRefreshSubscriberValue)
	MAP_NATIVE(UUILabelButton,execGetDataStoreBinding)
	MAP_NATIVE(UUILabelButton,execSetDataStoreBinding)
	MAP_NATIVE(UUILabelButton,execSetTextAlignment)
	MAP_NATIVE(UUILabelButton,execSetCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUILabelButton);

NATIVE_INFO(UUIList) GEngineUUIListNatives[] = 
{ 
	MAP_NATIVE(UUIList,execSaveSubscriberValue)
	MAP_NATIVE(UUIList,execIsElementAutoSizingEnabled)
	MAP_NATIVE(UUIList,execClearBoundDataStores)
	MAP_NATIVE(UUIList,execGetBoundDataStores)
	MAP_NATIVE(UUIList,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUIList,execRefreshSubscriberValue)
	MAP_NATIVE(UUIList,execGetDataStoreBinding)
	MAP_NATIVE(UUIList,execSetDataStoreBinding)
	MAP_NATIVE(UUIList,execIsHotTrackingEnabled)
	MAP_NATIVE(UUIList,execSetHotTracking)
	MAP_NATIVE(UUIList,execCanSelectElement)
	MAP_NATIVE(UUIList,execIsElementSelected)
	MAP_NATIVE(UUIList,execIsElementEnabled)
	MAP_NATIVE(UUIList,execSetTopIndex)
	MAP_NATIVE(UUIList,execNavigateIndex)
	MAP_NATIVE(UUIList,execSetIndex)
	MAP_NATIVE(UUIList,execFindItemIndex)
	MAP_NATIVE(UUIList,execGetElementCellState)
	MAP_NATIVE(UUIList,execSetElementCellState)
	MAP_NATIVE(UUIList,execGetElementValue)
	MAP_NATIVE(UUIList,execGetCurrentItem)
	MAP_NATIVE(UUIList,execGetSelectedItems)
	MAP_NATIVE(UUIList,execGetResizeColumn)
	MAP_NATIVE(UUIList,execCalculateIndexFromCursorLocation)
	MAP_NATIVE(UUIList,execGetClientRegion)
	MAP_NATIVE(UUIList,execGetRowHeight)
	MAP_NATIVE(UUIList,execGetColumnWidth)
	MAP_NATIVE(UUIList,execSetRowCount)
	MAP_NATIVE(UUIList,execSetColumnCount)
	MAP_NATIVE(UUIList,execGetTotalColumnCount)
	MAP_NATIVE(UUIList,execGetTotalRowCount)
	MAP_NATIVE(UUIList,execGetMaxNumVisibleColumns)
	MAP_NATIVE(UUIList,execGetMaxNumVisibleRows)
	MAP_NATIVE(UUIList,execGetMaxVisibleElementCount)
	MAP_NATIVE(UUIList,execGetItemCount)
	MAP_NATIVE(UUIList,execRemoveElement)
	MAP_NATIVE(UUIList,execScrollVertical)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIList);

NATIVE_INFO(UUINumericEditBox) GEngineUUINumericEditBoxNatives[] = 
{ 
	MAP_NATIVE(UUINumericEditBox,execGetNumericValue)
	MAP_NATIVE(UUINumericEditBox,execSetNumericValue)
	MAP_NATIVE(UUINumericEditBox,execDecrementValue)
	MAP_NATIVE(UUINumericEditBox,execIncrementValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUINumericEditBox);

NATIVE_INFO(UUINumericOptionList) GEngineUUINumericOptionListNatives[] = 
{ 
	MAP_NATIVE(UUINumericOptionList,execGetValue)
	MAP_NATIVE(UUINumericOptionList,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUINumericOptionList);

NATIVE_INFO(UUIObject) GEngineUUIObjectNatives[] = 
{ 
	MAP_NATIVE(UUIObject,execSetWidgetStyleByName)
	MAP_NATIVE(UUIObject,execFindStyleSubscriberIndexById)
	MAP_NATIVE(UUIObject,execFindStyleSubscriberIndex)
	MAP_NATIVE(UUIObject,execRemoveStyleSubscriber)
	MAP_NATIVE(UUIObject,execAddStyleSubscriber)
	MAP_NATIVE(UUIObject,execGetPositionExtent)
	MAP_NATIVE(UUIObject,execGetPositionExtents)
	MAP_NATIVE(UUIObject,execNeedsActiveCursorUpdates)
	MAP_NATIVE(UUIObject,execSetActiveCursorUpdate)
	MAP_NATIVE(UUIObject,execSetPrivateBehavior)
	MAP_NATIVE(UUIObject,execIsPrivateBehaviorSet)
	MAP_NATIVE(UUIObject,execCanAcceptFocus)
	MAP_NATIVE(UUIObject,execSetForcedNavigationTarget)
	MAP_NATIVE(UUIObject,execSetNavigationTarget)
	MAP_NATIVE(UUIObject,execIsDockedTo)
	MAP_NATIVE(UUIObject,execGetDockParameters)
	MAP_NATIVE(UUIObject,execSetDockParameters)
	MAP_NATIVE(UUIObject,execSetDockPadding)
	MAP_NATIVE(UUIObject,execSetDockTarget)
	MAP_NATIVE(UUIObject,execIsContainedBy)
	MAP_NATIVE(UUIObject,execNotifyValueChanged)
	MAP_NATIVE(UUIObject,execGetRotationMatrix)
	MAP_NATIVE(UUIObject,execGenerateTransformMatrix)
	MAP_NATIVE(UUIObject,execGetAnchorPosition)
	MAP_NATIVE(UUIObject,execUpdateRotationMatrix)
	MAP_NATIVE(UUIObject,execRotateWidget)
	MAP_NATIVE(UUIObject,execSetAnchorPosition)
	MAP_NATIVE(UUIObject,execHasTransform)
	MAP_NATIVE(UUIObject,execGetToolTipValue)
	MAP_NATIVE(UUIObject,execGenerateSceneDataStoreMarkup)
	MAP_NATIVE(UUIObject,execClearDefaultDataBinding)
	MAP_NATIVE(UUIObject,execGetDefaultDataStores)
	MAP_NATIVE(UUIObject,execResolveDefaultDataBinding)
	MAP_NATIVE(UUIObject,execGetDefaultDataBinding)
	MAP_NATIVE(UUIObject,execSetDefaultDataBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIObject);

NATIVE_INFO(UUIObjectList) GEngineUUIObjectListNatives[] = 
{ 
	MAP_NATIVE(UUIObjectList,execGetElementObjectValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIObjectList);

NATIVE_INFO(UUIOptionList) GEngineUUIOptionListNatives[] = 
{ 
	MAP_NATIVE(UUIOptionList,execSetCurrentIndex)
	MAP_NATIVE(UUIOptionList,execGetCurrentIndex)
	MAP_NATIVE(UUIOptionList,execIsCurrValueValid)
	MAP_NATIVE(UUIOptionList,execSetNextValue)
	MAP_NATIVE(UUIOptionList,execSetPrevValue)
	MAP_NATIVE(UUIOptionList,execGetListValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIOptionList);

NATIVE_INFO(UUIOptionListBase) GEngineUUIOptionListBaseNatives[] = 
{ 
	MAP_NATIVE(UUIOptionListBase,execOnMoveSelectionRight)
	MAP_NATIVE(UUIOptionListBase,execOnMoveSelectionLeft)
	MAP_NATIVE(UUIOptionListBase,execHasNextValue)
	MAP_NATIVE(UUIOptionListBase,execHasPrevValue)
	MAP_NATIVE(UUIOptionListBase,execSaveSubscriberValue)
	MAP_NATIVE(UUIOptionListBase,execClearBoundDataStores)
	MAP_NATIVE(UUIOptionListBase,execGetBoundDataStores)
	MAP_NATIVE(UUIOptionListBase,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUIOptionListBase,execRefreshSubscriberValue)
	MAP_NATIVE(UUIOptionListBase,execGetDataStoreBinding)
	MAP_NATIVE(UUIOptionListBase,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIOptionListBase);

NATIVE_INFO(UUIOptionListButton) GEngineUUIOptionListButtonNatives[] = 
{ 
	MAP_NATIVE(UUIOptionListButton,execUpdateButtonState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIOptionListButton);

NATIVE_INFO(UUIPrefabInstance) GEngineUUIPrefabInstanceNatives[] = 
{ 
	MAP_NATIVE(UUIPrefabInstance,execDetachFromSourcePrefab)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIPrefabInstance);

NATIVE_INFO(UUIProgressBar) GEngineUUIProgressBarNatives[] = 
{ 
	MAP_NATIVE(UUIProgressBar,execGetValue)
	MAP_NATIVE(UUIProgressBar,execSetValue)
	MAP_NATIVE(UUIProgressBar,execSaveSubscriberValue)
	MAP_NATIVE(UUIProgressBar,execClearBoundDataStores)
	MAP_NATIVE(UUIProgressBar,execGetBoundDataStores)
	MAP_NATIVE(UUIProgressBar,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUIProgressBar,execRefreshSubscriberValue)
	MAP_NATIVE(UUIProgressBar,execGetDataStoreBinding)
	MAP_NATIVE(UUIProgressBar,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIProgressBar);

NATIVE_INFO(UUIScene) GEngineUUISceneNatives[] = 
{ 
	MAP_NATIVE(UUIScene,execLogDockingStack)
	MAP_NATIVE(UUIScene,execSetActiveContextMenu)
	MAP_NATIVE(UUIScene,execGetActiveContextMenu)
	MAP_NATIVE(UUIScene,execSetActiveToolTip)
	MAP_NATIVE(UUIScene,execGetActiveToolTip)
	MAP_NATIVE(UUIScene,execGetDefaultContextMenu)
	MAP_NATIVE(UUIScene,execGetDefaultToolTip)
	MAP_NATIVE(UUIScene,execIsSceneActive)
	MAP_NATIVE(UUIScene,execGetWorldInfo)
	MAP_NATIVE(UUIScene,execSetSceneRenderMode)
	MAP_NATIVE(UUIScene,execGetSceneRenderMode)
	MAP_NATIVE(UUIScene,execGetSceneInputMode)
	MAP_NATIVE(UUIScene,execSetSceneInputMode)
	MAP_NATIVE(UUIScene,execGetScenePostProcessGroup)
	MAP_NATIVE(UUIScene,execShouldRenderParentScenes)
	MAP_NATIVE(UUIScene,execGetPreviousScene)
	MAP_NATIVE(UUIScene,execGetNextScene)
	MAP_NATIVE(UUIScene,execResolveDataStore)
	MAP_NATIVE(UUIScene,execUnbindSubscribers)
	MAP_NATIVE(UUIScene,execSaveSceneDataValues)
	MAP_NATIVE(UUIScene,execLoadSceneDataValues)
	MAP_NATIVE(UUIScene,execGetSceneDataStore)
	MAP_NATIVE(UUIScene,execFindTickableObjectIndex)
	MAP_NATIVE(UUIScene,execUnregisterTickableObject)
	MAP_NATIVE(UUIScene,execRegisterTickableObject)
	MAP_NATIVE(UUIScene,execResolveScenePositions)
	MAP_NATIVE(UUIScene,execRebuildDockingStack)
	MAP_NATIVE(UUIScene,execForceImmediateSceneUpdate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScene);

NATIVE_INFO(UUIScreenObject) GEngineUUIScreenObjectNatives[] = 
{ 
	MAP_NATIVE(UUIScreenObject,execIsAnimationPaused)
	MAP_NATIVE(UUIScreenObject,execPauseAnimations)
	MAP_NATIVE(UUIScreenObject,execIsAnimating)
	MAP_NATIVE(UUIScreenObject,execClearUIAnimationLoop)
	MAP_NATIVE(UUIScreenObject,execStopUIAnimation)
	MAP_NATIVE(UUIScreenObject,execPlayUIAnimation)
	MAP_NATIVE(UUIScreenObject,execFindAnimationSequenceIndex)
	MAP_NATIVE(UUIScreenObject,execTickAnimations)
	MAP_NATIVE(UUIScreenObject,execAnimGetCurrentPPSettings)
	MAP_NATIVE(UUIScreenObject,execAnim_SetValue)
	MAP_NATIVE(UUIScreenObject,execAnim_GetValue)
	MAP_NATIVE(UUIScreenObject,execGetWidgetPathName)
	MAP_NATIVE(UUIScreenObject,execGetAspectRatioAutoScaleFactor)
	MAP_NATIVE(UUIScreenObject,execGetInverseCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execGetCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execPixelToCanvas)
	MAP_NATIVE(UUIScreenObject,execScreenToCanvas)
	MAP_NATIVE(UUIScreenObject,execPixelToScreen)
	MAP_NATIVE(UUIScreenObject,execScreenToPixel)
	MAP_NATIVE(UUIScreenObject,execCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execDeProject)
	MAP_NATIVE(UUIScreenObject,execProject)
	MAP_NATIVE(UUIScreenObject,execGetDockedWidgets)
	MAP_NATIVE(UUIScreenObject,execResolveUIExtent)
	MAP_NATIVE(UUIScreenObject,execGetPositionVector)
	MAP_NATIVE(UUIScreenObject,execGetBounds)
	MAP_NATIVE(UUIScreenObject,execGetPosition)
	MAP_NATIVE(UUIScreenObject,execSetPosition)
	MAP_NATIVE(UUIScreenObject,execInvalidateAllPositions)
	MAP_NATIVE(UUIScreenObject,execInvalidatePosition)
	MAP_NATIVE(UUIScreenObject,execGetPlayerOwnerIndex)
	MAP_NATIVE(UUIScreenObject,execGetBestControllerId)
	MAP_NATIVE(UUIScreenObject,execGetBestPlayerIndex)
	MAP_NATIVE(UUIScreenObject,execGetSupportedPlayerCount)
	MAP_NATIVE(UUIScreenObject,execGetActivePlayerCount)
	MAP_NATIVE(UUIScreenObject,execSetInputMask)
	MAP_NATIVE(UUIScreenObject,execGetInputMask)
	MAP_NATIVE(UUIScreenObject,execAcceptsPlayerInput)
	MAP_NATIVE(UUIScreenObject,execIsRuntimeInstance)
	MAP_NATIVE(UUIScreenObject,execIsPressed)
	MAP_NATIVE(UUIScreenObject,execIsActive)
	MAP_NATIVE(UUIScreenObject,execIsFocused)
	MAP_NATIVE(UUIScreenObject,execIsDisabled)
	MAP_NATIVE(UUIScreenObject,execIsEnabled)
	MAP_NATIVE(UUIScreenObject,execOverrideLastFocusedControl)
	MAP_NATIVE(UUIScreenObject,execGetLastFocusedControl)
	MAP_NATIVE(UUIScreenObject,execGetFocusedControl)
	MAP_NATIVE(UUIScreenObject,execKillFocus)
	MAP_NATIVE(UUIScreenObject,execSetFocusToChild)
	MAP_NATIVE(UUIScreenObject,execSetFocus)
	MAP_NATIVE(UUIScreenObject,execCanPropagateFocusFor)
	MAP_NATIVE(UUIScreenObject,execCanAcceptFocus)
	MAP_NATIVE(UUIScreenObject,execIsNeverFocused)
	MAP_NATIVE(UUIScreenObject,execNavigateFocus)
	MAP_NATIVE(UUIScreenObject,execPrevControl)
	MAP_NATIVE(UUIScreenObject,execNextControl)
	MAP_NATIVE(UUIScreenObject,execFocusLastControl)
	MAP_NATIVE(UUIScreenObject,execFocusFirstControl)
	MAP_NATIVE(UUIScreenObject,execIsHoldingShift)
	MAP_NATIVE(UUIScreenObject,execIsHoldingAlt)
	MAP_NATIVE(UUIScreenObject,execIsHoldingCtrl)
	MAP_NATIVE(UUIScreenObject,execConditionalPropagateEnabledState)
	MAP_NATIVE(UUIScreenObject,execDeactivateStateByClass)
	MAP_NATIVE(UUIScreenObject,execDeactivateState)
	MAP_NATIVE(UUIScreenObject,execActivateStateByClass)
	MAP_NATIVE(UUIScreenObject,execActivateState)
	MAP_NATIVE(UUIScreenObject,execHasActiveStateOfClass)
	MAP_NATIVE(UUIScreenObject,execGetCurrentState)
	MAP_NATIVE(UUIScreenObject,execSetEnabled)
	MAP_NATIVE(UUIScreenObject,execFindEventsOfClass)
	MAP_NATIVE(UUIScreenObject,execActivateEventByClass)
	MAP_NATIVE(UUIScreenObject,execGetAspectRatio)
	MAP_NATIVE(UUIScreenObject,execGetViewportHeight)
	MAP_NATIVE(UUIScreenObject,execGetViewportWidth)
	MAP_NATIVE(UUIScreenObject,execGetViewportSize)
	MAP_NATIVE(UUIScreenObject,execGetViewportOrigin)
	MAP_NATIVE(UUIScreenObject,execGetViewportScale)
	MAP_NATIVE(UUIScreenObject,execGetViewportOffset)
	MAP_NATIVE(UUIScreenObject,execRebuildNavigationLinks)
	MAP_NATIVE(UUIScreenObject,execRequestPrimitiveReview)
	MAP_NATIVE(UUIScreenObject,execRequestSceneInputMaskUpdate)
	MAP_NATIVE(UUIScreenObject,execRequestFormattingUpdate)
	MAP_NATIVE(UUIScreenObject,execRequestSceneUpdate)
	MAP_NATIVE(UUIScreenObject,execGetDockClients)
	MAP_NATIVE(UUIScreenObject,execGetObjectCount)
	MAP_NATIVE(UUIScreenObject,execGetChildren)
	MAP_NATIVE(UUIScreenObject,execContainsChildOfClass)
	MAP_NATIVE(UUIScreenObject,execContainsChild)
	MAP_NATIVE(UUIScreenObject,execFindChildIndex)
	MAP_NATIVE(UUIScreenObject,execFindChildUsingID)
	MAP_NATIVE(UUIScreenObject,execFindChild)
	MAP_NATIVE(UUIScreenObject,execReplaceChild)
	MAP_NATIVE(UUIScreenObject,execReparentChildren)
	MAP_NATIVE(UUIScreenObject,execReparentChild)
	MAP_NATIVE(UUIScreenObject,execRemoveChildren)
	MAP_NATIVE(UUIScreenObject,execRemoveChild)
	MAP_NATIVE(UUIScreenObject,execInsertChild)
	MAP_NATIVE(UUIScreenObject,execInitialize)
	MAP_NATIVE(UUIScreenObject,execInstanceUIPrefab)
	MAP_NATIVE(UUIScreenObject,execCreateWidget)
	MAP_NATIVE(UUIScreenObject,execPlayUISound)
	MAP_NATIVE(UUIScreenObject,execGetPlayerOwner)
	MAP_NATIVE(UUIScreenObject,execInitializePlayerTracking)
	MAP_NATIVE(UUIScreenObject,execRemovePlayerData)
	MAP_NATIVE(UUIScreenObject,execCreatePlayerData)
	MAP_NATIVE(UUIScreenObject,execSetZDepth)
	MAP_NATIVE(UUIScreenObject,execGetZDepth)
	MAP_NATIVE(UUIScreenObject,execIsHidden)
	MAP_NATIVE(UUIScreenObject,execIsVisible)
	MAP_NATIVE(UUIScreenObject,execIsInitialized)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScreenObject);

NATIVE_INFO(UUIScrollbar) GEngineUUIScrollbarNatives[] = 
{ 
	MAP_NATIVE(UUIScrollbar,execDragScroll)
	MAP_NATIVE(UUIScrollbar,execDragScrollEnd)
	MAP_NATIVE(UUIScrollbar,execDragScrollBegin)
	MAP_NATIVE(UUIScrollbar,execScrollDecrement)
	MAP_NATIVE(UUIScrollbar,execScrollIncrement)
	MAP_NATIVE(UUIScrollbar,execEnableCornerPadding)
	MAP_NATIVE(UUIScrollbar,execSetNudgeSizePixels)
	MAP_NATIVE(UUIScrollbar,execSetNudgeSizePercent)
	MAP_NATIVE(UUIScrollbar,execSetMarkerPosition)
	MAP_NATIVE(UUIScrollbar,execSetMarkerSize)
	MAP_NATIVE(UUIScrollbar,execGetScrollZoneWidth)
	MAP_NATIVE(UUIScrollbar,execGetScrollZoneExtent)
	MAP_NATIVE(UUIScrollbar,execGetMarkerButtonPosition)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScrollbar);

NATIVE_INFO(UUIScrollFrame) GEngineUUIScrollFrameNatives[] = 
{ 
	MAP_NATIVE(UUIScrollFrame,execGetVisibleRegionPercentage)
	MAP_NATIVE(UUIScrollFrame,execGetClipRegion)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionSizeVector)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionPositionVector)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionSize)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionPosition)
	MAP_NATIVE(UUIScrollFrame,execSetClientRegionPositionVector)
	MAP_NATIVE(UUIScrollFrame,execSetClientRegionPosition)
	MAP_NATIVE(UUIScrollFrame,execScrollRegion)
	MAP_NATIVE(UUIScrollFrame,execReapplyFormatting)
	MAP_NATIVE(UUIScrollFrame,execRefreshScrollbars)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScrollFrame);

NATIVE_INFO(UUISkin) GEngineUUISkinNatives[] = 
{ 
	MAP_NATIVE(UUISkin,execGetStyleGroups)
	MAP_NATIVE(UUISkin,execFindStyleGroupIndex)
	MAP_NATIVE(UUISkin,execGetStyleGroupAtIndex)
	MAP_NATIVE(UUISkin,execRenameStyleGroup)
	MAP_NATIVE(UUISkin,execRemoveStyleGroupName)
	MAP_NATIVE(UUISkin,execAddStyleGroupName)
	MAP_NATIVE(UUISkin,execIsInheritedGroupName)
	MAP_NATIVE(UUISkin,execGetSkinSoundCues)
	MAP_NATIVE(UUISkin,execGetUISoundCue)
	MAP_NATIVE(UUISkin,execRemoveUISoundCue)
	MAP_NATIVE(UUISkin,execAddUISoundCue)
	MAP_NATIVE(UUISkin,execGetCursorResource)
	MAP_NATIVE(UUISkin,execGetAvailableStyles)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISkin);

NATIVE_INFO(UUISlider) GEngineUUISliderNatives[] = 
{ 
	MAP_NATIVE(UUISlider,execGetValue)
	MAP_NATIVE(UUISlider,execSetValue)
	MAP_NATIVE(UUISlider,execSaveSubscriberValue)
	MAP_NATIVE(UUISlider,execClearBoundDataStores)
	MAP_NATIVE(UUISlider,execGetBoundDataStores)
	MAP_NATIVE(UUISlider,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUISlider,execRefreshSubscriberValue)
	MAP_NATIVE(UUISlider,execGetDataStoreBinding)
	MAP_NATIVE(UUISlider,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISlider);

NATIVE_INFO(UUIStyle_Combo) GEngineUUIStyle_ComboNatives[] = 
{ 
	MAP_NATIVE(UUIStyle_Combo,execGetComboImageStyle)
	MAP_NATIVE(UUIStyle_Combo,execGetComboTextStyle)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIStyle_Combo);

NATIVE_INFO(UUITabButton) GEngineUUITabButtonNatives[] = 
{ 
	MAP_NATIVE(UUITabButton,execIsTargeted)
	MAP_NATIVE(UUITabButton,execCanActivateButton)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITabButton);

NATIVE_INFO(UUITabControl) GEngineUUITabControlNatives[] = 
{ 
	MAP_NATIVE(UUITabControl,execCreateTabPage)
	MAP_NATIVE(UUITabControl,execFindTargetedTab)
	MAP_NATIVE(UUITabControl,execGetPageAtIndex)
	MAP_NATIVE(UUITabControl,execGetPageCount)
	MAP_NATIVE(UUITabControl,execRequestLayoutUpdate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITabControl);

NATIVE_INFO(UUITabPage) GEngineUUITabPageNatives[] = 
{ 
	MAP_NATIVE(UUITabPage,execClearBoundDataStores)
	MAP_NATIVE(UUITabPage,execGetBoundDataStores)
	MAP_NATIVE(UUITabPage,execNotifyDataStoreValueUpdated)
	MAP_NATIVE(UUITabPage,execRefreshSubscriberValue)
	MAP_NATIVE(UUITabPage,execGetDataStoreBinding)
	MAP_NATIVE(UUITabPage,execSetDataStoreBinding)
	MAP_NATIVE(UUITabPage,execGetOwnerTabControl)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITabPage);

NATIVE_INFO(UUITexture) GEngineUUITextureNatives[] = 
{ 
	MAP_NATIVE(UUITexture,execHasValidStyleData)
	MAP_NATIVE(UUITexture,execSetImageStyle)
	MAP_NATIVE(UUITexture,execGetOwnerWidget)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITexture);

NATIVE_INFO(UUIToggleButton) GEngineUUIToggleButtonNatives[] = 
{ 
	MAP_NATIVE(UUIToggleButton,execSetValue)
	MAP_NATIVE(UUIToggleButton,execSetCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIToggleButton);

NATIVE_INFO(UUIToolTip) GEngineUUIToolTipNatives[] = 
{ 
	MAP_NATIVE(UUIToolTip,execUpdateToolTipPosition)
	MAP_NATIVE(UUIToolTip,execEndTracking)
	MAP_NATIVE(UUIToolTip,execBeginTracking)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIToolTip);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,ConsoleEntry,ConsolePromptLabel)
VERIFY_CLASS_OFFSET_NODIE(U,ConsoleEntry,CursorPosition)
VERIFY_CLASS_SIZE_NODIE(UConsoleEntry)
VERIFY_CLASS_OFFSET_NODIE(U,CurrentGameDataStore,ProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(U,CurrentGameDataStore,__OnAddTeamProvider__Delegate)
VERIFY_CLASS_SIZE_NODIE(UCurrentGameDataStore)
VERIFY_CLASS_SIZE_NODIE(UCurrentWeaponDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GameInfoDataProvider,GameDataSource)
VERIFY_CLASS_SIZE_NODIE(UGameInfoDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GameUISceneClient,ActiveScenes)
VERIFY_CLASS_OFFSET_NODIE(U,GameUISceneClient,AnimSequencePool)
VERIFY_CLASS_SIZE_NODIE(UGameUISceneClient)
VERIFY_CLASS_SIZE_NODIE(UInventoryDataProvider)
VERIFY_CLASS_SIZE_NODIE(UPickupDataProvider)
VERIFY_CLASS_SIZE_NODIE(UPlayerDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerOwnerDataProvider,PlayerData)
VERIFY_CLASS_SIZE_NODIE(UPlayerOwnerDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerOwnerDataStore,ProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerOwnerDataStore,PowerupList)
VERIFY_CLASS_SIZE_NODIE(UPlayerOwnerDataStore)
VERIFY_CLASS_SIZE_NODIE(UPlayerSettingsProvider)
VERIFY_CLASS_SIZE_NODIE(UPowerupDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,SceneDataStore,OwnerScene)
VERIFY_CLASS_OFFSET_NODIE(U,SceneDataStore,SceneDataProvider)
VERIFY_CLASS_SIZE_NODIE(USceneDataStore)
VERIFY_CLASS_OFFSET_NODIE(U,SessionSettingsProvider,ProviderClientClass)
VERIFY_CLASS_OFFSET_NODIE(U,SessionSettingsProvider,ProviderClient)
VERIFY_CLASS_SIZE_NODIE(USessionSettingsProvider)
VERIFY_CLASS_OFFSET_NODIE(U,TeamDataProvider,PlayerListFieldName)
VERIFY_CLASS_OFFSET_NODIE(U,TeamDataProvider,Players)
VERIFY_CLASS_SIZE_NODIE(UTeamDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIAnimation)
VERIFY_CLASS_OFFSET_NODIE(U,UIAnimationSeq,SeqName)
VERIFY_CLASS_OFFSET_NODIE(U,UIAnimationSeq,LoopMode)
VERIFY_CLASS_SIZE_NODIE(UUIAnimationSeq)
VERIFY_CLASS_OFFSET_NODIE(U,UIButton,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIButton,ClickedCue)
VERIFY_CLASS_SIZE_NODIE(UUIButton)
VERIFY_CLASS_OFFSET_NODIE(U,UICalloutButton,DefaultMarkupStringTemplate)
VERIFY_CLASS_OFFSET_NODIE(U,UICalloutButton,IconAlignment)
VERIFY_CLASS_SIZE_NODIE(UUICalloutButton)
VERIFY_CLASS_OFFSET_NODIE(U,UICalloutButtonPanel,ButtonTemplate)
VERIFY_CLASS_OFFSET_NODIE(U,UICalloutButtonPanel,CalloutButtonAliases)
VERIFY_CLASS_SIZE_NODIE(UUICalloutButtonPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UICheckbox,CheckedCue)
VERIFY_CLASS_OFFSET_NODIE(U,UICheckbox,CheckedImageComponent)
VERIFY_CLASS_SIZE_NODIE(UUICheckbox)
VERIFY_CLASS_OFFSET_NODIE(U,UIComboBox,ComboEditboxClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIComboBox,__CreateCustomComboList__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIComboBox)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_AutoAlignment,HorzAlignment)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_AutoAlignment,VertAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIComp_AutoAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ContextMenuListPresenter)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawCaption)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawComponents,FadeType)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawComponents,__OnFadeComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawComponents)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawImage,StyleResolverTag)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawImage,ImageStyle)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawString,SubscriberOwner)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawString,StringStyle)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawString)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawStringEditbox,UserText)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawStringEditbox,CaretOffset)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawStringEditbox)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawStringSlider)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListComponentBase)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListElementSorter,InitialSortColumn)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListElementSorter,__OverrideListSort__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListElementSorter)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListPresenter,ElementSchema)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListPresenter,MaxElementsPerPage)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenter)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenterBase)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenterCascade)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenterTree)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ObjectListPresenter)
VERIFY_CLASS_OFFSET_NODIE(U,UIConfigFileProvider,Sections)
VERIFY_CLASS_SIZE_NODIE(UUIConfigFileProvider)
VERIFY_CLASS_SIZE_NODIE(UUIConfigProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIConfigSectionProvider,SectionName)
VERIFY_CLASS_SIZE_NODIE(UUIConfigSectionProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIContainer,AutoAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIContainer)
VERIFY_CLASS_OFFSET_NODIE(U,UIContextMenu,InvokingWidget)
VERIFY_CLASS_OFFSET_NODIE(U,UIContextMenu,MenuItems)
VERIFY_CLASS_SIZE_NODIE(UUIContextMenu)
VERIFY_CLASS_OFFSET_NODIE(U,UICustomSkin,WidgetStyleMap)
VERIFY_CLASS_SIZE_NODIE(UUICustomSkin)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider,WriteAccessType)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider,__OnDataProviderPropertyChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_MenuItem,OptionType)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_MenuItem,IniName)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_MenuItem)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineClanMates)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineFriendMessages,Messages)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineFriendMessages,LastInviteFrom)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineFriendMessages)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineFriends,FriendsList)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineFriends,BusyText)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineFriends)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlinePlayerDataBase,Player)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayerDataBase)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayers)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettings,Profile)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettings,ProfileSettingsArrayProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettingsArray,ProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettingsArray,Values)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineProfileSettingsArray)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_PlayerAchievements,Achievements)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_PlayerAchievements)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_Settings,Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_Settings,SettingsArrayProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_SettingsArray,Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_SettingsArray,Values)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_SettingsArray)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore,Tag)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore,__OnDataStoreValueUpdated__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Color)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_DynamicResource,ProfileProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_DynamicResource,ResourceProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_DynamicResource)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Fonts)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_GameResource,ElementProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_GameResource,ListElementProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_GameResource)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_GameState,__OnRefreshDataFieldValue__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_GameState)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Gamma)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Images)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_InputAlias,InputAliases)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_InputAlias,InputAliasLookupMap)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_InputAlias)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_MenuItems,CurrentGameSettingsTag)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_MenuItems,DynamicProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_MenuItems)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSearch,SearchResultsName)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSearch,ActiveSearchIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineGameSearch)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSettings,GameSettingsCfgList)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSettings,SelectedIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineGameSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlinePlayerData,FriendsProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlinePlayerData,AchievementsProviderClass)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlinePlayerData)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineStats,StatsReadClasses)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineStats,PlayerInterface)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineStats)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_PlayerSettings,PlayerSettingsProviderClassNames)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_PlayerSettings,PlayerIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_PlayerSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_Registry,RegistryDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Registry)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Remote)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_SessionSettings,SessionSettingsProviderClassNames)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_SessionSettings,SessionSettings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_SessionSettings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_StringAliasMap,MenuInputMapArray)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_StringAliasMap,PlayerIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_StringAliasMap)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_StringBase)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_Strings,LocFileProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Strings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStorePublisher)
VERIFY_CLASS_SIZE_NODIE(UUIDataStoreSubscriber)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicDataProvider,DataClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicDataProvider,DataSource)
VERIFY_CLASS_SIZE_NODIE(UUIDynamicDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicFieldProvider,PersistentDataFields)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicFieldProvider,RuntimeCollectionData)
VERIFY_CLASS_SIZE_NODIE(UUIDynamicFieldProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIEditBox,DataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UIEditBox,__OnSubmitText__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIEditBox)
VERIFY_CLASS_SIZE_NODIE(UUIEditboxString)
VERIFY_CLASS_OFFSET_NODIE(U,UIFrameBox,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIFrameBox,BackgroundCornerSizes)
VERIFY_CLASS_SIZE_NODIE(UUIFrameBox)
VERIFY_CLASS_OFFSET_NODIE(U,UIImage,ImageDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UIImage,ImageComponent)
VERIFY_CLASS_SIZE_NODIE(UUIImage)
VERIFY_CLASS_OFFSET_NODIE(U,UILabel,DataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UILabel,LabelBackground)
VERIFY_CLASS_SIZE_NODIE(UUILabel)
VERIFY_CLASS_OFFSET_NODIE(U,UILabelButton,CaptionDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UILabelButton,StringRenderComponent)
VERIFY_CLASS_SIZE_NODIE(UUILabelButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIList,RowHeight)
VERIFY_CLASS_OFFSET_NODIE(U,UIList,__OnOverrideListElementState__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIList)
VERIFY_CLASS_SIZE_NODIE(UUIListElementCellProvider)
VERIFY_CLASS_SIZE_NODIE(UUIListElementProvider)
VERIFY_CLASS_SIZE_NODIE(UUIListString)
VERIFY_CLASS_OFFSET_NODIE(U,UIMapSummary,MapName)
VERIFY_CLASS_OFFSET_NODIE(U,UIMapSummary,Description)
VERIFY_CLASS_SIZE_NODIE(UUIMapSummary)
VERIFY_CLASS_OFFSET_NODIE(U,UIMeshWidget,Mesh)
VERIFY_CLASS_SIZE_NODIE(UUIMeshWidget)
VERIFY_CLASS_SIZE_NODIE(UUINavigationList)
VERIFY_CLASS_OFFSET_NODIE(U,UINumericEditBox,IncrementStyle)
VERIFY_CLASS_OFFSET_NODIE(U,UINumericEditBox,DecButton_Position)
VERIFY_CLASS_SIZE_NODIE(UUINumericEditBox)
VERIFY_CLASS_SIZE_NODIE(UUINumericEditBoxButton)
VERIFY_CLASS_OFFSET_NODIE(U,UINumericOptionList,RangeValue)
VERIFY_CLASS_SIZE_NODIE(UUINumericOptionList)
VERIFY_CLASS_OFFSET_NODIE(U,UIObject,WidgetID)
VERIFY_CLASS_OFFSET_NODIE(U,UIObject,__OnContextMenuItemSelected__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIObject)
VERIFY_CLASS_SIZE_NODIE(UUIObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionList,CurrentIndex)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionList,__OnIsCurrValueValid__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIOptionList)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionListBase,DecrementStyle)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionListBase,__CreateCustomIncrementButton__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIOptionListBase)
VERIFY_CLASS_SIZE_NODIE(UUIOptionListButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIPanel,BackgroundImageComponent)
VERIFY_CLASS_SIZE_NODIE(UUIPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefab,PrefabVersion)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefab,OriginalHeight)
VERIFY_CLASS_SIZE_NODIE(UUIPrefab)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefabInstance,SourcePrefab)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefabInstance,PI_ObjectMap)
VERIFY_CLASS_SIZE_NODIE(UUIPrefabInstance)
VERIFY_CLASS_SIZE_NODIE(UUIPrefabScene)
VERIFY_CLASS_OFFSET_NODIE(U,UIProgressBar,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIProgressBar,ProgressBarOrientation)
VERIFY_CLASS_SIZE_NODIE(UUIProgressBar)
VERIFY_CLASS_OFFSET_NODIE(U,UIPropertyDataProvider,ComplexPropertyTypes)
VERIFY_CLASS_OFFSET_NODIE(U,UIPropertyDataProvider,__CanSupportComplexPropertyType__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIPropertyDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIResourceCombinationProvider,StaticDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIResourceCombinationProvider,ProfileProvider)
VERIFY_CLASS_SIZE_NODIE(UUIResourceCombinationProvider)
VERIFY_CLASS_SIZE_NODIE(UUIResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UISafeRegionPanel,RegionType)
VERIFY_CLASS_OFFSET_NODIE(U,UISafeRegionPanel,RegionPercentages)
VERIFY_CLASS_SIZE_NODIE(UUISafeRegionPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UIScene,SceneTag)
VERIFY_CLASS_OFFSET_NODIE(U,UIScene,__OnQueryEndAnimation_EnableInput__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScene)
VERIFY_CLASS_OFFSET_NODIE(U,UIScreenObject,Position)
VERIFY_CLASS_OFFSET_NODIE(U,UIScreenObject,__OnUIAnim_TrackCompleted__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScreenObject)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollbar,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollbar,__OnClickedScrollZone__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScrollbar)
VERIFY_CLASS_SIZE_NODIE(UUIScrollbarButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollbarMarkerButton,__OnButtonDragged__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScrollbarMarkerButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollFrame,StaticBackgroundImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollFrame,FrameBounds)
VERIFY_CLASS_SIZE_NODIE(UUIScrollFrame)
VERIFY_CLASS_OFFSET_NODIE(U,UISettingsProvider,ProviderTag)
VERIFY_CLASS_SIZE_NODIE(UUISettingsProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UISkin,Styles)
VERIFY_CLASS_OFFSET_NODIE(U,UISkin,SoundCueMap)
VERIFY_CLASS_SIZE_NODIE(UUISkin)
VERIFY_CLASS_OFFSET_NODIE(U,UISlider,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UISlider,DecrementCue)
VERIFY_CLASS_SIZE_NODIE(UUISlider)
VERIFY_CLASS_SIZE_NODIE(UUIState_Active)
VERIFY_CLASS_SIZE_NODIE(UUIState_Focused)
VERIFY_CLASS_SIZE_NODIE(UUIState_Pressed)
VERIFY_CLASS_SIZE_NODIE(UUIState_TargetedTab)
VERIFY_CLASS_SIZE_NODIE(UUIStringRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Combo,ImageStyle)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Combo,TextStyle)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Combo)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Data,UIEditorControlClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Data,__MatchesStyleData__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Data)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Image,DefaultImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Image,AdjustmentType)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Image)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Text,StyleFont)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Text,SpacingAdjust)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Text)
VERIFY_CLASS_SIZE_NODIE(UUIStyleResolver)
VERIFY_CLASS_OFFSET_NODIE(U,UITabButton,TabPage)
VERIFY_CLASS_OFFSET_NODIE(U,UITabButton,__IsActivationAllowed__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUITabButton)
VERIFY_CLASS_OFFSET_NODIE(U,UITabControl,Pages)
VERIFY_CLASS_OFFSET_NODIE(U,UITabControl,__OnPageRemoved__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUITabControl)
VERIFY_CLASS_OFFSET_NODIE(U,UITabPage,ButtonClass)
VERIFY_CLASS_OFFSET_NODIE(U,UITabPage,PageDescription)
VERIFY_CLASS_SIZE_NODIE(UUITabPage)
VERIFY_CLASS_OFFSET_NODIE(U,UITexture,ImageStyleData)
VERIFY_CLASS_OFFSET_NODIE(U,UITexture,ImageTexture)
VERIFY_CLASS_SIZE_NODIE(UUITexture)
VERIFY_CLASS_SIZE_NODIE(UUITickableObject)
VERIFY_CLASS_OFFSET_NODIE(U,UITickableObjectProxy,__OnScriptTick__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUITickableObjectProxy)
VERIFY_CLASS_OFFSET_NODIE(U,UIToggleButton,ValueDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UIToggleButton,CheckedBackgroundImageComponent)
VERIFY_CLASS_SIZE_NODIE(UUIToggleButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIToolTip,SecondsActive)
VERIFY_CLASS_OFFSET_NODIE(U,UIToolTip,__CanShowToolTip__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIToolTip)
VERIFY_CLASS_SIZE_NODIE(UWeaponDataProvider)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
