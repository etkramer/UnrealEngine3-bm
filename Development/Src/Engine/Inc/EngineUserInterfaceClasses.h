/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#include "EngineUserInterfaceGlobalIncludes.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_USERINTERFACE_ENUMS
#define INCLUDED_ENGINE_USERINTERFACE_ENUMS 1

enum EUIPostProcessGroup
{
    UIPostProcess_None      =0,
    UIPostProcess_Background=1,
    UIPostProcess_Foreground=2,
    UIPostProcess_BackgroundAndForeground=3,
    UIPostProcess_Dynamic   =4,
    UIPostProcess_MAX       =5,
};
enum EInputPlatformType
{
    IPT_PC                  =0,
    IPT_360                 =1,
    IPT_PS3                 =2,
    IPT_MAX                 =3,
};
enum ERotationAnchor
{
    RA_Absolute             =0,
    RA_Center               =1,
    RA_PivotLeft            =2,
    RA_PivotRight           =3,
    RA_PivotTop             =4,
    RA_PivotBottom          =5,
    RA_UpperLeft            =6,
    RA_UpperRight           =7,
    RA_LowerLeft            =8,
    RA_LowerRight           =9,
    RA_MAX                  =10,
};
enum EEditBoxCharacterSet
{
    CHARSET_All             =0,
    CHARSET_NoSpecial       =1,
    CHARSET_AlphaOnly       =2,
    CHARSET_NumericOnly     =3,
    CHARSET_AlphaNumeric    =4,
    CHARSET_MAX             =5,
};
enum EUIDataProviderFieldType
{
    DATATYPE_Property       =0,
    DATATYPE_Provider       =1,
    DATATYPE_RangeProperty  =2,
    DATATYPE_NetIdProperty  =3,
    DATATYPE_Collection     =4,
    DATATYPE_ProviderCollection=5,
    DATATYPE_MAX            =6,
};
enum ESplitscreenRenderMode
{
    SPLITRENDER_Fullscreen  =0,
    SPLITRENDER_PlayerOwner =1,
    SPLITRENDER_MAX         =2,
};
enum EScreenInputMode
{
    INPUTMODE_None          =0,
    INPUTMODE_Locked        =1,
    INPUTMODE_Selective     =2,
    INPUTMODE_MatchingOnly  =3,
    INPUTMODE_ActiveOnly    =4,
    INPUTMODE_Free          =5,
    INPUTMODE_Simultaneous  =6,
    INPUTMODE_MAX           =7,
};
enum ENavigationLinkType
{
    NAVLINK_Automatic       =0,
    NAVLINK_Manual          =1,
    NAVLINK_MAX             =2,
};
enum EUIDefaultPenColor
{
    UIPEN_White             =0,
    UIPEN_Black             =1,
    UIPEN_Grey              =2,
    UIPEN_MAX               =3,
};
enum EUIAspectRatioConstraint
{
    UIASPECTRATIO_AdjustNone=0,
    UIASPECTRATIO_AdjustWidth=1,
    UIASPECTRATIO_AdjustHeight=2,
    UIASPECTRATIO_MAX       =3,
};
enum EUIWidgetFace
{
    UIFACE_Left             =0,
    UIFACE_Top              =1,
    UIFACE_Right            =2,
    UIFACE_Bottom           =3,
    UIFACE_MAX              =4,
};
enum EUIOrientation
{
    UIORIENT_Horizontal     =0,
    UIORIENT_Vertical       =1,
    UIORIENT_MAX            =2,
};
enum EColumnHeaderState
{
    COLUMNHEADER_Normal     =0,
    COLUMNHEADER_PrimarySort=1,
    COLUMNHEADER_SecondarySort=2,
    COLUMNHEADER_MAX        =3,
};
enum EUIListElementState
{
    ELEMENT_Normal          =0,
    ELEMENT_Active          =1,
    ELEMENT_Selected        =2,
    ELEMENT_UnderCursor     =3,
    ELEMENT_MAX             =4,
};
enum EUIAlignment
{
    UIALIGN_Left            =0,
    UIALIGN_Center          =1,
    UIALIGN_Right           =2,
    UIALIGN_Default         =3,
    UIALIGN_MAX             =4,
};
enum ETextAutoScaleMode
{
    UIAUTOSCALE_None        =0,
    UIAUTOSCALE_Normal      =1,
    UIAUTOSCALE_Justified   =2,
    UIAUTOSCALE_ResolutionBased=3,
    UIAUTOSCALE_MAX         =4,
};
enum ETextClipMode
{
    CLIP_None               =0,
    CLIP_Normal             =1,
    CLIP_Ellipsis           =2,
    CLIP_Wrap               =3,
    CLIP_MAX                =4,
};
enum EUIAutoSizeConstraintType
{
    UIAUTOSIZEREGION_Minimum=0,
    UIAUTOSIZEREGION_Maximum=1,
    UIAUTOSIZEREGION_MAX    =2,
};
enum EUIDockPaddingEvalType
{
    UIPADDINGEVAL_Pixels    =0,
    UIPADDINGEVAL_PercentTarget=1,
    UIPADDINGEVAL_PercentOwner=2,
    UIPADDINGEVAL_PercentScene=3,
    UIPADDINGEVAL_PercentViewport=4,
    UIPADDINGEVAL_MAX       =5,
};
enum EUIExtentEvalType
{
    UIEXTENTEVAL_Pixels     =0,
    UIEXTENTEVAL_PercentSelf=1,
    UIEXTENTEVAL_PercentOwner=2,
    UIEXTENTEVAL_PercentScene=3,
    UIEXTENTEVAL_PercentViewport=4,
    UIEXTENTEVAL_MAX        =5,
};
enum EPositionEvalType
{
    EVALPOS_None            =0,
    EVALPOS_PixelViewport   =1,
    EVALPOS_PixelScene      =2,
    EVALPOS_PixelOwner      =3,
    EVALPOS_PercentageViewport=4,
    EVALPOS_PercentageOwner =5,
    EVALPOS_PercentageScene =6,
    EVALPOS_MAX             =7,
};
enum EMaterialAdjustmentType
{
    ADJUST_None             =0,
    ADJUST_Normal           =1,
    ADJUST_Justified        =2,
    ADJUST_Bound            =3,
    ADJUST_Stretch          =4,
    ADJUST_MAX              =5,
};

#endif // !INCLUDED_ENGINE_USERINTERFACE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(ActivateState)
AUTOGENERATE_NAME(CanPlayOnline)
AUTOGENERATE_NAME(DeactivateState)
AUTOGENERATE_NAME(GetDefaultStyle)
AUTOGENERATE_NAME(GetLoginStatus)
AUTOGENERATE_NAME(GetNATType)
AUTOGENERATE_NAME(HasLinkConnection)
AUTOGENERATE_NAME(InitializeSceneClient)
AUTOGENERATE_NAME(IsLoggedIn)
AUTOGENERATE_NAME(IsStateAllowed)
AUTOGENERATE_NAME(IsWidgetClassSupported)
AUTOGENERATE_NAME(NotifyGameSessionEnded)
AUTOGENERATE_NAME(OnActivate)
AUTOGENERATE_NAME(OnDeactivate)
AUTOGENERATE_NAME(OnInitialize)
AUTOGENERATE_NAME(OnReceivedNativeInputAxis)
AUTOGENERATE_NAME(OnReceivedNativeInputChar)
AUTOGENERATE_NAME(OnReceivedNativeInputKey)
AUTOGENERATE_NAME(OutputText)
AUTOGENERATE_NAME(PlayerInput)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_USERINTERFACE_CLASSES
#define INCLUDED_ENGINE_USERINTERFACE_CLASSES 1

struct FWIDGET_ID : public FGuidImplementation
{

	FWIDGET_ID()
	: FGuidImplementation()
	{ }

	FWIDGET_ID(EEventParm)
	: FGuidImplementation(0,0,0,0)
	{}

	FWIDGET_ID( const FGuid& Other)
	: FGuidImplementation(Other.SmallGuid,0,0,0)
	{}

};

struct FSTYLE_ID : public FGuidImplementation
{

	FSTYLE_ID()
	: FGuidImplementation()
	{ }

	FSTYLE_ID(EEventParm)
	: FGuidImplementation(0,0,0,0)
	{}

	FSTYLE_ID( const FGuid& Other)
	: FGuidImplementation(Other.SmallGuid,0,0,0)
	{}

};

struct FUIRangeData
{
private:
    FLOAT CurrentValue;
public:
    FLOAT MinValue;
    FLOAT MaxValue;
private:
    FLOAT NudgeValue;
public:
    BITFIELD bIntRange:1;

	/** Constructors */
	FUIRangeData() {}
	FUIRangeData(EEventParm)
	: CurrentValue(0.f), MinValue(0.f), MaxValue(0.f), NudgeValue(0.f), bIntRange(FALSE)
	{}

	FUIRangeData( const FUIRangeData& Other )
	: CurrentValue(Other.CurrentValue)
	, MinValue(Other.MinValue), MaxValue(Other.MaxValue)
	, NudgeValue(Other.NudgeValue), bIntRange(Other.bIntRange)
	{}

	/** Comparison operators */
	UBOOL operator==( const FUIRangeData& Other ) const;
	UBOOL operator!=( const FUIRangeData& Other ) const;

	/**
	 * Returns true if any values in this struct are non-zero.
	 */
	UBOOL HasValue() const;

	/**
	 * Returns the amount that this range should be incremented/decremented when nudging.
	 */
	FLOAT GetNudgeValue() const;

	/**
	 * Sets the NudgeValue for this UIRangeData to the value specified.
	 */
	void SetNudgeValue( FLOAT NewNudgeValue )
	{
		NudgeValue = NewNudgeValue;
	}

	/**
	 * Returns the current value of this UIRange.
	 */
	FLOAT GetCurrentValue() const;

	/**
	 * Sets the value of this UIRange.
	 *
	 * @param	NewValue				the new value to assign to this UIRange.
	 * @param	bClampInvalidValues		specify TRUE to automatically clamp NewValue to a valid value for this UIRange.
	 *
	 * @return	TRUE if the value was successfully assigned.  FALSE if NewValue was outside the valid range and
	 *			bClampInvalidValues was FALSE or MinValue <= MaxValue.
	 */
	UBOOL SetCurrentValue( FLOAT NewValue, UBOOL bClampInvalidValues=TRUE );

};

struct FTextureCoordinates
{
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

	/** Constructors */
	FTextureCoordinates()
	{ }

	FTextureCoordinates(EEventParm)
	: U(0), V(0), UL(0), VL(0)
	{}

	FTextureCoordinates( FLOAT inU, FLOAT inV, FLOAT inUL, FLOAT inVL )
	: U(inU), V(inV), UL(inUL), VL(inVL)
	{ }

	/**
	 * Returns whether the values in this coordinate are zero, accounting for floating point
	 * precision errors.
	 */
	inline UBOOL IsZero() const
	{
		return	Abs(U) < DELTA && Abs(V) < DELTA
			&&	Abs(UL) < DELTA && Abs(VL) < DELTA;
	}

	/** Comparison operators */
	inline UBOOL operator==( const FTextureCoordinates& Other ) const
	{
		return ARE_FLOATS_EQUAL(U,Other.U)
			&& ARE_FLOATS_EQUAL(V,Other.V)
			&& ARE_FLOATS_EQUAL(UL,Other.UL)
			&& ARE_FLOATS_EQUAL(VL,Other.VL);
	}
	inline UBOOL operator!=( const FTextureCoordinates& Other ) const
	{
		return !ARE_FLOATS_EQUAL(U,Other.U)
			|| !ARE_FLOATS_EQUAL(V,Other.V)
			|| !ARE_FLOATS_EQUAL(UL,Other.UL)
			|| !ARE_FLOATS_EQUAL(VL,Other.VL);
	}

};

struct FUIProviderScriptFieldValue
{
    FName PropertyTag;
    BYTE PropertyType;
    FStringNoInit StringValue;
    class USurface* ImageValue;
    TArrayNoInit<INT> ArrayValue;
    struct FUIRangeData RangeValue;
    struct FUniqueNetId NetIdValue;
    struct FTextureCoordinates AtlasCoordinates;

		/** Constructors */
		FUIProviderScriptFieldValue() {}
		FUIProviderScriptFieldValue(EEventParm)
		{
			appMemzero(this, sizeof(FUIProviderScriptFieldValue));
		}

	    /** Copy constructor */
	    FUIProviderScriptFieldValue( const FUIProviderScriptFieldValue& Other )
	    : PropertyTag(Other.PropertyTag)
	    , PropertyType(Other.PropertyType)
	    , StringValue(Other.StringValue)
	    , ImageValue(Other.ImageValue)
	    , ArrayValue(Other.ArrayValue)
	    , RangeValue(Other.RangeValue)
	    , NetIdValue(Other.NetIdValue)
	    , AtlasCoordinates(Other.AtlasCoordinates)
	    {
		}

	    /**
	     * Returns true if this field value has been assigned.
	     */
	    UBOOL HasValue() const;

		/** @name Comparison operators */
		//@{
		UBOOL operator==( const struct FUIProviderScriptFieldValue& Other ) const;
		UBOOL operator!=( const struct FUIProviderScriptFieldValue& Other ) const;
		UBOOL operator==( const struct FUIProviderFieldValue& Other ) const;
		UBOOL operator!=( const struct FUIProviderFieldValue& Other ) const;
		//@}
	
};

struct FUIProviderFieldValue : public FUIProviderScriptFieldValue
{
    struct FUIStringNode* CustomStringNode;

		/** Constructor */
		FUIProviderFieldValue()
		: FUIProviderScriptFieldValue(), CustomStringNode(NULL)
		{ }
		FUIProviderFieldValue(EEventParm)
		: FUIProviderScriptFieldValue(EC_EventParm), CustomStringNode(NULL)
		{ }

		/** Copy constructor */
		FUIProviderFieldValue( const FUIProviderFieldValue& Other )
		: FUIProviderScriptFieldValue( (const FUIProviderScriptFieldValue&)Other ), CustomStringNode(Other.CustomStringNode)
		{ }

		FUIProviderFieldValue( const FUIProviderScriptFieldValue& Other )
		: FUIProviderScriptFieldValue(Other), CustomStringNode(NULL)
		{ }

		/** @name Comparison operators */
		//@{
		UBOOL operator==( const struct FUIProviderScriptFieldValue& Other ) const;
		UBOOL operator!=( const struct FUIProviderScriptFieldValue& Other ) const;
		UBOOL operator==( const struct FUIProviderFieldValue& Other ) const;
		UBOOL operator!=( const struct FUIProviderFieldValue& Other ) const;
		//@}
	
};

struct FUIStyleReference
{
    FName DefaultStyleTag;
    class UClass* RequiredStyleClass;
    struct FSTYLE_ID AssignedStyleID;
private:
    class UUIStyle* ResolvedStyle;
public:

		/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
		FUIStyleReference();
		/** Initialization constructor - zero initialize all members */
		FUIStyleReference(EEventParm);

		/**
		 * Clears the value for the resolved style.  Called whenever the resolved style is no longer valid, such as when the
		 * active skin has been changed.
		 */
		void InvalidateResolvedStyle();

		/**
		 * Returns the value of ResolvedStyle, optionally resolving the style reference from the currently active skin.
		 *
		 * @param	CurrentlyActiveSkin		if specified, will call ResolveStyleReference if the current value for ResolvedStyle is not valid
		 *									for the active skin (i.e. if ResolvedStyle is NULL or isn't contained by the active skin)
		 * @param	ResolvedStyleChanged	if specified, will be set to TRUE if the value for ResolvedStyle was changed during this call
		 *									to GetResolvedStyle()
		 *
		 * @return	a pointer to the UIStyle object that has been resolved from the style id and/or default style type for this
		 *			style reference.
		 */
		class UUIStyle* GetResolvedStyle( class UUISkin* CurrentlyActiveSkin=NULL, UBOOL* bResolvedStyleChanged=NULL );

		/**
		 * Resolves the style id or default style tag for this style reference into a UIStyle from the currently active skin, and assigns the result
		 * to ResolvedStyle
		 *
		 * @param	CurrentlyActiveSkin		the skin to use for resolving this style reference
		 *
		 * @return	TRUE if the style reference was successfully resolved
		 */
		UBOOL ResolveStyleReference( class UUISkin* CurrentlyActiveSkin );

		/**
		 * Resolves the style id or default style tag for this UIStyleReference and returns the result.
		 *
		 * @param	CurrentlyActiveSkin		the skin to use for resolving this style reference
		 *
		 * @return	a pointer to the UIStyle object resolved from the specified skin
		 */
		class UUIStyle* ResolveStyleFromSkin( class UUISkin* CurrentlyActiveSkin ) const;

		/**
		 * Determines whether the specified style is a valid style for this style reference, taking into account the RequiredStyleClass.
		 *
		 * @param	StyleToCheck	a pointer to a UIStyle with a valid StyleID.
		 * @param	bAllowNULLStyle	indicates whether a NULL value for StyleToCheck should be considered valid.
		 *
		 * @return	TRUE if the specified style is the right type for this style reference, or if StyleToCheck is NULL (it is always
		 *			valid to assign NULL styles to a style reference) and bAllowNULLStyle is TRUE.
		 */
		UBOOL IsValidStyle( class UUIStyle* StyleToCheck, UBOOL bAllowNULLStyle=TRUE ) const;

		/**
		 * Determines whether the specified style corresonds to the default style for this style reference.
		 *
		 * @param	StyleToCheck	a pointer to a UIStyle
		 *
		 * @return	TRUE if StyleToCheck is the same style that would be resolved by this style reference if it didn't have
		 *			a valid AssignedStyleId
		 */
		UBOOL IsDefaultStyle( class UUIStyle* StyleToCheck ) const;

		/**
		 * Returns the tag for the default style associated with this UIStyleReference.
		 *
		 * @param	CurrentlyActiveSkin		the skin to search for this style references' style tag in
		 * @param	bSkinContainsStyleTag	if specified, set to TRUE if CurrentlyActiveSkin contains this style reference's
		 *									DefaultStyleTag; useful for determining whether a result of e.g. "DefaultTextStyle" is
		 *									because the active skin didn't contain the style corresponding to this reference's DefaultStyleTag,
		 *									or whether this style reference's DefaultStyleTag is actually "DefaultTextStyle"
		 *
		 * @return	if DefaultStyleTag is set and a style with that tag exists in CurrentlyActiveSkin, returns that
		 *			style's tag; otherwise returns the tag for the default style corresponding to RequiredStyleClass.
		 */
		FName GetDefaultStyleTag( class UUISkin* CurrentlyActiveSkin, UBOOL* bSkinContainsStyleTag=NULL ) const;

		/**
		 * Returns the style data for the menu state specified.
		 */
		class UUIStyle_Data* GetStyleData( class UUIState* MenuState ) const;

		/**
		 * Returns the style data for the menu state specified.
		 */
		class UUIStyle_Data* GetStyleDataByClass( class UClass* MenuState ) const;

		/**
		 * Changes the style associated with this style refrerence.
		 *
		 * @param	NewStyle	the new style to assign to this style reference
		 *
		 * @return	TRUE if the style was successfully assigned to this reference.  FALSE if the specified style was invalid
		 *			or the currently assigned style matched the new style.
		 */
		UBOOL SetStyle( class UUIStyle* NewStyle );

		/**
		 * Changes the AssignedStyleID for this style reference
		 *
		 * @param	NewStyleID	the STYLE_ID for the UIStyle to link this style reference to
		 *
		 * @return	TRUE if the AssignedStyleId was changed.  FALSE if NewStyleID matched the value of AssignedStyleID.
		 */
		UBOOL SetStyleID( const struct FSTYLE_ID& NewStyleID );

	
};

struct FUIScreenValue
{
    FLOAT Value;
    BYTE ScaleType;
    BYTE Orientation;

		/**
		 * Calculates the origin and extent for the position value of a single widget face
		 *
		 * @param	OwnerWidget			the widget that owns this position
		 * @param	Face				the face to evaluate
		 * @param	Type				indicates how the base values will be used, how they should be formatted
		 * @param	BaseValue			[out] absolute pixel values for the base of this position for the specified face.  For example,
		 *								if the Face is UIFACE_Left, BaseValue will represent the X position of the OwnerWidget's container,
		 *								in absolute pixel values
		 * @param	bInternalPosition	specify TRUE to indicate that BaseValue should come from OwnerWidget; FALSE to indicate that BaseValue should come from
		 *								OwnerWidget's parent widget.
		 * @param	bIgnoreDockPadding	used to prevent recursion when evaluting docking links
		 */
		static void CalculateBaseValue( const class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType Type, FLOAT& BaseValue, FLOAT& BaseExtent, UBOOL bInternalPosition=FALSE, UBOOL bIgnoreDockPadding=FALSE );

		/**
		 * Evaluates the value stored in this UIScreenValue
		 *
		 * @param	OwnerWidget	the widget that contains this screen value
		 * @param	OutputType	determines the format of the result.
		 *						EVALPOS_None:
		 *							return value is formatted using this screen position's ScaleType for the specified face
		 *						EVALPOS_PercentageOwner:
		 *						EVALPOS_PercentageScene:
		 *						EVALPOS_PercentageViewport:
		 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *							base's actual size.  If OwnerWidget isn't specified, the size of the
		 *							entire viewport is used.
		 *						EVALPOS_PixelOwner
		 *						EVALPOS_PixelScene
		 *						EVALPOS_PixelViewport
		 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
		 * @param	bInternalPosition
		 *						specify TRUE if this UIScreenValue represents a point or distance inside of OwnerWidget, in which case any
		 *						relative scale types will use OwnerWidget as the base.  Specify FALSE if it represents a point/distance outside
		 *						OwnerWidget, in which case OwnerWidget's parent will be used as a base.
		 *
		 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
		 */
		FLOAT GetValue( const class UUIScreenObject* OwnerWidget, EPositionEvalType OutputType=EVALPOS_None, UBOOL bInternalPosition=TRUE ) const;

		/**
		 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
		 *
		 * @param	OwnerWidget		the widget that contains this screen value
		 * @param	NewValue		the new value (in pixels or percentage) to use
		 * @param	InputType		indicates the format of the input value
		 *							EVALPOS_None:
		 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
		 *							EVALPOS_PercentageOwner:
		 *							EVALPOS_PercentageScene:
		 *							EVALPOS_PercentageViewport:
		 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *								base's actual size.
		 *							EVALPOS_PixelOwner
		 *							EVALPOS_PixelScene
		 *							EVALPOS_PixelViewport
		 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
		 */
		void SetValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EPositionEvalType InputType=EVALPOS_PixelViewport );

		/**
		 * Changes the scale type for the specified face to the value specified, and converts the Value for that face into the new type.
		 *
		 * @param	OwnerWidget			the widget that contains this screen value
		 * @param	NewEvalType			the evaluation type to set for the specified face
		 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
		 */
		void ChangeScaleType( class UUIScreenObject* OwnerWidget, EPositionEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

		/**
		 * Constructors
		 */
		FUIScreenValue()
		{ }

		FUIScreenValue(EEventParm)
		{
			Value = 0.f;
			ScaleType = EVALPOS_PixelViewport;
		}

		FUIScreenValue( FLOAT inValue, EUIOrientation inOrientation )
		: Value(inValue), ScaleType(EVALPOS_None), Orientation(inOrientation)
		{ }

		FUIScreenValue( FLOAT inValue, EPositionEvalType inScaleType, EUIOrientation inOrientation )
		: Value(inValue), ScaleType(inScaleType), Orientation(inOrientation)
		{ }
	
};

struct FUIScreenValue_Extent
{
    FLOAT Value;
    BYTE ScaleType;
    BYTE Orientation;

		/**
		 * Calculates the extent to use as the base for evaluating percentage values.
		 *
		 * @param	OwnerWidget		the widget that contains this extent value
		 * @param	EvaluationType	indicates which base to use for calculating the base extent
		 * @param	BaseExtent		[out] set to the size of the region that will be used for evaluating this extent as a percentage; actual pixels
		 */
		void CalculateBaseExtent( const class UUIScreenObject* OwnerWidget, EUIExtentEvalType EvalType, FLOAT& BaseExtent ) const;

		/**
		 * Resolves the value stored in this extent according to the specified output type.
		 *
		 * @param	OwnerWidget		the widget that contains this extent value
		 * @param	OutputType	indicates the desired format for the result
		 *						UIEXTENTEVAL_Pixels:
		 *							Result should be the actual number of pixels
		 *						UIEXTENTEVAL_PercentOwner:
		 *							result should be formatted as a percentage of the widget's parent
		 *						UIEXTENTEVAL_PercentScene:
		 *							result should be formatted as a percentage of the scene
		 *						UIEXTENTEVAL_PercentViewport:
		 *							result should be formatted as a percentage of the viewport
		 *
		 * @return	the value of the auto-size region's min or max value
		 */
		FLOAT GetValue( const class UUIScreenObject* OwnerWidget, EUIExtentEvalType OutputType=UIEXTENTEVAL_Pixels ) const;

		/**
		 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
		 *
		 * @param	OwnerWidget	the widget that contains this extent value
		 * @param	NewValue	the new value (in pixels or percentage) to use
		 * @param	OutputType	specifies how NewValue should be interpreted format for the result
		 *						UIEXTENTEVAL_Pixels:
		 *							NewValue is in absolute pixels
		 *						UIEXTENTEVAL_PercentOwner:
		 *							NewValue is a percentage of the OwnerWidget
		 *						UIEXTENTEVAL_PercentScene:
		 *							NewValue is a percentage of the scene
		 *						UIEXTENTEVAL_PercentViewport:
		 *							NewValue is a percentage of the viewport
		 */
		void SetValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIExtentEvalType InputType=UIEXTENTEVAL_Pixels );

		/**
		 * Changes the scale type for this extent to the type specified, optionally converting the current Value into the new type.
		 *
		 * @param	OwnerWidget			the widget that contains this screen value
		 * @param	NewEvalType			the new evaluation type to ise
		 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
		 */
		void ChangeScaleType( class UUIScreenObject* OwnerWidget, EUIExtentEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

		/**
		 * Convert a EUIExtentEvalType into a EPositionEvalType
		 */
		static EPositionEvalType TranslateScaleType( EUIExtentEvalType EvalType )
		{
			EPositionEvalType Result = EVALPOS_PixelViewport;
			switch ( EvalType )
			{
			case UIEXTENTEVAL_PercentSelf:
			case UIEXTENTEVAL_PercentOwner:
				Result = EVALPOS_PercentageOwner;
				break;
			case UIEXTENTEVAL_PercentScene:
				Result = EVALPOS_PercentageScene;
				break;
			case UIEXTENTEVAL_PercentViewport:
				Result = EVALPOS_PercentageViewport;
				break;
			}
			return Result;
		}


		/**
		 * Constructors
		 */
		FUIScreenValue_Extent()
		{ }

		FUIScreenValue_Extent(EEventParm)
		{
			Value = 0.f;
			ScaleType = UIEXTENTEVAL_Pixels;
			Orientation = UIORIENT_Horizontal;
		}

		FUIScreenValue_Extent( FLOAT inValue, EUIOrientation inOrientation )
		: Value(inValue), ScaleType(UIEXTENTEVAL_Pixels), Orientation(inOrientation)
		{ }

		FUIScreenValue_Extent( FLOAT inValue, EUIExtentEvalType inScaleType, EUIOrientation inOrientation )
		: Value(inValue), ScaleType(inScaleType), Orientation(inOrientation)
		{ }

		/** @name Comparison operators */
		//@{
		UBOOL operator==( const FUIScreenValue_Extent& Other ) const
		{
			return	ARE_FLOATS_EQUAL(Value,Other.Value)
				&&	ScaleType	== Other.ScaleType
				&&	Orientation	== Other.Orientation;
		}
		UBOOL operator!=( const FUIScreenValue_Extent& Other ) const
		{
			return	!ARE_FLOATS_EQUAL(Value,Other.Value)
				||	ScaleType	!= Other.ScaleType
				||	Orientation	!= Other.Orientation;
		}
		//@}
	
};

struct FUIScreenValue_Position
{
    FLOAT Value[2];
    BYTE ScaleType[2];

		/**
		 * Evaluates the value stored in this UIScreenValue. It assumes that a Dimension of UIORIENT_Horizontal will correspond to the Left face and
		 * that a Dinemsion of UIORIENT_Vertical will correspond to the Right face.
		 *
		 * @param	Dimension		indicates which element of the Value array to evaluate
		 * @param	InputType		indicates the format of the input value
		 *							EVALPOS_None:
		 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
		 *							EVALPOS_PercentageOwner:
		 *							EVALPOS_PercentageScene:
		 *							EVALPOS_PercentageViewport:
		 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *								base's actual size.
		 *							EVALPOS_PixelOwner:
		 *							EVALPOS_PixelScene:
		 *							EVALPOS_PixelViewport
		 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
		 * @param	OwnerWidget		the widget that contains this screen value
		 *
		 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the dimension specified.
		 */
		FLOAT GetValue( EUIOrientation Dimension, EPositionEvalType OutputType, const class UUIScreenObject* OwnerWidget ) const;

		/**
		 * Evaluates the value stored in this UIScreenValue
		 *
		 * @param	Dimension		indicates which element of the Value array to evaluate
		 * @param	Face			indicates which face on the owner widget the element from the Value array will be relative to (if InputType is
		 *							applicable ).
		 * @param	InputType		indicates the format of the input value
		 *							EVALPOS_None:
		 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
		 *							EVALPOS_PercentageOwner:
		 *							EVALPOS_PercentageScene:
		 *							EVALPOS_PercentageViewport:
		 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *								base's actual size.
		 *							EVALPOS_PixelOwner:
		 *							EVALPOS_PixelScene:
		 *							EVALPOS_PixelViewport
		 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
		 * @param	OwnerWidget		the widget that contains this screen value
		 *
		 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the dimension specified.
		 */
		FLOAT GetValue( EUIOrientation Dimension, EUIWidgetFace Face, EPositionEvalType OutputType, const class UUIScreenObject* OwnerWidget ) const;

		/**
		 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
		 *
		 * @param	OwnerWidget		the widget that contains this screen value
		 * @param	Dimension		indicates which element of the Value array to evaluate
		 * @param	NewValue		the new value (in pixels or percentage) to use
		 * @param	InputType		indicates the format of the input value
		 *							EVALPOS_None:
		 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
		 *							EVALPOS_PercentageOwner:
		 *							EVALPOS_PercentageScene:
		 *							EVALPOS_PercentageViewport:
		 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *								base's actual size.
		 *							EVALPOS_PixelOwner
		 *							EVALPOS_PixelScene
		 *							EVALPOS_PixelViewport
		 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
		 */
		void SetValue( const class UUIScreenObject* OwnerWidget, EUIOrientation Dimension, FLOAT NewValue, EPositionEvalType InputType=EVALPOS_PixelViewport );

		/** Constructors */
		FUIScreenValue_Position()
		{
			// do not initialize any members in the default constructor
		}
		FUIScreenValue_Position(EEventParm)
		{
			Value[UIORIENT_Horizontal] = 0.f;
			Value[UIORIENT_Vertical] = 0.f;
			ScaleType[UIORIENT_Horizontal] = EVALPOS_PixelOwner;
			ScaleType[UIORIENT_Vertical] = EVALPOS_PixelOwner;
		}
		FUIScreenValue_Position( FLOAT XValue, FLOAT YValue )
		{
			Value[UIORIENT_Horizontal]	=	XValue;
			Value[UIORIENT_Vertical]	=	YValue;
			for ( INT i = 0; i < UIORIENT_MAX; i++ )
			{
				ScaleType[i] = EVALPOS_None;
			}
		}
		FUIScreenValue_Position( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType )
		{
			Value[UIORIENT_Horizontal]		=	XValue;
			Value[UIORIENT_Vertical]		=	YValue;

			ScaleType[UIORIENT_Horizontal]	=	XScaleType;
			ScaleType[UIORIENT_Vertical]	=	YScaleType;
		}

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FUIScreenValue_Position& Other ) const
		{
			return	ARE_FLOATS_EQUAL(Other.Value[UIORIENT_Horizontal],Value[UIORIENT_Horizontal])
				&&	ARE_FLOATS_EQUAL(Other.Value[UIORIENT_Vertical],Value[UIORIENT_Vertical])
				&&	Other.ScaleType[UIORIENT_Horizontal]	== ScaleType[UIORIENT_Horizontal]
				&&	Other.ScaleType[UIORIENT_Vertical]		== ScaleType[UIORIENT_Vertical];
		}
		FORCEINLINE UBOOL operator!=( const FUIScreenValue_Position& Other ) const
		{
			return	!ARE_FLOATS_EQUAL(Other.Value[UIORIENT_Horizontal],Value[UIORIENT_Horizontal])
				||	!ARE_FLOATS_EQUAL(Other.Value[UIORIENT_Vertical],Value[UIORIENT_Vertical])
				||	Other.ScaleType[UIORIENT_Horizontal]	!= ScaleType[UIORIENT_Horizontal]
				||	Other.ScaleType[UIORIENT_Vertical]		!= ScaleType[UIORIENT_Vertical];
		}
	
};

struct FUIScreenValue_Bounds
{
private:
    FLOAT Value[4];
    BYTE ScaleType[4];
    BYTE bInvalidated[4];
    BYTE AspectRatioMode;
public:

		/**
		 * Evaluates the value stored in this UIScreenValue
		 *
		 * @param	OwnerWidget	the widget that contains this screen value
		 * @param	Face		indicates which element of the Value array to evaluate
		 * @param	OutputType	determines the format of the result.
		 *						EVALPOS_None:
		 *							return value is formatted using this screen position's ScaleType for the specified face
		 *						EVALPOS_PercentageOwner:
		 *						EVALPOS_PercentageScene:
		 *						EVALPOS_PercentageViewport:
		 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *							base's actual size.  If OwnerWidget isn't specified, the size of the
		 *							entire viewport is used.
		 *						EVALPOS_PixelOwner
		 *						EVALPOS_PixelScene
		 *						EVALPOS_PixelViewport
		 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
		 * @param	bIgnoreDockPadding
		 *						used to prevent recursion when evaluting docking links
		 *
		 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
		 */
		FLOAT GetPositionValue( const class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType OutputType=EVALPOS_None, UBOOL bIgnoreDockPadding=FALSE ) const;


		/**
		 * Convert the value specified into the appropriate type for this screen value, and set that as the value for the face specified.
		 *
		 * @param	OwnerWidget		the widget that contains this screen value
		 * @param	NewValue		the new value (in pixels or percentage) to use
		 * @param	Face			indicates which element of the Value array to modify
		 * @param	InputType		indicates the format of the input value
		 *							EVALPOS_None:
		 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
		 *							EVALPOS_PercentageOwner:
		 *							EVALPOS_PercentageScene:
		 *							EVALPOS_PercentageViewport:
		 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *								base's actual size.
		 *							EVALPOS_PixelOwner
		 *							EVALPOS_PixelScene
		 *							EVALPOS_PixelViewport
		 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
		 * @param	bResolveChange	indicates whether a scene update should be requested if NewValue does not match the current value.
		 */
		void SetPositionValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIWidgetFace Face, EPositionEvalType InputType=EVALPOS_PixelOwner, UBOOL bResolveChange=TRUE );

		/**
		 * Retrieves the value of the width or height of this widget's bounds.
		 *
		 * @param	OwnerWidget	the widget that contains this screen value
		 * @param	Dimension	determines whether width or height is desired.  Specify UIORIENT_Horizontal to get the width, or UIORIENT_Vertical to get the height.
		 * @param	OutputType	determines the format of the result.
		 *						EVALPOS_None:
		 *							return value is formatted using this screen position's ScaleType for the specified face
		 *						EVALPOS_PercentageOwner:
		 *						EVALPOS_PercentageScene:
		 *						EVALPOS_PercentageViewport:
		 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *							base's actual size.  If OwnerWidget isn't specified, the size of the
		 *							entire viewport is used.
		 *						EVALPOS_PixelOwner
		 *						EVALPOS_PixelScene
		 *						EVALPOS_PixelViewport
		 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
		 * @param	bIgnoreDockPadding
		 *						used to prevent recursion when evaluting docking links
		 *
		 * @return	the value of the width/height of this UIScreenValue, in pixels or percentage.
		 */
		FLOAT GetBoundsExtent( const class UUIScreenObject* OwnerWidget, EUIOrientation Dimension, EPositionEvalType OutputType=EVALPOS_PixelOwner, UBOOL bIgnoreDockPadding=FALSE ) const;

		/**
		 * Changes the scale type for the specified face to the value specified, and converts the Value for that face into the new type.
		 *
		 * @param	Face				indicates which element of the Value array to modify
		 * @param	OwnerWidget			the widget that contains this screen value
		 * @param	NewEvalType			the evaluation type to set for the specified face
		 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
		 */
		void ChangeScaleType( class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

		/**
		 * Returns the ScaleType for the specified face.
		 *
		 * @param	Face	indicates which element of the ScaleType array to return.
		 *
		 * @return	the current value of ScaleType for the specified face.
		 */
		FORCEINLINE EPositionEvalType GetScaleType( EUIWidgetFace Face ) const
		{
			checkSlow(Face<UIFACE_MAX);
			return (EPositionEvalType)ScaleType[Face];
		}

		/**
		 * Changes the value for the specified face without performing any conversion.
		 *
		 * @param	Face			indicates which element of the Value array to modify; value must be one of the EUIWidgetFace values.
		 * @param	NewValue		the new value (in pixels or percentage) to use
		 * @param	NewScaleType	if specified, modified the ScaleType for this face as well.
		 */
		void SetRawPositionValue( BYTE Face, FLOAT NewValue, EPositionEvalType NewScaleType=EVALPOS_None );

		/**
		 * Changes the ScaleType for the specified face without performing any conversion.
		 *
		 * @param	Face			indicates which element of the Value array to modify; value must be one of the EUIWidgetFace values.
		 * @param	NewScaleType	the new scale type to use.
		 */
		void SetRawScaleType( BYTE Face, EPositionEvalType NewScaleType );

		/**
		 * Changes the AspectRatioMode for this screen value.
		 *
		 * @param	NewAspectRatioMode	the new aspect ratio mode; must be one of the EUIAspectRatioConstraint values.
		 */
		void SetAspectRatioMode( BYTE NewAspectRatioMode );

		/**
		 * Gets the current AspectRatioMode for this screen value.
		 */
		EUIAspectRatioConstraint GetAspectRatioMode() const
		{
			return (EUIAspectRatioConstraint)AspectRatioMode;
		}

		/**
		 * Toggles the bInvalidated flag for the specified face.
		 *
		 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
		 */
		FORCEINLINE void ValidatePosition( BYTE Face )
		{
			checkSlow(Face<UIFACE_MAX);
			bInvalidated[Face] = FALSE;
		}
		FORCEINLINE void InvalidatePosition( BYTE Face )
		{
			checkSlow(Face<UIFACE_MAX);
			bInvalidated[Face] = TRUE;
		}
		FORCEINLINE void InvalidateAllFaces()
		{
			bInvalidated[UIFACE_Left] = TRUE;
			bInvalidated[UIFACE_Top] = TRUE;
			bInvalidated[UIFACE_Right] = TRUE;
			bInvalidated[UIFACE_Bottom] = TRUE;
		}

		/**
		 * Returns whether the Value for the specified face has been modified since that face was last resolved.
		 *
		 * @param	OwnerWidget			the widget that contains this screen value
		 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
		 */
		UBOOL IsPositionCurrent( const class UUIObject* OwnerWidget, EUIWidgetFace Face ) const;

		/** @name Constructors */
		//@{
		FUIScreenValue_Bounds()
		{
			// do not initialize any members in the default constructor
		}
		FUIScreenValue_Bounds( EEventParm )
		{
			// zero-initialization ctor
			appMemzero(this, sizeof(FUIScreenValue_Bounds));
		}
		FUIScreenValue_Bounds( FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue )
		{
			Value[UIFACE_Left]		=	LeftValue;
			Value[UIFACE_Top]		=	RightValue;
			Value[UIFACE_Right]		=	LeftValue;
			Value[UIFACE_Bottom]	=	RightValue;

			for ( INT i = 0; i < UIFACE_MAX; i++ )
			{
				ScaleType[i] = EVALPOS_None;
				bInvalidated[i] = TRUE;
			}
			AspectRatioMode = UIASPECTRATIO_AdjustNone;
		}
		FUIScreenValue_Bounds
		(
			FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue,
			EPositionEvalType LeftScaleType, EPositionEvalType TopScaleType, EPositionEvalType RightScaleType, EPositionEvalType BottomScaleType
		)
		{
			Value[UIFACE_Left]			=	LeftValue;
			Value[UIFACE_Top]			=	RightValue;
			Value[UIFACE_Right]			=	LeftValue;
			Value[UIFACE_Bottom]		=	RightValue;
			ScaleType[UIFACE_Left]		=	LeftScaleType;
			ScaleType[UIFACE_Top]		=	TopScaleType;
			ScaleType[UIFACE_Right]		=	RightScaleType;
			ScaleType[UIFACE_Bottom]	=	BottomScaleType;
			for ( INT i = 0; i < UIFACE_MAX; i++ )
			{
				bInvalidated[i] = TRUE;
			}

			AspectRatioMode = UIASPECTRATIO_AdjustNone;
		}
		//@}

		/** @name Comparison operators */
		//@{
		UBOOL operator==( const FUIScreenValue_Bounds& Other ) const
		{
			return	AspectRatioMode == Other.AspectRatioMode
				&&	ARE_FLOATS_EQUAL(Value[UIFACE_Left],Other.Value[UIFACE_Left])
				&&	ARE_FLOATS_EQUAL(Value[UIFACE_Top],Other.Value[UIFACE_Top])
				&&	ARE_FLOATS_EQUAL(Value[UIFACE_Right],Other.Value[UIFACE_Right])
				&&	ARE_FLOATS_EQUAL(Value[UIFACE_Bottom],Other.Value[UIFACE_Bottom])
				&&	appMemcmp(ScaleType, Other.ScaleType, sizeof(ScaleType)) == 0
				&&	appMemcmp(bInvalidated, Other.bInvalidated, sizeof(bInvalidated)) == 0;
		}
		UBOOL operator!=( const FUIScreenValue_Bounds& Other ) const
		{
			return !(FUIScreenValue_Bounds::operator==(Other));
		}
		//@}
	
};

struct FUIAnchorPosition : public FUIScreenValue_Position
{
    FLOAT ZDepth;

		/** Constructors */
		FUIAnchorPosition()
		{
			// do not initialize any members in the default constructor
		}
		FUIAnchorPosition(EEventParm)
		: FUIScreenValue_Position(EC_EventParm), ZDepth(0.f)
		{ }
		FUIAnchorPosition(FLOAT XValue, FLOAT YValue)
		: FUIScreenValue_Position(XValue, YValue), ZDepth(0.f)
		{ }
		FUIAnchorPosition(FLOAT XValue, FLOAT YValue, FLOAT InZDepth)
		: FUIScreenValue_Position(XValue, YValue), ZDepth(InZDepth)
		{ }
		FUIAnchorPosition( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType )
		: FUIScreenValue_Position(XValue, YValue, XScaleType, YScaleType), ZDepth(0.f)
		{ }
		FUIAnchorPosition( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType, FLOAT InZDepth )
		: FUIScreenValue_Position(XValue, YValue, XScaleType, YScaleType), ZDepth(InZDepth)
		{ }

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FUIAnchorPosition& Other ) const
		{
			return ARE_FLOATS_EQUAL(ZDepth,Other.ZDepth)
				&& FUIScreenValue_Position::operator==((const FUIScreenValue_Position&)Other);
		}
		FORCEINLINE UBOOL operator!=( const FUIAnchorPosition& Other ) const
		{
			return !ARE_FLOATS_EQUAL(ZDepth,Other.ZDepth)
				|| FUIScreenValue_Position::operator!=((const FUIScreenValue_Position&)Other);
		}
	
};

struct FScreenPositionRange : public FUIScreenValue_Position
{

		/**
		 * Retrieves the value of the distance between the endpoints of this region
		 *
		 * @param	Dimension	indicates which element of the Value array to evaluate
		 * @param	OutputType	determines the format of the result.
		 *						EVALPOS_None:
		 *							return value is formatted using this screen position's ScaleType for the specified face
		 *						EVALPOS_PercentageOwner:	(only valid when OwnerWidget is specified)
		 *						EVALPOS_PercentageScene:	(only valid when OwnerWidget is specified)
		 *						EVALPOS_PercentageViewport:
		 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
		 *							base's actual size.  If OwnerWidget isn't specified, the size of the
		 *							entire viewport is used.
		 *						EVALPOS_PixelOwner:			(only valid when OwnerWidget is specified)
		 *						EVALPOS_PixelScene:			(only valid when OwnerWidget is specified)
		 *						EVALPOS_PixelViewport
		 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
		 * @param	OwnerWidget	the widget that contains this screen value
		 *
		 * @return	the value of the width of this UIScreenValue, in pixels or percentage.
		 */
		FLOAT GetRegionValue( EUIOrientation Dimension, EPositionEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

		/** Comparison */
		UBOOL operator ==( const FScreenPositionRange& Other ) const;
		UBOOL operator !=( const FScreenPositionRange& Other ) const;
	
};

struct FUIScreenValue_DockPadding
{
private:
    FLOAT PaddingValue[4];
    BYTE PaddingScaleType[4];
public:

		/**
		 * Calculates the size of the base region used for formatting the padding value of a single widget face
		 *
		 * @param	OwnerWidget			the widget that owns this padding
		 * @param	EvalFace			the face to evaluate
		 * @param	EvalType			indicates which type of base value is desired
		 * @param	BaseExtent			[out] the base extent for the specified face, in absolute pixel values.  BaseExtent is defined as the size of the widget associated with
		 *								the specified dock padding type and face's orientation.
		 */
		static void CalculateBaseExtent( const class UUIObject* OwnerWidget, EUIWidgetFace EvalFace, EUIDockPaddingEvalType EvalType, FLOAT& BaseExtent );

		/**
		 * Evaluates the value stored in this UIScreenValue_DockPadding
		 *
		 * @param	OwnerWidget	the widget that contains this screen value
		 * @param	Face		indicates which element of the Value array to evaluate
		 * @param	OutputType	indicates the desired format for the result
		 *						UIPADDINGEVAL_Pixels:
		 *							Result should be the actual number of pixels
		 *						UIPADDINGEVAL_PercentTarget:
		 *							result should be formatted as a percentage of the dock target
		 *						UIPADDINGEVAL_PercentOwner:
		 *							result should be formatted as a percentage of the widget's parent
		 *						UIPADDINGEVAL_PercentScene:
		 *							result should be formatted as a percentage of the scene
		 *						UIPADDINGEVAL_PercentViewport:
		 *							result should be formatted as a percentage of the viewport
		 *
		 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
		 */
		FLOAT GetPaddingValue( const class UUIObject* OwnerWidget, EUIWidgetFace Face, EUIDockPaddingEvalType OutputType=UIPADDINGEVAL_Pixels ) const;


		/**
		 * Convert the value specified into the appropriate format and assign the converted value to the Value element for the face specified.
		 *
		 * @param	OwnerWidget		the widget that contains this screen value
		 * @param	NewValue		the new value (in pixels or percentage) to use
		 * @param	Face			indicates which element of the Value array to modify
		 * @param	InputType		indicates the desired format for the result
		 *							UIPADDINGEVAL_Pixels:
		 *								NewValue is in pixels
		 *							UIPADDINGEVAL_PercentTarget:
		 *								NewValue is a percentage of the dock target extent in the corresponding orientation
		 *							UIPADDINGEVAL_PercentOwner:
		 *								NewValue is a percentage of OwnerWidget parent's extent in the corresponding orientation
		 *							UIPADDINGEVAL_PercentScene:
		 *								NewValue is a percentage of the scene
		 *							UIPADDINGEVAL_PercentViewport:
		 *								NewValue is a percentage of the viewport.
		 * @param	bResolveChange	indicates whether a scene update should be requested if NewValue does not match the current value.
		 */
		void SetPaddingValue( class UUIObject* OwnerWidget, FLOAT NewValue, EUIWidgetFace Face, EUIDockPaddingEvalType InputType=UIPADDINGEVAL_Pixels, UBOOL bResolveChange=TRUE );

		/**
		 * Changes the scale type for the specified face to the value specified, optionally converting the Value for that face into the new type.
		 *
		 * @param	OwnerWidget			the widget that contains this screen value
		 * @param	Face				indicates which element of the Value array to modify
		 * @param	NewEvalType			the evaluation type to set for the specified face
		 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
		 */
		void ChangePaddingScaleType( class UUIObject* OwnerWidget, EUIWidgetFace Face, EUIDockPaddingEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

		/**
		 * Returns the PaddingScaleType for the specified face.
		 *
		 * @param	Face	indicates which element of the ScaleType array to return.
		 *
		 * @return	the current value of ScaleType for the specified face.
		 */
		FORCEINLINE EUIDockPaddingEvalType GetPaddingScaleType( EUIWidgetFace Face ) const
		{
			checkSlow(Face<UIFACE_MAX);
			return static_cast<EUIDockPaddingEvalType>(PaddingScaleType[Face]);
		}

		/** @name Constructors */
		//@{
		FUIScreenValue_DockPadding()
		{
			// do not initialize any members in the default constructor
		}
		FUIScreenValue_DockPadding( EEventParm )
		{
			// zero-initialization ctor
			appMemzero(this, sizeof(FUIScreenValue_DockPadding));
		}
		/** Stack constructor */
		FUIScreenValue_DockPadding
		(
			FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue,
			EUIDockPaddingEvalType LeftScaleType=UIPADDINGEVAL_Pixels, EUIDockPaddingEvalType TopScaleType=UIPADDINGEVAL_Pixels,
			EUIDockPaddingEvalType RightScaleType=UIPADDINGEVAL_Pixels, EUIDockPaddingEvalType BottomScaleType=UIPADDINGEVAL_Pixels
		)
		{
			PaddingValue[UIFACE_Left]		=	LeftValue;
			PaddingValue[UIFACE_Top]		=	RightValue;
			PaddingValue[UIFACE_Right]		=	LeftValue;
			PaddingValue[UIFACE_Bottom]		=	RightValue;
			PaddingScaleType[UIFACE_Left]	=	LeftScaleType;
			PaddingScaleType[UIFACE_Top]	=	TopScaleType;
			PaddingScaleType[UIFACE_Right]	=	RightScaleType;
			PaddingScaleType[UIFACE_Bottom]	=	BottomScaleType;
		}
		//@}

		/** @name Comparison operators */
		//@{
		UBOOL operator==( const FUIScreenValue_DockPadding& Other ) const
		{
			return	ARE_FLOATS_EQUAL(PaddingValue[UIFACE_Left],Other.PaddingValue[UIFACE_Left])
				&&	ARE_FLOATS_EQUAL(PaddingValue[UIFACE_Top],Other.PaddingValue[UIFACE_Top])
				&&	ARE_FLOATS_EQUAL(PaddingValue[UIFACE_Right],Other.PaddingValue[UIFACE_Right])
				&&	ARE_FLOATS_EQUAL(PaddingValue[UIFACE_Bottom],Other.PaddingValue[UIFACE_Bottom])
				&&	appMemcmp(PaddingScaleType, Other.PaddingScaleType, sizeof(PaddingScaleType)) == 0;
		}
		UBOOL operator!=( const FUIScreenValue_DockPadding& Other ) const
		{
			return !(FUIScreenValue_DockPadding::operator==(Other));
		}
		//@}
	
};

struct FUIScreenValue_AutoSizeRegion
{
    FLOAT Value[2];
    BYTE EvalType[2];

		/** Constructors */
		FUIScreenValue_AutoSizeRegion()
		{}
		FUIScreenValue_AutoSizeRegion(EEventParm)
		{
			Value[UIAUTOSIZEREGION_Minimum] = 0.f;
			Value[UIAUTOSIZEREGION_Maximum] = 0.f;
			EvalType[UIAUTOSIZEREGION_Minimum] = UIEXTENTEVAL_Pixels;
			EvalType[UIAUTOSIZEREGION_Maximum] = UIEXTENTEVAL_Pixels;
		}

		/** Comparison operator */
		UBOOL operator==( const FUIScreenValue_AutoSizeRegion& Other ) const
		{
			return	ARE_FLOATS_EQUAL(Value[UIAUTOSIZEREGION_Minimum],Other.Value[UIAUTOSIZEREGION_Minimum])
				&&	ARE_FLOATS_EQUAL(Value[UIAUTOSIZEREGION_Maximum],Other.Value[UIAUTOSIZEREGION_Maximum])
				&&	EvalType[UIAUTOSIZEREGION_Minimum] == Other.EvalType[UIAUTOSIZEREGION_Minimum]
				&&	EvalType[UIAUTOSIZEREGION_Maximum] == Other.EvalType[UIAUTOSIZEREGION_Maximum];
		}

		/**
		 * Calculates the extent to use as the base for evaluating percentage values.
		 *
		 * @param	Orientation		indicates which orientation to use for evaluating the actual extent of the widget's parent
		 * @param	EvaluationType	indicates which base to use for calculating the base extent
		 * @param	OwnerWidget		the widget that this auto-size region is for
		 * @param	BaseExtent		[out] set to the size of the region that will be used for evaluating this auto-size region as a percentage; actual pixels
		 */
		static void CalculateBaseValue( EUIOrientation Orientation, EUIExtentEvalType EvaluationType, class UUIScreenObject* OwnerWidget, FLOAT& BaseExtent );

		/**
		 * Resolves the value stored in this AutoSizeRegion according to the specified output type.
		 *
		 * @param	ValueType	indicates whether to return the min or max value.
		 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
		 * @param	OutputType	indicates the desired format for the result
		 *						UIEXTENTEVAL_Pixels:
		 *							Result should be the actual number of pixels
		 *						UIEXTENTEVAL_PercentOwner:
		 *							result should be formatted as a percentage of the widget's parent
		 *						UIEXTENTEVAL_PercentScene:
		 *							result should be formatted as a percentage of the scene
		 *						UIEXTENTEVAL_PercentViewport:
		 *							result should be formatted as a percentage of the viewport
		 * @param	OwnerWidget	the widget that this auto-size region is for
		 *
		 * @return	the value of the auto-size region's min or max value
		 */
		FLOAT GetValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, EUIExtentEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

		/**
		 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
		 *
		 * @param	ValueType	indicates whether to set the min or max value.
		 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
		 * @param	OwnerWidget	the widget that contains this extent value
		 * @param	NewValue	the new value (in pixels or percentage) to use
		 * @param	OutputType	specifies how NewValue should be interpreted format for the result
		 *						UIEXTENTEVAL_Pixels:
		 *							NewValue is in absolute pixels
		 *						UIEXTENTEVAL_PercentOwner:
		 *							NewValue is a percentage of the OwnerWidget
		 *						UIEXTENTEVAL_PercentScene:
		 *							NewValue is a percentage of the scene
		 *						UIEXTENTEVAL_PercentViewport:
		 *							NewValue is a percentage of the viewport
		 */
		void SetValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIExtentEvalType InputType=UIEXTENTEVAL_Pixels );

		/**
		 * Changes the scale type for this extent to the type specified, optionally converting the current Value into the new type.
		 *
		 * @param	ValueType			indicates whether to set the min or max value.
		 * @param	Orientation			indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
		 * @param	OwnerWidget			the widget that contains this screen value
		 * @param	NewEvalType			the new evaluation type to ise
		 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
		 */
		void ChangeScaleType( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget, EUIExtentEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );
	
};

struct FAutoSizePadding : public FUIScreenValue_AutoSizeRegion
{

    /** Constructors */
    FAutoSizePadding() {}
    FAutoSizePadding(EEventParm)
    {
        appMemzero(this, sizeof(FAutoSizePadding));
    }
};

struct FAutoSizeData
{
    struct FUIScreenValue_AutoSizeRegion Extent;
    struct FAutoSizePadding Padding;
    BITFIELD bAutoSizeEnabled:1;

		/**
		 * Evaluates and returns the padding value stored in this AutoSizeData
		 *
		 * @param	ValueType	indicates which element of the Value array to evaluate
		 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
		 * @param	OutputType	specifies how the result should be formatted
		 *						UIEXTENTEVAL_Pixels:
		 *							NewValue is in absolute pixels
		 *						UIEXTENTEVAL_PercentOwner:
		 *							NewValue is a percentage of the OwnerWidget
		 *						UIEXTENTEVAL_PercentScene:
		 *							NewValue is a percentage of the scene
		 *						UIEXTENTEVAL_PercentViewport:
		 *							NewValue is a percentage of the viewport
		* @param	OwnerWidget		the widget that contains this screen value
		*
		* @return	the actual padding value for this AutoSizeData, in pixels or percentage, for the dimension specified.
		*/
		FLOAT GetPaddingValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, EUIExtentEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

		/**
		 * Returns the minimum allowed size for this auto-size region.
		 *
		 * @param	OutputType		indicates how the result should be formatted.
		 * @param	Orientation		indicates which axis this auto-size region is associated with on the owner widget.
		 * @param	OwnerWidget		the widget that this auto-size region is used by.
		 *
		 * @return	the minimum size allowed for this auto-size region, or 0 if this auto-size region is disabled.
		 */
		FLOAT GetMinValue( EUIExtentEvalType OutputType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget ) const;

		/**
		 * Returns the maximum allowed size for this auto-size region.
		 *
		 * @param	OutputType		indicates how the result should be formatted.
		 * @param	Orientation		indicates which axis this auto-size region is associated with on the owner widget.
		 * @param	OwnerWidget		the widget that this auto-size region is used by.
		 *
		 * @return	the maximum size allowed for this auto-size region, or 0 if there is no max size configured or this auto-size region
		 *			is not enabled.
		 */
		FLOAT GetMaxValue( EUIExtentEvalType OutputType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget ) const;
	
};

struct FUIRenderingSubregion
{
    struct FUIScreenValue_Extent ClampRegionSize;
    struct FUIScreenValue_Extent ClampRegionOffset;
    BYTE ClampRegionAlignment;
    BITFIELD bSubregionEnabled:1 GCC_BITFIELD_MAGIC;

    /** Constructors */
    FUIRenderingSubregion() {}
    FUIRenderingSubregion(EEventParm)
    {
        appMemzero(this, sizeof(FUIRenderingSubregion));
    }
};

struct FInputEventSubscription
{
    FName KeyName;
    TArray<class UUIScreenObject*> Subscribers;

		/** Constructors */
		FInputEventSubscription() {}
		FInputEventSubscription( FName InKeyName )
		: KeyName(InKeyName)
		{}
	
};

struct FDefaultEventSpecification
{
    class UUIEvent* EventTemplate;
    class UClass* EventState;

    /** Constructors */
    FDefaultEventSpecification() {}
    FDefaultEventSpecification(EEventParm)
    {
        appMemzero(this, sizeof(FDefaultEventSpecification));
    }
};

struct FInputKeyAction
{
    FName InputKeyName;
    BYTE InputKeyState;
    TArrayNoInit<struct FSeqOpOutputInputLink> TriggeredOps;
    TArrayNoInit<class USequenceOp*> ActionsToExecute;

		/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
		FInputKeyAction() {}

		/** Initialization constructor - zero initialize all members */
		FInputKeyAction(EEventParm)
		{
			appMemzero(this, sizeof(FInputKeyAction));
			InputKeyName = NAME_None;
			InputKeyState = IE_Released;
		}

		/** Copy constructor */
		FInputKeyAction( const FInputKeyAction& Other );

		/** Standard ctor */
		FInputKeyAction( FName InKeyName, EInputEvent InKeyState )
		{
			appMemzero(this, sizeof(FInputKeyAction));
			InputKeyName = InKeyName;
			InputKeyState = InKeyState;
		}

		/** Comparison operator */
		UBOOL operator==( const FInputKeyAction& Other ) const;

		/** Serialization operator */
		friend FArchive& operator<<(FArchive& Ar,FInputKeyAction& MyInputKeyAction);

		/**
		 * @return	TRUE if this input key action is linked to the sequence op.
		 */
		UBOOL IsLinkedTo( const class USequenceOp* CheckOp ) const;
	
};

struct FStateInputKeyAction : public FInputKeyAction
{
    class UClass* Scope;

		/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
		FStateInputKeyAction() {}
		/** Initialization constructor - zero initialize all members */
		FStateInputKeyAction(EEventParm) : FInputKeyAction(EC_EventParm), Scope(NULL) {}
		/** Copy constructor */
		FStateInputKeyAction( const FStateInputKeyAction& Other )
		: FInputKeyAction(Other), Scope(Other.Scope) { }
		/** Standard ctor */
		FStateInputKeyAction( FName InKeyName, EInputEvent InKeyState, UClass* InScope )
		: FInputKeyAction(InKeyName,InKeyState), Scope(InScope)
		{}
		/** Copy ctor from FInputKeyAction */
		FStateInputKeyAction( const FInputKeyAction& Other, class UClass* OwnerStateClass )
		: FInputKeyAction(Other), Scope(OwnerStateClass)
		{}

		/** Comparison operator */
		UBOOL operator==( const FStateInputKeyAction& Other ) const
		{
			return ((FInputKeyAction&)*this) == Other && Scope == Other.Scope;
		}
	
};

struct FPlayerInteractionData
{
    class UUIObject* FocusedControl;
    class UUIObject* LastFocusedControl;

		/**
		 * Changes the FocusedControl to the widget specified
		 *
		 * @param	NewFocusedControl	the widget that should become the focused control
		 */
		void SetFocusedControl( class UUIObject* NewFocusedControl );

		/**
		 * Gets the currently focused control.
		 */
		class UUIObject* GetFocusedControl() const;

		/**
		 * Changes the FocusedControl to the widget specified
		 *
		 * @param	Widget	the widget that should become the LastFocusedControl control
		 */
		void SetLastFocusedControl( class UUIObject* Widget );

		/**
		 * Gets the previously focused control.
		 */
		class UUIObject* GetLastFocusedControl() const;
	
};

struct FUIFocusPropagationData
{
    class UUIObject* FirstFocusTarget;
    class UUIObject* LastFocusTarget;
    class UUIObject* NextFocusTarget;
    class UUIObject* PrevFocusTarget;
    BITFIELD bPendingReceiveFocus:1;

		/**
		 * Returns the child widget that is configured as the first focus target for this widget.
		 */
		class UUIObject* GetFirstFocusTarget() const;

		/**
		 * Returns the child widget that is configured as the last focus target for this widget.
		 */
		class UUIObject* GetLastFocusTarget() const;

		/**
		 * Returns the sibling widget that is configured as the next focus target for tab navigation.
		 */
		class UUIObject* GetNextFocusTarget() const;

		/**
		 * Returns the sibling widget that is configured as the previous focus target for tab navigation.
		 */
		class UUIObject* GetPrevFocusTarget() const;

		/**
		 * Sets the default first focus target for this widget.
		 *
		 * @param	FocusTarget			the child of this widget that should become the first focus target for this widget
		 *
		 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
		 *			the new value was the same as the current value.
		 */
		UBOOL SetFirstFocusTarget( class UUIObject* FocusTarget );

		/**
		 * Sets the default last focus target for this widget.
		 *
		 * @param	FocusTarget			the child of this widget that should become the last focus target for this widget.
		 *
		 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
		 *			the new value was the same as the current value.
		 */
		UBOOL SetLastFocusTarget( class UUIObject* FocusTarget );

		/**
		 * Sets the next tab-nav focus target for this widget.
		 *
		 * @param	FocusTarget			a sibling of this widget that should become the next tab-nav target for this widget.
		 *
		 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
		 *			the new value was the same as the current value.
		 */
		UBOOL SetNextFocusTarget( class UUIObject* FocusTarget );

		/**
		 * Sets the previous tab-nav focus target for this widget.
		 *
		 * @param	FocusTarget			a sibling of this widget that should become the previous tab-nav target for this widget.
		 *
		 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
		 *			the new value was the same as the current value.
		 */
		UBOOL SetPrevFocusTarget( class UUIObject* FocusTarget );
	
};

struct FUINavigationData
{
    class UUIObject* NavigationTarget[4];
    class UUIObject* ForcedNavigationTarget[4];
    BYTE bNullOverride[4];

		/**
		 * Sets the actual navigation target for the specified face.
		 *
		 * @param	Face			the face to set the navigation link for
		 * @param	NewNavTarget	the widget to set as the link for the specified face
		 *
		 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
		 *			the new value was the same as the current value.
		 */
		UBOOL SetNavigationTarget( EUIWidgetFace Face, class UUIObject* NewNavTarget );
		UBOOL SetNavigationTarget( class UUIObject* LeftTarget, class UUIObject* TopTarget, class UUIObject* RightTarget, class UUIObject* BottomTarget );

		/**
		 * Sets the designer-specified navigation target for the specified face.  When navigation links for the scene are rebuilt,
		 * the designer-specified navigation target will always override any auto-calculated targets.
		 *
		 * @param	Face				the face to set the navigation link for
		 * @param	NavTarget			the widget to set as the link for the specified face
		 * @param	bIsNullOverride		if NavTarget is NULL, specify TRUE to indicate that this face's nav target should not
		 *								be automatically calculated.
		 *
		 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
		 *			the new value was the same as the current value.
		 */
		UBOOL SetForcedNavigationTarget( EUIWidgetFace Face, class UUIObject* NavTarget, UBOOL bIsNullOverride=FALSE );
		UBOOL SetForcedNavigationTarget( class UUIObject* LeftTarget, class UUIObject* TopTarget, class UUIObject* RightTarget, class UUIObject* BottomTarget );

		/**
		 * Gets the navigation target for the specified face.  If a designer-specified nav target is set for the specified face,
		 * that object is returned.
		 *
		 * @param	Face		the face to get the nav target for
		 * @param	LinkType	specifies which navigation link type to return.
		 *							NAVLINK_MAX: 		return the designer specified navigation target, if set; otherwise returns the auto-generated navigation target
		 *							NAVLINK_Automatic:	return the auto-generated navigation target, even if the designer specified nav target is set
		 *							NAVLINK_Manual:		return the designer specified nav target, even if it isn't set
		 *
		 * @return	a pointer to a widget that will be the navigation target for the specified direction, or NULL if there is
		 *			no nav target for that face.
		 */
		class UUIObject* GetNavigationTarget( EUIWidgetFace Face, ENavigationLinkType LinkType=NAVLINK_MAX ) const;

		/**
		 * Determines whether the designer has overriden all navigation targets.
		 *
		 * @return	FALSE if an override target has been specified for all faces.
		 */
		UBOOL NeedsLinkGeneration() const;
	
};

struct FUIDockingSet
{
    class UUIObject* OwnerWidget;
private:
    class UUIObject* TargetWidget[4];
    struct FUIScreenValue_DockPadding DockPadding;
    BITFIELD bLockWidthWhenDocked:1;
    BITFIELD bLockHeightWhenDocked:1;
    BYTE TargetFace[4] GCC_BITFIELD_MAGIC;
    BYTE bResolved[4];
public:
    BYTE bLinking[4];

		/**
		 * Evaluate the widget's Position into an absolute pixel value, and store that value in the corresponding
		 * member of the widget's RenderBounds array.
		 * This function assumes that UpdateDockingSet has already been called for the TargetFace of the TargetWidget.
		 * This function should only be called from ResolveScenePositions.
		 *
		 * @param	Face			the face that needs to be resolved
		 */
		void UpdateDockingSet( EUIWidgetFace Face );

		/**
		 * Used to determine whether the specified face is docked.
		 *
		 * @return	TRUE if SourceFace is docked, FALSE if it isn't.
		 */
		UBOOL IsDocked( EUIWidgetFace SourceFace, UBOOL bRequireValidTargetFace=TRUE, UBOOL bIgnoreSceneTargets=FALSE ) const
		{
			checkSlow(SourceFace<UIFACE_MAX);
			return	TargetWidget[SourceFace] != NULL
				&& (TargetWidget[SourceFace] != OwnerWidget || !bIgnoreSceneTargets)
				&& (!bRequireValidTargetFace || TargetFace[SourceFace] < UIFACE_MAX);
		}

		/**
		 * Accessor for checking the value of bResolved
		 */
		UBOOL IsResolved( BYTE FaceToCheck ) const
		{
			checkSlow(FaceToCheck<UIFACE_MAX);
			return bResolved[FaceToCheck] != 0;
		}

		/**
		 * Accessor for updating the value of bResolved
		 */
		void MarkResolved( BYTE FaceToMark, BYTE bIsResolved=1 )
		{
			checkSlow(FaceToMark<UIFACE_MAX);
			bResolved[FaceToMark] = bIsResolved;
		}

		/**
		 * Retrieves the target widget for the specified face in this docking set.
		 *
		 * @param	SourceFace		the face to retrieve the dock target for
		 *
		 * @return	a pointer to the widget that the specified face is docked to.  NULL if the face is not docked or is docked to the scene.
		 *			If return value is NULL, IsDocked() can be used to determine whether the face is docked to the scene or not.
		 */
		class UUIObject* GetDockTarget( EUIWidgetFace SourceFace ) const;

		/**
		 * Retrieves the target face for the specified source face in this docking set.
		 *
		 * @param	SourceFace		the face to retrieve the dock target face for
		 *
		 * @return	the face of the dock target that SourceFace is docked to, or UIFACE_MAX if SourceFace is not docked.
		 */
		EUIWidgetFace GetDockFace( EUIWidgetFace SourceFace ) const;

		/**
		 *	Returns the ammount of padding for the specified face.
		 */
		FLOAT GetDockPadding( EUIWidgetFace SourceFace, EUIDockPaddingEvalType OutputType=UIPADDINGEVAL_Pixels ) const;

		/**
		 * Returns the dock padding eval type for the specified face.
		 */
		EUIDockPaddingEvalType GetDockPaddingType( EUIWidgetFace SourceFace ) const;

		/**
		 * Changes the configured dock target and face for the specified face.
		 *
		 * @param	SourceFace	the face to set the value for
		 * @param	DockTarget	the widget that SourceFace should be docked to, or NULL to indicate that this face should no longer be docked.
		 * @param	DockFace	the face on the dock target that SourceFace should be docked to.
		 *
		 * @return	TRUE indicates that the dock target values for the specified face were successfully changed.
		 */
		UBOOL SetDockTarget( EUIWidgetFace SourceFace, class UUIScreenObject* DockTarget, EUIWidgetFace DockFace );

		/**
		 * Changes the dock padding value for the specified face.
		 *
		 * @param	DockFace			the face to change padding for
		 * @param	NewValue			the new value to use for padding
		 * @param	InputType			the format to use for interpreting NewValue.
		 * @param	bChangeScaleType	specify TRUE to permanently change the scale type for the specified face to InputType.
		 *
		 * @return	TRUE indicates that the dock padding values for the specified face were successfully changed.
		 */
		UBOOL SetDockPadding( EUIWidgetFace DockFace, float NewValue, EUIDockPaddingEvalType InputType=UIPADDINGEVAL_Pixels, UBOOL bChangeScaleType=FALSE );

		/**
		 * Initializes the value of this docking set's OwnerWidget and convert UIDockingSets over to the new behavior
		 * (where TargetFace == OwnerWidget if docked to the scene)
		 *
		 * @param	inOwnerWidget	the widget that contains this docking set.
		 */
		void InitializeDockingSet( UUIObject* inOwnerWidget );

		/**
		 * Returns whether this widget's width should remain constant when adjusting its position due to docking relationships.
		 */
		UBOOL IsWidthLocked() const
		{
			return bLockWidthWhenDocked;
		}

		/**
		 * Returns whether this widget's height should remain constant when adjusting its position due to docking relationships.
		 */
		UBOOL IsHeightLocked() const
		{
			return bLockHeightWhenDocked;
		}

		/**
		 * Changes whether this widget's width should remain constant when adjusting its position due to docking relationships
		 * according to the value specified.
		 */
		void LockWidth( UBOOL bShouldLockWidth=TRUE )
		{
			bLockWidthWhenDocked = bShouldLockWidth;
		}

		/**
		 * Changes whether this widget's width should remain constant when adjusting its position due to docking relationships
		 * according to the value specified.
		 */
		void LockHeight( UBOOL bShouldLockHeight=TRUE )
		{
			bLockHeightWhenDocked = bShouldLockHeight;
		}
	
};

struct FUIDockingNode
{
    class UUIObject* Widget;
    BYTE Face;

		/**
		 * Comparison operator
		 */
		UBOOL operator==( const FUIDockingNode& Other ) const
		{
			return Widget == Other.Widget && Face == Other.Face;
		}

		/**
		 * Constructors
		 */
		FUIDockingNode( UUIObject* inWidget=NULL, EUIWidgetFace inFace=UIFACE_MAX )
		: Widget(inWidget), Face(inFace)
		{ }

		FUIDockingNode( const FUIDockingNode& Other )
		: Widget(Other.Widget), Face(Other.Face)
		{ }

		/** Required in order for FUIDockingNode to be used as the key in a map */
		friend inline DWORD GetTypeHash( const FUIDockingNode& Node )
		{
			return PointerHash(Node.Widget,Node.Face);
		}
	
};

struct FUIRotation
{
    FRotator Rotation;
    FMatrix TransformMatrix;
    struct FUIAnchorPosition AnchorPosition;
    BYTE AnchorType;

		/**
		 * Sets the location of the anchor of rotation for this widget.
		 *
		 * @param	AnchorPos		New location for the anchor of rotation.
		 * @param	InputType		indicates which format the AnchorPos value is in
		 */
		void SetAnchorLocation(const class UUIScreenObject* OwnerWidget, const FVector& AnchorPos, EPositionEvalType InputType=EVALPOS_PixelViewport);
	
};

struct FUIDataStoreBinding
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    BYTE RequiredFieldType;
    FStringNoInit MarkupString;
    INT BindingIndex;
    FName DataStoreName;
    FName DataStoreField;
    class UUIDataStore* ResolvedDataStore;

		/**
		 * Registers the current subscriber with ResolvedDataStore's list of RefreshSubscriberNotifies
		 */
		void RegisterSubscriberCallback();

		/**
		 * Removes the current subscriber from ResolvedDataStore's list of RefreshSubscriberNotifies.
		 */
		void UnregisterSubscriberCallback();

		/**
		 * Determines whether the specified data field can be assigned to this data store binding.
		 *
		 * @param	DataField	the data field to verify.
		 *
		 * @return	TRUE if DataField's FieldType is compatible with the RequiredFieldType for this data binding.
		 */
		UBOOL IsValidDataField( const struct FUIDataProviderField& DataField ) const;

		/**
		 * Determines whether the specified field type is valid for this data store binding.
		 *
		 * @param	FieldType	the data field type to check
		 *
		 * @return	TRUE if FieldType is compatible with the RequiredFieldType for this data binding.
		 */
		UBOOL IsValidDataField( EUIDataProviderFieldType FieldType ) const;

		/**
		 * Resolves the value of MarkupString into a data store reference, and fills in the values for all members of this struct
		 *
		 * @param	InSubscriber	the subscriber that contains this data store binding
		 *
		 * @return	TRUE if the markup was successfully resolved.
		 */
		UBOOL ResolveMarkup( TScriptInterface<class IUIDataStoreSubscriber> InSubscriber );

		/**
		 * Retrieves the value for this data store binding from the ResolvedDataStore.
		 *
		 * @param	out_ResolvedValue	will contain the value of the data store binding.
		 *
		 * @return	TRUE if the value for this data store binding was successfully retrieved from the data store.
		 */
		UBOOL GetBindingValue( struct FUIProviderFieldValue& out_ResolvedValue ) const;

		/**
		 * Publishes the value for this data store binding to the ResolvedDataStore.
		 *
		 * @param	NewValue	contains the value that should be published to the data store
		 *
		 * @return	TRUE if the value was successfully published to the data store.
		 */
		UBOOL SetBindingValue( const struct FUIProviderScriptFieldValue& NewValue ) const;

		/**
		 * Unregisters any bound data stores and clears all references.
		 */
		UBOOL ClearDataBinding();

	    /** Constructors */
		FUIDataStoreBinding() {}
	    FUIDataStoreBinding(EEventParm)
		{
			appMemzero(this, sizeof(FUIDataStoreBinding));
		}

		/**
		 * Member access operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
		 */
		FORCEINLINE class UUIDataStore* operator->()
		{
			return ResolvedDataStore;
		}

		/**
		 * Dereference operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
		 *
		 * @return	ResolvedDataStore
		 */
		FORCEINLINE class UUIDataStore*& operator*()
		{
			return ResolvedDataStore;
		}

		/**
		 * Boolean operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
		 *
		 * @return	TRUE if ResolvedDataStore is non-NULL.
		 */
		FORCEINLINE operator UBOOL() const
		{
			return ResolvedDataStore != NULL;
		}

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FUIDataStoreBinding& Other ) const
		{
			return	Subscriber			== Other.Subscriber
				&&	RequiredFieldType	== Other.RequiredFieldType
				&&	MarkupString		== Other.MarkupString
				&&	DataStoreName		== Other.DataStoreName
				&&	DataStoreField		== Other.DataStoreField
				&&	ResolvedDataStore	== Other.ResolvedDataStore;
		}
		FORCEINLINE UBOOL operator!=( const FUIDataStoreBinding& Other ) const
		{
			return !(FUIDataStoreBinding::operator==(Other));
		}

		/* Editor serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FUIDataStoreBinding& Binding )
		{
			return Ar << (UObject*&)Binding.ResolvedDataStore << Binding.Subscriber;
		}
		friend FArchive& operator<<( FArchive& Ar, FUIDataStoreBinding* Binding )
		{
			if ( Binding != NULL )
			{
				Ar << (UObject*&)Binding->ResolvedDataStore << Binding->Subscriber;
			}
			return Ar;
		}
	
};

struct FUIStyleSubscriberReference
{
    FName SubscriberId;
    TScriptInterface<class IUIStyleResolver> Subscriber;

		/** Constructors */
		FUIStyleSubscriberReference()
		: SubscriberId(NAME_None)
		{
		}
		FUIStyleSubscriberReference(EEventParm)
		: SubscriberId(NAME_None)
		{
		}

		FUIStyleSubscriberReference( FName InSubscriberId, const class TScriptInterface<class IUIStyleResolver>& InSubscriber );

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FUIStyleSubscriberReference& Other ) const
		{
			return SubscriberId == Other.SubscriberId && Subscriber == Other.Subscriber;
		}
		FORCEINLINE UBOOL operator!=( const FUIStyleSubscriberReference& Other ) const
		{
			return SubscriberId != Other.SubscriberId || Subscriber != Other.Subscriber;
		}
	
};

struct FStyleReferenceId
{
    FName StyleReferenceTag;
    class UProperty* StyleProperty;

		/** Constructors */
		FStyleReferenceId()
		: StyleReferenceTag(NAME_None), StyleProperty(NULL)
		{}
		FStyleReferenceId( UProperty* InStyleProperty )
		: StyleReferenceTag(NAME_None), StyleProperty(InStyleProperty)
		{}
		FStyleReferenceId( const FName& InReferenceTag, class UProperty* InStyleProperty )
		: StyleReferenceTag(InReferenceTag), StyleProperty(InStyleProperty)
		{}

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FStyleReferenceId& Other ) const
		{
			return GetStyleReferenceTag() == Other.GetStyleReferenceTag() && StyleProperty == Other.StyleProperty;
		}
		FORCEINLINE UBOOL operator!=( const FStyleReferenceId& Other ) const
		{
			return GetStyleReferenceTag() != Other.GetStyleReferenceTag() || StyleProperty != Other.StyleProperty;
		}

		friend FORCEINLINE DWORD GetTypeHash( const FStyleReferenceId& RefId )
		{
			return PointerHash(RefId.StyleProperty);
		}

		/**
		 * Returns the display name for this style reference
		 */
		FString GetStyleReferenceName( UBOOL bAllowDisplayName=!GIsGame ) const;

		/**
		 * Faster version of GetStyleReferenceName which never allows meta data localized text to be used.
		 */
		FName GetStyleReferenceTag() const;
	
};

struct FUITextAttributes
{
    BITFIELD Bold:1;
    BITFIELD Italic:1;
    BITFIELD Underline:1;
    BITFIELD Shadow:1;
    BITFIELD Strikethrough:1;

		/** Comparison operator */
		UBOOL operator==( const FUITextAttributes& Other ) const
		{
			return appMemcmp(this, &Other, sizeof(FUITextAttributes)) == 0;
		}

		UBOOL operator!=( const FUITextAttributes& Other ) const
		{
			return !((*this)==Other);
		}

		/**
		 * Resets the values for all attributes to false.
		 */
		void Reset();
	
};

struct FUIImageAdjustmentData
{
    struct FUIScreenValue_Extent ProtectedRegion[2];
    BYTE AdjustmentType;
    BYTE Alignment;

		/** Comparison */
		UBOOL operator ==( const FUIImageAdjustmentData& Other ) const;
		UBOOL operator !=( const FUIImageAdjustmentData& Other ) const;
	
};

struct FUIStringCaretParameters
{
    BITFIELD bDisplayCaret:1;
    BYTE CaretType GCC_BITFIELD_MAGIC;
    FLOAT CaretWidth;
    FName CaretStyle;
    INT CaretPosition;
    class UMaterialInterface* CaretMaterial;

    /** Constructors */
    FUIStringCaretParameters() {}
    FUIStringCaretParameters(EEventParm)
    {
        appMemzero(this, sizeof(FUIStringCaretParameters));
    }
};

struct FRenderParameters
{
    FLOAT DrawX;
    FLOAT DrawY;
    FLOAT DrawXL;
    FLOAT DrawYL;
    FVector2D Scaling;
    class UFont* DrawFont;
    BYTE TextAlignment[2];
    FVector2D ImageExtent;
    struct FTextureCoordinates DrawCoords;
    FVector2D SpacingAdjust;
    FLOAT ViewportHeight;

		/** Constructors */
		FRenderParameters( FLOAT InViewportHeight=0.f )
		: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f)
		, Scaling(1.f,1.f), DrawFont(NULL), ImageExtent(0.f,0.f)
		, DrawCoords(0,0,0,0), SpacingAdjust(0.0f,0.0f), ViewportHeight(InViewportHeight)
		{
			TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
			TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
		}

		FRenderParameters( FLOAT inDrawX, FLOAT inDrawY, FLOAT inDrawXL, FLOAT inDrawYL, UFont* inFont=NULL, FLOAT InViewportHeight=0.f )
		: DrawX(inDrawX), DrawY(inDrawY), DrawXL(inDrawXL), DrawYL(inDrawYL)
		, Scaling(1.f,1.f), DrawFont(inFont), ImageExtent(0.f,0.f)
		, DrawCoords(0,0,0,0), SpacingAdjust( 0.0f, 0.0f ), ViewportHeight(InViewportHeight)
		{
			TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
			TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
		}

		FRenderParameters( UFont* inFont, FLOAT ScaleX, FLOAT ScaleY, FLOAT InViewportHeight=0.f )
		: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f)
		, Scaling(ScaleX,ScaleY), DrawFont(inFont), ImageExtent(0.f,0.f)
		, DrawCoords(0,0,0,0), SpacingAdjust( 0.0f, 0.0f ), ViewportHeight(InViewportHeight)
		{
			TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
			TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
		}
	
};

struct FTextAutoScaleValue
{
    FLOAT MinScale;
    BYTE AutoScaleMode;

		/** Constructors */
		FTextAutoScaleValue() {}
		FTextAutoScaleValue(EEventParm)
		: MinScale(0.f), AutoScaleMode(UIAUTOSCALE_None)
		{}

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FTextAutoScaleValue& Other ) const
		{
			return	ARE_FLOATS_EQUAL(MinScale,Other.MinScale)
				&&	AutoScaleMode	== Other.AutoScaleMode;
		}
		FORCEINLINE UBOOL operator!=( const FTextAutoScaleValue& Other ) const
		{
			return	!ARE_FLOATS_EQUAL(MinScale,Other.MinScale)
				||	AutoScaleMode	!= Other.AutoScaleMode;
		}
	
};

struct FUIStyleOverride
{
    FLinearColor DrawColor;
    FLOAT Opacity;
    FLOAT Padding[2];
private:
    BITFIELD bOverrideDrawColor:1;
    BITFIELD bOverrideOpacity:1;
    BITFIELD bOverridePadding:1;
public:

		/**
		 * Enables/disables customization of style data without changing the existing value.
		 *
		 * @return	TRUE if the value was changed.
		 */
		UBOOL EnableCustomDrawColor( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideDrawColor != bEnabled);
			bOverrideDrawColor=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomOpacity( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideOpacity != bEnabled);
			bOverrideOpacity=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomPadding( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverridePadding != bEnabled);
			bOverridePadding=bEnabled;
			return bResult;
		}

		UBOOL IsCustomDrawColorEnabled()	const	{ return bOverrideDrawColor; }
		UBOOL IsCustomOpacityEnabled()		const	{ return bOverrideOpacity; }
		UBOOL IsCustomPaddingEnabled()		const	{ return bOverridePadding; }

		/**
		 * Changes the draw color to the color specified and enables draw color override.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomDrawColor( const struct FLinearColor& NewDrawColor );

		/**
		 * Changes the opacity
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomOpacity( float NewOpacity );

		/**
		 * Changes the padding for the specified orientation.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomPadding( EUIOrientation Orientation, FLOAT NewPadding );

		/**
		 * Copies the value of DrawColor onto the specified value if draw color customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeDrawColor( struct FLinearColor& OriginalColor ) const;

		/**
		 * Applies the value of Opacity onto the specified value if draw color customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeOpacity( struct FLinearColor& OriginalColor ) const;

		/**
		 * Applies the value of StylePadding onto the specified value if padding customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizePadding( EUIOrientation Orientation, FLOAT& OriginalPadding ) const;
	
};

struct FUITextStyleOverride : public FUIStyleOverride
{
    class UFont* DrawFont;
    struct FUITextAttributes TextAttributes;
    BYTE TextAlignment[2];
    BYTE ClipMode;
    BYTE ClipAlignment;
    struct FTextAutoScaleValue AutoScaling;
    FLOAT DrawScale[2];
    FLOAT SpacingAdjust[2];
private:
    BITFIELD bOverrideDrawFont:1;
    BITFIELD bOverrideAttributes:1;
    BITFIELD bOverrideAlignment:1;
    BITFIELD bOverrideClipMode:1;
    BITFIELD bOverrideClipAlignment:1;
    BITFIELD bOverrideAutoScale:1;
    BITFIELD bOverrideScale:1;
    BITFIELD bOverrideSpacingAdjust:1;
public:

		UBOOL EnableCustomDrawFont( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideDrawFont != bEnabled);
			bOverrideDrawFont=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomAttributes( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideAttributes != bEnabled);
			bOverrideAttributes=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomClipMode( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideClipMode != bEnabled);
			bOverrideClipMode=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomClipAlignment( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideClipAlignment != bEnabled);
			bOverrideClipAlignment=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomAlignment( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideAlignment != bEnabled);
			bOverrideAlignment=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomAutoScaleMode( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideAutoScale != bEnabled);
			bOverrideAutoScale=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomScale( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideScale != bEnabled);
			bOverrideScale=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomSpacingAdjust( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideSpacingAdjust != bEnabled);
			bOverrideSpacingAdjust=bEnabled;
			return bResult;
		}
		UBOOL IsCustomDrawFontEnabled()		const	{ return bOverrideDrawFont; }
		UBOOL IsCustomAttributesEnabled()	const	{ return bOverrideAttributes; }
		UBOOL IsCustomClipModeEnabled()		const	{ return bOverrideClipMode; }
		UBOOL IsCustomAlignmentEnabled()	const	{ return bOverrideAlignment; }
		UBOOL IsCustomClipAlignmentEnabled()const	{ return bOverrideClipAlignment; }
		UBOOL IsCustomAutoScaleEnabled()	const	{ return bOverrideAutoScale; }
		UBOOL IsCustomScaleEnabled()		const	{ return bOverrideScale; }
		UBOOL IsCustomSpacingAdjustEnabled()	const	{ return bOverrideSpacingAdjust; }

		/**
		 * Changes the draw font to the font specified and enables font override.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomDrawFont( class UFont* NewFont );

		/**
		 * Changes the custom attributes to the value specified and enables text attribute customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomAttributes( const struct FUITextAttributes& NewAttributes );

		/**
		 * Changes the custom text clipping mode to the value specified and enables clipmode customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomClipMode( enum ETextClipMode CustomClipMode );

		/**
		 * Changes the custom text clip alignment to the value specified and enables clip alignment customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomClipAlignment( enum EUIAlignment NewClipAlignment );

		/**
		 * Changes the custom text alignment to the value specified and enables alignment customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomAlignment( enum EUIOrientation Orientation, enum EUIAlignment NewAlignment );

		/**
		 * Changes the custom text auto scale mode to the value specified and enables auto scale mode customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomAutoScaling( enum ETextAutoScaleMode NewAutoScaleMode, FLOAT NewMinScale );

		/**
		 * Changes the custom text auto scale mode to the value specified and enables auto scale mode customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomAutoScaling( const struct FTextAutoScaleValue& NewAutoScaleValue );

		/**
		 * Changes the custom text scale to the value specified and enables scale customization.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomScale( enum EUIOrientation Orientation, FLOAT NewScale );

		/**
		 * Changes the custom horizontal spacing adjustment between characters and vertical spacing between wrapped lines
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomSpacingAdjust( enum EUIOrientation Orientation, FLOAT NewSpacingAdjust );

		/**
		 * Copies the value of DrawFont onto the specified value if font customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeDrawFont( class UFont*& OriginalFont ) const;

		/**
		 * Copies the value of TextAttributes into the specified value if attribute customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeAttributes( struct FUITextAttributes& OriginalAttributes ) const;

		/**
		 * Copies the value of ClipMode into the specified value if clipmode customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeClipMode( enum ETextClipMode& OriginalClipMode ) const;

		/**
		 * Copies the value of TextAlignment for the specified orientation into the specified value if alignment customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeAlignment( enum EUIOrientation Orientation, enum EUIAlignment& OriginalAlignment ) const;

		/**
		 * Copies the value of ClipAlignment into the specified value if alignment customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeClipAlignment( enum EUIAlignment& OriginalAlignment ) const;

		/**
		 * Copies the value of AutoScaleMode into the specified value if attribute customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeAutoScaling( struct FTextAutoScaleValue& OriginalAutoScaling ) const;

		/**
		 * Copies the value of Scale into the specified value if attribute customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeScale( enum EUIOrientation Orientation, FLOAT& OriginalScale ) const;

		/**
		 * Copies the value of SpacingAdjust into the specified value if attribute customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeSpacingAdjust( enum EUIOrientation Orientation, FLOAT& OriginalSpacingAdjust ) const;
	
};

struct FUIImageStyleOverride : public FUIStyleOverride
{
    struct FTextureCoordinates Coordinates;
    struct FUIImageAdjustmentData Formatting[2];
private:
    BITFIELD bOverrideCoordinates:1;
    BITFIELD bOverrideFormatting:1;
public:

		UBOOL EnableCustomCoordinates( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideCoordinates != bEnabled);
			bOverrideCoordinates=bEnabled;
			return bResult;
		}
		UBOOL EnableCustomFormatting( UBOOL bEnabled=TRUE )
		{
			UBOOL bResult = (bOverrideFormatting != bEnabled);
			bOverrideFormatting=bEnabled;
			return bResult;
		}
		UBOOL IsCustomCoordinatesEnabled()	const	{ return bOverrideCoordinates; }
		UBOOL IsCustomFormattingEnabled()	const	{ return bOverrideFormatting; }

		/**
		 * Changes the draw coordinates to the coordinates specified and enables coordinate override.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomCoordinates( const struct FTextureCoordinates& NewCoordinates );

		/**
		 * Changes the image adjustment data to the values specified and enables image adjustment data override.
		 *
		 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
		 *			otherwise couldn't be applied.
		 */
		UBOOL SetCustomFormatting( enum EUIOrientation Orientation, const struct FUIImageAdjustmentData& NewAdjustmentData );

		/**
		 * Copies the value of Coordinates onto the specified value if coordinates customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeCoordinates( struct FTextureCoordinates& OriginalCoordinates ) const;

		/**
		 * Copies the value of Formatting for the specified orientation onto the specified value if formatting customization is enabled.
		 *
		 * @return	TRUE if the input value was modified.
		 */
		UBOOL CustomizeFormatting( enum EUIOrientation Orientation, struct FUIImageAdjustmentData& OriginalFormatting ) const;
	
};

struct FUICombinedStyleData
{
    FLinearColor TextColor;
    FLinearColor ImageColor;
    FLOAT TextPadding[2];
    FLOAT ImagePadding[2];
    class UFont* DrawFont;
    class USurface* FallbackImage;
    struct FTextureCoordinates AtlasCoords;
    struct FUITextAttributes TextAttributes;
    BYTE TextAlignment[2];
    BYTE TextClipMode;
    BYTE TextClipAlignment;
    struct FUIImageAdjustmentData AdjustmentType[2];
    struct FTextAutoScaleValue TextAutoScaling;
    FVector2D TextScale;
    FVector2D TextSpacingAdjust;
private:
    BITFIELD bInitialized:1;
public:

		/** Serializer for GC */
	    friend FArchive& operator<<( FArchive& Ar, struct FUICombinedStyleData& Container)
	    {
	        Ar << (UObject*&)Container.DrawFont << (UObject*&)Container.FallbackImage;
	        return Ar;
	    }

		/** Default Constructor */
		FUICombinedStyleData();

		/** Copy constructor */
		FUICombinedStyleData( const struct FUICombinedStyleData& Other );

		/**
		 * Standard constructor
		 *
		 * @param	SourceStyle		the style to use for initializing this StyleDataContainer.
		 */
		FUICombinedStyleData( class UUIStyle_Data* SourceStyle );

		/** Comparison operators */
		UBOOL operator==( const struct FUICombinedStyleData& Other ) const;
		UBOOL operator!=(const struct FUICombinedStyleData& Other ) const;

		/**
		 * Initializes the values of this UICombinedStyleData based on the values of the UIStyle_Data specified.
		 *
		 * @param	SourceStyle			the style to copy values from
		 * @param	bClearUnusedData	controls whether style data that isn't found in SourceStyle should be zero'd; for example
		 *								if SourceStyle is a text style, the image style data in this struct will be cleared if
		 *								bClearUnusedData is TRUE, or left alone if FALSE
		 */
		void InitializeStyleDataContainer( class UUIStyle_Data* SourceStyle, UBOOL bClearUnusedData=TRUE );

		/**
		 * Determines if this style data container has been initialized.
		 *
		 * @return	TRUE if either DrawFont or FallbackImage is set.
		 */
		UBOOL IsInitialized() const { return bInitialized; }
	
};

struct FUIStringNodeModifier
{
    struct FModifierData
    {
        class UUIStyle_Data* Style;
        TArray<class UFont*> InlineFontStack;

        /** Constructors */
        FModifierData()
        : Style(NULL)
        {}
        FModifierData(EEventParm)
        {
            appMemzero(this, sizeof(FModifierData));
        }
    };

private:
    struct FUICombinedStyleData CustomStyleData;
    struct FUICombinedStyleData BaseStyleData;
    TArray<struct FModifierData> ModifierStack;
    class UUIState* CurrentMenuState;
public:

		/**
		 * Constructor
		 *
		 * @param	SourceStyle		the style to use for initializing the CustomStyleData member;  normally the UIString's DefaultStringStyle
		 * @param	MenuState		the current menu state of the widget that owns the UIString.
		 */
		FUIStringNodeModifier( class UUIStyle_Data* SourceStyle, class UUIState* MenuState );
		FUIStringNodeModifier( const struct FUICombinedStyleData& SourceStyleData, class UUIState* MenuState );

		/** Copy constructor */
		FUIStringNodeModifier( const struct FUIStringNodeModifier& Other );

		/**
		 * Adds the specified font to the InlineFontStack of the current ModifierData, then updates the DrawFont of CustomStyleData to point to the new font
		 *
		 * @param	NewFont	the font to use when creating new string nodes
		 *
		 * @return	TRUE if the specified font was successfully added to the list.
		 */
		UBOOL AddFont( class UFont* NewFont );

		/**
		 * Removes a font from the InlineFontStack of the current ModifierData.  If the font that was removed was the style data container's
		 * current DrawFont, updates CustomStyleData's font as well.
		 *
		 * @param	FontToRemove	if specified, the font to remove.  If NULL, removes the font at the top of the stack.
		 *
		 * @return	TRUE if the font was successfully removed from the InlineFontStack.  FALSE if the font wasn't part of the InlineFontStack
		 */
		UBOOL RemoveFont( class UFont* FontToRemove=NULL );

		/**
		 * Adds a new element to the ModifierStack using the specified style, then reinitializes the CustomStyleData with the values from this style.
		 *
		 * @param	NewStyle	the style to add to the stack
		 *
		 * @return	TRUE if the specified style was successfully added to the list.
		 */
		UBOOL AddStyle( class UUIStyle_Data* NewStyle );

		/**
		 * Removes the element containing StyleToRemove from ModifierStack.  If the style that was removed was style at the top of the StyleStack,
		 * reinitializes CustomStyleData with the style data from the previous style in the stack.
		 *
		 * @param	StyleToRemove	if specified, the style to remove.  If NULL, removes the style at the top of the stack.
		 *
		 * @return	TRUE if the style was successfully removed from the ModifierStack.  FALSE if the style wasn't part of the ModifierStack or it
		 *			was the last node in the ModifierStack (which cannot be removed).
		 */
		UBOOL RemoveStyle( class UUIStyle_Data* StyleToRemove=NULL );

		/**
		 * Returns the location of the ModifierData that contains the specified style.
		 *
		 * @param	SearchStyle	the style to search for
		 *
		 * @return	an index into the ModifierStack array for the ModifierData that contains the specified style, or INDEX_NONE
		 *			if there are no elements referencing that style.
		 */
		INT FindModifierIndex( class UUIStyle_Data* SearchStyle );

		/**
		 * Returns the style data contained by this string customizer
		 */
		const struct FUICombinedStyleData& GetCustomStyleData() const;

		/**
		 * Returns the configured menu state.
		 */
		class UUIState* GetMenuState() { return CurrentMenuState; }

		/**
		 * Sets the Custom Text Color to use
		 *
		 * @param	CustomTextColor		The linear color to use
		 */
		void SetCustomTextColor(FLinearColor CustomTextColor);

		/**
		 * Resets the current text color to the active style's draw color.
		 */
		void ClearCustomTextColor();

		/**
		 * returns the current text color
		 */
		FLinearColor GetCustomTextColor();


	
};

struct FUIStringNode
{
    class UUIDataStore* NodeDataStore;
    FUIStringNode* ParentNode;
    FString SourceText;
    FVector2D Extent;
    FVector2D Scaling;
    BITFIELD bForceWrap:1;

		/** Constructor */
		FUIStringNode( const TCHAR* inSourceText )
		: NodeDataStore(NULL), ParentNode(NULL)
		, SourceText(inSourceText), Extent(0.f,0.f)
		, Scaling(1.f,1.f), bForceWrap(FALSE)
		{}

		/** Destructor */
		virtual ~FUIStringNode() {}

		/**
		 * Initializes this node's style
		 */
		virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle )=0;

		/**
		 * Initializes this node's style.
		 */
		virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData )=0;

		/**
		 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
		 *
		 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
		 *									scale the image correctly.
		 * @param	ViewportHeight			the height of the viewport that this string node will render to; used by the string
		 *									rendering functions to support multifonts
		 */
		virtual void CalculateExtent( FLOAT DefaultLineHeight, FLOAT ViewportHeight )=0;

		/**
		 * Returns the value of this UIStringNode
		 *
		 * @param	bProcessedValue		indicates whether the raw or processed version of the value is desired
		 *								The raw value will contain any markup; the processed string will be text only.
		 *								Any image tokens are converted to their text counterpart.
		 *
		 * @return	the value of this UIStringNode, or NULL if this node has no value
		 */
		virtual const TCHAR* GetValue( UBOOL bProcessedValue ) const;

		/**
		 * Renders this UIStringNode using the parameters specified.
		 *
		 * @param	Canvas		the canvas to use for rendering this node
		 * @param	Parameters	the bounds for the region that this node should render to
		 *						the Scaling value of Parameters will be applied against the Scaling
		 *						value for this node.  The DrawXL/YL of the Parameters are used to
		 *						determine whether this node has enough room to render itself completely.
		 */
		virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters) {};

		// UObject interface.
		/**
		 * Callback used to allow object register its direct object references that are not already covered by
		 * the token stream.
		 *
		 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
		 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
		 */
		virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects ) {};

		/** Serializers */
		friend FArchive& operator<<( FArchive& Ar, FUIStringNode& StringNode);
		virtual void Serialize( FArchive& Ar ) {};

		/**
		 * Poor man's RTTI
		 */
		virtual UBOOL IsTextNode() const=0;
		virtual UBOOL IsImageNode() const=0;
		virtual UBOOL IsNestParent() const { return FALSE; }
		virtual UBOOL IsFormattingParent() const { return FALSE; }

		/**
		 * Determines whether this node was created to contain additional text as a result of wrapping, clipping, or nested markup resolution.
		 *
		 * @param	SearchParent	if specified, will iterate up the ParentNode chain to determine whether this string node is a direct or indirect
		 *							slave of the specified parent node.
		 */
		UBOOL IsSlaveNode( struct FUIStringNode* SearchParent=NULL ) const;
	
};

struct FUIStringNode_Text : public FUIStringNode
{
    FString RenderedText;
protected:
    struct FUICombinedStyleData NodeStyleParameters;
public:

		FUIStringNode_Text( const TCHAR* inSourceText )
		: FUIStringNode(inSourceText)
		{}

		/** Conversion constructor - copies the data from a formatting parent to a text node */
		FUIStringNode_Text( const struct FUIStringNode_FormattedNodeParent& SourceNode );

		/**
		 * Initializes this node's style data
		 */
		virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle );

		/**
		 * Initializes this node's style.
		 */
		virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData );

		/**
		 * Return the style data for this node.
		 */
		struct FUICombinedStyleData& GetNodeStyleData();

		/**
		 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
		 *
		 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
		 *									scale the image correctly.
		 * @param	ViewportHeight			the height of the viewport that this string node will render to; used by the string
		 *									rendering functions to support multifonts
		 */
		virtual void CalculateExtent( FLOAT DefaultLineHeight, FLOAT ViewportHeight );

		/**
		 * Assigns the RenderedText to the value specified, and recalculates the extent for this node.
		 */
		void SetRenderText( const TCHAR* NewRenderText );

		/**
		 * Returns the value of this UIStringNode
		 *
		 * @param	bProcessedValue		indicates whether the raw or processed version of the value is desired
		 *								The raw value will contain any markup; the processed string will be text only.
		 *								Any image tokens are converted to their text counterpart.
		 *
		 * @return	the value of this UIStringNode, or NULL if this node has no value
		 */
		virtual const TCHAR* GetValue( UBOOL bProcessedValue ) const;

		/**
		 * Renders this UIStringNode using the parameters specified.
		 *
		 * @param	Canvas		the canvas to use for rendering this node
		 * @param	Parameters	the bounds for the region that this node should render to
		 *						the Scaling value of Parameters will be applied against the Scaling
		 *						value for this node.  The DrawXL/YL of the Parameters are used to
		 *						determine whether this node has enough room to render itself completely.
		 */
		virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters);

		/**
		 * Determines whether this node contains only modification markup.
		 */
		UBOOL IsModifierNode() const;

		// UObject interface
		/**
		 * Callback used to allow object register its direct object references that are not already covered by
		 * the token stream.
		 *
		 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
		 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
		 */
		virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects );

		/**
		 * Serializer
		 */
		virtual void Serialize( FArchive& Ar )
		{
			Ar << RenderedText << NodeStyleParameters;
		}

		/**
		 * Poor man's RTTI
		 */
		virtual UBOOL IsTextNode() const { return TRUE; }
		virtual UBOOL IsImageNode() const { return FALSE; }
	
};

struct FUIStringNode_Image : public FUIStringNode
{
    FVector2D ForcedExtent;
    struct FTextureCoordinates TexCoords;
    class UUITexture* RenderedImage;

		FUIStringNode_Image( const TCHAR* inSourceText )
		: FUIStringNode(inSourceText), ForcedExtent(0.f,0.f), TexCoords(EC_EventParm), RenderedImage(NULL)
		{}

		/**
		 * Initializes this node's style
		 */
		virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle );

		/**
		 * Initializes this node's style.
		 */
		virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData );

		/**
		 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
		 *
		 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
		 *									scale the image correctly.
		 * @param	ViewportHeight			the height of the viewport that this string node will render to; used by the string
		 *									rendering functions to support multifonts
		 */
		virtual void CalculateExtent( FLOAT DefaultLineHeight, FLOAT ViewportHeight );

		/**
		 * Renders this UIStringNode using the parameters specified.
		 *
		 * @param	Canvas		the canvas to use for rendering this node
		 * @param	Parameters	the bounds for the region that this node should render to
		 *						the Scaling value of Parameters will be applied against the Scaling
		 *						value for this node.  The DrawXL/YL of the Parameters are used to
		 *						determine whether this node has enough room to render itself completely.
		 */
		virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters);

		// UObject interface
		/**
		 * Callback used to allow object register its direct object references that are not already covered by
		 * the token stream.
		 *
		 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
		 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
		 */
		virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects );

		/**
		 * Serializer
		 */
		virtual void Serialize( FArchive& Ar )
		{
			Ar << (UObject*&)RenderedImage;
		}

		/**
		 * Poor man's RTTI
		 */
		virtual UBOOL IsTextNode() const { return FALSE; }
		virtual UBOOL IsImageNode() const { return TRUE; }
	
};

struct FUIStringNode_NestedMarkupParent : public FUIStringNode
{

		/* === UIStringNode_NestedMarkupParent interface === */
		FUIStringNode_NestedMarkupParent( const TCHAR* inSourceText )
		: FUIStringNode(inSourceText)
		{}


		/** === UIStringNode interface === */

		/**
		 * Initializes this node's style
		 */
		virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle ) {};

		/**
		 * Initializes this node's style.
		 */
		virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData ) {};

		/**
		 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
		 *
		 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
		 *									scale the image correctly.
		 * @param	ViewportHeight			the height of the viewport that this string node will render to; used by the string
		 *									rendering functions to support multifonts
		 */
		virtual void CalculateExtent( FLOAT DefaultLineHeight, FLOAT ViewportHeight );

		virtual UBOOL IsTextNode() const { return FALSE; }
		virtual UBOOL IsImageNode() const { return FALSE; }
		virtual UBOOL IsNestParent() const { return TRUE; }
	
};

struct FUIStringNode_FormattedNodeParent : public FUIStringNode_Text
{

		/** constructor */
		FUIStringNode_FormattedNodeParent( struct FUIStringNode_Text& SourceNode );

		/**
		 * UIString_WrappedNodeParent is never rendered, so the extent for this node type is always 0.
		 */
		virtual void CalculateExtent( FLOAT Unused, FLOAT Unused2 ) { Extent.X = Extent.Y = 0.f; }

		/**
		 * UIString_WrappedNodeParent is never rendered.
		 */
		virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters) {}

		virtual UBOOL IsFormattingParent() const { return TRUE; }
	
};

struct FWrappedStringElement
{
    FString Value;
    FVector2D LineExtent;

		/** Constructor */
		FWrappedStringElement( const TCHAR* InValue, FLOAT Width, FLOAT Height )
		: Value(InValue), LineExtent(Width,Height)
		{}
	
};

struct FUIMouseCursor
{
    FName CursorStyle;
    class UUITexture* Cursor;
    friend FArchive& operator<<(FArchive& Ar,FUIMouseCursor& MyUIMouseCursor)
    {
        return Ar << MyUIMouseCursor.CursorStyle << (UObject*&)MyUIMouseCursor.Cursor;
    }

    /** Constructors */
    FUIMouseCursor() {}
    FUIMouseCursor(EEventParm)
    {
        appMemzero(this, sizeof(FUIMouseCursor));
    }
};

struct FInputEventParameters
{
    INT PlayerIndex;
    INT ControllerId;
    FName InputKeyName;
    BYTE EventType;
    FLOAT InputDelta;
    FLOAT DeltaTime;
    BITFIELD bAltPressed:1;
    BITFIELD bCtrlPressed:1;
    BITFIELD bShiftPressed:1;

		/** Default constructor */
		FInputEventParameters();

		/** Input Key Event constructor */
		FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

		/** Input Axis Event constructor */
		FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );
	
};

struct FSubscribedInputEventParameters : public FInputEventParameters
{
    FName InputAliasName;

		/** Default constructor */
		FSubscribedInputEventParameters();

		/** Input Key Event constructor */
		FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, FName InInputAliasName, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

		/** Input Axis Event constructor */
		FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FName InInputAliasName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );

		/** Copy constructor */
		FSubscribedInputEventParameters( const FSubscribedInputEventParameters& Other );
		FSubscribedInputEventParameters( const FInputEventParameters& Other, FName InInputAliasName );
	
};

struct FUIAxisEmulationDefinition
{
    FName AxisInputKey;
    FName AdjacentAxisInputKey;
    BITFIELD bEmulateButtonPress:1;
    FName InputKeyToEmulate[2];

    /** Constructors */
    FUIAxisEmulationDefinition() {}
    FUIAxisEmulationDefinition(EEventParm)
    {
        appMemzero(this, sizeof(FUIAxisEmulationDefinition));
    }
};

struct FRawInputKeyEventData
{
    FName InputKeyName;
    BYTE ModifierKeyFlags;
    friend FArchive& operator<<(FArchive& Ar,FRawInputKeyEventData& MyRawInputKeyEventData)
    {
        return Ar << MyRawInputKeyEventData.InputKeyName << MyRawInputKeyEventData.ModifierKeyFlags;
    }

		/** Constructors */
		FRawInputKeyEventData() {}
		FRawInputKeyEventData(EEventParm)
		{
			appMemzero(this, sizeof(FRawInputKeyEventData));
		}

		explicit FRawInputKeyEventData( FName InKeyName, BYTE InModifierFlags=(KEYMODIFIER_AltExcluded|KEYMODIFIER_CtrlExcluded|KEYMODIFIER_ShiftExcluded) )
		: InputKeyName(InKeyName), ModifierKeyFlags(InModifierFlags)
		{}

		FRawInputKeyEventData( const FRawInputKeyEventData& Other )
		: InputKeyName(Other.InputKeyName), ModifierKeyFlags(Other.ModifierKeyFlags)
		{}

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FRawInputKeyEventData& Other ) const
		{
			return InputKeyName == Other.InputKeyName && ModifierKeyFlags == Other.ModifierKeyFlags;
		}
		FORCEINLINE UBOOL operator!=( const FRawInputKeyEventData& Other ) const
		{
			return InputKeyName != Other.InputKeyName || ModifierKeyFlags != Other.ModifierKeyFlags;
		}
		/** Required in order for FRawInputKeyEventData to be used as the key in a map */
		friend inline DWORD GetTypeHash( const FRawInputKeyEventData& KeyEvt )
		{
			return GetTypeHash(KeyEvt.InputKeyName);
		}

		/**
		 * Applies the specified modifier key bitmask to ModifierKeyFlags
		 */
		FORCEINLINE void SetModifierKeyFlags( BYTE ModifierFlags )
		{
			ModifierKeyFlags |= ModifierFlags;
		}
		/** Clears the specified modifier key bitmask from ModifierKeyFlags */
		FORCEINLINE void ClearModifierKeyFlags( BYTE ModifierFlags )
		{
			ModifierKeyFlags &= ~ModifierFlags;
		}

		/**
		 * Returns TRUE if ModifierKeyFlags contains any of the bits in FlagsToCheck.
		 */
		FORCEINLINE UBOOL HasAnyModifierKeyFlags( BYTE FlagsToCheck ) const
		{
			return (ModifierKeyFlags&FlagsToCheck) != 0 || FlagsToCheck == KEYMODIFIER_All;
		}

		/**
		 * Returns TRUE if ModifierKeyFlags contains all of the bits in FlagsToCheck
		 */
		FORCEINLINE UBOOL HasAllModifierFlags( BYTE FlagsToCheck ) const
		{
			return (ModifierKeyFlags&FlagsToCheck) == FlagsToCheck;
		}
	
};

struct FUIInputActionAlias
{
    FName InputAliasName;
    TArrayNoInit<struct FRawInputKeyEventData> LinkedInputKeys;
    friend FArchive& operator<<(FArchive& Ar,FUIInputActionAlias& MyUIInputActionAlias)
    {
        return Ar << MyUIInputActionAlias.InputAliasName << MyUIInputActionAlias.LinkedInputKeys;
    }

    /** Constructors */
    FUIInputActionAlias() {}
    FUIInputActionAlias(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputActionAlias));
    }
};

struct FUIInputAliasValue
{
    BYTE ModifierFlagMask;
    FName InputAliasName;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasValue& MyUIInputAliasValue)
    {
        return Ar << MyUIInputAliasValue.ModifierFlagMask << MyUIInputAliasValue.InputAliasName;
    }

		FUIInputAliasValue()
		: ModifierFlagMask(0), InputAliasName(NAME_None)
		{}

		FUIInputAliasValue( BYTE InModifierFlagMask, const FName& inAliasName )
		: ModifierFlagMask(InModifierFlagMask), InputAliasName(inAliasName)
		{}
		FUIInputAliasValue(EEventParm)
		{
			appMemzero(this, sizeof(FUIInputAliasValue));
		}

		/**
		 * Returns FALSE if this input alias value's ModifierFlagMask disallows the provided modifier key states.
		 */
		UBOOL MatchesModifierState( UBOOL bAltPressed, UBOOL bCtrlPressed, UBOOL bShiftPressed ) const;

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FUIInputAliasValue& Other ) const
		{
			return InputAliasName == Other.InputAliasName && ModifierFlagMask == Other.ModifierFlagMask;
		}
		FORCEINLINE UBOOL operator!=( const FUIInputAliasValue& Other ) const
		{
			return InputAliasName != Other.InputAliasName || ModifierFlagMask != Other.ModifierFlagMask;
		}
	
};

struct FUIInputAliasMap
{
    TMultiMap< FName, FUIInputAliasValue > InputAliasLookupTable;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasMap& MyUIInputAliasMap)
    {
        return Ar << MyUIInputAliasMap.InputAliasLookupTable;
    }

		/** Constructors */
	    FUIInputAliasMap() {}
	    FUIInputAliasMap(EEventParm)
	    {
	        appMemzero(this, sizeof(FUIInputAliasMap));
	    }
	
};

struct FUIInputAliasStateMap
{
    FStringNoInit StateClassName;
    class UClass* State;
    TArrayNoInit<struct FUIInputActionAlias> StateInputAliases;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasStateMap& MyUIInputAliasStateMap)
    {
        return Ar << MyUIInputAliasStateMap.StateClassName << (UObject*&)MyUIInputAliasStateMap.State << MyUIInputAliasStateMap.StateInputAliases;
    }

    /** Constructors */
    FUIInputAliasStateMap() {}
    FUIInputAliasStateMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputAliasStateMap));
    }
};

struct FUIInputAliasClassMap
{
    FStringNoInit WidgetClassName;
    class UClass* WidgetClass;
    TArrayNoInit<struct FUIInputAliasStateMap> WidgetStates;
    TMap< UClass*,  FUIInputAliasMap > StateLookupTable;
    TMap< UClass*,  TArray<const FUIInputAliasStateMap*> > StateReverseLookupTable;

		/** Constructors */
	    FUIInputAliasClassMap() {}
	    FUIInputAliasClassMap(EEventParm)
	    {
	        appMemzero(this, sizeof(FUIInputAliasClassMap));
	    }

		/**
		 * Initializes the runtime lookup table with the aliases stored in WidgetInputAliases
		 *
		 * @param	InputAliasList	the list of input alias mappings for all registered UI classes.
		 */
		void InitializeLookupTable( const TMap<UClass*,FUIInputAliasClassMap*>& InputAliasList );
	
};

#define UCONST_MAX_SUPPORTED_GAMEPADS 4
#define UCONST_SCENE_DATASTORE_TAG SceneData
#define UCONST_DEFAULT_SIZE_Y 768
#define UCONST_DEFAULT_SIZE_X 1024
#define UCONST_ASPECTRATIO_Widescreen 1.777778f
#define UCONST_ASPECTRATIO_Monitor 1.25f
#define UCONST_ASPECTRATIO_Normal 1.333333f
#define UCONST_PRIVATE_Protected 0x380
#define UCONST_PRIVATE_KeepFocusedState 0x800
#define UCONST_PRIVATE_PropagateState 0x400
#define UCONST_PRIVATE_EditorNoReparent 0x200
#define UCONST_PRIVATE_EditorNoRename 0x100
#define UCONST_PRIVATE_EditorNoDelete 0x080
#define UCONST_PRIVATE_TreeHiddenRecursive 0x042
#define UCONST_PRIVATE_ManagedStyle 0x020
#define UCONST_PRIVATE_NotRotatable 0x010
#define UCONST_PRIVATE_NotDockable 0x008
#define UCONST_PRIVATE_NotFocusable 0x004
#define UCONST_PRIVATE_TreeHidden 0x002
#define UCONST_PRIVATE_NotEditorSelectable 0x001
#define UCONST_DEFAULT_SCENE_PRIORITY 10
#define UCONST_TEMP_SPLITSCREEN_INDEX 0

class UUIRoot : public UObject
{
public:
    //## BEGIN PROPS UIRoot
    //## END PROPS UIRoot

    UBOOL SetDataStoreFieldValue(const FString& InDataStoreMarkup,const struct FUIProviderFieldValue& InFieldValue,class UUIScene* OwnerScene=NULL,class ULocalPlayer* OwnerPlayer=NULL);
    UBOOL GetDataStoreFieldValue(const FString& InDataStoreMarkup,struct FUIProviderFieldValue& OutFieldValue,class UUIScene* OwnerScene=NULL,class ULocalPlayer* OwnerPlayer=NULL);
    DECLARE_FUNCTION(execGetInputPlatformType);
    DECLARE_FUNCTION(execGetCurrentUIController);
    DECLARE_FUNCTION(execGetSceneClient);
    DECLARE_FUNCTION(execGetFaceOrientation);
    DECLARE_FUNCTION(execGetCursorPosition);
    DECLARE_FUNCTION(execGetCursorSize);
    DECLARE_FUNCTION(execSetMouseCaptureOverride);
    DECLARE_FUNCTION(execGetPrimitiveTransform);
    DECLARE_FUNCTION(execSetDataStoreFieldValue)
    {
        P_GET_STR(InDataStoreMarkup);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,InFieldValue);
        P_GET_OBJECT_OPTX(UUIScene,OwnerScene,NULL);
        P_GET_OBJECT_OPTX(ULocalPlayer,OwnerPlayer,NULL);
        P_FINISH;
        *(UBOOL*)Result=SetDataStoreFieldValue(InDataStoreMarkup,InFieldValue,OwnerScene,OwnerPlayer);
    }
    DECLARE_FUNCTION(execGetDataStoreFieldValue)
    {
        P_GET_STR(InDataStoreMarkup);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,OutFieldValue);
        P_GET_OBJECT_OPTX(UUIScene,OwnerScene,NULL);
        P_GET_OBJECT_OPTX(ULocalPlayer,OwnerPlayer,NULL);
        P_FINISH;
        *(UBOOL*)Result=GetDataStoreFieldValue(InDataStoreMarkup,OutFieldValue,OwnerScene,OwnerPlayer);
    }
    DECLARE_ABSTRACT_CLASS(UUIRoot,UObject,0,Engine)
	/**
	 * Given a face, return the opposite face.
	 *
	 * @return	the EUIWidgetFace member corresponding to the opposite face of the input value, or UIFACE_MAX if the input
	 *			value is invalid.
	 */
	static EUIWidgetFace GetOppositeFace( BYTE Face );

	/**
	 * Returns the friendly name of for the specified face from the EUIWidgetFace enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetDockFaceText( BYTE Face );

	/**
	 * Returns the friendly name for the specified input event from the EInputEvent enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetInputEventText( BYTE InputEvent );

	/**
	 * Returns the friendly name for the specified cell state from the UIListElementState enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetCellStateText( BYTE CellState );

	/**
	 * Returns the friendly name for the specified field type from the UIDataProviderFieldType enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetDataProviderFieldTypeText( BYTE FieldType );

	/**
	 * Returns the friendly name for the specified platform type from the EInputPlatformType enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetInputPlatformTypeText( BYTE PlatformType );

	/**
	 * Wrapper for returns the orientation associated with the specified face.
	 */
	static EUIOrientation GetFaceOrientation( BYTE Face );

	/**
	 * Returns the platform type for the current input device.  This is not necessarily the platform the game is actually running
	 * on; for example, if the game is running on a PC, but the player is using an Xbox controller, the current InputPlatformType
	 * would be IPT_360.
	 *
	 * @param	OwningPlayer	if specified, the returned InputPlatformType will reflect the actual input device the player
	 *							is using.  Otherwise, the returned InputPlatformType is always the platform the game is running on.
	 *
	 * @return	the platform type for the current input device (if a player is specified) or the host platform.
	 */
	static EInputPlatformType GetInputPlatformType( ULocalPlayer* OwningPlayer=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorPosition	receives the position of the cursor
	 * @param	Scene			if specified, provides access to an FViewport through the scene's SceneClient that can be used
	 *							for retrieving the mouse position when not in the game.
	 *
	 * @return	TRUE if the cursor position was retrieved correctly.
	 */
	static UBOOL GetCursorPosition( FVector2D& CursorPosition, const UUIScene* Scene=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorX		receives the X position of the cursor
	 * @param	CursorY		receives the Y position of the cursor
	 * @param	Scene		if specified, provides access to an FViewport through the scene's SceneClient that can be used
	 *						for retrieving the mouse position when not in the game.
	 *
	 * @return	TRUE if the cursor position was retrieved correctly.
	 */
	static UBOOL GetCursorPosition( INT& CursorX, INT& CursorY, const UUIScene* Scene=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorXL	receives the width of the cursor
	 * @param	CursorYL	receives the height of the cursor
	 *
	 * @return	TRUE if the cursor size was retrieved correctly.
	 */
	static UBOOL GetCursorSize( FLOAT& CursorXL, FLOAT& CursorYL );

	/**
	 * Changes the value of GameViewportClient.bUIMouseCaptureOverride to the specified value.  Used by widgets that process
	 * dragging to ensure that the widget receives the mouse button release event.
	 *
	 * @param	bCaptureMouse	whether to capture all mouse input.
	 */
	static void SetMouseCaptureOverride( UBOOL bCaptureMouse );

	/**
	 * @return	TRUE if the specified key is a mouse key
	 */
	static UBOOL IsCursorInputKey( FName KeyName );

	/**
	 * Returns the UIController class set for this game.
	 *
	 * @return	a pointer to a UIInteraction class which is set as the value for GameViewportClient.UIControllerClass.
	 */
	static class UClass* GetUIControllerClass();

	/**
	 * Returns the default object for the UIController class set for this game.
	 *
	 * @return	a pointer to the CDO for UIInteraction class configured for this game.
	 */
	static class UUIInteraction* GetDefaultUIController();

	/**
	 * Returns the UIInteraction instance currently controlling the UI system, which is valid in game.
	 *
	 * @return	a pointer to the UIInteraction object currently controlling the UI system.
	 */
	static class UUIInteraction* GetCurrentUIController();

	/**
	 * Returns the game's scene client.
	 *
	 * @return 	a pointer to the UGameUISceneClient instance currently managing the scenes for the UI System.
	 */
	static class UGameUISceneClient* GetSceneClient();

	/**
	 * Resolves a data store from markup.
	 *
	 * @param	DatafieldMarkupString	The markup string to resolve
	 * @param	InOwnerScene			The scene to use (can be null)
	 * @param	InOwnerPlayer			The local player to use (can be null)
	 * @param	out_ResolvedProvider	The provider associated with the markup
	 * @param 	out_DataFieldName		The Datafield associated with the markup
	 * @param	out_ResolvedDataStore	The resolved data store
	 *
	 */
	static UBOOL ResolveDataStoreMarkup(const FString &DataFieldMarkupString, UUIScene* InOwnerScene, ULocalPlayer* InOwnerPlayer,
					class UUIDataProvider*& out_ResolvedProvider, FString& out_DataFieldName, class UUIDataStore** out_ResolvedDataStore=NULL );

	/**
	 * Returns a matrix which includes the translation, rotation and scale necessary to transform a point from origin to the
	 * the specified widget's position onscreen.  This matrix can then be passed to ConditionalUpdateTransform() for primitives
	 * in use by the UI.
	 *
	 * @param	Widget					the widget to generate the matrix for
	 * @param	bIncludeAnchorPosition	specify TRUE to include translation to the widget's anchor; if FALSE, the translation will move
	 *									the point to the widget's upper left corner (in local space)
	 * @param	bIncludeRotation		specify FALSE to remove the widget's rotation from the resulting matrix
	 * @param	bIncludeScale			specify FALSE to remove the viewport's scale from the resulting matrix
	 *
	 * @return	a matrix which can be used to translate from origin (0,0) to the widget's position, including rotation and viewport scale.
	 */
	static class FMatrix GetPrimitiveTransform( UUIObject* Widget, UBOOL bIncludeAnchorPosition=FALSE, UBOOL bIncludeRotation=TRUE, UBOOL bIncludeScale=TRUE );
};

struct FPlayerDataStoreGroup
{
    class ULocalPlayer* PlayerOwner;
    TArray<class UUIDataStore*> DataStores;

    /** Constructors */
    FPlayerDataStoreGroup()
    : PlayerOwner(NULL)
    {}
    FPlayerDataStoreGroup(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerDataStoreGroup));
    }
};

struct DataStoreClient_eventNotifyGameSessionEnded_Parms
{
    DataStoreClient_eventNotifyGameSessionEnded_Parms(EEventParm)
    {
    }
};
class UDataStoreClient : public UUIRoot
{
public:
    //## BEGIN PROPS DataStoreClient
    TArrayNoInit<FString> GlobalDataStoreClasses;
    TArrayNoInit<class UUIDataStore*> GlobalDataStores;
    TArrayNoInit<FString> PlayerDataStoreClassNames;
    TArrayNoInit<class UClass*> PlayerDataStoreClasses;
    TArrayNoInit<struct FPlayerDataStoreGroup> PlayerDataStores;
    //## END PROPS DataStoreClient

    class UUIDataStore* FindDataStore(FName DataStoreTag,class ULocalPlayer* PlayerOwner=NULL);
    class UUIDataStore* CreateDataStore(class UClass* DataStoreClass);
    UBOOL RegisterDataStore(class UUIDataStore* DataStore,class ULocalPlayer* PlayerOwner=NULL);
    UBOOL UnregisterDataStore(class UUIDataStore* DataStore);
    void GetAvailableDataStores(class UUIScene* CurrentScene,TArray<class UUIDataStore*>& out_DataStores) const;
    INT FindPlayerDataStoreIndex(class ULocalPlayer* PlayerOwner) const;
    DECLARE_FUNCTION(execFindDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=FindDataStore(DataStoreTag,PlayerOwner);
    }
    DECLARE_FUNCTION(execCreateDataStore)
    {
        P_GET_OBJECT(UClass,DataStoreClass);
        P_FINISH;
        *(class UUIDataStore**)Result=CreateDataStore(DataStoreClass);
    }
    DECLARE_FUNCTION(execRegisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(UBOOL*)Result=RegisterDataStore(DataStore,PlayerOwner);
    }
    DECLARE_FUNCTION(execUnregisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_FINISH;
        *(UBOOL*)Result=UnregisterDataStore(DataStore);
    }
    DECLARE_FUNCTION(execGetAvailableDataStores)
    {
        P_GET_OBJECT(UUIScene,CurrentScene);
        P_GET_TARRAY_REF(class UUIDataStore*,out_DataStores);
        P_FINISH;
        GetAvailableDataStores(CurrentScene,out_DataStores);
    }
    DECLARE_FUNCTION(execFindPlayerDataStoreIndex)
    {
        P_GET_OBJECT(ULocalPlayer,PlayerOwner);
        P_FINISH;
        *(INT*)Result=FindPlayerDataStoreIndex(PlayerOwner);
    }
    void eventNotifyGameSessionEnded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyGameSessionEnded),NULL);
    }
    DECLARE_CLASS(UDataStoreClient,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/**
	 * Loads each of the classes from the GlobalDataStoreClasses array, creates an instance of that class, and stores
	 * that instance in the GlobalDataStores array.
	 */
	virtual void InitializeDataStores();
};

struct Interaction_eventOnInitialize_Parms
{
    Interaction_eventOnInitialize_Parms(EEventParm)
    {
    }
};
struct Interaction_eventTick_Parms
{
    FLOAT DeltaTime;
    Interaction_eventTick_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputChar_Parms
{
    INT ControllerId;
    FString Unicode;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputChar_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputAxis_Parms
{
    INT ControllerId;
    FName Key;
    FLOAT Delta;
    FLOAT DeltaTime;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputAxis_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputKey_Parms
{
    INT ControllerId;
    FName Key;
    BYTE EventType;
    FLOAT AmountDepressed;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputKey_Parms(EEventParm)
    {
    }
};
class UInteraction : public UUIRoot
{
public:
    //## BEGIN PROPS Interaction
    FScriptDelegate __OnReceivedNativeInputKey__Delegate;
    FScriptDelegate __OnReceivedNativeInputAxis__Delegate;
    FScriptDelegate __OnReceivedNativeInputChar__Delegate;
    FScriptDelegate __OnInitialize__Delegate;
    //## END PROPS Interaction

    virtual void Init();
    DECLARE_FUNCTION(execInit)
    {
        P_FINISH;
        Init();
    }
    void delegateOnInitialize()
    {
        ProcessDelegate(ENGINE_OnInitialize,&__OnInitialize__Delegate,NULL);
    }
    void eventTick(FLOAT DeltaTime)
    {
        Interaction_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    UBOOL delegateOnReceivedNativeInputChar(INT ControllerId,const FString& Unicode)
    {
        Interaction_eventOnReceivedNativeInputChar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Unicode=Unicode;
        ProcessDelegate(ENGINE_OnReceivedNativeInputChar,&__OnReceivedNativeInputChar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnReceivedNativeInputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad=FALSE)
    {
        Interaction_eventOnReceivedNativeInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.Delta=Delta;
        Parms.DeltaTime=DeltaTime;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnReceivedNativeInputAxis,&__OnReceivedNativeInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnReceivedNativeInputKey(INT ControllerId,FName Key,BYTE EventType,FLOAT AmountDepressed=1.000000,UBOOL bGamepad=FALSE)
    {
        Interaction_eventOnReceivedNativeInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.EventType=EventType;
        Parms.AmountDepressed=AmountDepressed;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnReceivedNativeInputKey,&__OnReceivedNativeInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UInteraction,UUIRoot,0|CLASS_Transient,Engine)
	/**
	 * Minimal initialization constructor.
	 */
	UInteraction();

	/**
	 * Called once a frame to update the interaction's state.
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime)
	{
		eventTick(DeltaTime);
	}

	/**
	 * Process an input key event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	EventType		the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process an input axis (joystick, thumbstick, or mouse) event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this input axis event
	 * @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
	 * @param	Delta			the movement delta for the axis
	 * @param	DeltaTime		the time (in seconds) since the last axis update.
	 *
	 * @return	TRUE to consume the axis event, FALSE to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process a character input event (typing) received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this character input event
	 * @param	Character		the character that was typed
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character)
	{
		return FALSE;
	}
public:
};

#define UCONST_MaxHistory 16

struct Console_eventOutputText_Parms
{
    FString Text;
    Console_eventOutputText_Parms(EEventParm)
    {
    }
};
class UConsole : public UInteraction
{
public:
    //## BEGIN PROPS Console
    class ULocalPlayer* ConsoleTargetPlayer;
    class UUIScene* LargeConsoleScene;
    class UUIScene* MiniConsoleScene;
    class UUILabel* ConsoleBufferText;
    class UConsoleEntry* MiniConsoleInput;
    class UConsoleEntry* LargeConsoleInput;
    class UTexture2D* DefaultTexture_Black;
    class UTexture2D* DefaultTexture_White;
    FName ConsoleKey;
    FName TypeKey;
    INT MaxScrollbackSize;
    TArrayNoInit<FString> Scrollback;
    INT SBHead;
    INT SBPos;
    INT HistoryTop;
    INT HistoryBot;
    INT HistoryCur;
    FStringNoInit History[16];
    FStringNoInit TypedStr;
    INT TypedStrPos;
    BITFIELD bCaptureKeyInput:1;
    BITFIELD bCtrl:1;
    BITFIELD bEnableUI:1;
    //## END PROPS Console

    void eventOutputText(const FString& Text)
    {
        Console_eventOutputText_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(ENGINE_OutputText),&Parms);
    }
    DECLARE_CLASS(UConsole,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

    NO_DEFAULT_CONSTRUCTOR(UConsole)
};

struct FKeyBind
{
    FName Name;
    FStringNoInit Command;
    BITFIELD Control:1;
    BITFIELD Shift:1;
    BITFIELD Alt:1;
    BITFIELD bIgnoreCtrl:1;
    BITFIELD bIgnoreShift:1;
    BITFIELD bIgnoreAlt:1;

	FKeyBind()
	: Name()
	, Control(FALSE), Shift(FALSE), Alt(FALSE)
	, bIgnoreCtrl(FALSE), bIgnoreShift(FALSE), bIgnoreAlt(FALSE)
	{}

};

class UInput : public UInteraction
{
public:
    //## BEGIN PROPS Input
    TArrayNoInit<struct FKeyBind> Bindings;
    TArrayNoInit<FName> PressedKeys;
    BYTE CurrentEvent;
    FLOAT CurrentDelta;
    FLOAT CurrentDeltaTime;
    TMap< FName,void* > NameToPtr;
    TArray<FLOAT*> AxisArray;
    //## END PROPS Input

    virtual void ResetInput();
    virtual FString GetBind(FName Key);
    DECLARE_FUNCTION(execResetInput)
    {
        P_FINISH;
        ResetInput();
    }
    DECLARE_FUNCTION(execGetBind)
    {
        P_GET_NAME(Key);
        P_FINISH;
        *(FString*)Result=GetBind(Key);
    }
    DECLARE_CLASS(UInput,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	// UInteraction interface.

	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime, UBOOL bGamepad=FALSE);
	virtual void Tick(FLOAT DeltaTime);
	UBOOL IsPressed( FName InKey ) const;
	UBOOL IsCtrlPressed() const;
	UBOOL IsShiftPressed() const;
	UBOOL IsAltPressed() const;

	// UInput interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/**
	 * Clears the PressedKeys array.  Should be called when another interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys()
	{
		PressedKeys.Empty();
	}

	// Protected.

	BYTE* FindButtonName(const TCHAR* ButtonName);
	FLOAT* FindAxisName(const TCHAR* ButtonName);
	/**
	 * Returns the Name of a bind using the bind's Command as the key
	 * StartBind Index is where the search will start from and where the index result will be stored
	 *   -- If you don't where to start your search from (as the list will search backwards), set the StartBindIndex to -1 before passing it in
	 */
	FString GetBindNameFromCommand(const FString& KeyCommand, INT* StartBindIndex = NULL ) const;
	void ExecInputCommands(const TCHAR* Cmd,class FOutputDevice& Ar);
	virtual void UpdateAxisValue( FLOAT* Axis, FLOAT Delta );
};

struct PlayerInput_eventPlayerInput_Parms
{
    FLOAT DeltaTime;
    PlayerInput_eventPlayerInput_Parms(EEventParm)
    {
    }
};
class UPlayerInput : public UInput
{
public:
    //## BEGIN PROPS PlayerInput
    BITFIELD bUsingGamepad:1;
    BITFIELD bInvertMouse:1;
    BITFIELD bInvertTurn:1;
    BITFIELD bWasForward:1;
    BITFIELD bWasBack:1;
    BITFIELD bWasLeft:1;
    BITFIELD bWasRight:1;
    BITFIELD bEdgeForward:1;
    BITFIELD bEdgeBack:1;
    BITFIELD bEdgeLeft:1;
    BITFIELD bEdgeRight:1;
    BITFIELD bEnableMouseSmoothing:1;
    BITFIELD bEnableFOVScaling:1;
    FName LastAxisKeyName;
    FLOAT DoubleClickTimer;
    FLOAT DoubleClickTime;
    FLOAT MouseSensitivity;
    FLOAT aBaseX;
    FLOAT aBaseY;
    FLOAT aBaseZ;
    FLOAT aMouseX;
    FLOAT aMouseY;
    FLOAT aForward;
    FLOAT aTurn;
    FLOAT aStrafe;
    FLOAT aUp;
    FLOAT aLookUp;
    FLOAT aPS3AccelX;
    FLOAT aPS3AccelY;
    FLOAT aPS3AccelZ;
    FLOAT aPS3Gyro;
    FLOAT RawJoyUp;
    FLOAT RawJoyRight;
    FLOAT RawJoyLookRight;
    FLOAT RawJoyLookUp;
    FLOAT MoveForwardSpeed;
    FLOAT MoveStrafeSpeed;
    FLOAT LookRightScale;
    FLOAT LookUpScale;
    BYTE bStrafe;
    BYTE bXAxis;
    BYTE bYAxis;
    FLOAT ZeroTime[2];
    FLOAT SmoothedMouse[2];
    INT MouseSamples;
    FLOAT MouseSamplingTotal;
    //## END PROPS PlayerInput

    void eventPlayerInput(FLOAT DeltaTime)
    {
        PlayerInput_eventPlayerInput_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerInput),&Parms);
    }
    DECLARE_CLASS(UPlayerInput,UInput,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(APlayerController)
	/**
	 * Generates an IE_Released event for each key in the PressedKeys array, then clears the array.  Should be called when another
	 * interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys();

	/** Override to detect input from a gamepad */
	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime, UBOOL bGamepad=FALSE);
	virtual void  UpdateAxisValue( FLOAT* Axis, FLOAT Delta );

};

class UPlayerManagerInteraction : public UInteraction
{
public:
    //## BEGIN PROPS PlayerManagerInteraction
    //## END PROPS PlayerManagerInteraction

    DECLARE_CLASS(UPlayerManagerInteraction,UInteraction,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UGameViewportClient)
	/* === UInteraction interface === */
	/**
	 * Routes an input key event to the player's interactions array
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Routes an axis input event to the player's interactions array.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Routes a character input to the player's Interaction array.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);
};

struct FUIKeyRepeatData
{
    FName CurrentRepeatKey;
    DOUBLE NextRepeatTime;

    /** Constructors */
	FUIKeyRepeatData()
	: CurrentRepeatKey(NAME_None)
	, NextRepeatTime(0.f)
	{}

};

struct FUIAxisEmulationData : public FUIKeyRepeatData
{
    BITFIELD bEnabled:1;

    /** Constructors */
	FUIAxisEmulationData()
	: FUIKeyRepeatData(), bEnabled(TRUE)
	{}

	/**
	 * Toggles whether this axis emulation is enabled.
	 */
	void EnableAxisEmulation( UBOOL bShouldEnable )
	{
		if ( bEnabled != bShouldEnable )
		{
			bEnabled = bShouldEnable;
			CurrentRepeatKey = NAME_None;
			NextRepeatTime = 0.f;
		}
	}

};

#define UCONST_DEFAULT_UISKIN TEXT("DefaultUISkin.DefaultSkin")

struct UIInteraction_eventGetNATType_Parms
{
    BYTE ReturnValue;
    UIInteraction_eventGetNATType_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventCanPlayOnline_Parms
{
    INT ControllerId;
    UBOOL ReturnValue;
    UIInteraction_eventCanPlayOnline_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventIsLoggedIn_Parms
{
    INT ControllerId;
    UBOOL bRequireOnlineLogin;
    UBOOL ReturnValue;
    UIInteraction_eventIsLoggedIn_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventHasLinkConnection_Parms
{
    UBOOL ReturnValue;
    UIInteraction_eventHasLinkConnection_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventGetLoginStatus_Parms
{
    INT ControllerId;
    BYTE ReturnValue;
    UIInteraction_eventGetLoginStatus_Parms(EEventParm)
    {
    }
};
class UUIInteraction : public UInteraction, public FExec, public FGlobalDataStoreClientManager, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UIInteraction
    class UClass* SceneClientClass;
    class UGameUISceneClient* SceneClient;
    FStringNoInit UISkinName;
    TArrayNoInit<FName> UISoundCueNames;
    TArrayNoInit<FName> SupportedDoubleClickKeys;
private:
    class UDataStoreClient* DataStoreManager;
    class UUIInputConfiguration* UIInputConfig;
public:
    TMap< UClass*,struct FUIInputAliasClassMap* > WidgetInputAliasLookupTable;
    BITFIELD bProcessInput:1;
    BITFIELD bDisableToolTips:1;
    BITFIELD bFocusOnActive:1;
    BITFIELD bFocusedStateRules:1;
    BITFIELD bIsUIPrimitiveSceneInitialized:1;
    FLOAT UIJoystickDeadZone;
    FLOAT UIAxisMultiplier;
    FLOAT AxisRepeatDelay;
    FLOAT MouseButtonRepeatDelay;
    FLOAT DoubleClickTriggerSeconds;
    INT DoubleClickPixelTolerance;
    FLOAT ToolTipInitialDelaySeconds;
    FLOAT ToolTipExpirationSeconds;
    struct FUIKeyRepeatData MouseButtonRepeatInfo;
    TMap< FName,struct FUIAxisEmulationDefinition > AxisEmulationDefinitions;
    struct FUIAxisEmulationData AxisInputEmulation[4];
    class FCanvasScene* CanvasScene;
    //## END PROPS UIInteraction

    UBOOL PlayUISound(FName SoundCueName,INT PlayerIndex=0);
    class UUIObject* CreateTransientWidget(class UClass* WidgetClass,FName WidgetTag,class UUIObject* Owner=NULL);
    class UUIScene* CreateScene(class UClass* SceneClass,FName SceneTag=NAME_None,class UUIScene* SceneTemplate=NULL);
    DECLARE_FUNCTION(execGetPlayerCount)
    {
        P_FINISH;
        *(INT*)Result=GetPlayerCount();
    }
    DECLARE_FUNCTION(execGetPlayerIndex)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(INT*)Result=GetPlayerIndex(ControllerId);
    }
    DECLARE_FUNCTION(execGetPlayerControllerId)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(INT*)Result=GetPlayerControllerId(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreClient)
    {
        P_FINISH;
        *(class UDataStoreClient**)Result=GetDataStoreClient();
    }
    DECLARE_FUNCTION(execPlayUISound)
    {
        P_GET_NAME(SoundCueName);
        P_GET_INT_OPTX(PlayerIndex,0);
        P_FINISH;
        *(UBOOL*)Result=PlayUISound(SoundCueName,PlayerIndex);
    }
    DECLARE_FUNCTION(execCreateTransientWidget)
    {
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_NAME(WidgetTag);
        P_GET_OBJECT_OPTX(UUIObject,Owner,NULL);
        P_FINISH;
        *(class UUIObject**)Result=CreateTransientWidget(WidgetClass,WidgetTag,Owner);
    }
    DECLARE_FUNCTION(execCreateScene)
    {
        P_GET_OBJECT(UClass,SceneClass);
        P_GET_NAME_OPTX(SceneTag,NAME_None);
        P_GET_OBJECT_OPTX(UUIScene,SceneTemplate,NULL);
        P_FINISH;
        *(class UUIScene**)Result=CreateScene(SceneClass,SceneTag,SceneTemplate);
    }
    BYTE eventGetNATType()
    {
        UIInteraction_eventGetNATType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetNATType),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventCanPlayOnline(INT ControllerId)
    {
        UIInteraction_eventCanPlayOnline_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_CanPlayOnline),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsLoggedIn(INT ControllerId,UBOOL bRequireOnlineLogin=FALSE)
    {
        UIInteraction_eventIsLoggedIn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.bRequireOnlineLogin=bRequireOnlineLogin ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsLoggedIn),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventHasLinkConnection()
    {
        UIInteraction_eventHasLinkConnection_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_HasLinkConnection),&Parms);
        return Parms.ReturnValue;
    }
    BYTE eventGetLoginStatus(INT ControllerId)
    {
        UIInteraction_eventGetLoginStatus_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_GetLoginStatus),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIInteraction,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* =======================================
		UObject interface
	======================================= */
	/**
	* Called to finish destroying the object.
	*/
	virtual void FinishDestroy();

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* === FCallbackEventDevice interface === */
	/**
	 * Called for notifications that require no additional information.
	 */
	virtual void Send( ECallbackEventType InType );

	/**
	 * Called when the viewport has been resized.
	 */
	virtual void Send( ECallbackEventType InType, FViewport* InViewport, UINT InMessage);

	/* ==============================================
		FGlobalDataStoreClientManager interface
	============================================== */
	/**
	 * Initializes the singleton data store client that will manage the global data stores.
	 */
	virtual void InitializeGlobalDataStore();

	/* =======================================
		UInteraction interface
	======================================= */
	/**
	 * Called when UIInteraction is added to the GameViewportClient's Interactions array
	 */
	virtual void Init();

	/**
	 * Called once a frame to update the interaction's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/* =======================================
		UUIInteraction interface
	======================================= */
	/**
	 * Constructor
	 */
	UUIInteraction();

	/**
	 * Cleans up all objects created by this UIInteraction, including unrooting objects and unreferencing any other objects.
	 * Called when the UI system is being closed down (such as when exiting PIE).
	 */
	virtual void TearDownUI();

	/**
	 * Initializes the axis button-press/release emulation map.
	 */
	void InitializeAxisInputEmulations();

	/**
	 * Initializes all of the UI input alias names.
	 */
	void InitializeUIInputAliasNames();

	/**
	 * Initializes all of the UI event key lookup maps.
	 */
	void InitializeInputAliasLookupTable();

	/**
	 * Load the UISkin specified by UISkinName
	 *
	 * @return	a pointer to the UISkin object corresponding to UISkinName, or
	 *			the default UISkin if the configured skin couldn't be loaded
	 */
	class UUISkin* LoadInitialSkin() const;

	/**
	 * Notifies the scene client to render all scenes
	 */
	void RenderUI( FCanvas* Canvas );

	/**
	 * Returns the CDO for the configured scene client class.
	 */
	class UGameUISceneClient* GetDefaultSceneClient() const;

	/**
	 * Returns the UIInputConfiguration singleton, creating one if necessary.
	 */
	class UUIInputConfiguration* GetInputSettings();

	/**
	 * Returns the number of players currently active.
	 */
	static INT GetPlayerCount();

	/**
	 * Retrieves the index (into the Engine.GamePlayers array) for the player which has the ControllerId specified
	 *
	 * @param	ControllerId	the gamepad index of the player to search for
	 *
	 * @return	the index [into the Engine.GamePlayers array] for the player that has the ControllerId specified, or INDEX_NONE
	 *			if no players have that ControllerId
	 */
	static INT GetPlayerIndex( INT ControllerId );

	/**
	 * Returns the index [into the Engine.GamePlayers array] for the player specified.
	 *
	 * @param	Player	the player to search for
	 *
	 * @return	the index of the player specified, or INDEX_NONE if the player is not in the game's list of active players.
	 */
	static INT GetPlayerIndex( class ULocalPlayer* Player );

	/**
	 * Retrieves the ControllerId for the player specified.
	 *
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player to retrieve the ControllerId for
	 *
	 * @return	the ControllerId for the player at the specified index in the GamePlayers array, or INDEX_NONE if the index is invalid
	 */
	static INT GetPlayerControllerId( INT PlayerIndex );

	/**
	 * Returns TRUE if button press/release events should be emulated for the specified axis input.
	 *
	 * @param	AxisKeyName		the name of the axis key that
	 */
	static UBOOL ShouldEmulateKeyPressForAxis( const FName& AxisKeyName );

	/**
	 * Returns a reference to the global data store client, if it exists.
	 *
	 * @return	the global data store client for the game.
	 */
	static class UDataStoreClient* GetDataStoreClient();

//	/**
//	 * @return	reference to the global storage device manager.
//	 */
//	static class UStorageDeviceManager* GetStorageManager();

	/**
	 * Returns if this UI requires a CanvasScene for rendering 3D primitives
	 *
	 * @return TRUE if 3D primitives are used
	 */
	virtual UBOOL UsesUIPrimitiveScene() const;

	/**
	 * Returns the internal CanvasScene that may be used by this UI
	 *
	 * @return canvas scene or NULL
	 */
	virtual class FCanvasScene* GetUIPrimitiveScene();

	/**
	 * Determine if the canvas scene for primitive rendering needs to be initialized
	 *
	 * @return TRUE if InitUIPrimitiveScene should be called
	 */
	virtual UBOOL NeedsInitUIPrimitiveScene();

	/**
	 * Setup a canvas scene by adding primtives and lights to it from this UI
	 *
	 * @param InCanvasScene - scene for rendering 3D prims
	 */
	virtual void InitUIPrimitiveScene( class FCanvasScene* InCanvasScene );

	/**
	 * Updates the actor components in the canvas scene
	 *
	 * @param InCanvasScene - scene for rendering 3D prims
	 */
	virtual void UpdateUIPrimitiveScene( class FCanvasScene* InCanvasScene );
};

class UUIInputConfiguration : public UUIRoot
{
public:
    //## BEGIN PROPS UIInputConfiguration
private:
    TArrayNoInit<struct FUIInputAliasClassMap> WidgetInputAliases;
public:
    TArrayNoInit<struct FUIAxisEmulationDefinition> AxisEmulationDefinitions;
    //## END PROPS UIInputConfiguration

    void LoadInputAliasClasses();
    virtual void NotifyGameSessionEnded();
    DECLARE_FUNCTION(execLoadInputAliasClasses)
    {
        P_FINISH;
        LoadInputAliasClasses();
    }
    DECLARE_FUNCTION(execNotifyGameSessionEnded)
    {
        P_FINISH;
        NotifyGameSessionEnded();
    }
    DECLARE_CLASS(UUIInputConfiguration,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	friend class WxDlgUIEventKeyBindings;

	/**
	 * Returns the list of widget class input aliases.
	 */
	TArray<struct FUIInputAliasClassMap>& GetInputAliasList();
};

class UUILayerBase : public UUIRoot
{
public:
    //## BEGIN PROPS UILayerBase
    //## END PROPS UILayerBase

    DECLARE_ABSTRACT_CLASS(UUILayerBase,UUIRoot,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUILayerBase)
};

#define UCONST_SCENEFILTER_Any 0xFFFFFFFF
#define UCONST_SCENEFILTER_ReceivesFocus 0x00000020
#define UCONST_SCENEFILTER_UsesPostProcessing 0x00000010
#define UCONST_SCENEFILTER_PrimitiveUsersOnly 0x00000008
#define UCONST_SCENEFILTER_PausersOnly 0x00000004
#define UCONST_SCENEFILTER_InputProcessorOnly 0x00000002
#define UCONST_SCENEFILTER_IncludeTransient 0x00000001
#define UCONST_SCENEFILTER_None 0x00000000

struct UISceneClient_eventInitializeSceneClient_Parms
{
    UISceneClient_eventInitializeSceneClient_Parms(EEventParm)
    {
    }
};
class UUISceneClient : public UUIRoot, public FExec
{
public:
    //## BEGIN PROPS UISceneClient
    FViewport* RenderViewport;
    class UUISkin* ActiveSkin;
    FIntPoint MousePosition;
    class UUIObject* ActiveControl;
    class UDataStoreClient* DataStoreManager;
    class UMaterialInstanceConstant* OpacityParameter;
    FName OpacityParameterName;
    FMatrix CanvasToScreen;
    FMatrix InvCanvasToScreen;
    class UPostProcessChain* UIScenePostProcess;
    BITFIELD bEnablePostProcess:1;
    //## END PROPS UISceneClient

    virtual void SetMousePosition(INT NewMouseX,INT NewMouseY);
    virtual UBOOL ChangeMouseCursor(FName CursorName);
    FMatrix GetCanvasToScreen(const class UUIObject* Widget=NULL) const;
    FMatrix GetInverseCanvasToScreen(const class UUIObject* Widget=NULL) const;
    DECLARE_FUNCTION(execChangeActiveSkin)
    {
        P_GET_OBJECT(UUISkin,NewActiveSkin);
        P_FINISH;
        *(UBOOL*)Result=ChangeActiveSkin(NewActiveSkin);
    }
    DECLARE_FUNCTION(execIsUIActive)
    {
        P_GET_INT_OPTX(Flags,-1);
        P_FINISH;
        *(UBOOL*)Result=IsUIActive(Flags);
    }
    DECLARE_FUNCTION(execIsSceneInitialized)
    {
        P_GET_OBJECT(UUIScene,Scene);
        P_FINISH;
        *(UBOOL*)Result=IsSceneInitialized(Scene);
    }
    DECLARE_FUNCTION(execInitializeScene)
    {
        P_GET_OBJECT(UUIScene,Scene);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_GET_OBJECT_OPTX_REF(UUIScene,InitializedScene,NULL);
        P_FINISH;
        *(UBOOL*)Result=InitializeScene(Scene,SceneOwner,pInitializedScene ? &InitializedScene : NULL);
    }
    DECLARE_FUNCTION(execOpenScene)
    {
        P_GET_OBJECT(UUIScene,Scene);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_GET_OBJECT_OPTX_REF(UUIScene,OpenedScene,NULL);
        P_GET_BYTE_OPTX(ForcedPriority,0);
        P_FINISH;
        *(UBOOL*)Result=OpenScene(Scene,SceneOwner,pOpenedScene ? &OpenedScene : NULL,ForcedPriority);
    }
    DECLARE_FUNCTION(execInsertScene)
    {
        P_GET_INT(DesiredInsertIndex);
        P_GET_OBJECT(UUIScene,Scene);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_GET_OBJECT_OPTX_REF(UUIScene,OpenedScene,NULL);
        P_GET_INT_OPTX_REF(ActualInsertIndex,0);
        P_GET_BYTE_OPTX(ForcedPriority,0);
        P_FINISH;
        *(UBOOL*)Result=InsertScene(DesiredInsertIndex,Scene,SceneOwner,pOpenedScene ? &OpenedScene : NULL,pActualInsertIndex ? &ActualInsertIndex : NULL,ForcedPriority);
    }
    DECLARE_FUNCTION(execReplaceScene)
    {
        P_GET_OBJECT(UUIScene,SceneInstanceToReplace);
        P_GET_OBJECT(UUIScene,SceneToOpen);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_GET_OBJECT_OPTX_REF(UUIScene,OpenedScene,NULL);
        P_GET_BYTE_OPTX(ForcedPriority,0);
        P_FINISH;
        *(UBOOL*)Result=ReplaceScene(SceneInstanceToReplace,SceneToOpen,SceneOwner,pOpenedScene ? &OpenedScene : NULL,ForcedPriority);
    }
    DECLARE_FUNCTION(execReplaceSceneAtIndex)
    {
        P_GET_INT(IndexOfSceneToReplace);
        P_GET_OBJECT(UUIScene,SceneToOpen);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_GET_OBJECT_OPTX_REF(UUIScene,OpenedScene,NULL);
        P_GET_BYTE_OPTX(ForcedPriority,0);
        P_FINISH;
        *(UBOOL*)Result=ReplaceSceneAtIndex(IndexOfSceneToReplace,SceneToOpen,SceneOwner,pOpenedScene ? &OpenedScene : NULL,ForcedPriority);
    }
    DECLARE_FUNCTION(execCloseScene)
    {
        P_GET_OBJECT(UUIScene,Scene);
        P_GET_UBOOL_OPTX(bCloseChildScenes,TRUE);
        P_GET_UBOOL_OPTX(bForceCloseImmediately,FALSE);
        P_FINISH;
        *(UBOOL*)Result=CloseScene(Scene,bCloseChildScenes,bForceCloseImmediately);
    }
    DECLARE_FUNCTION(execCloseSceneAtIndex)
    {
        P_GET_INT(SceneStackIndex);
        P_GET_UBOOL_OPTX(bCloseChildScenes,TRUE);
        P_GET_UBOOL_OPTX(bForceCloseImmediately,FALSE);
        P_FINISH;
        *(UBOOL*)Result=CloseSceneAtIndex(SceneStackIndex,bCloseChildScenes,bForceCloseImmediately);
    }
    DECLARE_FUNCTION(execSetMousePosition)
    {
        P_GET_INT(NewMouseX);
        P_GET_INT(NewMouseY);
        P_FINISH;
        SetMousePosition(NewMouseX,NewMouseY);
    }
    DECLARE_FUNCTION(execChangeMouseCursor)
    {
        P_GET_NAME(CursorName);
        P_FINISH;
        *(UBOOL*)Result=ChangeMouseCursor(CursorName);
    }
    DECLARE_FUNCTION(execUpdateCanvasToScreen)
    {
        P_FINISH;
        UpdateCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_GET_OBJECT_OPTX(UUIObject,Widget,NULL);
        P_FINISH;
        *(FMatrix*)Result=GetCanvasToScreen(Widget);
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_GET_OBJECT_OPTX(UUIObject,Widget,NULL);
        P_FINISH;
        *(FMatrix*)Result=GetInverseCanvasToScreen(Widget);
    }
    void eventInitializeSceneClient()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeSceneClient),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUISceneClient,UUIRoot,0|CLASS_Transient,Engine)

	/**
	 * Used to limit which scenes should be considered when determining whether the UI should be considered "active"
	 */
	enum ESceneFilterTypes
	{
		SCENEFILTER_None=UCONST_SCENEFILTER_None,

		/** Include the transient scene */
		SCENEFILTER_IncludeTransient=UCONST_SCENEFILTER_IncludeTransient,

		/** Consider only scenes which can process input */
		SCENEFILTER_InputProcessorOnly=UCONST_SCENEFILTER_InputProcessorOnly,

		/** Consider only scenes which require the game to be paused */
		SCENEFILTER_PausersOnly=UCONST_SCENEFILTER_PausersOnly,

		/** Consider only scenes which support 3D primitives rendering */
		SCENEFILTER_PrimitiveUsersOnly=UCONST_SCENEFILTER_PrimitiveUsersOnly,

		/** Only consider scenes which render full-screen */
		SCENEFILTER_UsesPostProcessing=UCONST_SCENEFILTER_UsesPostProcessing,

		/** Include only those scenes which can receive focus (i.e. bNeverFocus=false) */
		SCENEFILTER_ReceivesFocus=UCONST_SCENEFILTER_ReceivesFocus,

		/** Include ANY scene, regardless of feature set */
		SCENEFILTER_Any=UCONST_SCENEFILTER_Any,
	};

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* =======================================
		UUISceneClient interface
	======================================= */

	/**
	 * Performs any initialization for the UISceneClient.
	 *
	 * @param	InitialSkin		UISkin that should be set to the initial ActiveSkin
	 */
	virtual void InitializeClient( UUISkin* InitialSkin );

	/**
	 * Assigns the viewport that scenes will use for rendering.
	 *
	 * @param	inViewport	the viewport to use for rendering scenes
	 */
	virtual void SetRenderViewport( FViewport* SceneViewport );

	/**
	 * Changes the active skin to the skin specified
	 */
	void SetActiveSkin( UUISkin* NewActiveSkin );

	/**
	 * Changes the active skin to the skin specified, initializes the skin and performs all necessary cleanup and callbacks.
	 * This method should only be called from script.
	 *
	 * @param	NewActiveScene	The skin to activate
	 *
	 * @return	TRUE if the skin was successfully changed.
	 */
	virtual UBOOL ChangeActiveSkin( UUISkin* NewActiveSkin ) PURE_VIRTUAL(UUISceneClient::ChangeActiveSkin, return FALSE;);

	/**
	 * Refreshes all existing UI elements with the styles from the currently active skin.
	 */
	virtual void OnActiveSkinChanged() PURE_VIRTUAL(UUISceneClient::OnActiveSkinChanged,);

	/**
	 * Retrieves the virtual offset for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 * Non-zero when the user has panned or zoomed the UI editor such that the 0,0 viewport position is no longer the same
	 * as the 0,0 canvas location.
	 *
	 * @param	out_ViewportOffset	[out] will be filled in with the delta between the viewport's actual origin and virtual origin.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOffset( const UUIScene* Scene, FVector2D& out_ViewportOffset )
	{
		out_ViewportOffset = FVector2D(0,0);
		return FALSE;
	}

	/**
	 * Retrieves the scale factor for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 */
	virtual FLOAT GetViewportScale( const UUIScene* Scene ) const
	{
		return 1.f;
	}

	/**
	 * Retrieves the virtual point of origin for the viewport that renders the specified scene
	 *
	 * In the game, this will be non-zero if Scene is for split-screen and isn't for the first player.
	 * In the editor, this will be equal to the value of the gutter region around the viewport.
	 *
	 * @param	out_ViewportOrigin	[out] will be filled in with the position of the virtual origin point of the viewport.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOrigin( const UUIScene* Scene, FVector2D& out_ViewportOrigin )
	{
		out_ViewportOrigin = FVector2D(0,0);
		return TRUE;
	}

	/**
	 * Retrieves the size of the viewport for the scene specified.
	 *
	 * @param	out_ViewportSize	[out] will be filled in with the width & height that the scene should use as the viewport size
	 *
	 * @return	TRUE if the viewport size was successfully retrieved
	 */
	virtual UBOOL GetViewportSize( const UUIScene* Scene, FVector2D& out_ViewportSize );

	/**
	 * Recalculates the matrix used for projecting local coordinates into screen (normalized device)
	 * coordinates.  This method should be called anytime the viewport size or origin changes.
	 */
	virtual void UpdateCanvasToScreen() PURE_VIRTUAL(UUISceneClient::UpdateCanvasToScreen,);

	/**
	 * Provides the scene client with a way to apply a platform input type other than the actual input type being used.
	 * Primarily for simulating platforms in the editor.
	 *
	 * @param	OwningPlayer		the player to use for determining the real platform input type, if necessary.
	 * @param	SimulatedPlatform	receives the value of the platform that should be used.
	 *
	 * @return	TRUE if the scene client wants to override the current platform input type.
	 */
	virtual UBOOL GetSimulatedPlatformInputType( BYTE& SimulatedPlatform ) const { return FALSE; }

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE) PURE_VIRTUAL(UUISceneClient::InputKey,return FALSE;);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE) PURE_VIRTUAL(UUISceneClient::InputAxis,return FALSE;);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character) PURE_VIRTUAL(UUISceneClient::InputChar,return FALSE;);

	/**
	 * Initializes the specified scene without opening it.
	 *
	 * @param	Scene				the scene to initialize;  if the scene specified is contained in a content package, a copy of the scene
	 *								will be created, and that scene will be initialized instead.
	 * @param	SceneOwner			the player that should be associated with the new scene.  Will be assigned to the scene's
	 *								PlayerOwner property.
	 * @param	InitializedScene	the scene that was actually initialized.  If Scene is located in a content package, InitializedScene will be
	 *								the copy of the scene that was created.  Otherwise, InitializedScene will be the same as the scene passed in.
	 *
	 * @return	TRUE if the scene was successfully initialized
	 */
	virtual UBOOL InitializeScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** InitializedScene=NULL );

	/**
	 * Adds the specified scene to the list of active scenes, loading the scene and performing initialization as necessary.
	 *
	 * @param	Scene			the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *							and the copy will be opened instead.
	 * @param	SceneOwner		the player that should be associated with the new scene.  Will be assigned to the scene's
	 *							PlayerOwner property.
	 * @param	OpenedScene		the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *							the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ForcedPriority	overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully opened
	 */
	virtual UBOOL OpenScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL, BYTE ForcedPriority=0 )
	{
		return FALSE;
	}

	/**
	 * Instances, initializes, and activates the specified scene, inserting it into the scene stack at the specified location.
	 *
	 * @param	DesiredInsertIndex	the index [into the ActiveScenes array] to insert the scene.  the scene's SceneStackPriority will take precedence over this value.
	 * @param	Scene				the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *								and the copy will be opened instead.
	 * @param	SceneOwner			the player that should be associated with the new scene.  Will be assigned to the scene's
	 *								PlayerOwner property.
	 * @param	OpenedScene			the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *								the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ActualInsertIndex	receives the location where the scene was actually inserted into the scene stack.
	 * @param	ForcedPriority		overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully activated and inserted into the scene stack (although not necessarily at the DesiredSceneIndex)
	 */
	virtual UBOOL InsertScene( INT DesiredInsertIndex, class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL, INT* ActualInsertIndex=NULL, BYTE ForcedPriority=0 )
	{
		return OpenScene(Scene, SceneOwner, OpenedScene, ForcedPriority);
	}

	/**
	 * Instances, initializes, and activates a scene, replacing an existing scene's location in the scene stack.  The existing scene will be deactivated and no longer part
	 * of the scene stack.  The location in the scene stack for the new scene instance may be modified if its SceneStackPriority requires the scene stack to be resorted.
	 *
	 * @param	SceneInstanceToReplace	the scene that should be replaced.
	 * @param	SceneToOpen				the scene that will replace the existing scene.  If the scene specified is contained in a content package, the scene will be duplicated and
	 *									the duplicate will be added instead.
	 * @param	SceneOwner				the player that should be associated with the new scene.  Will be assigned to the scene's
	 *									PlayerOwner property.
	 * @param	OpenedScene				the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *									the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ForcedPriority			overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully activated and inserted into the scene stack (although not necessarily at the DesiredSceneIndex)
	 */
	virtual UBOOL ReplaceScene( class UUIScene* SceneInstanceToReplace, class UUIScene* SceneToOpen, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL, BYTE ForcedPriority=0 )
	{
		return FALSE;
	}

	/**
	 * Instances, initializes, and activates a scene, replacing an existing scene's location in the scene stack.  The existing scene will be deactivated and no longer part
	 * of the scene stack.  The location in the scene stack for the new scene instance may be modified if its SceneStackPriority requires the scene stack to be resorted.
	 *
	 * @param	IndexOfSceneToReplace	the index into the stack of scenes for the scene to be replaced.
	 * @param	SceneToOpen				the scene that will replace the existing scene.  If the scene specified is contained in a content package, the scene will be duplicated and
	 *									the duplicate will be added instead.
	 * @param	SceneOwner				the player that should be associated with the new scene.  Will be assigned to the scene's
	 *									PlayerOwner property.
	 * @param	OpenedScene				the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *									the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	ForcedPriority			overrides the scene's SceneStackPriority value to allow callers to modify where the scene is placed in the stack.
	 *
	 * @return TRUE if the scene was successfully activated and inserted into the scene stack (although not necessarily at the DesiredSceneIndex)
	 */
	virtual UBOOL ReplaceSceneAtIndex( INT IndexOfSceneToReplace, class UUIScene* SceneToOpen, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL, BYTE ForcedPriority=0 )
	{
		return FALSE;
	}

	/**
	 * Deactivates the specified scene and removes it from the stack of scenes.
	 *
	 * @param	Scene				the scene to deactivate
	 * @param	bCloseChildScenes	normally any scenes which are higher in the stack than the scene being closed are also closed.  Specify
	 *								FALSE To override this behavior.
	 * @param	bForceCloseImmediately
	 *								indicates that the result of calling the scene's OnQueryCloseSceneAllowed delegate should be ignored; used
	 *								when closing all scenes as the result of a map change, for example.
	 *
	 * @return true if the scene was successfully deactivated
	 */
	virtual UBOOL CloseScene( class UUIScene* Scene, UBOOL bCloseChildScenes=TRUE, UBOOL bForceCloseImmediately=FALSE )
	{
		return FALSE;
	}

	/**
	 * Deactivates the scene located at the specified index in the stack of scenes.
	 *
	 * @param	SceneStackIndex		the index in the stack of scenes for the scene that should be deactivated
	 * @param	bCloseChildScenes	normally any scenes which are higher in the stack than the scene being closed are also closed.  Specify
	 *								FALSE To override this behavior.
	 * @param	bForceCloseImmediately
	 *								indicates that the result of calling the scene's OnQueryCloseSceneAllowed delegate should be ignored; used
	 *								when closing all scenes as the result of a map change, for example.
	 *
	 * @return true if the scene was successfully deactivated
	 */
	virtual UBOOL CloseSceneAtIndex( INT SceneStackIndex, UBOOL bCloseChildScenes=TRUE, UBOOL bForceCloseImmediately=FALSE )
	{
		return FALSE;
	}

	/**
	 * Perform 2D rendering for all active scenes
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 */
	virtual void RenderScenes( class FCanvas* Canvas ) PURE_VIRTUAL(UUISceneClient::RenderScenes,);

	/**
	 * Renders the specified scene and its widgets using a 2D plane
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 * @param	Scene	the UIScene to render
	 * @param	UIPostProcessGroup	Group determines current pp pass that is being rendered
	 */
	virtual void Render_Scene( class FCanvas* Canvas, UUIScene* Scene, EUIPostProcessGroup UIPostProcessGroup );

	/**
	 * Renders the specified scene's post process
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 * @param	Scene	the UIScene to render
	 * @param	UIPostProcessGroup	Group determines current pp pass that needs to be rendered
	 */
	virtual void Render_Scene_PostProcess( class FCanvas* Canvas, UUIScene* Scene, EUIPostProcessGroup UIPostProcessGroup );

	/**
	 * Re-initializes all primitives in the specified scene.  Will occur on the next tick.
	 *
	 * @param	Sender	the scene to re-initialize primitives for.
	 */
	virtual void RequestPrimitiveReinitialization( class UUIScene* Sender ) PURE_VIRTUAL(UUISceneClient::RequestPrimitiveReinitialization,);

	/**
	 * Gives all UIScenes a chance to create, attach, and/or initialize any primitives contained in the UIScene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene ) PURE_VIRTUAL(UUISceneClient::InitializePrimitives,);

	/**
	 * Updates 3D primitives for all active scenes
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateActivePrimitives( class FCanvasScene* CanvasScene ) PURE_VIRTUAL(UUISceneClient::UpdateActivePrimitives,);

	/**
	 * Updates 3D primitives for the specified scene and its child widgets.
	 *
	 * @param	CanvasScene	the scene to use for attaching any 3D primitives
	 * @param	Scene		the UIScene to update
	 */
	virtual void Update_ScenePrimitives( FCanvasScene* Canvas, UUIScene* Scene );

	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=SCENEFILTER_Any ) const PURE_VIRTUAL(UUISceneClient::IsUIActive,return FALSE;);

	/**
	 * Returns whether the specified scene has been fully initialized.  Different from UUIScene::IsInitialized() in that this
	 * method returns true only once all objects related to this scene have been created and initialized (e.g. in the UI editor
	 * only returns TRUE once the editor window for this scene has finished creation).
	 *
	 * @param	Scene	the scene to check.
	 */
	virtual UBOOL IsSceneInitialized( const class UUIScene* Scene ) const PURE_VIRTUAL(UUISceneClient::IsSceneInitialized,return TRUE;);

	/**
	 * Returns true if the UI scenes should be rendered with post process
	 *
	 * @return TRUE if post process is enabled for any of the UI scenes
	 */
	virtual UBOOL UsesPostProcess() const;
};

class UUIEventContainer : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIEventContainer,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIEventContainer)
};

class IUIEventContainer
{
protected:
	virtual ~IUIEventContainer() {}
public:
	typedef UUIEventContainer UClassType;
	virtual UObject* GetUObjectInterfaceUIEventContainer()=0;
    virtual void GetUIEvents(TArray<class UUIEvent*>& out_Events,class UClass* LimitClass=NULL)=0;
    virtual UBOOL AddSequenceObject(class USequenceObject* NewObj,UBOOL bRecurse=FALSE)=0;
    virtual void RemoveSequenceObject(class USequenceObject* ObjectToRemove)=0;
    virtual void RemoveSequenceObjects(const TArray<class USequenceObject*>& ObjectsToRemove)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIEventContainer)
};

struct UIState_eventIsStateAllowed_Parms
{
    class UUIScreenObject* Target;
    class UUIState* NewState;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventIsStateAllowed_Parms(EEventParm)
    {
    }
};
struct UIState_eventOnDeactivate_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL bPoppedState;
    UIState_eventOnDeactivate_Parms(EEventParm)
    {
    }
};
struct UIState_eventOnActivate_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL bPushedState;
    UIState_eventOnActivate_Parms(EEventParm)
    {
    }
};
struct UIState_eventDeactivateState_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventDeactivateState_Parms(EEventParm)
    {
    }
};
struct UIState_eventActivateState_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventActivateState_Parms(EEventParm)
    {
    }
};
struct UIState_eventIsWidgetClassSupported_Parms
{
    class UClass* WidgetClass;
    UBOOL ReturnValue;
    UIState_eventIsWidgetClassSupported_Parms(EEventParm)
    {
    }
};
class UUIState : public UUIRoot, public IUIEventContainer
{
public:
    //## BEGIN PROPS UIState
    class UUIStateSequence* StateSequence;
    TArrayNoInit<struct FInputKeyAction> StateInputActions;
    TArrayNoInit<struct FInputKeyAction> DisabledInputActions;
    FName MouseCursorName;
    BYTE PlayerIndexMask;
    BYTE StackPriority;
    //## END PROPS UIState

    UBOOL IsActiveForPlayer(INT PlayerIndex) const;
    void GetUIEvents(TArray<class UUIEvent*>& out_Events,class UClass* LimitClass=NULL);
    UBOOL AddSequenceObject(class USequenceObject* NewObj,UBOOL bRecurse=FALSE);
    void RemoveSequenceObject(class USequenceObject* ObjectToRemove);
    void RemoveSequenceObjects(const TArray<class USequenceObject*>& ObjectsToRemove);
    DECLARE_FUNCTION(execIsActiveForPlayer)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=IsActiveForPlayer(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetUIEvents)
    {
        P_GET_TARRAY_REF(class UUIEvent*,out_Events);
        P_GET_OBJECT_OPTX(UClass,LimitClass,NULL);
        P_FINISH;
        GetUIEvents(out_Events,LimitClass);
    }
    DECLARE_FUNCTION(execAddSequenceObject)
    {
        P_GET_OBJECT(USequenceObject,NewObj);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        *(UBOOL*)Result=AddSequenceObject(NewObj,bRecurse);
    }
    DECLARE_FUNCTION(execRemoveSequenceObject)
    {
        P_GET_OBJECT(USequenceObject,ObjectToRemove);
        P_FINISH;
        RemoveSequenceObject(ObjectToRemove);
    }
    DECLARE_FUNCTION(execRemoveSequenceObjects)
    {
        P_GET_TARRAY_REF(class USequenceObject*,ObjectsToRemove);
        P_FINISH;
        RemoveSequenceObjects(ObjectsToRemove);
    }
    UBOOL eventIsStateAllowed(class UUIScreenObject* Target,class UUIState* NewState,INT PlayerIndex)
    {
        UIState_eventIsStateAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Target=Target;
        Parms.NewState=NewState;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsStateAllowed),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnDeactivate(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPoppedState)
    {
        UIState_eventOnDeactivate_Parms Parms(EC_EventParm);
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bPoppedState=bPoppedState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_OnDeactivate),&Parms);
    }
    void eventOnActivate(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPushedState)
    {
        UIState_eventOnActivate_Parms Parms(EC_EventParm);
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bPushedState=bPushedState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_OnActivate),&Parms);
    }
    UBOOL eventDeactivateState(class UUIScreenObject* Target,INT PlayerIndex)
    {
        UIState_eventDeactivateState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_DeactivateState),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivateState(class UUIScreenObject* Target,INT PlayerIndex)
    {
        UIState_eventActivateState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateState),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsWidgetClassSupported(class UClass* WidgetClass)
    {
        UIState_eventIsWidgetClassSupported_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.WidgetClass=WidgetClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsWidgetClassSupported),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIState,UUIRoot,0,Engine)
    virtual UObject* GetUObjectInterfaceUIEventContainer(){return this;}
	/**
	 * Called when the state is created.
	 */
	virtual void Created();

	/**
	 * Creates and initializes a UIStateSequence for this UIState.
	 *
	 * @param	SequenceName	the name for the new sequence.  only specified when importing (copy/paste) to ensure that
	 *							the new sequence's name matches the name for any references to that sequence in the t3d text
	 */
	virtual void CreateStateSequence( FName SequenceName=NAME_None );

	/**
	 * Returns the widget that contains this UIState.
	 */
	UUIScreenObject* GetOwner() const;

	/**
	 * Activate this state for the specified target.
	 *
	 * @param	Target			the widget that is activating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be activated for the specified
	 *			Target or this state was already part of the Target's state stack.
	 */
	virtual UBOOL ActivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Deactivate this state for the specified target.
	 *
	 * @param	Target			the widget that is deactivating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be deactivated for the specified
	 *			Target or this state wasn't part of the Target's state stack.
	 */
	virtual UBOOL DeactivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );

	/**
	 * Adds the specified InputAction to this UIState's StateInputActions array, if it doesn't already exist.
	 *
	 * @param	InputAction		the key/action combo that will be scoped by this UIState
	 */
	virtual void AddInputAction( const FInputKeyAction& InputAction );

	/**
	 * Removes the specified InputAction from this UIState's StateInputActions array.  If the input action was instanced
	 * from a default input action in the widget class's default properties, adds the input action to the state's DisabledInputActions array
	 *
	 * @param	InputAction		the key/action combo to remove from this state's list of input keys
	 */
	virtual void RemoveInputAction( const FInputKeyAction& InputAction );

	/**
	 * Adds the specified PlayerIndex to this state's PlayerIndexMask, indicating that this state is now active for that
	 * player.
	 */
	void EnablePlayerIndex( INT PlayerIndex );

	/**
	 * Removes the specified PlayerIndex from this state's PlayerIndexMask, indicating that this state is now active for that
	 * player.
	 */
	void DisablePlayerIndex( INT PlayerIndex );

	/**
	 * Changes this state's StackPriority to the specified value.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	NewStackPriority	the new priority to assign to this state
	 * @param	bSkipNotification	specify TRUE to prevent the widget from re-resolving its style (useful when calling
	 *								this method on several states at a time)
	 */
	void SetStatePriority( INT PlayerIndex, BYTE NewStackPriority, UBOOL bSkipNotification=FALSE );

	/**
	 * Resets this state's StackPriority to its default value.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bSkipNotification	specify TRUE to prevent the widget from re-resolving its style (useful when calling
	 *								this method on several states at a time)
	 */
	void ResetStatePriority( INT PlayerIndex, UBOOL bSkipNotification=FALSE );

protected:
	/**
	 * Called when this state's StackPriority is changed at runtime.  Moves the state to the appropriate location in the
	 * the owning widget's list of active states, if applicable.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bSendNotification	specify TRUE to re-resolve the owning widget's style if the top-most state changed as
	 *								a result of this state's StackPriority changing.
	 */
	virtual void OnStackPriorityChanged( INT PlayerIndex, UBOOL bSendNotification );

public:

	/* === UObject interface === */
	/**
	 * Called after the object has loaded.
	 */
	virtual void PostLoad();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class UUIState_Disabled : public UUIState
{
public:
    //## BEGIN PROPS UIState_Disabled
    //## END PROPS UIState_Disabled

    DECLARE_CLASS(UUIState_Disabled,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIState_Enabled : public UUIState
{
public:
    //## BEGIN PROPS UIState_Enabled
    //## END PROPS UIState_Enabled

    DECLARE_CLASS(UUIState_Enabled,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIString : public UUIRoot
{
public:
    //## BEGIN PROPS UIString
    TArrayNoInit<FUIStringNode*> Nodes;
    struct FUICombinedStyleData StringStyleData;
    FVector2D StringExtent;
    //## END PROPS UIString

    virtual UBOOL SetValue(const FString& InputString,UBOOL bIgnoreMarkup);
    FString GetValue(UBOOL bReturnProcessedText=TRUE) const;
    void GetAutoScaleValue(FVector2D BoundingRegionSize,FVector2D StringSize,FVector2D& out_AutoScalePercent) const;
    UBOOL ContainsMarkup() const;
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(InputString);
        P_GET_UBOOL(bIgnoreMarkup);
        P_FINISH;
        *(UBOOL*)Result=SetValue(InputString,bIgnoreMarkup);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnProcessedText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnProcessedText);
    }
    DECLARE_FUNCTION(execGetAutoScaleValue)
    {
        P_GET_STRUCT(FVector2D,BoundingRegionSize);
        P_GET_STRUCT(FVector2D,StringSize);
        P_GET_STRUCT_REF(FVector2D,out_AutoScalePercent);
        P_FINISH;
        GetAutoScaleValue(BoundingRegionSize,StringSize,out_AutoScalePercent);
    }
    DECLARE_FUNCTION(execContainsMarkup)
    {
        P_FINISH;
        *(UBOOL*)Result=ContainsMarkup();
    }
    DECLARE_CLASS(UUIString,UUIRoot,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIScreenObject)
	/* === UIString Interface === */
	/**
	 * Calculates the size of the specified string.
	 *
	 * @param	Parameters	Used for various purposes
	 *							DrawXL:		[out] will be set to the width of the string
	 *							DrawYL:		[out] will be set to the height of the string
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[out] specifies the amount of scaling to apply to the string
	 * @param	pText		the string to calculate the size for
	 * @param	EOL			a pointer to a single character that is used as the end-of-line marker in this string
	 * @param	bStripTrailingCharSpace
	 *						whether the inter-character spacing following the last character should be included in the calculated width of the result string
	 */
	static void StringSize( FRenderParameters& Parameters, const TCHAR* pText, const TCHAR* EOL=NULL, UBOOL bStripTrailingCharSpace=TRUE );

	/**
	 * Clips text to the bounding region specified.
	 *
	 * @param	Parameters			Various:
	 *									DrawX:		[in] specifies the pixel location of the start of the bounding region that should be used for clipping
	 *									DrawXL:		[in] specifies the pixel location of the end of the bounding region that should be used for clipping
	 *												[out] set to the width of out_ResultString, in pixels
	 *									DrawY:		unused
	 *									DrawYL:		[out] set to the height of the string
	 *									Scaling:	specifies the amount of scaling to apply to the string
	 * @param	pText				the text that should be clipped
	 * @param	out_ResultString	[out] a string containing all characters from the source string that fit into the bounding region
	 * @param	ClipAlignment		controls which part of the input string is preserved (remains after clipping).
	 * @param	bStripTrailingCharSpace
	 *								whether the inter-character spacing following the last character should be included in the calculated width of the result string
	 * @param	bClipToNearestEdge	indicates whether the last character should be included in the result string if its midpoint is inside the bounding region.
	 */
	static void ClipString( FRenderParameters& Parameters, const TCHAR* pText, FString& out_ResultString, EUIAlignment ClipAlignment=UIALIGN_Left, UBOOL bStripTrailingCharSpace=TRUE, UBOOL bClipToNearestEdge=FALSE );

	/**
	 * Parses a single string into an array of strings that will fit inside the specified bounding region.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the pixel location of the start of the horizontal bounding region that should be used for wrapping.
	 *							DrawY:		[in] specifies the Y origin of the bounding region.  This should normally be set to 0, as this will be
	 *										     used as the base value for DrawYL.
	 *										[out] Will be set to the Y position (+YL) of the last line, i.e. the total height of all wrapped lines relative to the start of the bounding region
	 *							DrawXL:		[in] specifies the pixel location of the end of the horizontal bounding region that should be used for wrapping
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.  A input value of 0 indicates that
	 *										     the bounding region height should not be considered.  Once the total height of lines reaches this
	 *										     value, the function returns and no further processing occurs.
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in] specifies the amount of scaling to apply to the string
	 * @param	CurX			specifies the pixel location to begin the wrapping; usually equal to the X pos of the bounding region, unless wrapping is initiated
	 *								in the middle of the bounding region (i.e. indentation)
	 * @param	pText			the text that should be wrapped
	 * @param	out_Lines		[out] will contain an array of strings which fit inside the bounding region specified.  Does
	 *							not clear the array first.
	 * @param	EOL				a pointer to a single character that is used as the end-of-line marker in this string
	 * @param	MaxLines		the maximum number of lines that can be created.
	 */
	static void WrapString( FRenderParameters& Parameters, FLOAT CurX, const TCHAR* pText, TArray<struct FWrappedStringElement>& out_Lines, const TCHAR* EOL = NULL, INT MaxLines = MAXINT);

	/**
	 * Changes the style data for this UIString.
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringStyle( const struct FUICombinedStyleData& NewStringStyle );

	/**
	 * Changes the complete style for this UIString.
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringStyle( class UUIStyle_Combo* NewStringStyle );

	/**
	 * Changes the text style for this UIString.
	 *
	 * @param	NewTextStyle	the new text style data to use
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringTextStyle( const struct FStyleDataReference& NewTextStyle );

	/**
	 * Changes the text style for this UIString.
	 *
	 * @param	NewSourceStyle	the UIStyle object to retrieve the new text style data from
	 * @param	NewSourceState	the menu state corresponding to the style data to apply to the string
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringTextStyle( UUIStyle* NewSourceStyle, UUIState* NewSourceState );

	/**
	 * Changes the image style for this UIString.
	 *
	 * @param	NewTextStyle	the new image style data to use
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringImageStyle( const struct FStyleDataReference& NewImageStyle );

	/**
	 * Changes the image style for this UIString.
	 *
	 * @param	NewSourceStyle	the UIStyle object to retrieve the new image style data from
	 * @param	NewSourceState	the menu state corresponding to the style data to apply to the string
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringImageStyle( UUIStyle* NewSourceStyle, UUIState* NewSourceState );

	/**
	 * Retrieves the UIState that should be used for applying style data.
	 */
	virtual class UUIState* GetCurrentMenuState() const;

	/**
	 * Propagates the string's text and image styles to all existing string nodes.
	 */
	void RefreshNodeStyles();

	/**
	 * Removes all slave nodes which were created as a result of wrapping or other string formatting, appending their RenderedText
	 * to the parent node.
	 */
	void UnrollWrappedNodes();

	/**
	 * Reformats this UIString's nodes to fit within the bounding region specified.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the X position of the bounding region, in pixels
	 *										[out] Will be set to the X position of the end of the last node in the string.
	 *							DrawY:		[out] Will be set to the Y position of the last node in the string
	 *							DrawXL:		[in] specifies the width of the bounding region, in pixels.
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.
	 *							DrawFont:	unused
	 *							Scale:		unused
	 * @param	bIgnoreMarkup	if TRUE, does not attempt to process any markup and only one UITextNode is created
	 */
	void ApplyFormatting( FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Converts the raw source text containing optional markup (such as tokens and inline images)
	 * into renderable data structures.
	 *
	 * @param	InputString			A string containing optional markup.
	 * @param	bSystemMarkupOnly	if TRUE, only system generated markup will be processed (such as markup for rendering carets, etc.)
	 * @param	out_Nodes			[out] A collection of UITextNodes which will contain the parsed nodes.
	 * @param	StringNodeModifier	the style data to use as the starting point for string node modifications.  If not specified, uses the
	 *								string's DefaultStringStyle as the starting point.  Generally only specified when recursively calling
	 *								ParseString.
	 *
	 * @return	TRUE if InputString was successfully parsed into out_Nodes
	 */
	UBOOL ParseString( const FString& InputString, UBOOL bSystemMarkupOnly, TArray<FUIStringNode*>& out_Nodes, struct FUIStringNodeModifier* StringNodeModifier=NULL ) const;

	/**
	 * Render this UIString using the parameters specified.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this string
	 * @param	Parameters	the bounds for the region that this string can render to.
	 */
	void Render_String( FCanvas* Canvas, const FRenderParameters& Parameters );

	/**
	 * Calculates the height of a single line of text using the string's default text style for sizing.
	 *
	 * @return	the average height a single line in this string, in pixels, using the string's current text style.
	 */
	FLOAT GetDefaultLineHeight( FLOAT ViewportHeight ) const;

	/**
	 * Retrieves a list of all data stores resolved by this UIString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by this string.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	void GetResolvedDataStores( TArray<class UUIDataStore*>& StringDataStores );

	/**
	 * Gets the size of the viewport.
	 *
	 * @param	out_ViewportSize	receives the viewport size.
	 *
	 * @return	TRUE if the viewport size was retrieved successfully.
	 */
	virtual UBOOL GetViewportSize( FVector2D& out_ViewportSize ) const;

protected:

	/**
	 * Find the data store that has the specified tag.
	 *
	 * @param	DataStoreTag	A name corresponding to the 'Tag' property of a data store
	 *
	 * @return	a pointer to the data store that has a Tag corresponding to DataStoreTag, or NULL if no data
	 *			were found with that tag.
	 */
	UUIDataStore* ResolveDataStore( FName DataStoreTag ) const;

	/**
	 * Deletes all nodes allocated by this UIString and empties the Nodes array
	 */
	void ClearNodes();

	/**
	 * Hook for adjusting the extents and render text of any nodes prior to applyig formatting data.
	 *
	 * @param	FormatData	contains the precalculated formatting data (available bounding region size, etc.)
	 *
	 * @return	TRUE to indicate that the string has been preclipping (forces UUIString::ApplyFormatting to use UIALIGN_Left
	 *			instead of the configured text clip mode, if the string must be clipped further).
	 */
	virtual UBOOL AdjustNodeExtents( struct FNodeFormattingData& FormatData ) { return FALSE; }

public:
	/* === UObject interface. === */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void FinishDestroy();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

struct UIStyle_eventGetDefaultStyle_Parms
{
    class UUIStyle_Data* ReturnValue;
    UIStyle_eventGetDefaultStyle_Parms(EEventParm)
    {
    }
};
class UUIStyle : public UUIRoot
{
public:
    //## BEGIN PROPS UIStyle
    struct FSTYLE_ID StyleID;
    FName StyleTag;
    FStringNoInit StyleName;
    FStringNoInit StyleGroupName;
    class UClass* StyleDataClass;
    TMap< class UUIState*,class UUIStyle_Data* > StateDataMap;
    //## END PROPS UIStyle

    class UUIStyle_Data* GetStyleForState(class UUIState* StateObject) const;
    class UUIStyle_Data* GetStyleForStateByClass(class UClass* StateClass) const;
    DECLARE_FUNCTION(execGetStyleForState)
    {
        P_GET_OBJECT(UUIState,StateObject);
        P_FINISH;
        *(class UUIStyle_Data**)Result=GetStyleForState(StateObject);
    }
    DECLARE_FUNCTION(execGetStyleForStateByClass)
    {
        P_GET_OBJECT(UClass,StateClass);
        P_FINISH;
        *(class UUIStyle_Data**)Result=GetStyleForStateByClass(StateClass);
    }
    class UUIStyle_Data* eventGetDefaultStyle()
    {
        UIStyle_eventGetDefaultStyle_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDefaultStyle),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIStyle,UUIRoot,0,Engine)
    DECLARE_WITHIN(UUISkin)
	/**
	 *	Obtain style data for the specified state from the archetype style
	 *
	 *	@param StateObject	State for which the data will be extracted
	 *	@return returns the corresponding state data or NULL archetype doesn't contain this state or
	 *			if this style's archetype is the class default object
	 */
	UUIStyle_Data* GetArchetypeStyleForState(class UUIState* StateObject) const;

	/**
	 * Called when this style is loaded by its owner skin.
	 *
	 * @param	OwnerSkin	the skin that contains this style.
	 */
	void InitializeStyle( class UUISkin* OwnerSkin );

	/**
	 * Get the name for this style.
	 *
	 * @return	If the value for StyleName is identical to the value for this style's template, returns this style's
	 *			StyleTag....otherwise, returns this style's StyleName
	 */
	FString	GetStyleName() const;

	/**
	 * Creates and initializes a new style data object for the UIState specified.
	 *
	 * @param	StateToAdd		the state to add style data for.  If StateToAdd does not have either the RF_ArchetypeObject
	 * 							or RF_ClassDefaultObject flags set, the new style data will be associated with StateToAdd's
	 *							ObjectArchetype instead.
	 * @param	DataArchetype	if specified, uses this object as the template for the new style data object
	 */
	UUIStyle_Data* AddNewState( class UUIState* StateToAdd, class UUIStyle_Data* DataArchetype=NULL );

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @param	DataToCheck		if specified, returns whether the values have been modified for that style data only.  If not
	 *							specified, checks all style data contained by this style.
	 *
	 * @return	TRUE if the style data contained by this style needs to be reapplied to any widgets using this style.
	 */
	UBOOL IsDirty( UUIStyle_Data* DataToCheck=NULL ) const;

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @param	StateToCheck	if specified, returns whether the values have been modified for that menu state's style data only.
	 *							If not specified, checks all style data contained by this style.
	 *
	 * @return	TRUE if the style data contained by this style needs to be reapplied to any widgets using this style.
	 */
	UBOOL IsDirty( UUIState* StateToCheck=NULL ) const;

	/**
	 * Sets or clears the dirty flag for this style, which indicates whether this style's data should be reapplied.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 * @param	Target		if specified, only sets the dirty flag for this style data object.  Otherwise, sets the dirty
	 *						flag for all style data contained by this style.
	 */
	void SetDirtiness( UBOOL bIsDirty, UUIStyle_Data* Target=NULL );

	/**
	 * Creates a newly constructed copy of the receiver with a hard copy of its StateDataMap.
	 * New style will be transient and cannot be saved out.
	 *
	 * @return	Pointer to a newly constructed transient copy of the passed style
	 */
	UUIStyle* CreateTransientCopy();

	/**
	 * Returns TRUE if this style indirectly references specified style through its DataMap
	 */
	UBOOL ReferencesStyle(const UUIStyle* Style) const;

	/**
     * Returns TRUE if this style is one of the designated default styles
     */
    UBOOL IsDefaultStyle() const;

    /**
     * Restores the archetype for the specified style and reinitializes the style data object against the new archetype,
	 * preserving the values serialized into StyleData
     *
     * @param	StyleData			the style data object that has the wrong archetype
     * @param	StyleDataArchetype	the style data object that should be the archetype
     */
	void RestoreStyleArchetype( class UUIStyle_Data* StyleData, class UUIStyle_Data* StyleDataArchetype );

	/* === UObject interface === */
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& Objects );

	/** File I/O */
	virtual void Serialize( FArchive& Ar );

	/**
	 * Fixes the archetypes for any style data objects which have lost their archetypes.
	 */
	virtual void PostLoad();

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIComponent : public UComponent
{
public:
    //## BEGIN PROPS UIComponent
    //## END PROPS UIComponent

    DECLARE_ABSTRACT_CLASS(UUIComponent,UComponent,0,Engine)
    DECLARE_WITHIN(UUIScreenObject)
	/* === UObject interface === */
	/**
	 * Called just after a property in this object's archetype is modified, immediately after this object has been de-serialized
	 * from the archetype propagation archive.
	 *
	 * Allows objects to perform reinitialization specific to being de-serialized from an FArchetypePropagationArc and
	 * reinitialized against an archetype. Only called for instances of archetypes, where the archetype has the RF_ArchetypeObject flag.
	 */
	virtual void PostSerializeFromPropagationArchive();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for UIScreenObjects is handled by the UIPrefab/UIPrefabInstance code, so this version just
	 * skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class UUIComp_Event : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_Event
    TArrayNoInit<struct FDefaultEventSpecification> DefaultEvents;
    class UUISequence* EventContainer;
    class UUIEvent_ProcessInput* InputProcessor;
    TArrayNoInit<FName> DisabledEventAliases;
    //## END PROPS UIComp_Event

    void RegisterInputEvents(class UUIState* InputEventOwner,INT PlayerIndex);
    void UnregisterInputEvents(class UUIState* InputEventOwner,INT PlayerIndex);
    DECLARE_FUNCTION(execRegisterInputEvents)
    {
        P_GET_OBJECT(UUIState,InputEventOwner);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        RegisterInputEvents(InputEventOwner,PlayerIndex);
    }
    DECLARE_FUNCTION(execUnregisterInputEvents)
    {
        P_GET_OBJECT(UUIState,InputEventOwner);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        UnregisterInputEvents(InputEventOwner,PlayerIndex);
    }
    DECLARE_CLASS(UUIComp_Event,UUIComponent,0,Engine)
	/**
	 * Returns the widget associated with this event provider.
	 */
	class UUIScreenObject* GetOwner() const;

	/**
	 * Called when the screen object that owns this UIComp_Event is created.  Creates the UISequence which will contain
	 * the events for this widget, instances any objects assigned to the DefaultEvents array and adds those instances
	 * to the sequence container.
	 */
	void Created();

	/**
	 * Determines which sequences should be instanced for the widget that owns this event component.  Note that this method
	 * does not care whether the sequences have ALREADY been instanced - it just determines whether a sequence should be instanced
	 * in the case where the corresponding sequence container has a NULL sequence.
	 *
	 * @param	out_EventsToInstance	will receive the list of indexes of the event templates which have linked ops, thus need to be instanced
	 *
	 * @return	TRUE if the global sequence for this component should be instanced.
	 */
	UBOOL ShouldInstanceSequence( TArray<INT>& out_EventsToInstance );

	/**
	 * Determines whether the specified event template should be instanced when this event component is initializing its sequence.
	 *
	 * @param	DefaultIndex	index into the DefaultEvents array for the event to check
	 *
	 * @return	returns TRUE if the event located at the specified index is valid for instancing; FALSE otherwise.
	 *			Note that this function does not care whether the event has ALREADY been instanced or not - just whether
	 *			it is valid to instance that event.
	 */
	UBOOL ShouldInstanceDefaultEvent( INT DefaultIndex );

	/**
	 * Creates the sequence for this event component
	 *
	 * @param	SequenceName	optionally specify the name for the sequence container....used by the T3D import code to
	 *							make sure that the new sequence can be resolved by other objects which reference it
	 *
	 * @return	a pointer to a new UISequence which has this component as its Outer
	 */
	class UUISequence* CreateEventContainer( FName SequenceName=NAME_None ) const;

	/**
	 * Initializes the sequence associated with this event component.  Assigns the parent sequence for the EventContainer
	 * to the UISequence associated with the widget that owns this component's owner widget.
	 *
	 * @param	bInitializeSequence		if TRUE, calls InitializeSequence on the sequence owned by this widget.  Should only
	 *									be TRUE in the game.
	 */
	void InitializeEventProvider( UBOOL bInitializeSequence=GIsGame );

	/**
	 * Cleans up any references to objects contained in other widgets.  Called when the owning widget is removed from the scene.
	 */
	void CleanupEventProvider();

	/**
	 * Adds the specified sub-sequence to the widget's list of nested sequences.
	 *
	 * @param	StateSequence	the sequence to add.  This should be a sequence owned by one of the UIStates in this
	 *							widget's InactiveStates array.
	 *
	 * @return	TRUE if the sequence was successfully added to [or if it already existed] the widget's sequence
	 */
	virtual UBOOL PushStateSequence( class UUIStateSequence* StateSequence );

	/**
	 * Removes the specified sub-sequence from the widget's list of nested sequences.
	 *
	 * @param	StateSequence	the sequence to remove.  This should be a sequence owned by one of the UIStates in this
	 *							widget's InactiveStates array.
	 *
	 * @return	TRUE if the sequence was successfully removed [or wasn't in the list] from the widget's sequence
	 */
	virtual UBOOL PopStateSequence( class UUIStateSequence* StateSequence );

protected:
	/**
	 * Creates a UIEvent_ProcessInput object for routing input events to actions.
	 */
	void CreateInputProcessor();

	/**
	 * Assigns the parent sequence for this widget's sequence to the sequence owned by this widget's parent, if necessary.
	 */
	void SetParentSequence();

	/**
	 * Creates instances for any newly attached actions, variables, etc. that were declared in the class defaultproperties which don't exist in the sequence.
	 *
	 * @param	StateInstanceMap	maps the DefaultStates array to the UIState instance of that class living in the owning widget's InactiveStates array
	 * @param	EventsToInstance	the indexes for the elements of the DefaultEvents array which should be instanced.
	 */
	void InstanceEventTemplates( TMap<UClass*,UUIState*>& StateInstanceMap, const TArray<INT>& EventsToInstance );

	/**
	 * Creates an UIEvent instance using the DefaultEvent template located at the index specified.
	 *
	 * @param	TargetContainer		the UIEventContainer that will contain the newly instanced ops
	 * @param	DefaultIndex	index into the DefaultEvents array for the template to use when creating the event
	 *
	 * @return	a pointer to the UIEvent instance that was creatd, or NULL if it couldn't be created for some reason
	 */
	UUIEvent* InstanceDefaultEvent( class IUIEventContainer* TargetContainer, INT DefaultIndex );

	/**
	 * Used for initializing sequence operations which have been instanced from event templates assigned to the
	 * DefaultEvents array.  Iterates through the op's input links, output links, and variable links, instancing
	 * any linked sequence objects which are contained within a class default object.
	 *
	 * @param	TargetContainer		the UIEventContainer that will contain the newly instanced ops
	 * @param	OpInstance			the SequenceOp to initialize.  This should either be a UIEvent created during
	 *								UUIComp_Event::Created() or some other sequence op referenced by an script-declared
	 */
	void InitializeInstancedOp( class IUIEventContainer* TargetContainer, class USequenceOp* OpInstance );

	/**
	 * Generates a list of UIEvent instances that have been previously created and added to either the widget's sequence
	 * or one of its states.
	 *
	 * @param	StateInstanceMap		map of UIState classes to the corresonding instance of that UIState from the owning widget's
	 *									InactiveStates array
	 * @param	out_ExistingEventMap	Will be filled with the list of previously instanced UIEvents, mapped to
	 *									their corresponding containers
	 */
	void GetInstancedEvents( TMap<UClass*,UUIState*>& StateInstanceMap, TMultiMap<IUIEventContainer*,UUIEvent*>& out_ExistingEventMap );

public:
	/** Fixup default event templates that were incorrectly instanced */
	virtual void PostLoad();
};

#endif // !INCLUDED_ENGINE_USERINTERFACE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindPlayerDataStoreIndex);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execGetAvailableDataStores);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execUnregisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execRegisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execCreateDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindDataStore);
AUTOGENERATE_FUNCTION(UInput,-1,execGetBind);
AUTOGENERATE_FUNCTION(UInput,-1,execResetInput);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInit);
AUTOGENERATE_FUNCTION(UUIComp_Event,-1,execUnregisterInputEvents);
AUTOGENERATE_FUNCTION(UUIComp_Event,-1,execRegisterInputEvents);
AUTOGENERATE_FUNCTION(UUIInputConfiguration,-1,execNotifyGameSessionEnded);
AUTOGENERATE_FUNCTION(UUIInputConfiguration,-1,execLoadInputAliasClasses);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execCreateScene);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execCreateTransientWidget);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execPlayUISound);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetDataStoreClient);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerControllerId);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerIndex);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerCount);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetDataStoreFieldValue);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execSetDataStoreFieldValue);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetPrimitiveTransform);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execSetMouseCaptureOverride);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCursorSize);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCursorPosition);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetFaceOrientation);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetSceneClient);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCurrentUIController);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetInputPlatformType);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execUpdateCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execChangeMouseCursor);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execSetMousePosition);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execCloseSceneAtIndex);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execCloseScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execReplaceSceneAtIndex);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execReplaceScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execInsertScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execOpenScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execInitializeScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execIsSceneInitialized);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execIsUIActive);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execChangeActiveSkin);
AUTOGENERATE_FUNCTION(UUIState,-1,execRemoveSequenceObjects);
AUTOGENERATE_FUNCTION(UUIState,-1,execRemoveSequenceObject);
AUTOGENERATE_FUNCTION(UUIState,-1,execAddSequenceObject);
AUTOGENERATE_FUNCTION(UUIState,-1,execGetUIEvents);
AUTOGENERATE_FUNCTION(UUIState,-1,execIsActiveForPlayer);
AUTOGENERATE_FUNCTION(UUIString,-1,execContainsMarkup);
AUTOGENERATE_FUNCTION(UUIString,-1,execGetAutoScaleValue);
AUTOGENERATE_FUNCTION(UUIString,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIString,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIStyle,-1,execGetStyleForStateByClass);
AUTOGENERATE_FUNCTION(UUIStyle,-1,execGetStyleForState);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_USERINTERFACE_NATIVE_DEFS
#define ENGINE_USERINTERFACE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UConsole);
DECLARE_NATIVE_TYPE(Engine,UDataStoreClient);
DECLARE_NATIVE_TYPE(Engine,UInput);
DECLARE_NATIVE_TYPE(Engine,UInteraction);
DECLARE_NATIVE_TYPE(Engine,UPlayerInput);
DECLARE_NATIVE_TYPE(Engine,UPlayerManagerInteraction);
DECLARE_NATIVE_TYPE(Engine,UUIComp_Event);
DECLARE_NATIVE_TYPE(Engine,UUIComponent);
DECLARE_NATIVE_TYPE(Engine,UUIEventContainer);
DECLARE_NATIVE_TYPE(Engine,UUIInputConfiguration);
DECLARE_NATIVE_TYPE(Engine,UUIInteraction);
DECLARE_NATIVE_TYPE(Engine,UUILayerBase);
DECLARE_NATIVE_TYPE(Engine,UUIRoot);
DECLARE_NATIVE_TYPE(Engine,UUISceneClient);
DECLARE_NATIVE_TYPE(Engine,UUIState);
DECLARE_NATIVE_TYPE(Engine,UUIState_Disabled);
DECLARE_NATIVE_TYPE(Engine,UUIState_Enabled);
DECLARE_NATIVE_TYPE(Engine,UUIString);
DECLARE_NATIVE_TYPE(Engine,UUIStyle);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_USERINTERFACE \
	UConsole::StaticClass(); \
	UDataStoreClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUDataStoreClientNative; \
	UInput::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUInputNative; \
	UInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUInteractionNative; \
	UPlayerInput::StaticClass(); \
	UPlayerManagerInteraction::StaticClass(); \
	UUIComp_Event::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_EventNative; \
	UUIComponent::StaticClass(); \
	UUIEventContainer::StaticClass(); \
	UUIInputConfiguration::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIInputConfigurationNative; \
	UUIInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIInteractionNative; \
	UUILayerBase::StaticClass(); \
	UUIRoot::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIRootNative; \
	UUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISceneClientNative; \
	UUIState::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStateNative; \
	UUIState_Disabled::StaticClass(); \
	UUIState_Enabled::StaticClass(); \
	UUIString::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStringNative; \
	UUIStyle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStyleNative; \

#endif // ENGINE_USERINTERFACE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UDataStoreClient) GEngineUDataStoreClientNatives[] = 
{ 
	MAP_NATIVE(UDataStoreClient,execFindPlayerDataStoreIndex)
	MAP_NATIVE(UDataStoreClient,execGetAvailableDataStores)
	MAP_NATIVE(UDataStoreClient,execUnregisterDataStore)
	MAP_NATIVE(UDataStoreClient,execRegisterDataStore)
	MAP_NATIVE(UDataStoreClient,execCreateDataStore)
	MAP_NATIVE(UDataStoreClient,execFindDataStore)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UDataStoreClient);

NATIVE_INFO(UInput) GEngineUInputNatives[] = 
{ 
	MAP_NATIVE(UInput,execGetBind)
	MAP_NATIVE(UInput,execResetInput)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UInput);

NATIVE_INFO(UInteraction) GEngineUInteractionNatives[] = 
{ 
	MAP_NATIVE(UInteraction,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UInteraction);

NATIVE_INFO(UUIComp_Event) GEngineUUIComp_EventNatives[] = 
{ 
	MAP_NATIVE(UUIComp_Event,execUnregisterInputEvents)
	MAP_NATIVE(UUIComp_Event,execRegisterInputEvents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_Event);

NATIVE_INFO(UUIInputConfiguration) GEngineUUIInputConfigurationNatives[] = 
{ 
	MAP_NATIVE(UUIInputConfiguration,execNotifyGameSessionEnded)
	MAP_NATIVE(UUIInputConfiguration,execLoadInputAliasClasses)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIInputConfiguration);

NATIVE_INFO(UUIInteraction) GEngineUUIInteractionNatives[] = 
{ 
	MAP_NATIVE(UUIInteraction,execCreateScene)
	MAP_NATIVE(UUIInteraction,execCreateTransientWidget)
	MAP_NATIVE(UUIInteraction,execPlayUISound)
	MAP_NATIVE(UUIInteraction,execGetDataStoreClient)
	MAP_NATIVE(UUIInteraction,execGetPlayerControllerId)
	MAP_NATIVE(UUIInteraction,execGetPlayerIndex)
	MAP_NATIVE(UUIInteraction,execGetPlayerCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIInteraction);

NATIVE_INFO(UUIRoot) GEngineUUIRootNatives[] = 
{ 
	MAP_NATIVE(UUIRoot,execGetDataStoreFieldValue)
	MAP_NATIVE(UUIRoot,execSetDataStoreFieldValue)
	MAP_NATIVE(UUIRoot,execGetPrimitiveTransform)
	MAP_NATIVE(UUIRoot,execSetMouseCaptureOverride)
	MAP_NATIVE(UUIRoot,execGetCursorSize)
	MAP_NATIVE(UUIRoot,execGetCursorPosition)
	MAP_NATIVE(UUIRoot,execGetFaceOrientation)
	MAP_NATIVE(UUIRoot,execGetSceneClient)
	MAP_NATIVE(UUIRoot,execGetCurrentUIController)
	MAP_NATIVE(UUIRoot,execGetInputPlatformType)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIRoot);

NATIVE_INFO(UUISceneClient) GEngineUUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UUISceneClient,execGetInverseCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execGetCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execUpdateCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execChangeMouseCursor)
	MAP_NATIVE(UUISceneClient,execSetMousePosition)
	MAP_NATIVE(UUISceneClient,execCloseSceneAtIndex)
	MAP_NATIVE(UUISceneClient,execCloseScene)
	MAP_NATIVE(UUISceneClient,execReplaceSceneAtIndex)
	MAP_NATIVE(UUISceneClient,execReplaceScene)
	MAP_NATIVE(UUISceneClient,execInsertScene)
	MAP_NATIVE(UUISceneClient,execOpenScene)
	MAP_NATIVE(UUISceneClient,execInitializeScene)
	MAP_NATIVE(UUISceneClient,execIsSceneInitialized)
	MAP_NATIVE(UUISceneClient,execIsUIActive)
	MAP_NATIVE(UUISceneClient,execChangeActiveSkin)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISceneClient);

NATIVE_INFO(UUIState) GEngineUUIStateNatives[] = 
{ 
	MAP_NATIVE(UUIState,execRemoveSequenceObjects)
	MAP_NATIVE(UUIState,execRemoveSequenceObject)
	MAP_NATIVE(UUIState,execAddSequenceObject)
	MAP_NATIVE(UUIState,execGetUIEvents)
	MAP_NATIVE(UUIState,execIsActiveForPlayer)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIState);

NATIVE_INFO(UUIString) GEngineUUIStringNatives[] = 
{ 
	MAP_NATIVE(UUIString,execContainsMarkup)
	MAP_NATIVE(UUIString,execGetAutoScaleValue)
	MAP_NATIVE(UUIString,execGetValue)
	MAP_NATIVE(UUIString,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIString);

NATIVE_INFO(UUIStyle) GEngineUUIStyleNatives[] = 
{ 
	MAP_NATIVE(UUIStyle,execGetStyleForStateByClass)
	MAP_NATIVE(UUIStyle,execGetStyleForState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIStyle);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,Console,ConsoleTargetPlayer)
VERIFY_CLASS_OFFSET_NODIE(U,Console,TypedStrPos)
VERIFY_CLASS_SIZE_NODIE(UConsole)
VERIFY_CLASS_OFFSET_NODIE(U,DataStoreClient,GlobalDataStoreClasses)
VERIFY_CLASS_OFFSET_NODIE(U,DataStoreClient,PlayerDataStores)
VERIFY_CLASS_SIZE_NODIE(UDataStoreClient)
VERIFY_CLASS_OFFSET_NODIE(U,Input,Bindings)
VERIFY_CLASS_OFFSET_NODIE(U,Input,AxisArray)
VERIFY_CLASS_SIZE_NODIE(UInput)
VERIFY_CLASS_OFFSET_NODIE(U,Interaction,__OnReceivedNativeInputKey__Delegate)
VERIFY_CLASS_OFFSET_NODIE(U,Interaction,__OnInitialize__Delegate)
VERIFY_CLASS_SIZE_NODIE(UInteraction)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerInput,LastAxisKeyName)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerInput,MouseSamplingTotal)
VERIFY_CLASS_SIZE_NODIE(UPlayerInput)
VERIFY_CLASS_SIZE_NODIE(UPlayerManagerInteraction)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_Event,DefaultEvents)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_Event,DisabledEventAliases)
VERIFY_CLASS_SIZE_NODIE(UUIComp_Event)
VERIFY_CLASS_SIZE_NODIE(UUIComponent)
VERIFY_CLASS_SIZE_NODIE(UUIEventContainer)
VERIFY_CLASS_OFFSET_NODIE(U,UIInputConfiguration,WidgetInputAliases)
VERIFY_CLASS_OFFSET_NODIE(U,UIInputConfiguration,AxisEmulationDefinitions)
VERIFY_CLASS_SIZE_NODIE(UUIInputConfiguration)
VERIFY_CLASS_OFFSET_NODIE(U,UIInteraction,SceneClientClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIInteraction,CanvasScene)
VERIFY_CLASS_SIZE_NODIE(UUIInteraction)
VERIFY_CLASS_SIZE_NODIE(UUILayerBase)
VERIFY_CLASS_SIZE_NODIE(UUIRoot)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneClient,RenderViewport)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneClient,UIScenePostProcess)
VERIFY_CLASS_SIZE_NODIE(UUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(U,UIState,StateSequence)
VERIFY_CLASS_OFFSET_NODIE(U,UIState,StackPriority)
VERIFY_CLASS_SIZE_NODIE(UUIState)
VERIFY_CLASS_SIZE_NODIE(UUIState_Disabled)
VERIFY_CLASS_SIZE_NODIE(UUIState_Enabled)
VERIFY_CLASS_OFFSET_NODIE(U,UIString,Nodes)
VERIFY_CLASS_OFFSET_NODIE(U,UIString,StringExtent)
VERIFY_CLASS_SIZE_NODIE(UUIString)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle,StyleID)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle,StateDataMap)
VERIFY_CLASS_SIZE_NODIE(UUIStyle)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
