/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_AUDIODEVICE_ENUMS
#define INCLUDED_ENGINE_AUDIODEVICE_ENUMS 1

enum ETTSSpeaker
{
    TTSSPEAKER_Paul         =0,
    TTSSPEAKER_Harry        =1,
    TTSSPEAKER_Frank        =2,
    TTSSPEAKER_Dennis       =3,
    TTSSPEAKER_Kit          =4,
    TTSSPEAKER_Betty        =5,
    TTSSPEAKER_Ursula       =6,
    TTSSPEAKER_Rita         =7,
    TTSSPEAKER_Wendy        =8,
    TTSSPEAKER_MAX          =9,
};
enum ESoundClassName
{
    Master                  =0,
    ESoundClassName_MAX     =1,
};

#endif // !INCLUDED_ENGINE_AUDIODEVICE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_AUDIODEVICE_CLASSES
#define INCLUDED_ENGINE_AUDIODEVICE_CLASSES 1

struct FListener
{
    class APortalVolume* PortalVolume;
    FVector Location;
    FVector Up;
    FVector Right;
    FVector Front;

    /** Constructors */
    FListener() {}
    FListener(EEventParm)
    {
        appMemzero(this, sizeof(FListener));
    }
};

struct FAudioGroupInfo
{
    INT NumResident;
    INT SizeResident;
    INT NumRealTime;
    INT SizeRealTime;

    /** Constructors */
    FAudioGroupInfo() {}
    FAudioGroupInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAudioGroupInfo));
    }
};

struct FSoundGroupProperties
{
    FLOAT Volume;
    FLOAT Pitch;
    FLOAT VoiceCenterChannelVolume;
    FLOAT VoiceRadioVolume;
    BITFIELD bApplyEffects:1;
    BITFIELD bAlwaysPlay:1;
    BITFIELD bIsUISound:1;
    BITFIELD bIsMusic:1;
    BITFIELD bNoReverb:1;
    BITFIELD bBleedStereo:1;

		/** Interpolate the data in sound groups */
		void Interpolate( FLOAT InterpValue, FSoundGroupProperties& Start, FSoundGroupProperties& End );
	
};

struct FSoundGroup
{
    struct FSoundGroupProperties Properties;
    FName GroupName;
    TArrayNoInit<FName> ChildGroupNames;

    /** Constructors */
    FSoundGroup() {}
    FSoundGroup(EEventParm)
    {
        appMemzero(this, sizeof(FSoundGroup));
    }
};

class UAudioDevice : public USubsystem
{
public:
    //## BEGIN PROPS AudioDevice
    INT MaxChannels;
    INT CommonAudioPoolSize;
    BITFIELD UseEffectsProcessing:1;
    BITFIELD bGameWasTicking:1;
    BITFIELD bTestLowPassFilter:1;
    BITFIELD bDisableLowPassFilter:1;
    BITFIELD bTestEQFilter:1;
    BITFIELD bDisableEQFilter:1;
    BITFIELD bTestRadioFilter:1;
    BITFIELD bDisableRadioFilter:1;
    FPointer CommonAudioPool;
    INT CommonAudioPoolFreeBytes;
    TArrayNoInit<class UAudioComponent*> AudioComponents;
    TArrayNoInit<FSoundSource*> Sources;
    TArrayNoInit<FSoundSource*> FreeSources;
    TMap<FWaveInstance*, FSoundSource*> WaveInstanceSourceMap;
    TArrayNoInit<struct FListener> Listeners;
    QWORD CurrentTick;
    TMap<FName, INT> NameToSoundGroupIndexMap;
    TArrayNoInit<struct FSoundGroup> SourceSoundGroups;
    TArrayNoInit<struct FSoundGroup> CurrentSoundGroups;
    TArrayNoInit<struct FSoundGroup> DestinationSoundGroups;
    TArrayNoInit<struct FSoundGroup> SoundGroups;
    TMap<FName, class USoundMode*> SoundModes;
    class FAudioEffectsManager* Effects;
    class USoundMode* CurrentMode;
    DOUBLE SoundModeStartTime;
    DOUBLE SoundModeFadeInStartTime;
    DOUBLE SoundModeFadeInEndTime;
    DOUBLE SoundModeEndTime;
    class UAudioComponent* TestAudioComponent;
    class FTextToSpeech* TextToSpeech;
    FLOAT TransientMasterVolume;
    //## END PROPS AudioDevice

    void SetSoundMode(FName NewMode);
    DECLARE_FUNCTION(execSetSoundMode)
    {
        P_GET_NAME(NewMode);
        P_FINISH;
        SetSoundMode(NewMode);
    }
    DECLARE_CLASS(UAudioDevice,USubsystem,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	friend class FSoundSource;

	/** Constructor */
	UAudioDevice( void ) 
	{
	}

	/**
	 * Basic initialisation of the platform agnostic layer of the audio system
	 */
	virtual UBOOL Init( void );

	/**
	 * Stop all the audio components and sources attached to the scene. NULL scene means all components.
	 */
	virtual void Flush( FSceneInterface* Scene );

	/**
	 * Add any referenced objects that shouldn't be garbage collected
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	/**
	 * Complete the destruction of this class
	 */
	virtual void FinishDestroy( void );

	/**
	 * Handle pausing/unpausing of sources when entering or leaving pause mode
	 */
	void HandlePause( UBOOL bGameTicking );

	/**
	 * Iterate over the active AudioComponents for wave instances that could be playing
	 */
	INT GetSortedActiveWaveInstances( TArray<FWaveInstance*>& WaveInstances, UBOOL bGameTicking );

	/**
	 * Stop sources that are no longer audible
	 */
	void StopSources( TArray<FWaveInstance*>& WaveInstances, INT FirstActiveIndex );

	/**
	 * Start and/or update any sources that have a high enough priority to play
	 */
	void StartSources( TArray<FWaveInstance*>& WaveInstances, INT FirstActiveIndex, UBOOL bGameTicking );

	/**
	 * The audio system's main "Tick" function
	 */
	virtual void Update( UBOOL bGameTicking );

	/**
	 * Sets the listener's location and orientation for the viewport
	 */
	void SetListener( INT ViewportIndex, INT MaxViewportIndex, const FVector& Location, const FVector& Up, const FVector& Right, const FVector& Front );

	/**
	 * Stops all game sounds (and possibly UI) sounds
	 *
	 * @param bShouldStopUISounds If TRUE, this function will stop UI sounds as well
	 */
	virtual void StopAllSounds( UBOOL bShouldStopUISounds = FALSE );

	/**
	 * Pushes the specified reverb settings onto the reverb settings stack.
	 *
	 * @param	ReverbSettings		The reverb settings to use.
	 */
	void SetReverbSettings( const FReverbSettings& ReverbSettings );

	/**
	 * Frees the bulk resource data assocated with this SoundNodeWave.
	 *
	 * @param	SoundNodeWave	wave object to free associated bulk data
	 */
	virtual void FreeResource( USoundNodeWave* SoundNodeWave )
	{
	}

	/**
	 * Precaches the passed in sound node wave object.
	 *
	 * @param	SoundNodeWave	Resource to be precached.
	 */
	virtual void Precache( USoundNodeWave* SoundNodeWave )
	{
	}

	/**
	 * Lists all the loaded sounds and their memory footprint
	 */
	virtual void ListSounds( const TCHAR* Cmd, FOutputDevice& Ar )
	{
	}
	
	/**
	 * Sets the 'pause' state of sounds which are always loaded.
	 *
	 * @param	bPaused			Pause sounds if TRUE, play paused sounds if FALSE.
	 */
	virtual void PauseAlwaysLoadedSounds(UBOOL bPaused)
	{
	}

	/**
	 * Check for errors and output a human readable string
	 */
	virtual UBOOL ValidateAPICall( const TCHAR* Function, INT ErrorCode )
	{
		return( TRUE );
	}
	
	/** 
	 * Gets a summary of loaded sound collated by group
	 */
	void GetSoundGroupInfo( TMap<FName, FAudioGroupInfo>& AudioGroupInfos );
	
	/**
	 * Lists all the playing waveinstances and their associated source
	 */
	void ListWaves( FOutputDevice& Ar );
	
	/**
	 * Lists a summary of loaded sound collated by group
	 */
	void ListSoundGroups( FOutputDevice& Ar );

	/**
	 * Set up the sound group hierarchy
	 */
	void InitSoundClasses( void );

	/**
	 * Add a newly created sound mode to the base set
	 */
	void AddMode( USoundMode* Mode );

	/**
	 * Load up all requested sound modes
	 */
	void InitSoundModes( void );

	/**
	 * Returns the sound group properties associates with a sound group taking into account
	 * the group tree.
	 *
	 * @param	SoundGroupName	name of sound group to retrieve properties from
	 * @return	sound group properties if a sound group with name SoundGroupName exists, NULL otherwise
	 */
	FSoundGroupProperties* GetSoundGroupProperties( FName SoundGroupName );

	/**
	 * Parses the sound groups and propagates multiplicative properties down the tree.
	 */
	void ParseSoundClasses( void );

	/**
	 * Construct the CurrentSoundGroupProperties map
	 *
	 * This contains the original sound group properties propagated properly, and all adjustments due to the sound mode
	 */
	void GetCurrentSoundGroupState( void );

	/**
	 * Gets the parameters for EQ based on settings and time
	 */
	void Interpolate( FLOAT InterpValue, FSoundGroupProperties& Current, FSoundGroupProperties& Start, FSoundGroupProperties& End );

	/**
	 * Set the mode for altering sound group properties
	 */
	void ApplySoundMode( USoundMode* NewMode );

	/**
	 * Adds a component to the audio device
	 */
	void AddComponent( UAudioComponent* AudioComponent );

	/**
	 * Removes an attached audio component
	 */
	void RemoveComponent( UAudioComponent* AudioComponent );

	/**
	 * Creates an audio component to handle playing a sound cue
	 */
	static UAudioComponent* CreateComponent( USoundCue* SoundCue, FSceneInterface* Scene, AActor* Actor = NULL, UBOOL Play = TRUE, UBOOL bStopWhenOwnerDestroyed = FALSE, FVector* Location = NULL );

	/**
	 * Exec
	 */
	UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Ar = *GLog );

	/**
	 * PostEditChange
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Serialize
	 */
	virtual void Serialize( FArchive& Ar );

	/**
	 * Platform dependent call to init effect data on a sound source
	 */
	void* InitEffect( FSoundSource* Source );

	/**
	 * Platform dependent call to update the sound output with new parameters
	 */
	void* UpdateEffect( FSoundSource* Source );

	/**
	 * Platform dependent call to destroy any effect related data
	 */
	void DestroyEffect( FSoundSource* Source );

	/**
	 * Updates sound group volumes
	 */
	void SetGroupVolume( FName Group, FLOAT Volume );

	/**
	 * Return the pointer to the sound effects handler
	 */
	class FAudioEffectsManager* GetEffects( void )
	{
		return( Effects );
	}

	/**
	 * Checks to see if a coordinate is within a distance of any listener
	 */
	UBOOL LocationIsAudible( FVector Location, FLOAT MaxDistance );

	/**
	 * Creates a soundcue and PCM data for a the text in SpokenText
	 */ 
	USoundCue* CreateTTSSoundCue( const FString& SpokenText, ETTSSpeaker Speaker );

	/**
	 * Checks to see if the low pass filter is being tested
	 */
	UBOOL IsTestingLowPassFilter( void ) const
	{
		return( bTestLowPassFilter );
	}

	/**
	 * Checks to see if the low pass filter has been disabled
	 */
	UBOOL IsDisabledLowPassFilter( void ) const
	{
		return( bDisableLowPassFilter );
	}

	/**
	 * Checks to see if the EQ filter is being tested
	 */
	UBOOL IsTestingEQFilter( void ) const
	{
		return( bTestEQFilter );
	}

	/**
	 * Checks to see if the EQ filter has been disabled
	 */
	UBOOL IsDisabledEQFilter( void ) const
	{
		return( bDisableEQFilter );
	}

	/**
	 * Checks to see if the EQ filter is being tested
	 */
	UBOOL IsTestingRadioFilter( void ) const
	{
		return( bTestRadioFilter );
	}

	/**
	 * Checks to see if the EQ filter has been disabled
	 */
	UBOOL IsDisabledRadioFilter( void ) const
	{
		return( bDisableRadioFilter );
	}

protected:
	/** Internal */
	void SortWaveInstances( INT MaxChannels );

	/**
	 * Internal helper function used by ParseSoundGroups to traverse the tree.
	 *
	 * @param CurrentGroup			Subtree to deal with
	 * @param ParentProperties		Propagated properties of parent node
	 */
	void RecurseIntoSoundGroups( FSoundGroup* CurrentGroup, FSoundGroupProperties* ParentProperties );
};

#endif // !INCLUDED_ENGINE_AUDIODEVICE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UAudioDevice,-1,execSetSoundMode);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_AUDIODEVICE_NATIVE_DEFS
#define ENGINE_AUDIODEVICE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UAudioDevice);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_AUDIODEVICE \
	UAudioDevice::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAudioDeviceNative; \

#endif // ENGINE_AUDIODEVICE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UAudioDevice) GEngineUAudioDeviceNatives[] = 
{ 
	MAP_NATIVE(UAudioDevice,execSetSoundMode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAudioDevice);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,AudioDevice,MaxChannels)
VERIFY_CLASS_OFFSET_NODIE(U,AudioDevice,TransientMasterVolume)
VERIFY_CLASS_SIZE_NODIE(UAudioDevice)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
