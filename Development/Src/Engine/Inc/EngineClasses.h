/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2008 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_ENUMS
#define INCLUDED_ENGINE_ENUMS 1

enum EDoubleClickDir
{
    DCLICK_None             =0,
    DCLICK_Left             =1,
    DCLICK_Right            =2,
    DCLICK_Forward          =3,
    DCLICK_Back             =4,
    DCLICK_Active           =5,
    DCLICK_Done             =6,
    DCLICK_MAX              =7,
};
enum ETravelType
{
    TRAVEL_Absolute         =0,
    TRAVEL_Partial          =1,
    TRAVEL_Relative         =2,
    TRAVEL_MAX              =3,
};
enum ECollisionType
{
    COLLIDE_CustomDefault   =0,
    COLLIDE_NoCollision     =1,
    COLLIDE_BlockAll        =2,
    COLLIDE_BlockWeapons    =3,
    COLLIDE_TouchAll        =4,
    COLLIDE_TouchWeapons    =5,
    COLLIDE_BlockAllButWeapons=6,
    COLLIDE_TouchAllButWeapons=7,
    COLLIDE_BlockWeaponsKickable=8,
    COLLIDE_MAX             =9,
};
enum ENetRole
{
    ROLE_None               =0,
    ROLE_SimulatedProxy     =1,
    ROLE_AutonomousProxy    =2,
    ROLE_Authority          =3,
    ROLE_MAX                =4,
};
enum EMoveDir
{
    MD_Stationary           =0,
    MD_Forward              =1,
    MD_Backward             =2,
    MD_Left                 =3,
    MD_Right                =4,
    MD_Up                   =5,
    MD_Down                 =6,
    MD_MAX                  =7,
};
enum EPhysics
{
    PHYS_None               =0,
    PHYS_Walking            =1,
    PHYS_Falling            =2,
    PHYS_Swimming           =3,
    PHYS_Flying             =4,
    PHYS_Rotating           =5,
    PHYS_Projectile         =6,
    PHYS_Interpolating      =7,
    PHYS_Spider             =8,
    PHYS_Ladder             =9,
    PHYS_RigidBody          =10,
    PHYS_SoftBody           =11,
    PHYS_Unused             =12,
    PHYS_MAX                =13,
};
enum ECsgOper
{
    CSG_Active              =0,
    CSG_Add                 =1,
    CSG_Subtract            =2,
    CSG_Intersect           =3,
    CSG_Deintersect         =4,
    CSG_MAX                 =5,
};
enum EStreamingVolumeUsage
{
    SVB_Loading             =0,
    SVB_LoadingAndVisibility=1,
    SVB_VisibilityBlockingOnLoad=2,
    SVB_BlockingOnLoad      =3,
    SVB_LoadingNotVisible   =4,
    SVB_MAX                 =5,
};
enum EAmbientOcclusionQuality
{
    AO_High                 =0,
    AO_Medium               =1,
    AO_Low                  =2,
    AO_MAX                  =3,
};
enum EFocusType
{
    FOCUS_Distance          =0,
    FOCUS_Position          =1,
    FOCUS_MAX               =2,
};
enum ReverbPreset
{
    REVERB_Default          =0,
    REVERB_Bathroom         =1,
    REVERB_StoneRoom        =2,
    REVERB_Auditorium       =3,
    REVERB_ConcertHall      =4,
    REVERB_Cave             =5,
    REVERB_Hallway          =6,
    REVERB_StoneCorridor    =7,
    REVERB_Alley            =8,
    REVERB_Forest           =9,
    REVERB_City             =10,
    REVERB_Mountains        =11,
    REVERB_Quarry           =12,
    REVERB_Plain            =13,
    REVERB_ParkingLot       =14,
    REVERB_SewerPipe        =15,
    REVERB_Underwater       =16,
    REVERB_SmallRoom        =17,
    REVERB_MediumRoom       =18,
    REVERB_LargeRoom        =19,
    REVERB_MediumHall       =20,
    REVERB_LargeHall        =21,
    REVERB_Plate            =22,
    REVERB_MAX              =23,
};
enum EViewTargetBlendFunction
{
    VTBlend_Linear          =0,
    VTBlend_Cubic           =1,
    VTBlend_EaseIn          =2,
    VTBlend_EaseOut         =3,
    VTBlend_EaseInOut       =4,
    VTBlend_MAX             =5,
};
enum EPropertyValueMappingType
{
    PVMT_RawValue           =0,
    PVMT_PredefinedValues   =1,
    PVMT_Ranged             =2,
    PVMT_IdMapped           =3,
    PVMT_MAX                =4,
};
enum ESettingsDataType
{
    SDT_Empty               =0,
    SDT_Int32               =1,
    SDT_Int64               =2,
    SDT_Double              =3,
    SDT_String              =4,
    SDT_Float               =5,
    SDT_Blob                =6,
    SDT_DateTime            =7,
    SDT_MAX                 =8,
};
enum EOnlineDataAdvertisementType
{
    ODAT_DontAdvertise      =0,
    ODAT_OnlineService      =1,
    ODAT_QoS                =2,
    ODAT_OnlineServiceAndQoS=3,
    ODAT_MAX                =4,
};
enum EOnlineNewsType
{
    ONT_Unknown             =0,
    ONT_GameNews            =1,
    ONT_ContentAnnouncements=2,
    ONT_Misc                =3,
    ONT_MAX                 =4,
};
enum EOnlineAccountCreateStatus
{
    OACS_CreateSuccessful   =0,
    OACS_UnknownError       =1,
    OACS_InvalidUserName    =2,
    OACS_InvalidPassword    =3,
    OACS_InvalidUniqueUserName=4,
    OACS_UniqueUserNameInUse=5,
    OACS_ServiceUnavailable =6,
    OACS_MAX                =7,
};
enum ELanBeaconState
{
    LANB_NotUsingLanBeacon  =0,
    LANB_Hosting            =1,
    LANB_Searching          =2,
    LANB_MAX                =3,
};
enum ENATType
{
    NAT_Unknown             =0,
    NAT_Open                =1,
    NAT_Moderate            =2,
    NAT_Strict              =3,
    NAT_MAX                 =4,
};
enum EOnlineServerConnectionStatus
{
    OSCS_NotConnected       =0,
    OSCS_Connected          =1,
    OSCS_ConnectionDropped  =2,
    OSCS_NoNetworkConnection=3,
    OSCS_ServiceUnavailable =4,
    OSCS_UpdateRequired     =5,
    OSCS_ServersTooBusy     =6,
    OSCS_DuplicateLoginDetected=7,
    OSCS_InvalidUser        =8,
    OSCS_MAX                =9,
};
enum EOnlineFriendState
{
    OFS_Offline             =0,
    OFS_Online              =1,
    OFS_Away                =2,
    OFS_Busy                =3,
    OFS_MAX                 =4,
};
enum EOnlineEnumerationReadState
{
    OERS_NotStarted         =0,
    OERS_InProgress         =1,
    OERS_Done               =2,
    OERS_Failed             =3,
    OERS_MAX                =4,
};
enum EOnlineGameState
{
    OGS_NoSession           =0,
    OGS_Pending             =1,
    OGS_Starting            =2,
    OGS_InProgress          =3,
    OGS_Ending              =4,
    OGS_Ended               =5,
    OGS_MAX                 =6,
};
enum ENetworkNotificationPosition
{
    NNP_TopLeft             =0,
    NNP_TopCenter           =1,
    NNP_TopRight            =2,
    NNP_CenterLeft          =3,
    NNP_Center              =4,
    NNP_CenterRight         =5,
    NNP_BottomLeft          =6,
    NNP_BottomCenter        =7,
    NNP_BottomRight         =8,
    NNP_MAX                 =9,
};
enum EFeaturePrivilegeLevel
{
    FPL_Disabled            =0,
    FPL_EnabledFriendsOnly  =1,
    FPL_Enabled             =2,
    FPL_MAX                 =3,
};
enum ELoginStatus
{
    LS_NotLoggedIn          =0,
    LS_UsingLocalProfile    =1,
    LS_LoggedIn             =2,
    LS_MAX                  =3,
};
enum EOnlineGameSearchSortType
{
    OGSSO_Ascending         =0,
    OGSSO_Descending        =1,
    OGSSO_MAX               =2,
};
enum EOnlineGameSearchComparisonType
{
    OGSCT_Equals            =0,
    OGSCT_NotEquals         =1,
    OGSCT_GreaterThan       =2,
    OGSCT_GreaterThanEquals =3,
    OGSCT_LessThan          =4,
    OGSCT_LessThanEquals    =5,
    OGSCT_MAX               =6,
};
enum EOnlineGameSearchEntryType
{
    OGSET_Property          =0,
    OGSET_LocalizedSetting  =1,
    OGSET_ObjectProperty    =2,
    OGSET_MAX               =3,
};
enum EProgressMessageType
{
    PMT_Clear               =0,
    PMT_Information         =1,
    PMT_AdminMessage        =2,
    PMT_DownloadProgress    =3,
    PMT_ConnectionFailure   =4,
    PMT_SocketFailure       =5,
    PMT_MAX                 =6,
};
enum EInputMatchAction
{
    IMA_GreaterThan         =0,
    IMA_LessThan            =1,
    IMA_MAX                 =2,
};
enum EInputTypes
{
    IT_XAxis                =0,
    IT_YAxis                =1,
    IT_MAX                  =2,
};
enum ECoverLocationDescription
{
    CoverDesc_None          =0,
    CoverDesc_InWindow      =1,
    CoverDesc_InDoorway     =2,
    CoverDesc_BehindCar     =3,
    CoverDesc_BehindTruck   =4,
    CoverDesc_OnTruck       =5,
    CoverDesc_BehindBarrier =6,
    CoverDesc_BehindColumn  =7,
    CoverDesc_BehindCrate   =8,
    CoverDesc_BehindWall    =9,
    CoverDesc_BehindStatue  =10,
    CoverDesc_BehindSandbags=11,
    CoverDesc_MAX           =12,
};
enum ECoverType
{
    CT_None                 =0,
    CT_Standing             =1,
    CT_MidLevel             =2,
    CT_MAX                  =3,
};
enum ECoverDirection
{
    CD_Default              =0,
    CD_Left                 =1,
    CD_Right                =2,
    CD_Up                   =3,
    CD_MAX                  =4,
};
enum ECoverAction
{
    CA_Default              =0,
    CA_BlindLeft            =1,
    CA_BlindRight           =2,
    CA_LeanLeft             =3,
    CA_LeanRight            =4,
    CA_PopUp                =5,
    CA_BlindUp              =6,
    CA_PeekLeft             =7,
    CA_PeekRight            =8,
    CA_PeekUp               =9,
    CA_MAX                  =10,
};
enum EDoorType
{
    DOOR_Shoot              =0,
    DOOR_Touch              =1,
    DOOR_MAX                =2,
};
enum ECoverGroupFillAction
{
    CGFA_Overwrite          =0,
    CGFA_Add                =1,
    CGFA_Remove             =2,
    CGFA_Clear              =3,
    CGFA_Cylinder           =4,
    CGFA_MAX                =5,
};
enum FWFileType
{
    FWFT_Log                =0,
    FWFT_Stats              =1,
    FWFT_HTML               =2,
    FWFT_User               =3,
    FWFT_Debug              =4,
    FWFT_MAX                =5,
};
enum ERouteType
{
    ERT_Linear              =0,
    ERT_Loop                =1,
    ERT_Circle              =2,
    ERT_MAX                 =3,
};
enum ERouteDirection
{
    ERD_Forward             =0,
    ERD_Reverse             =1,
    ERD_MAX                 =2,
};
enum ERouteFillAction
{
    RFA_Overwrite           =0,
    RFA_Add                 =1,
    RFA_Remove              =2,
    RFA_Clear               =3,
    RFA_MAX                 =4,
};
enum EConsoleType
{
    CONSOLE_Any             =0,
    CONSOLE_Xbox360         =1,
    CONSOLE_PS3             =2,
    CONSOLE_MAX             =3,
};
enum ENetMode
{
    NM_Standalone           =0,
    NM_DedicatedServer      =1,
    NM_ListenServer         =2,
    NM_Client               =3,
    NM_MAX                  =4,
};
enum EWeaponFireType
{
    EWFT_InstantHit         =0,
    EWFT_Projectile         =1,
    EWFT_Custom             =2,
    EWFT_None               =3,
    EWFT_MAX                =4,
};
enum EPathSearchType
{
    PST_Default             =0,
    PST_Breadth             =1,
    PST_NewBestPathTo       =2,
    PST_Constraint          =3,
    PST_MAX                 =4,
};
enum ESceneCaptureViewMode
{
    SceneCapView_Lit        =0,
    SceneCapView_Unlit      =1,
    SceneCapView_LitNoShadows=2,
    SceneCapView_Wire       =3,
    SceneCapView_MAX        =4,
};
enum DistributionParamMode
{
    DPM_Normal              =0,
    DPM_Abs                 =1,
    DPM_Direct              =2,
    DPM_MAX                 =3,
};
enum EFontImportCharacterSet
{
    FontICS_Default         =0,
    FontICS_Ansi            =1,
    FontICS_Symbol          =2,
    FontICS_MAX             =3,
};
enum ESafeZoneType
{
    eSZ_TOP                 =0,
    eSZ_BOTTOM              =1,
    eSZ_LEFT                =2,
    eSZ_RIGHT               =3,
    eSZ_MAX                 =4,
};
enum ESplitScreenType
{
    eSST_NONE               =0,
    eSST_2P_HORIZONTAL      =1,
    eSST_2P_VERTICAL        =2,
    eSST_3P_FAVOR_TOP       =3,
    eSST_3P_FAVOR_BOTTOM    =4,
    eSST_4P                 =5,
    eSST_MAX                =6,
};
enum EProfileVoiceThruSpeakersOptions
{
    PVTSO_Off               =0,
    PVTSO_On                =1,
    PVTSO_Both              =2,
    PVTSO_MAX               =3,
};
enum EProfileControllerVibrationToggleOptions
{
    PCVTO_Off               =0,
    PCVTO_IgnoreThis        =1,
    PCVTO_IgnoreThis2       =2,
    PCVTO_On                =3,
    PCVTO_MAX               =4,
};
enum EProfileXInversionOptions
{
    PXIO_Off                =0,
    PXIO_On                 =1,
    PXIO_MAX                =2,
};
enum EProfileYInversionOptions
{
    PYIO_Off                =0,
    PYIO_On                 =1,
    PYIO_MAX                =2,
};
enum EProfileRaceAcceleratorControlOptions
{
    PRACO_Trigger           =0,
    PRACO_Button            =1,
    PRACO_MAX               =2,
};
enum EProfileRaceBrakeControlOptions
{
    PRBCO_Trigger           =0,
    PRBCO_Button            =1,
    PRBCO_MAX               =2,
};
enum EProfileRaceCameraLocationOptions
{
    PRCLO_Behind            =0,
    PRCLO_Front             =1,
    PRCLO_Inside            =2,
    PRCLO_MAX               =3,
};
enum EProfileRaceTransmissionOptions
{
    PRTO_Auto               =0,
    PRTO_Manual             =1,
    PRTO_MAX                =2,
};
enum EProfileMovementControlOptions
{
    PMCO_L_Thumbstick       =0,
    PMCO_R_Thumbstick       =1,
    PMCO_MAX                =2,
};
enum EProfileAutoCenterOptions
{
    PACO_Off                =0,
    PACO_On                 =1,
    PACO_MAX                =2,
};
enum EProfileAutoAimOptions
{
    PAAO_Off                =0,
    PAAO_On                 =1,
    PAAO_MAX                =2,
};
enum EProfilePreferredColorOptions
{
    PPCO_None               =0,
    PPCO_Black              =1,
    PPCO_White              =2,
    PPCO_Yellow             =3,
    PPCO_Orange             =4,
    PPCO_Pink               =5,
    PPCO_Red                =6,
    PPCO_Purple             =7,
    PPCO_Blue               =8,
    PPCO_Green              =9,
    PPCO_Brown              =10,
    PPCO_Silver             =11,
    PPCO_MAX                =12,
};
enum EProfileControllerSensitivityOptions
{
    PCSO_Medium             =0,
    PCSO_Low                =1,
    PCSO_High               =2,
    PCSO_MAX                =3,
};
enum EProfileDifficultyOptions
{
    PDO_Normal              =0,
    PDO_Easy                =1,
    PDO_Hard                =2,
    PDO_MAX                 =3,
};
enum EOnlineProfileAsyncState
{
    OPAS_None               =0,
    OPAS_Read               =1,
    OPAS_Write              =2,
    OPAS_MAX                =3,
};
enum EProfileSettingID
{
    PSI_Unknown             =0,
    PSI_ControllerVibration =1,
    PSI_YInversion          =2,
    PSI_GamerCred           =3,
    PSI_GamerRep            =4,
    PSI_VoiceMuted          =5,
    PSI_VoiceThruSpeakers   =6,
    PSI_VoiceVolume         =7,
    PSI_GamerPictureKey     =8,
    PSI_GamerMotto          =9,
    PSI_GamerTitlesPlayed   =10,
    PSI_GamerAchievementsEarned=11,
    PSI_GameDifficulty      =12,
    PSI_ControllerSensitivity=13,
    PSI_PreferredColor1     =14,
    PSI_PreferredColor2     =15,
    PSI_AutoAim             =16,
    PSI_AutoCenter          =17,
    PSI_MovementControl     =18,
    PSI_RaceTransmission    =19,
    PSI_RaceCameraLocation  =20,
    PSI_RaceBrakeControl    =21,
    PSI_RaceAcceleratorControl=22,
    PSI_GameCredEarned      =23,
    PSI_GameAchievementsEarned=24,
    PSI_EndLiveIds          =25,
    PSI_ProfileVersionNum   =26,
    PSI_ProfileSaveCount    =27,
    PSI_MAX                 =28,
};
enum EOnlineProfilePropertyOwner
{
    OPPO_None               =0,
    OPPO_OnlineService      =1,
    OPPO_Game               =2,
    OPPO_MAX                =3,
};
enum EMaterialUsage
{
    MATUSAGE_SkeletalMesh   =0,
    MATUSAGE_FracturedMeshes=1,
    MATUSAGE_ParticleSprites=2,
    MATUSAGE_BeamTrails     =3,
    MATUSAGE_ParticleSubUV  =4,
    MATUSAGE_Foliage        =5,
    MATUSAGE_SpeedTree      =6,
    MATUSAGE_StaticLighting =7,
    MATUSAGE_GammaCorrection=8,
    MATUSAGE_LensFlare      =9,
    MATUSAGE_InstancedMeshParticles=10,
    MATUSAGE_FluidSurface   =11,
    MATUSAGE_Decals         =12,
    MATUSAGE_MaterialEffect =13,
    MATUSAGE_MAX            =14,
};
enum EMaterialLightingModel
{
    MLM_Phong               =0,
    MLM_NonDirectional      =1,
    MLM_Unlit               =2,
    MLM_SHPRT               =3,
    MLM_Custom              =4,
    MLM_MAX                 =5,
};
enum EBlendMode
{
    BLEND_Opaque            =0,
    BLEND_Masked            =1,
    BLEND_Translucent       =2,
    BLEND_Additive          =3,
    BLEND_Modulate          =4,
    BLEND_MAX               =5,
};
enum TextureGroup
{
    TEXTUREGROUP_World      =0,
    TEXTUREGROUP_WorldNormalMap=1,
    TEXTUREGROUP_WorldSpecular=2,
    TEXTUREGROUP_Character  =3,
    TEXTUREGROUP_CharacterNormalMap=4,
    TEXTUREGROUP_CharacterSpecular=5,
    TEXTUREGROUP_Weapon     =6,
    TEXTUREGROUP_WeaponNormalMap=7,
    TEXTUREGROUP_WeaponSpecular=8,
    TEXTUREGROUP_Vehicle    =9,
    TEXTUREGROUP_VehicleNormalMap=10,
    TEXTUREGROUP_VehicleSpecular=11,
    TEXTUREGROUP_Cinematic  =12,
    TEXTUREGROUP_Effects    =13,
    TEXTUREGROUP_EffectsNotFiltered=14,
    TEXTUREGROUP_Skybox     =15,
    TEXTUREGROUP_UI         =16,
    TEXTUREGROUP_LightAndShadowMap=17,
    TEXTUREGROUP_RenderTarget=18,
    TEXTUREGROUP_MAX        =19,
};
enum TextureAddress
{
    TA_Wrap                 =0,
    TA_Clamp                =1,
    TA_Mirror               =2,
    TA_MAX                  =3,
};
enum TextureFilter
{
    TF_Nearest              =0,
    TF_Linear               =1,
    TF_MAX                  =2,
};
enum EPixelFormat
{
    PF_Unknown              =0,
    PF_A32B32G32R32F        =1,
    PF_A8R8G8B8             =2,
    PF_G8                   =3,
    PF_G16                  =4,
    PF_DXT1                 =5,
    PF_DXT3                 =6,
    PF_DXT5                 =7,
    PF_UYVY                 =8,
    PF_FloatRGB             =9,
    PF_FloatRGBA            =10,
    PF_DepthStencil         =11,
    PF_ShadowDepth          =12,
    PF_FilteredShadowDepth  =13,
    PF_R32F                 =14,
    PF_G16R16               =15,
    PF_G16R16F              =16,
    PF_G16R16F_FILTER       =17,
    PF_G32R32F              =18,
    PF_A2B10G10R10          =19,
    PF_A16B16G16R16         =20,
    PF_D24                  =21,
    PF_R16F                 =22,
    PF_R16F_FILTER          =23,
    PF_MAX                  =24,
};
enum TextureCompressionSettings
{
    TC_Default              =0,
    TC_Normalmap            =1,
    TC_Displacementmap      =2,
    TC_NormalmapAlpha       =3,
    TC_Grayscale            =4,
    TC_HighDynamicRange     =5,
    TC_MAX                  =6,
};
enum TextureFlipBookMethod
{
    TFBM_UL_ROW             =0,
    TFBM_UL_COL             =1,
    TFBM_UR_ROW             =2,
    TFBM_UR_COL             =3,
    TFBM_LL_ROW             =4,
    TFBM_LL_COL             =5,
    TFBM_LR_ROW             =6,
    TFBM_LR_COL             =7,
    TFBM_RANDOM             =8,
    TFBM_MAX                =9,
};
enum EMovieStreamSource
{
    MovieStream_File        =0,
    MovieStream_Memory      =1,
    MovieStream_MAX         =2,
};

#endif // !INCLUDED_ENGINE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Accept)
AUTOGENERATE_NAME(AcceptInventory)
AUTOGENERATE_NAME(ActorEnteredVolume)
AUTOGENERATE_NAME(ActorLeavingVolume)
AUTOGENERATE_NAME(AddDebugText)
AUTOGENERATE_NAME(AddDefaultInventory)
AUTOGENERATE_NAME(AllowDetourTo)
AUTOGENERATE_NAME(AnimTreeUpdated)
AUTOGENERATE_NAME(Attach)
AUTOGENERATE_NAME(BaseChange)
AUTOGENERATE_NAME(BecomeViewTarget)
AUTOGENERATE_NAME(BeginAnimControl)
AUTOGENERATE_NAME(BreathTimer)
AUTOGENERATE_NAME(Broadcast)
AUTOGENERATE_NAME(BroadcastLocalized)
AUTOGENERATE_NAME(BroadcastLocalizedMessage)
AUTOGENERATE_NAME(BroadcastLocalizedTeam)
AUTOGENERATE_NAME(BroadcastLocalizedTeamMessage)
AUTOGENERATE_NAME(BugIt)
AUTOGENERATE_NAME(BugItAI)
AUTOGENERATE_NAME(Bump)
AUTOGENERATE_NAME(CameraLookAtFinished)
AUTOGENERATE_NAME(CanUnpause)
AUTOGENERATE_NAME(Claim)
AUTOGENERATE_NAME(ClearOnlineDelegates)
AUTOGENERATE_NAME(ClearPause)
AUTOGENERATE_NAME(ClientCancelPendingMapChange)
AUTOGENERATE_NAME(ClientCommitMapChange)
AUTOGENERATE_NAME(ClientConvolve)
AUTOGENERATE_NAME(ClientFlushLevelStreaming)
AUTOGENERATE_NAME(ClientForceGarbageCollection)
AUTOGENERATE_NAME(ClientHearSound)
AUTOGENERATE_NAME(ClientMessage)
AUTOGENERATE_NAME(ClientMutePlayer)
AUTOGENERATE_NAME(ClientPlayForceFeedbackWaveform)
AUTOGENERATE_NAME(ClientPlaySound)
AUTOGENERATE_NAME(ClientPrepareMapChange)
AUTOGENERATE_NAME(ClientPrestreamTextures)
AUTOGENERATE_NAME(ClientSetBlockOnAsyncLoading)
AUTOGENERATE_NAME(ClientSetCameraFade)
AUTOGENERATE_NAME(ClientSetForceMipLevelsToBeResident)
AUTOGENERATE_NAME(ClientSetViewTarget)
AUTOGENERATE_NAME(ClientSpawnCameraLensEffect)
AUTOGENERATE_NAME(ClientStopForceFeedbackWaveform)
AUTOGENERATE_NAME(ClientTravel)
AUTOGENERATE_NAME(ClientUnmutePlayer)
AUTOGENERATE_NAME(ClientWasKicked)
AUTOGENERATE_NAME(CollisionChanged)
AUTOGENERATE_NAME(ConditionalPause)
AUTOGENERATE_NAME(ConstraintBrokenNotify)
AUTOGENERATE_NAME(ContinueOnFoot)
AUTOGENERATE_NAME(CreateInventory)
AUTOGENERATE_NAME(CreatePlayer)
AUTOGENERATE_NAME(CurrentLevelUnloaded)
AUTOGENERATE_NAME(DebugFreezeGame)
AUTOGENERATE_NAME(Destroyed)
AUTOGENERATE_NAME(Detach)
AUTOGENERATE_NAME(DetourWeight)
AUTOGENERATE_NAME(DisableModifier)
AUTOGENERATE_NAME(DiscardInventory)
AUTOGENERATE_NAME(DriverLeave)
AUTOGENERATE_NAME(EncroachedBy)
AUTOGENERATE_NAME(EncroachingOn)
AUTOGENERATE_NAME(EndCrouch)
AUTOGENERATE_NAME(EndViewTarget)
AUTOGENERATE_NAME(EnemyNotVisible)
AUTOGENERATE_NAME(Exit)
AUTOGENERATE_NAME(Falling)
AUTOGENERATE_NAME(FellOutOfWorld)
AUTOGENERATE_NAME(FindInventoryType)
AUTOGENERATE_NAME(FindPlayerByControllerId)
AUTOGENERATE_NAME(FinishAnimControl)
AUTOGENERATE_NAME(ForceNetRelevant)
AUTOGENERATE_NAME(GainedChild)
AUTOGENERATE_NAME(GameEnding)
AUTOGENERATE_NAME(GameSessionEnded)
AUTOGENERATE_NAME(GetAchievementProgression)
AUTOGENERATE_NAME(GetActorEyesViewPoint)
AUTOGENERATE_NAME(GetActorFaceFXAsset)
AUTOGENERATE_NAME(GetBaseAimRotation)
AUTOGENERATE_NAME(GetBeaconText)
AUTOGENERATE_NAME(GetDebugAbbrev)
AUTOGENERATE_NAME(GetDebugString)
AUTOGENERATE_NAME(GetDefaultGameClassPath)
AUTOGENERATE_NAME(GetEntryLocation)
AUTOGENERATE_NAME(GetFaceFXAudioComponent)
AUTOGENERATE_NAME(GetFOVAngle)
AUTOGENERATE_NAME(GetMuzzleLoc)
AUTOGENERATE_NAME(GetNamedInterface)
AUTOGENERATE_NAME(GetPawnViewLocation)
AUTOGENERATE_NAME(GetPhysicalFireStartLoc)
AUTOGENERATE_NAME(GetPlayerViewPoint)
AUTOGENERATE_NAME(GetSeamlessTravelActorList)
AUTOGENERATE_NAME(GetSubtitleRegion)
AUTOGENERATE_NAME(GetTraceRange)
AUTOGENERATE_NAME(GetViewRotation)
AUTOGENERATE_NAME(GetWeaponStartTraceLocation)
AUTOGENERATE_NAME(HandleInputAxis)
AUTOGENERATE_NAME(HandleInputChar)
AUTOGENERATE_NAME(HandleInputKey)
AUTOGENERATE_NAME(HandlePathObstruction)
AUTOGENERATE_NAME(HandleSeamlessTravelPlayer)
AUTOGENERATE_NAME(HeadVolumeChange)
AUTOGENERATE_NAME(HearNoise)
AUTOGENERATE_NAME(HitWall)
AUTOGENERATE_NAME(InFreeCam)
AUTOGENERATE_NAME(Init)
AUTOGENERATE_NAME(InitGame)
AUTOGENERATE_NAME(InitInputSystem)
AUTOGENERATE_NAME(InitUniquePlayerId)
AUTOGENERATE_NAME(InsertInteraction)
AUTOGENERATE_NAME(InterpolationChanged)
AUTOGENERATE_NAME(InterpolationFinished)
AUTOGENERATE_NAME(InterpolationStarted)
AUTOGENERATE_NAME(IsFiring)
AUTOGENERATE_NAME(IsInCombat)
AUTOGENERATE_NAME(IsLookInputIgnored)
AUTOGENERATE_NAME(IsMoveInputIgnored)
AUTOGENERATE_NAME(IsSameTeam)
AUTOGENERATE_NAME(IsSpectating)
AUTOGENERATE_NAME(KickIdler)
AUTOGENERATE_NAME(KickWarning)
AUTOGENERATE_NAME(Kismet_ClientPlaySound)
AUTOGENERATE_NAME(Kismet_ClientStopSound)
AUTOGENERATE_NAME(Landed)
AUTOGENERATE_NAME(LayoutPlayers)
AUTOGENERATE_NAME(LevelStreamingStatusChanged)
AUTOGENERATE_NAME(LimitViewRotation)
AUTOGENERATE_NAME(Login)
AUTOGENERATE_NAME(LongFall)
AUTOGENERATE_NAME(LostChild)
AUTOGENERATE_NAME(MatineeCancelled)
AUTOGENERATE_NAME(MayFall)
AUTOGENERATE_NAME(MessagePlayer)
AUTOGENERATE_NAME(ModifyAvailableProfileSettings)
AUTOGENERATE_NAME(ModifyHearSoundComponent)
AUTOGENERATE_NAME(ModifyVelocity)
AUTOGENERATE_NAME(MoverFinished)
AUTOGENERATE_NAME(MoveUnreachable)
AUTOGENERATE_NAME(NotifyBump)
AUTOGENERATE_NAME(NotifyCoverAdjusted)
AUTOGENERATE_NAME(NotifyDirectorControl)
AUTOGENERATE_NAME(NotifyFallingHitWall)
AUTOGENERATE_NAME(NotifyHeadVolumeChange)
AUTOGENERATE_NAME(NotifyHitWall)
AUTOGENERATE_NAME(NotifyJumpApex)
AUTOGENERATE_NAME(NotifyLanded)
AUTOGENERATE_NAME(NotifyLoadedWorld)
AUTOGENERATE_NAME(NotifyMissedJump)
AUTOGENERATE_NAME(NotifyPendingConnectionLost)
AUTOGENERATE_NAME(NotifyPhysicsVolumeChange)
AUTOGENERATE_NAME(NotifyPostLanded)
AUTOGENERATE_NAME(NotifyPropertyValueUpdated)
AUTOGENERATE_NAME(NotifySettingValueUpdated)
AUTOGENERATE_NAME(NotifySkelControlBeyondLimit)
AUTOGENERATE_NAME(OnAnimEnd)
AUTOGENERATE_NAME(OnAnimPlay)
AUTOGENERATE_NAME(OnLostFocusPause)
AUTOGENERATE_NAME(OnRanOver)
AUTOGENERATE_NAME(OnReadComplete)
AUTOGENERATE_NAME(OnReadPlaylistComplete)
AUTOGENERATE_NAME(OnReadTitleFileComplete)
AUTOGENERATE_NAME(OnRigidBodySpringOverextension)
AUTOGENERATE_NAME(OnStatsWriteComplete)
AUTOGENERATE_NAME(OutsideWorldBounds)
AUTOGENERATE_NAME(OverRotated)
AUTOGENERATE_NAME(PawnEnteredVolume)
AUTOGENERATE_NAME(PawnLeavingVolume)
AUTOGENERATE_NAME(PhysicsChangedFor)
AUTOGENERATE_NAME(PhysicsVolumeChange)
AUTOGENERATE_NAME(PlayActorFaceFXAnim)
AUTOGENERATE_NAME(PlayerTick)
AUTOGENERATE_NAME(PlayFootStepSound)
AUTOGENERATE_NAME(PlayParticleEffect)
AUTOGENERATE_NAME(PlayRumble)
AUTOGENERATE_NAME(Possess)
AUTOGENERATE_NAME(PostBeginPlay)
AUTOGENERATE_NAME(PostCommitMapChange)
AUTOGENERATE_NAME(PostInit)
AUTOGENERATE_NAME(PostInitAnimTree)
AUTOGENERATE_NAME(PostLogin)
AUTOGENERATE_NAME(PostRender)
AUTOGENERATE_NAME(PostRenderFor)
AUTOGENERATE_NAME(PostSeamlessTravel)
AUTOGENERATE_NAME(PostTouch)
AUTOGENERATE_NAME(PreBeginPlay)
AUTOGENERATE_NAME(PreClientTravel)
AUTOGENERATE_NAME(PreCommitMapChange)
AUTOGENERATE_NAME(PreExit)
AUTOGENERATE_NAME(PreLogin)
AUTOGENERATE_NAME(PreRender)
AUTOGENERATE_NAME(ProcessActorSetVolume)
AUTOGENERATE_NAME(RanInto)
AUTOGENERATE_NAME(RatePickup)
AUTOGENERATE_NAME(ReceivedPlayer)
AUTOGENERATE_NAME(ReceiveLocalizedMessage)
AUTOGENERATE_NAME(RemoveDebugText)
AUTOGENERATE_NAME(RemovePlayer)
AUTOGENERATE_NAME(Render)
AUTOGENERATE_NAME(ReplicatedDataBinding)
AUTOGENERATE_NAME(ReplicatedEvent)
AUTOGENERATE_NAME(Reset)
AUTOGENERATE_NAME(ResetCameraMode)
AUTOGENERATE_NAME(RigidBodyCollision)
AUTOGENERATE_NAME(RootMotionExtracted)
AUTOGENERATE_NAME(RootMotionModeChanged)
AUTOGENERATE_NAME(ScriptGetTeamNum)
AUTOGENERATE_NAME(SeeMonster)
AUTOGENERATE_NAME(SeePlayer)
AUTOGENERATE_NAME(SendClientAdjustment)
AUTOGENERATE_NAME(ServerMutePlayer)
AUTOGENERATE_NAME(ServerNotifyLoadedWorld)
AUTOGENERATE_NAME(ServerProcessConvolve)
AUTOGENERATE_NAME(ServerTravel)
AUTOGENERATE_NAME(ServerUnmutePlayer)
AUTOGENERATE_NAME(ServerUpdateLevelVisibility)
AUTOGENERATE_NAME(SetAccountInterface)
AUTOGENERATE_NAME(SetAnimPosition)
AUTOGENERATE_NAME(SetContentInterface)
AUTOGENERATE_NAME(SetDisabled)
AUTOGENERATE_NAME(SetGameInterface)
AUTOGENERATE_NAME(SetGameType)
AUTOGENERATE_NAME(SetInitialState)
AUTOGENERATE_NAME(SetInvalidUntil)
AUTOGENERATE_NAME(SetMorphWeight)
AUTOGENERATE_NAME(SetNamedInterface)
AUTOGENERATE_NAME(SetNewsInterface)
AUTOGENERATE_NAME(SetPickupMesh)
AUTOGENERATE_NAME(SetPickupParticles)
AUTOGENERATE_NAME(SetPlayerInterface)
AUTOGENERATE_NAME(SetPlayerInterfaceEx)
AUTOGENERATE_NAME(SetPlayerName)
AUTOGENERATE_NAME(SetProgressMessage)
AUTOGENERATE_NAME(SetProgressTime)
AUTOGENERATE_NAME(SetSkelControlScale)
AUTOGENERATE_NAME(SetSlotEnabled)
AUTOGENERATE_NAME(SetStatsInterface)
AUTOGENERATE_NAME(SetSystemInterface)
AUTOGENERATE_NAME(SetTemplate)
AUTOGENERATE_NAME(SetToDefaults)
AUTOGENERATE_NAME(SetupSpecialPathAbilities)
AUTOGENERATE_NAME(SetVoiceInterface)
AUTOGENERATE_NAME(SetWalking)
AUTOGENERATE_NAME(ShouldShowGore)
AUTOGENERATE_NAME(ShutDown)
AUTOGENERATE_NAME(SoakPause)
AUTOGENERATE_NAME(SortSearchResults)
AUTOGENERATE_NAME(SpawnedByKismet)
AUTOGENERATE_NAME(SpawnPlayerCamera)
AUTOGENERATE_NAME(SpecialCost)
AUTOGENERATE_NAME(SpecialHandling)
AUTOGENERATE_NAME(StartAutomatedMapTestTimer)
AUTOGENERATE_NAME(StartCrouch)
AUTOGENERATE_NAME(StartDriving)
AUTOGENERATE_NAME(StopActorFaceFXAnim)
AUTOGENERATE_NAME(StopDriving)
AUTOGENERATE_NAME(StopFiring)
AUTOGENERATE_NAME(StuckOnPawn)
AUTOGENERATE_NAME(SuggestMovePreparation)
AUTOGENERATE_NAME(TakeDamage)
AUTOGENERATE_NAME(TakeRadiusDamageOnBones)
AUTOGENERATE_NAME(TeamMessage)
AUTOGENERATE_NAME(Tick)
AUTOGENERATE_NAME(Timer)
AUTOGENERATE_NAME(TornOff)
AUTOGENERATE_NAME(Touch)
AUTOGENERATE_NAME(UnClaim)
AUTOGENERATE_NAME(UnPossess)
AUTOGENERATE_NAME(UnTouch)
AUTOGENERATE_NAME(Update)
AUTOGENERATE_NAME(UpdateCamera)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_CLASSES
#define INCLUDED_ENGINE_CLASSES 1

struct FTimerData
{
    BITFIELD bLoop:1;
    FName FuncName;
    FLOAT Rate;
    FLOAT Count;
    class UObject* TimerObj;
    BITFIELD bPaused:1;

    /** Constructors */
    FTimerData() {}
    FTimerData(EEventParm)
    {
        appMemzero(this, sizeof(FTimerData));
    }
};

struct FTraceHitInfo
{
    class UMaterial* Material;
    class UPhysicalMaterial* PhysMaterial;
    INT Item;
    INT LevelIndex;
    FName BoneName;
    class UPrimitiveComponent* HitComponent;

    /** Constructors */
    FTraceHitInfo()
    : Material(NULL)
    , PhysMaterial(NULL)
    , Item(0)
    , LevelIndex(0)
    , BoneName(NAME_None)
    , HitComponent(NULL)
    {}
    FTraceHitInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTraceHitInfo));
    }
};

struct FImpactInfo
{
    class AActor* HitActor;
    FVector HitLocation;
    FVector HitNormal;
    FVector RayDir;
    FVector StartTrace;
    struct FTraceHitInfo HitInfo;

    /** Constructors */
    FImpactInfo()
    : HitActor(NULL)
    {}
    FImpactInfo(EEventParm)
    {
        appMemzero(this, sizeof(FImpactInfo));
    }
};

struct FAnimSlotInfo
{
    FName SlotName;
    TArray<FLOAT> ChannelWeights;

    /** Constructors */
    FAnimSlotInfo()
    : SlotName(NAME_None)
    {}
    FAnimSlotInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnimSlotInfo));
    }
};

struct FAnimSlotDesc
{
    FName SlotName;
    INT NumChannels;

    /** Constructors */
    FAnimSlotDesc()
    : SlotName(NAME_None)
    , NumChannels(0)
    {}
    FAnimSlotDesc(EEventParm)
    {
        appMemzero(this, sizeof(FAnimSlotDesc));
    }
};

struct FReplicatedHitImpulse
{
    FVector AppliedImpulse;
    FVector HitLocation;
    FName BoneName;
    BYTE ImpulseCount;
    BITFIELD bRadialImpulse:1 GCC_BITFIELD_MAGIC;

    /** Constructors */
    FReplicatedHitImpulse() {}
    FReplicatedHitImpulse(EEventParm)
    {
        appMemzero(this, sizeof(FReplicatedHitImpulse));
    }
};

struct FPhysEffectInfo
{
    FLOAT Threshold;
    FLOAT ReFireDelay;
    class UParticleSystem* Effect;
    class USoundCue* Sound;

    /** Constructors */
    FPhysEffectInfo() {}
    FPhysEffectInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPhysEffectInfo));
    }
};

struct FActorReference
{
    class AActor* Actor;
    FGuid Guid;

		FActorReference()
		{
			Actor = NULL;
		}
		FActorReference(EEventParm)
		{
			appMemzero(this, sizeof(FActorReference));
		}
		explicit FActorReference(class AActor *InActor, FGuid &InGuid)
		{
			Actor = InActor;
			Guid = InGuid;
		}
		// overload various operators to make the reference struct as transparent as possible
		FORCEINLINE AActor* operator*()
		{
			return Actor;
		}
		FORCEINLINE AActor* operator->()
		{
			return Actor;
		}
		/** Slow version of deref that will use GUID if Actor is NULL */
		AActor* operator~();
		FORCEINLINE FActorReference* operator=(AActor* TargetActor)
		{
			Actor = TargetActor;
			return this;
		}
		FORCEINLINE UBOOL operator==(const FActorReference &Ref) const
		{
			return (Ref != NULL && (Ref.Actor == Actor));
		}
		FORCEINLINE UBOOL operator!=(const FActorReference &Ref) const
		{
			return (Ref == NULL || (Ref.Actor != Actor));
		}
		FORCEINLINE UBOOL operator==(AActor *TestActor) const
		{
			return (Actor == TestActor);
		}
		FORCEINLINE UBOOL operator!=(AActor *TestActor) const
		{
			return (Actor != TestActor);
		}
		FORCEINLINE operator AActor*()
		{
			return Actor;
		}
		FORCEINLINE operator UBOOL()
		{
			return (Actor != NULL);
		}
		FORCEINLINE UBOOL operator!()
		{
			return (Actor == NULL);
		}
		FORCEINLINE class ANavigationPoint* Nav()
		{
			return ((class ANavigationPoint*)Actor);
		}
	
};

struct FNavReference
{
    class ANavigationPoint* Nav;
    FGuid Guid;

    /** Constructors */
    FNavReference() {}
    FNavReference(EEventParm)
    {
        appMemzero(this, sizeof(FNavReference));
    }
};

#define UCONST_RB_Sleeping 0x02
#define UCONST_RB_NeedsUpdate 0x01
#define UCONST_RB_None 0x00
#define UCONST_RBSTATE_ANGVELSCALE 1000.0
#define UCONST_RBSTATE_LINVELSCALE 10.0
#define UCONST_ACTORMAXSTEPHEIGHT 35.0
#define UCONST_MINFLOORZ 0.7
#define UCONST_REP_RBLOCATION_ERROR_TOLERANCE_SQ 16.0f
#define UCONST_TRACEFLAG_Blocking 8
#define UCONST_TRACEFLAG_SkipMovers 4
#define UCONST_TRACEFLAG_PhysicsVolumes 2
#define UCONST_TRACEFLAG_Bullet 1

struct Actor_eventAnimTreeUpdated_Parms
{
    class USkeletalMeshComponent* SkelMesh;
    Actor_eventAnimTreeUpdated_Parms(EEventParm)
    {
    }
};
struct Actor_eventPlayParticleEffect_Parms
{
    const class UAnimNotify_PlayParticleEffect* AnimNotifyData;
    Actor_eventPlayParticleEffect_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnRigidBodySpringOverextension_Parms
{
    class URB_BodyInstance* BodyInstance;
    Actor_eventOnRigidBodySpringOverextension_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostInitAnimTree_Parms
{
    class USkeletalMeshComponent* SkelComp;
    Actor_eventPostInitAnimTree_Parms(EEventParm)
    {
    }
};
struct Actor_eventRootMotionExtracted_Parms
{
    class USkeletalMeshComponent* SkelComp;
    FBoneAtom ExtractedRootMotionDelta;
    Actor_eventRootMotionExtracted_Parms(EEventParm)
    {
    }
};
struct Actor_eventRootMotionModeChanged_Parms
{
    class USkeletalMeshComponent* SkelComp;
    Actor_eventRootMotionModeChanged_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostRenderFor_Parms
{
    class APlayerController* PC;
    class UCanvas* Canvas;
    FVector CameraPosition;
    FVector CameraDir;
    Actor_eventPostRenderFor_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnRanOver_Parms
{
    class ASVehicle* Vehicle;
    class UPrimitiveComponent* RunOverComponent;
    INT WheelIndex;
    Actor_eventOnRanOver_Parms(EEventParm)
    {
    }
};
struct Actor_eventRigidBodyCollision_Parms
{
    class UPrimitiveComponent* HitComponent;
    class UPrimitiveComponent* OtherComponent;
    FCollisionImpactData RigidCollisionData;
    INT ContactIndex;
    Actor_eventRigidBodyCollision_Parms(EEventParm)
    : RigidCollisionData(EC_EventParm)
    {
    }
};
struct Actor_eventInterpolationChanged_Parms
{
    class USeqAct_Interp* InterpAction;
    Actor_eventInterpolationChanged_Parms(EEventParm)
    {
    }
};
struct Actor_eventInterpolationFinished_Parms
{
    class USeqAct_Interp* InterpAction;
    Actor_eventInterpolationFinished_Parms(EEventParm)
    {
    }
};
struct Actor_eventInterpolationStarted_Parms
{
    class USeqAct_Interp* InterpAction;
    Actor_eventInterpolationStarted_Parms(EEventParm)
    {
    }
};
struct Actor_eventSpawnedByKismet_Parms
{
    Actor_eventSpawnedByKismet_Parms(EEventParm)
    {
    }
};
struct Actor_eventScriptGetTeamNum_Parms
{
    BYTE ReturnValue;
    Actor_eventScriptGetTeamNum_Parms(EEventParm)
    {
    }
};
struct Actor_eventGetActorEyesViewPoint_Parms
{
    FVector out_Location;
    FRotator out_Rotation;
    Actor_eventGetActorEyesViewPoint_Parms(EEventParm)
    {
    }
};
struct Actor_eventGetActorFaceFXAsset_Parms
{
    class UFaceFXAsset* ReturnValue;
    Actor_eventGetActorFaceFXAsset_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetSkelControlScale_Parms
{
    FName SkelControlName;
    FLOAT Scale;
    Actor_eventSetSkelControlScale_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetMorphWeight_Parms
{
    FName MorphNodeName;
    FLOAT MorphWeight;
    Actor_eventSetMorphWeight_Parms(EEventParm)
    {
    }
};
struct Actor_eventStopActorFaceFXAnim_Parms
{
    Actor_eventStopActorFaceFXAnim_Parms(EEventParm)
    {
    }
};
struct Actor_eventPlayActorFaceFXAnim_Parms
{
    class UFaceFXAnimSet* AnimSet;
    FString GroupName;
    FString SeqName;
    class USoundCue* SoundCueToPlay;
    UBOOL ReturnValue;
    Actor_eventPlayActorFaceFXAnim_Parms(EEventParm)
    {
    }
};
struct Actor_eventFinishAnimControl_Parms
{
    Actor_eventFinishAnimControl_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetAnimPosition_Parms
{
    FName SlotName;
    INT ChannelIndex;
    FName InAnimSeqName;
    FLOAT InPosition;
    UBOOL bFireNotifies;
    UBOOL bLooping;
    Actor_eventSetAnimPosition_Parms(EEventParm)
    {
    }
};
struct Actor_eventBeginAnimControl_Parms
{
    TArray<class UAnimSet*> InAnimSets;
    Actor_eventBeginAnimControl_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnAnimPlay_Parms
{
    class UAnimNodeSequence* SeqNode;
    Actor_eventOnAnimPlay_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnAnimEnd_Parms
{
    class UAnimNodeSequence* SeqNode;
    FLOAT PlayedTime;
    FLOAT ExcessTime;
    Actor_eventOnAnimEnd_Parms(EEventParm)
    {
    }
};
struct Actor_eventShutDown_Parms
{
    Actor_eventShutDown_Parms(EEventParm)
    {
    }
};
struct Actor_eventForceNetRelevant_Parms
{
    Actor_eventForceNetRelevant_Parms(EEventParm)
    {
    }
};
struct Actor_eventReset_Parms
{
    Actor_eventReset_Parms(EEventParm)
    {
    }
};
struct Actor_eventGetFaceFXAudioComponent_Parms
{
    class UAudioComponent* ReturnValue;
    Actor_eventGetFaceFXAudioComponent_Parms(EEventParm)
    {
    }
};
struct Actor_eventModifyHearSoundComponent_Parms
{
    class UAudioComponent* AC;
    Actor_eventModifyHearSoundComponent_Parms(EEventParm)
    {
    }
};
struct Actor_eventEndViewTarget_Parms
{
    class APlayerController* PC;
    Actor_eventEndViewTarget_Parms(EEventParm)
    {
    }
};
struct Actor_eventBecomeViewTarget_Parms
{
    class APlayerController* PC;
    Actor_eventBecomeViewTarget_Parms(EEventParm)
    {
    }
};
struct Actor_eventDebugFreezeGame_Parms
{
    class AActor* ActorToLookAt;
    Actor_eventDebugFreezeGame_Parms(EEventParm)
    {
    }
};
struct Actor_eventTakeDamage_Parms
{
    INT DamageAmount;
    class AController* EventInstigator;
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    struct FTraceHitInfo HitInfo;
    class AActor* DamageCauser;
    Actor_eventTakeDamage_Parms(EEventParm)
    {
    }
};
struct Actor_eventNotifySkelControlBeyondLimit_Parms
{
    class USkelControlLookAt* LookAt;
    Actor_eventNotifySkelControlBeyondLimit_Parms(EEventParm)
    {
    }
};
struct Actor_eventConstraintBrokenNotify_Parms
{
    class AActor* ConOwner;
    class URB_ConstraintSetup* ConSetup;
    class URB_ConstraintInstance* ConInstance;
    Actor_eventConstraintBrokenNotify_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetInitialState_Parms
{
    Actor_eventSetInitialState_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostBeginPlay_Parms
{
    Actor_eventPostBeginPlay_Parms(EEventParm)
    {
    }
};
struct Actor_eventBroadcastLocalizedTeamMessage_Parms
{
    INT TeamIndex;
    class UClass* InMessageClass;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    Actor_eventBroadcastLocalizedTeamMessage_Parms(EEventParm)
    {
    }
};
struct Actor_eventBroadcastLocalizedMessage_Parms
{
    class UClass* InMessageClass;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    Actor_eventBroadcastLocalizedMessage_Parms(EEventParm)
    {
    }
};
struct Actor_eventPreBeginPlay_Parms
{
    Actor_eventPreBeginPlay_Parms(EEventParm)
    {
    }
};
struct Actor_eventTornOff_Parms
{
    Actor_eventTornOff_Parms(EEventParm)
    {
    }
};
struct Actor_eventOutsideWorldBounds_Parms
{
    Actor_eventOutsideWorldBounds_Parms(EEventParm)
    {
    }
};
struct Actor_eventFellOutOfWorld_Parms
{
    class UClass* dmgType;
    Actor_eventFellOutOfWorld_Parms(EEventParm)
    {
    }
};
struct Actor_eventOverRotated_Parms
{
    FRotator out_Desired;
    FRotator out_Actual;
    UBOOL ReturnValue;
    Actor_eventOverRotated_Parms(EEventParm)
    {
    }
};
struct Actor_eventRanInto_Parms
{
    class AActor* Other;
    Actor_eventRanInto_Parms(EEventParm)
    {
    }
};
struct Actor_eventEncroachedBy_Parms
{
    class AActor* Other;
    Actor_eventEncroachedBy_Parms(EEventParm)
    {
    }
};
struct Actor_eventEncroachingOn_Parms
{
    class AActor* Other;
    UBOOL ReturnValue;
    Actor_eventEncroachingOn_Parms(EEventParm)
    {
    }
};
struct Actor_eventCollisionChanged_Parms
{
    Actor_eventCollisionChanged_Parms(EEventParm)
    {
    }
};
struct Actor_eventSpecialHandling_Parms
{
    class APawn* Other;
    class AActor* ReturnValue;
    Actor_eventSpecialHandling_Parms(EEventParm)
    {
    }
};
struct Actor_eventDetach_Parms
{
    class AActor* Other;
    Actor_eventDetach_Parms(EEventParm)
    {
    }
};
struct Actor_eventAttach_Parms
{
    class AActor* Other;
    Actor_eventAttach_Parms(EEventParm)
    {
    }
};
struct Actor_eventBaseChange_Parms
{
    Actor_eventBaseChange_Parms(EEventParm)
    {
    }
};
struct Actor_eventBump_Parms
{
    class AActor* Other;
    class UPrimitiveComponent* OtherComp;
    FVector HitNormal;
    Actor_eventBump_Parms(EEventParm)
    {
    }
};
struct Actor_eventUnTouch_Parms
{
    class AActor* Other;
    Actor_eventUnTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostTouch_Parms
{
    class AActor* Other;
    Actor_eventPostTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventTouch_Parms
{
    class AActor* Other;
    class UPrimitiveComponent* OtherComp;
    FVector HitLocation;
    FVector HitNormal;
    Actor_eventTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventPhysicsVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    Actor_eventPhysicsVolumeChange_Parms(EEventParm)
    {
    }
};
struct Actor_eventLanded_Parms
{
    FVector HitNormal;
    class AActor* FloorActor;
    Actor_eventLanded_Parms(EEventParm)
    {
    }
};
struct Actor_eventFalling_Parms
{
    Actor_eventFalling_Parms(EEventParm)
    {
    }
};
struct Actor_eventHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    class UPrimitiveComponent* WallComp;
    Actor_eventHitWall_Parms(EEventParm)
    {
    }
};
struct Actor_eventTimer_Parms
{
    Actor_eventTimer_Parms(EEventParm)
    {
    }
};
struct Actor_eventTick_Parms
{
    FLOAT DeltaTime;
    Actor_eventTick_Parms(EEventParm)
    {
    }
};
struct Actor_eventLostChild_Parms
{
    class AActor* Other;
    Actor_eventLostChild_Parms(EEventParm)
    {
    }
};
struct Actor_eventGainedChild_Parms
{
    class AActor* Other;
    Actor_eventGainedChild_Parms(EEventParm)
    {
    }
};
struct Actor_eventDestroyed_Parms
{
    Actor_eventDestroyed_Parms(EEventParm)
    {
    }
};
struct Actor_eventReplicatedDataBinding_Parms
{
    FName VarName;
    Actor_eventReplicatedDataBinding_Parms(EEventParm)
    {
    }
};
struct Actor_eventReplicatedEvent_Parms
{
    FName VarName;
    Actor_eventReplicatedEvent_Parms(EEventParm)
    {
    }
};
class AActor : public UObject
{
public:
    //## BEGIN PROPS Actor
    TArrayNoInit<class UActorComponent*> Components;
    TArrayNoInit<class UActorComponent*> AllComponents;
    FVector Location;
    FRotator Rotation;
    FLOAT DrawScale;
    FVector DrawScale3D;
    FVector PrePivot;
    FRenderCommandFence DetachFence;
    FLOAT CustomTimeDilation;
    BYTE Physics;
    BYTE RemoteRole;
    BYTE Role;
    BYTE CollisionType;
    BYTE ReplicatedCollisionType;
    BYTE TickGroup;
    class AActor* Owner;
    class AActor* Base;
    TArrayNoInit<struct FTimerData> Timers;
    BITFIELD bStatic:1;
    BITFIELD bHidden:1;
    BITFIELD bNoDelete:1;
    BITFIELD bDeleteMe:1;
    BITFIELD bTicked:1;
    BITFIELD bOnlyOwnerSee:1;
    BITFIELD bStasis:1;
    BITFIELD bWorldGeometry:1;
    BITFIELD bIgnoreRigidBodyPawns:1;
    BITFIELD bOrientOnSlope:1;
    BITFIELD bIgnoreEncroachers:1;
    BITFIELD bPushedByEncroachers:1;
    BITFIELD bDestroyedByInterpActor:1;
    BITFIELD bRouteBeginPlayEvenIfStatic:1;
    BITFIELD bIsMoving:1;
    BITFIELD bAlwaysEncroachCheck:1;
    BITFIELD bHasAlternateTargetLocation:1;
    BITFIELD bNetTemporary:1;
    BITFIELD bOnlyRelevantToOwner:1;
    BITFIELD bNetDirty:1;
    BITFIELD bAlwaysRelevant:1;
    BITFIELD bReplicateInstigator:1;
    BITFIELD bReplicateMovement:1;
    BITFIELD bSkipActorPropertyReplication:1;
    BITFIELD bUpdateSimulatedPosition:1;
    BITFIELD bTearOff:1;
    BITFIELD bOnlyDirtyReplication:1;
    BITFIELD bAllowFluidSurfaceInteraction:1;
    BITFIELD bDemoRecording:1;
    BITFIELD bDemoOwner:1;
    BITFIELD bForceDemoRelevant:1;
    BITFIELD bNetInitialRotation:1;
    BITFIELD bReplicateRigidBodyLocation:1;
    BITFIELD bKillDuringLevelTransition:1;
    BITFIELD bExchangedRoles:1;
    BITFIELD bConsiderAllStaticMeshComponentsForStreaming:1;
    BITFIELD bDebug:1;
    BITFIELD bPostRenderIfNotVisible:1;
    BITFIELD bForceNetUpdate:1;
    BITFIELD bPendingNetUpdate:1;
    BITFIELD bHardAttach:1;
    BITFIELD bIgnoreBaseRotation:1;
    BITFIELD bShadowParented:1;
    BITFIELD bCanBeAdheredTo:1;
    BITFIELD bCanBeFrictionedTo:1;
    BITFIELD bHurtEntry:1;
    BITFIELD bGameRelevant:1;
    BITFIELD bMovable:1;
    BITFIELD bDestroyInPainVolume:1;
    BITFIELD bCanBeDamaged:1;
    BITFIELD bShouldBaseAtStartup:1;
    BITFIELD bPendingDelete:1;
    BITFIELD bCanTeleport:1;
    BITFIELD bAlwaysTick:1;
    BITFIELD bBlocksNavigation:1;
    BITFIELD BlockRigidBody:1;
    BITFIELD bCollideWhenPlacing:1;
    BITFIELD bCollideActors:1;
    BITFIELD bCollideWorld:1;
    BITFIELD bCollideComplex:1;
    BITFIELD bBlockActors:1;
    BITFIELD bProjTarget:1;
    BITFIELD bBlocksTeleport:1;
    BITFIELD bNoEncroachCheck:1;
    BITFIELD bPhysRigidBodyOutOfWorldCheck:1;
    BITFIELD bComponentOutsideWorld:1;
    BITFIELD bBounce:1;
    BITFIELD bJustTeleported:1;
    BITFIELD bNetInitial:1;
    BITFIELD bNetOwner:1;
    BITFIELD bHiddenEd:1;
    BITFIELD bHiddenEdGroup:1;
    BITFIELD bHiddenEdCustom:1;
    BITFIELD bEdShouldSnap:1;
    BITFIELD bTempEditor:1;
    BITFIELD bPathColliding:1;
    BITFIELD bPathTemp:1;
    BITFIELD bScriptInitialized:1;
    BITFIELD bLockLocation:1;
    BITFIELD bForceAllowKismetModification:1;
    INT NetTag;
    FLOAT NetUpdateTime;
    FLOAT NetUpdateFrequency;
    FLOAT NetPriority;
    FLOAT LastNetUpdateTime;
    class APawn* Instigator;
    class AWorldInfo* WorldInfo;
    FLOAT LifeSpan;
    FLOAT CreationTime;
    FLOAT LastRenderTime;
    FName Tag;
    FName InitialState;
    FName Group;
    TArrayNoInit<class AActor*> Touching;
    TArrayNoInit<class AActor*> Children;
    FLOAT LatentFloat;
    class UAnimNodeSequence* LatentSeqNode;
    class APhysicsVolume* PhysicsVolume;
    FVector Velocity;
    FVector Acceleration;
    FVector AngularVelocity;
    class USkeletalMeshComponent* BaseSkelComponent;
    FName BaseBoneName;
    TArrayNoInit<class AActor*> Attached;
    FVector RelativeLocation;
    FRotator RelativeRotation;
    class UPrimitiveComponent* CollisionComponent;
    INT OverlapTag;
    FRotator RotationRate;
    FRotator DesiredRotation;
    class AActor* PendingTouch;
    class UClass* MessageClass;
    TArrayNoInit<class UClass*> SupportedEvents;
    TArrayNoInit<class USequenceEvent*> GeneratedEvents;
    TArrayNoInit<class USeqAct_Latent*> LatentActions;
    //## END PROPS Actor

    virtual void ForceUpdateComponents(UBOOL bCollisionUpdate=FALSE,UBOOL bTransformOnly=TRUE);
    virtual FString ConsoleCommand(const FString& Command,UBOOL bWriteToLog=TRUE);
    void Sleep(FLOAT Seconds);
    void FinishAnim(class UAnimNodeSequence* SeqNode);
    void SetCollisionSize(FLOAT NewRadius,FLOAT NewHeight);
    void SetCollisionType(BYTE NewCollisionType);
    void SetDrawScale(FLOAT NewScale);
    void SetDrawScale3D(FVector NewScale3D);
    UBOOL Move(FVector Delta);
    UBOOL SetLocation(FVector NewLocation);
    UBOOL SetRotation(FRotator NewRotation);
    virtual BYTE MovingWhichWay(FLOAT& Amount);
    UBOOL SetRelativeRotation(FRotator NewRotation);
    UBOOL SetRelativeLocation(FVector NewLocation);
    INT fixedTurn(INT Current,INT Desired,INT DeltaRate);
    void AutonomousPhysics(FLOAT DeltaSeconds);
    virtual FLOAT GetTerminalVelocity();
    void SetOwner(class AActor* NewOwner);
    virtual void FindBase();
    virtual class AActor* GetBaseMost();
    void SetForcedInitialReplicatedProperty(class UProperty* PropToReplicate,UBOOL bAdd);
    void FlushPersistentDebugLines();
    void DrawDebugLine(FVector LineStart,FVector LineEnd,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE);
    void DrawDebugBox(FVector Center,FVector Extent,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE);
    void DrawDebugCoordinateSystem(FVector AxisLoc,FRotator AxisRot,FLOAT Scale,UBOOL bPersistentLines=FALSE);
    void DrawDebugSphere(FVector Center,FLOAT Radius,INT Segments,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE);
    void DrawDebugCylinder(FVector Start,FVector End,FLOAT Radius,INT Segments,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE);
    void DrawDebugCone(FVector Origin,FVector Direction,FLOAT Length,FLOAT AngleWidth,FLOAT AngleHeight,INT NumSides,FColor DrawColor,UBOOL bPersistentLines=FALSE);
    void ChartData(const FString& DataName,FLOAT DataValue);
    void SetHidden(UBOOL bNewHidden);
    void SetOnlyOwnerSee(UBOOL bNewOnlyOwnerSee);
    void Clock(FLOAT& Time);
    void UnClock(FLOAT& Time);
    void AttachComponent(class UActorComponent* NewComponent);
    void DetachComponent(class UActorComponent* ExComponent);
    void ReattachComponent(class UActorComponent* ComponentToReattach);
    void SetTickGroup(BYTE NewTickGroup);
    UBOOL ClampRotation(FRotator& out_Rot,FRotator rBase,FRotator rUpperLimits,FRotator rLowerLimits);
    UBOOL FindSpot(FVector BoxExtent,FVector& SpotLocation);
    UBOOL ContainsPoint(FVector Spot);
    void GetComponentsBoundingBox(FBox& ActorBox) const;
    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    void SetTimer(FLOAT InRate,UBOOL inbLoop=FALSE,FName inTimerFunc=FName(TEXT("Timer")),class UObject* inObj=NULL);
    void ClearTimer(FName inTimerFunc=FName(TEXT("Timer")),class UObject* inObj=NULL);
    void PauseTimer(UBOOL bPause,FName inTimerFunc=FName(TEXT("Timer")),class UObject* inObj=NULL);
    UBOOL IsTimerActive(FName inTimerFunc=FName(TEXT("Timer")),class UObject* inObj=NULL);
    FLOAT GetTimerCount(FName inTimerFunc=FName(TEXT("Timer")),class UObject* inObj=NULL);
    FLOAT GetTimerRate(FName TimerFuncName=FName(TEXT("Timer")),class UObject* inObj=NULL);
    class UAudioComponent* CreateAudioComponent(class USoundCue* InSoundCue,UBOOL bPlay=FALSE,UBOOL bStopWhenOwnerDestroyed=FALSE,UBOOL bUseLocation=FALSE,FVector SourceLocation=FVector(EC_EventParm),UBOOL bAttachToSelf=TRUE);
    void MakeNoise(FLOAT Loudness,FName NoiseType=NAME_None);
    UBOOL PlayerCanSeeMe();
    virtual FVector GetDestination(class AController* C);
    FString GetURLMap();
    virtual FLOAT GetGravityZ();
    void SetNetUpdateTime(FLOAT NewUpdateTime);
    virtual void PrestreamTextures(FLOAT Seconds,UBOOL bEnableStreaming);
    virtual UBOOL IsPlayerOwned();
    virtual BYTE GetTeamNum();
    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL,UBOOL bRequestAlternateLoc=FALSE) const;
    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual void NativePostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir);
    FGuid GetPackageGuid(FName PackageName);
    UBOOL IsInPersistentLevel() const;
    virtual UBOOL SupportsKismetModification(class USequenceOp* AskingOp) const;
    DECLARE_FUNCTION(execForceUpdateComponents)
    {
        P_GET_UBOOL_OPTX(bCollisionUpdate,FALSE);
        P_GET_UBOOL_OPTX(bTransformOnly,TRUE);
        P_FINISH;
        ForceUpdateComponents(bCollisionUpdate,bTransformOnly);
    }
    DECLARE_FUNCTION(execConsoleCommand)
    {
        P_GET_STR(Command);
        P_GET_UBOOL_OPTX(bWriteToLog,TRUE);
        P_FINISH;
        *(FString*)Result=ConsoleCommand(Command,bWriteToLog);
    }
    DECLARE_FUNCTION(execSleep)
    {
        P_GET_FLOAT(Seconds);
        P_FINISH;
        Sleep(Seconds);
    }
    DECLARE_FUNCTION(execFinishAnim)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_FINISH;
        FinishAnim(SeqNode);
    }
    DECLARE_FUNCTION(execSetCollision);
    DECLARE_FUNCTION(execSetCollisionSize)
    {
        P_GET_FLOAT(NewRadius);
        P_GET_FLOAT(NewHeight);
        P_FINISH;
        SetCollisionSize(NewRadius,NewHeight);
    }
    DECLARE_FUNCTION(execSetCollisionType)
    {
        P_GET_BYTE(NewCollisionType);
        P_FINISH;
        SetCollisionType(NewCollisionType);
    }
    DECLARE_FUNCTION(execSetDrawScale)
    {
        P_GET_FLOAT(NewScale);
        P_FINISH;
        SetDrawScale(NewScale);
    }
    DECLARE_FUNCTION(execSetDrawScale3D)
    {
        P_GET_STRUCT(FVector,NewScale3D);
        P_FINISH;
        SetDrawScale3D(NewScale3D);
    }
    DECLARE_FUNCTION(execMove)
    {
        P_GET_STRUCT(FVector,Delta);
        P_FINISH;
        *(UBOOL*)Result=Move(Delta);
    }
    DECLARE_FUNCTION(execSetLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        *(UBOOL*)Result=SetLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetRotation)
    {
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        *(UBOOL*)Result=SetRotation(NewRotation);
    }
    DECLARE_FUNCTION(execMovingWhichWay)
    {
        P_GET_FLOAT_REF(Amount);
        P_FINISH;
        *(BYTE*)Result=MovingWhichWay(Amount);
    }
    DECLARE_FUNCTION(execSetZone);
    DECLARE_FUNCTION(execSetRelativeRotation)
    {
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        *(UBOOL*)Result=SetRelativeRotation(NewRotation);
    }
    DECLARE_FUNCTION(execSetRelativeLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        *(UBOOL*)Result=SetRelativeLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetHardAttach);
    DECLARE_FUNCTION(execfixedTurn)
    {
        P_GET_INT(Current);
        P_GET_INT(Desired);
        P_GET_INT(DeltaRate);
        P_FINISH;
        *(INT*)Result=fixedTurn(Current,Desired,DeltaRate);
    }
    DECLARE_FUNCTION(execMoveSmooth);
    DECLARE_FUNCTION(execAutonomousPhysics)
    {
        P_GET_FLOAT(DeltaSeconds);
        P_FINISH;
        AutonomousPhysics(DeltaSeconds);
    }
    DECLARE_FUNCTION(execGetTerminalVelocity)
    {
        P_FINISH;
        *(FLOAT*)Result=GetTerminalVelocity();
    }
    DECLARE_FUNCTION(execSetBase);
    DECLARE_FUNCTION(execSetOwner)
    {
        P_GET_OBJECT(AActor,NewOwner);
        P_FINISH;
        SetOwner(NewOwner);
    }
    DECLARE_FUNCTION(execFindBase)
    {
        P_FINISH;
        FindBase();
    }
    DECLARE_FUNCTION(execIsBasedOn);
    DECLARE_FUNCTION(execGetBaseMost)
    {
        P_FINISH;
        *(class AActor**)Result=GetBaseMost();
    }
    DECLARE_FUNCTION(execIsOwnedBy);
    DECLARE_FUNCTION(execSetForcedInitialReplicatedProperty)
    {
        P_GET_OBJECT(UProperty,PropToReplicate);
        P_GET_UBOOL(bAdd);
        P_FINISH;
        SetForcedInitialReplicatedProperty(PropToReplicate,bAdd);
    }
    DECLARE_FUNCTION(execFlushPersistentDebugLines)
    {
        P_FINISH;
        FlushPersistentDebugLines();
    }
    DECLARE_FUNCTION(execDrawDebugLine)
    {
        P_GET_STRUCT(FVector,LineStart);
        P_GET_STRUCT(FVector,LineEnd);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        DrawDebugLine(LineStart,LineEnd,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugBox)
    {
        P_GET_STRUCT(FVector,Center);
        P_GET_STRUCT(FVector,Extent);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        DrawDebugBox(Center,Extent,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugCoordinateSystem)
    {
        P_GET_STRUCT(FVector,AxisLoc);
        P_GET_STRUCT(FRotator,AxisRot);
        P_GET_FLOAT(Scale);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        DrawDebugCoordinateSystem(AxisLoc,AxisRot,Scale,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugSphere)
    {
        P_GET_STRUCT(FVector,Center);
        P_GET_FLOAT(Radius);
        P_GET_INT(Segments);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        DrawDebugSphere(Center,Radius,Segments,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugCylinder)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FVector,End);
        P_GET_FLOAT(Radius);
        P_GET_INT(Segments);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        DrawDebugCylinder(Start,End,Radius,Segments,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugCone)
    {
        P_GET_STRUCT(FVector,Origin);
        P_GET_STRUCT(FVector,Direction);
        P_GET_FLOAT(Length);
        P_GET_FLOAT(AngleWidth);
        P_GET_FLOAT(AngleHeight);
        P_GET_INT(NumSides);
        P_GET_STRUCT(FColor,DrawColor);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        DrawDebugCone(Origin,Direction,Length,AngleWidth,AngleHeight,NumSides,DrawColor,bPersistentLines);
    }
    DECLARE_FUNCTION(execChartData)
    {
        P_GET_STR(DataName);
        P_GET_FLOAT(DataValue);
        P_FINISH;
        ChartData(DataName,DataValue);
    }
    DECLARE_FUNCTION(execSetHidden)
    {
        P_GET_UBOOL(bNewHidden);
        P_FINISH;
        SetHidden(bNewHidden);
    }
    DECLARE_FUNCTION(execSetOnlyOwnerSee)
    {
        P_GET_UBOOL(bNewOnlyOwnerSee);
        P_FINISH;
        SetOnlyOwnerSee(bNewOnlyOwnerSee);
    }
    DECLARE_FUNCTION(execSetPhysics);
    DECLARE_FUNCTION(execClock)
    {
        P_GET_FLOAT_REF(Time);
        P_FINISH;
        Clock(Time);
    }
    DECLARE_FUNCTION(execUnClock)
    {
        P_GET_FLOAT_REF(Time);
        P_FINISH;
        UnClock(Time);
    }
    DECLARE_FUNCTION(execAttachComponent)
    {
        P_GET_OBJECT(UActorComponent,NewComponent);
        P_FINISH;
        AttachComponent(NewComponent);
    }
    DECLARE_FUNCTION(execDetachComponent)
    {
        P_GET_OBJECT(UActorComponent,ExComponent);
        P_FINISH;
        DetachComponent(ExComponent);
    }
    DECLARE_FUNCTION(execReattachComponent)
    {
        P_GET_OBJECT(UActorComponent,ComponentToReattach);
        P_FINISH;
        ReattachComponent(ComponentToReattach);
    }
    DECLARE_FUNCTION(execSetTickGroup)
    {
        P_GET_BYTE(NewTickGroup);
        P_FINISH;
        SetTickGroup(NewTickGroup);
    }
    DECLARE_FUNCTION(execClampRotation)
    {
        P_GET_STRUCT_REF(FRotator,out_Rot);
        P_GET_STRUCT(FRotator,rBase);
        P_GET_STRUCT(FRotator,rUpperLimits);
        P_GET_STRUCT(FRotator,rLowerLimits);
        P_FINISH;
        *(UBOOL*)Result=ClampRotation(out_Rot,rBase,rUpperLimits,rLowerLimits);
    }
    DECLARE_FUNCTION(execTrace);
    DECLARE_FUNCTION(execTraceComponent);
    DECLARE_FUNCTION(execPointCheckComponent);
    DECLARE_FUNCTION(execFastTrace);
    DECLARE_FUNCTION(execTraceAllPhysicsAssetInteractions);
    DECLARE_FUNCTION(execFindSpot)
    {
        P_GET_STRUCT(FVector,BoxExtent);
        P_GET_STRUCT_REF(FVector,SpotLocation);
        P_FINISH;
        *(UBOOL*)Result=FindSpot(BoxExtent,SpotLocation);
    }
    DECLARE_FUNCTION(execContainsPoint)
    {
        P_GET_STRUCT(FVector,Spot);
        P_FINISH;
        *(UBOOL*)Result=ContainsPoint(Spot);
    }
    DECLARE_FUNCTION(execIsOverlapping);
    DECLARE_FUNCTION(execGetComponentsBoundingBox)
    {
        P_GET_STRUCT_REF(FBox,ActorBox);
        P_FINISH;
        GetComponentsBoundingBox(ActorBox);
    }
    DECLARE_FUNCTION(execGetBoundingCylinder)
    {
        P_GET_FLOAT_REF(CollisionRadius);
        P_GET_FLOAT_REF(CollisionHeight);
        P_FINISH;
        GetBoundingCylinder(CollisionRadius,CollisionHeight);
    }
    DECLARE_FUNCTION(execSpawn);
    DECLARE_FUNCTION(execDestroy);
    DECLARE_FUNCTION(execSetTimer)
    {
        P_GET_FLOAT(InRate);
        P_GET_UBOOL_OPTX(inbLoop,FALSE);
        P_GET_NAME_OPTX(inTimerFunc,FName(TEXT("Timer")));
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        SetTimer(InRate,inbLoop,inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execClearTimer)
    {
        P_GET_NAME_OPTX(inTimerFunc,FName(TEXT("Timer")));
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        ClearTimer(inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execPauseTimer)
    {
        P_GET_UBOOL(bPause);
        P_GET_NAME_OPTX(inTimerFunc,FName(TEXT("Timer")));
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        PauseTimer(bPause,inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execIsTimerActive)
    {
        P_GET_NAME_OPTX(inTimerFunc,FName(TEXT("Timer")));
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        *(UBOOL*)Result=IsTimerActive(inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execGetTimerCount)
    {
        P_GET_NAME_OPTX(inTimerFunc,FName(TEXT("Timer")));
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        *(FLOAT*)Result=GetTimerCount(inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execGetTimerRate)
    {
        P_GET_NAME_OPTX(TimerFuncName,FName(TEXT("Timer")));
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        *(FLOAT*)Result=GetTimerRate(TimerFuncName,inObj);
    }
    DECLARE_FUNCTION(execCreateAudioComponent)
    {
        P_GET_OBJECT(USoundCue,InSoundCue);
        P_GET_UBOOL_OPTX(bPlay,FALSE);
        P_GET_UBOOL_OPTX(bStopWhenOwnerDestroyed,FALSE);
        P_GET_UBOOL_OPTX(bUseLocation,FALSE);
        P_GET_STRUCT_OPTX(FVector,SourceLocation,FVector(EC_EventParm));
        P_GET_UBOOL_OPTX(bAttachToSelf,TRUE);
        P_FINISH;
        *(class UAudioComponent**)Result=CreateAudioComponent(InSoundCue,bPlay,bStopWhenOwnerDestroyed,bUseLocation,SourceLocation,bAttachToSelf);
    }
    DECLARE_FUNCTION(execPlaySound);
    DECLARE_FUNCTION(execMakeNoise)
    {
        P_GET_FLOAT(Loudness);
        P_GET_NAME_OPTX(NoiseType,NAME_None);
        P_FINISH;
        MakeNoise(Loudness,NoiseType);
    }
    DECLARE_FUNCTION(execPlayerCanSeeMe)
    {
        P_FINISH;
        *(UBOOL*)Result=PlayerCanSeeMe();
    }
    DECLARE_FUNCTION(execSuggestTossVelocity);
    DECLARE_FUNCTION(execGetDestination)
    {
        P_GET_OBJECT(AController,C);
        P_FINISH;
        *(FVector*)Result=GetDestination(C);
    }
    DECLARE_FUNCTION(execGetURLMap)
    {
        P_FINISH;
        *(FString*)Result=GetURLMap();
    }
    DECLARE_FUNCTION(execAllActors);
    DECLARE_FUNCTION(execDynamicActors);
    DECLARE_FUNCTION(execChildActors);
    DECLARE_FUNCTION(execBasedActors);
    DECLARE_FUNCTION(execTouchingActors);
    DECLARE_FUNCTION(execTraceActors);
    DECLARE_FUNCTION(execVisibleActors);
    DECLARE_FUNCTION(execVisibleCollidingActors);
    DECLARE_FUNCTION(execCollidingActors);
    DECLARE_FUNCTION(execOverlappingActors);
    DECLARE_FUNCTION(execComponentList);
    DECLARE_FUNCTION(execAllOwnedComponents);
    DECLARE_FUNCTION(execLocalPlayerControllers);
    DECLARE_FUNCTION(execGetGravityZ)
    {
        P_FINISH;
        *(FLOAT*)Result=GetGravityZ();
    }
    DECLARE_FUNCTION(execSetNetUpdateTime)
    {
        P_GET_FLOAT(NewUpdateTime);
        P_FINISH;
        SetNetUpdateTime(NewUpdateTime);
    }
    DECLARE_FUNCTION(execPrestreamTextures)
    {
        P_GET_FLOAT(Seconds);
        P_GET_UBOOL(bEnableStreaming);
        P_FINISH;
        PrestreamTextures(Seconds,bEnableStreaming);
    }
    DECLARE_FUNCTION(execIsPlayerOwned)
    {
        P_FINISH;
        *(UBOOL*)Result=IsPlayerOwned();
    }
    DECLARE_FUNCTION(execGetTeamNum)
    {
        P_FINISH;
        *(BYTE*)Result=GetTeamNum();
    }
    DECLARE_FUNCTION(execGetTargetLocation)
    {
        P_GET_OBJECT_OPTX(AActor,RequestedBy,NULL);
        P_GET_UBOOL_OPTX(bRequestAlternateLoc,FALSE);
        P_FINISH;
        *(FVector*)Result=GetTargetLocation(RequestedBy,bRequestAlternateLoc);
    }
    DECLARE_FUNCTION(execSetHUDLocation)
    {
        P_GET_STRUCT(FVector,NewHUDLocation);
        P_FINISH;
        SetHUDLocation(NewHUDLocation);
    }
    DECLARE_FUNCTION(execNativePostRenderFor)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_GET_OBJECT(UCanvas,Canvas);
        P_GET_STRUCT(FVector,CameraPosition);
        P_GET_STRUCT(FVector,CameraDir);
        P_FINISH;
        NativePostRenderFor(PC,Canvas,CameraPosition,CameraDir);
    }
    DECLARE_FUNCTION(execGetPackageGuid)
    {
        P_GET_NAME(PackageName);
        P_FINISH;
        *(FGuid*)Result=GetPackageGuid(PackageName);
    }
    DECLARE_FUNCTION(execIsInPersistentLevel)
    {
        P_FINISH;
        *(UBOOL*)Result=IsInPersistentLevel();
    }
    DECLARE_FUNCTION(execSupportsKismetModification)
    {
        P_GET_OBJECT(USequenceOp,AskingOp);
        P_FINISH;
        *(UBOOL*)Result=SupportsKismetModification(AskingOp);
    }
    void eventAnimTreeUpdated(class USkeletalMeshComponent* SkelMesh)
    {
        Actor_eventAnimTreeUpdated_Parms Parms(EC_EventParm);
        Parms.SkelMesh=SkelMesh;
        ProcessEvent(FindFunctionChecked(ENGINE_AnimTreeUpdated),&Parms);
    }
    void eventPlayParticleEffect(const class UAnimNotify_PlayParticleEffect* AnimNotifyData)
    {
        Actor_eventPlayParticleEffect_Parms Parms(EC_EventParm);
        Parms.AnimNotifyData=AnimNotifyData;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayParticleEffect),&Parms);
    }
    void eventOnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance)
    {
        Actor_eventOnRigidBodySpringOverextension_Parms Parms(EC_EventParm);
        Parms.BodyInstance=BodyInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRigidBodySpringOverextension),&Parms);
    }
    void eventPostInitAnimTree(class USkeletalMeshComponent* SkelComp)
    {
        Actor_eventPostInitAnimTree_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        ProcessEvent(FindFunctionChecked(ENGINE_PostInitAnimTree),&Parms);
    }
    void eventRootMotionExtracted(class USkeletalMeshComponent* SkelComp,FBoneAtom& ExtractedRootMotionDelta)
    {
        Actor_eventRootMotionExtracted_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        Parms.ExtractedRootMotionDelta=ExtractedRootMotionDelta;
        ProcessEvent(FindFunctionChecked(ENGINE_RootMotionExtracted),&Parms);
        ExtractedRootMotionDelta=Parms.ExtractedRootMotionDelta;
    }
    void eventRootMotionModeChanged(class USkeletalMeshComponent* SkelComp)
    {
        Actor_eventRootMotionModeChanged_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        ProcessEvent(FindFunctionChecked(ENGINE_RootMotionModeChanged),&Parms);
    }
    void eventPostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir)
    {
        Actor_eventPostRenderFor_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        Parms.Canvas=Canvas;
        Parms.CameraPosition=CameraPosition;
        Parms.CameraDir=CameraDir;
        ProcessEvent(FindFunctionChecked(ENGINE_PostRenderFor),&Parms);
    }
    void eventOnRanOver(class ASVehicle* Vehicle,class UPrimitiveComponent* RunOverComponent,INT WheelIndex)
    {
        Actor_eventOnRanOver_Parms Parms(EC_EventParm);
        Parms.Vehicle=Vehicle;
        Parms.RunOverComponent=RunOverComponent;
        Parms.WheelIndex=WheelIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRanOver),&Parms);
    }
    void eventRigidBodyCollision(class UPrimitiveComponent* HitComponent,class UPrimitiveComponent* OtherComponent,const FCollisionImpactData& RigidCollisionData,INT ContactIndex)
    {
        Actor_eventRigidBodyCollision_Parms Parms(EC_EventParm);
        Parms.HitComponent=HitComponent;
        Parms.OtherComponent=OtherComponent;
        Parms.RigidCollisionData=RigidCollisionData;
        Parms.ContactIndex=ContactIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RigidBodyCollision),&Parms);
    }
    void eventInterpolationChanged(class USeqAct_Interp* InterpAction)
    {
        Actor_eventInterpolationChanged_Parms Parms(EC_EventParm);
        Parms.InterpAction=InterpAction;
        ProcessEvent(FindFunctionChecked(ENGINE_InterpolationChanged),&Parms);
    }
    void eventInterpolationFinished(class USeqAct_Interp* InterpAction)
    {
        Actor_eventInterpolationFinished_Parms Parms(EC_EventParm);
        Parms.InterpAction=InterpAction;
        ProcessEvent(FindFunctionChecked(ENGINE_InterpolationFinished),&Parms);
    }
    void eventInterpolationStarted(class USeqAct_Interp* InterpAction)
    {
        Actor_eventInterpolationStarted_Parms Parms(EC_EventParm);
        Parms.InterpAction=InterpAction;
        ProcessEvent(FindFunctionChecked(ENGINE_InterpolationStarted),&Parms);
    }
    void eventSpawnedByKismet()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnedByKismet),NULL);
    }
    BYTE eventScriptGetTeamNum()
    {
        Actor_eventScriptGetTeamNum_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_ScriptGetTeamNum),&Parms);
        return Parms.ReturnValue;
    }
    void eventGetActorEyesViewPoint(FVector& out_Location,FRotator& out_Rotation)
    {
        Actor_eventGetActorEyesViewPoint_Parms Parms(EC_EventParm);
        Parms.out_Location=out_Location;
        Parms.out_Rotation=out_Rotation;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActorEyesViewPoint),&Parms);
        out_Location=Parms.out_Location;
        out_Rotation=Parms.out_Rotation;
    }
    class UFaceFXAsset* eventGetActorFaceFXAsset()
    {
        Actor_eventGetActorFaceFXAsset_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActorFaceFXAsset),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetSkelControlScale(FName SkelControlName,FLOAT Scale)
    {
        Actor_eventSetSkelControlScale_Parms Parms(EC_EventParm);
        Parms.SkelControlName=SkelControlName;
        Parms.Scale=Scale;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSkelControlScale),&Parms);
    }
    void eventSetMorphWeight(FName MorphNodeName,FLOAT MorphWeight)
    {
        Actor_eventSetMorphWeight_Parms Parms(EC_EventParm);
        Parms.MorphNodeName=MorphNodeName;
        Parms.MorphWeight=MorphWeight;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMorphWeight),&Parms);
    }
    void eventStopActorFaceFXAnim()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StopActorFaceFXAnim),NULL);
    }
    UBOOL eventPlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet,const FString& GroupName,const FString& SeqName,class USoundCue* SoundCueToPlay)
    {
        Actor_eventPlayActorFaceFXAnim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimSet=AnimSet;
        Parms.GroupName=GroupName;
        Parms.SeqName=SeqName;
        Parms.SoundCueToPlay=SoundCueToPlay;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayActorFaceFXAnim),&Parms);
        return Parms.ReturnValue;
    }
    void eventFinishAnimControl()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_FinishAnimControl),NULL);
    }
    void eventSetAnimPosition(FName SlotName,INT ChannelIndex,FName InAnimSeqName,FLOAT InPosition,UBOOL bFireNotifies,UBOOL bLooping)
    {
        Actor_eventSetAnimPosition_Parms Parms(EC_EventParm);
        Parms.SlotName=SlotName;
        Parms.ChannelIndex=ChannelIndex;
        Parms.InAnimSeqName=InAnimSeqName;
        Parms.InPosition=InPosition;
        Parms.bFireNotifies=bFireNotifies ? FIRST_BITFIELD : FALSE;
        Parms.bLooping=bLooping ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAnimPosition),&Parms);
    }
    void eventBeginAnimControl(const TArray<class UAnimSet*>& InAnimSets)
    {
        Actor_eventBeginAnimControl_Parms Parms(EC_EventParm);
        Parms.InAnimSets=InAnimSets;
        ProcessEvent(FindFunctionChecked(ENGINE_BeginAnimControl),&Parms);
    }
    void eventOnAnimPlay(class UAnimNodeSequence* SeqNode)
    {
        Actor_eventOnAnimPlay_Parms Parms(EC_EventParm);
        Parms.SeqNode=SeqNode;
        ProcessEvent(FindFunctionChecked(ENGINE_OnAnimPlay),&Parms);
    }
    void eventOnAnimEnd(class UAnimNodeSequence* SeqNode,FLOAT PlayedTime,FLOAT ExcessTime)
    {
        Actor_eventOnAnimEnd_Parms Parms(EC_EventParm);
        Parms.SeqNode=SeqNode;
        Parms.PlayedTime=PlayedTime;
        Parms.ExcessTime=ExcessTime;
        ProcessEvent(FindFunctionChecked(ENGINE_OnAnimEnd),&Parms);
    }
    void eventShutDown()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ShutDown),NULL);
    }
    void eventForceNetRelevant()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ForceNetRelevant),NULL);
    }
    void eventReset()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Reset),NULL);
    }
    class UAudioComponent* eventGetFaceFXAudioComponent()
    {
        Actor_eventGetFaceFXAudioComponent_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFaceFXAudioComponent),&Parms);
        return Parms.ReturnValue;
    }
    void eventModifyHearSoundComponent(class UAudioComponent* AC)
    {
        Actor_eventModifyHearSoundComponent_Parms Parms(EC_EventParm);
        Parms.AC=AC;
        ProcessEvent(FindFunctionChecked(ENGINE_ModifyHearSoundComponent),&Parms);
    }
    void eventEndViewTarget(class APlayerController* PC)
    {
        Actor_eventEndViewTarget_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_EndViewTarget),&Parms);
    }
    void eventBecomeViewTarget(class APlayerController* PC)
    {
        Actor_eventBecomeViewTarget_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_BecomeViewTarget),&Parms);
    }
    void eventDebugFreezeGame(class AActor* ActorToLookAt=NULL)
    {
        Actor_eventDebugFreezeGame_Parms Parms(EC_EventParm);
        Parms.ActorToLookAt=ActorToLookAt;
        ProcessEvent(FindFunctionChecked(ENGINE_DebugFreezeGame),&Parms);
    }
    void eventTakeDamage(INT DamageAmount,class AController* EventInstigator,FVector HitLocation,FVector Momentum,class UClass* DamageType,struct FTraceHitInfo HitInfo=FTraceHitInfo(EC_EventParm),class AActor* DamageCauser=NULL)
    {
        Actor_eventTakeDamage_Parms Parms(EC_EventParm);
        Parms.DamageAmount=DamageAmount;
        Parms.EventInstigator=EventInstigator;
        Parms.HitLocation=HitLocation;
        Parms.Momentum=Momentum;
        Parms.DamageType=DamageType;
        Parms.HitInfo=HitInfo;
        Parms.DamageCauser=DamageCauser;
        ProcessEvent(FindFunctionChecked(ENGINE_TakeDamage),&Parms);
    }
    void eventNotifySkelControlBeyondLimit(class USkelControlLookAt* LookAt)
    {
        Actor_eventNotifySkelControlBeyondLimit_Parms Parms(EC_EventParm);
        Parms.LookAt=LookAt;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifySkelControlBeyondLimit),&Parms);
    }
    void eventConstraintBrokenNotify(class AActor* ConOwner,class URB_ConstraintSetup* ConSetup,class URB_ConstraintInstance* ConInstance)
    {
        Actor_eventConstraintBrokenNotify_Parms Parms(EC_EventParm);
        Parms.ConOwner=ConOwner;
        Parms.ConSetup=ConSetup;
        Parms.ConInstance=ConInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ConstraintBrokenNotify),&Parms);
    }
    void eventSetInitialState()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetInitialState),NULL);
    }
    void eventPostBeginPlay()
    {
        if(IsProbing(NAME_PostBeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_PostBeginPlay),NULL);
        }
    }
    void eventBroadcastLocalizedTeamMessage(INT TeamIndex,class UClass* InMessageClass,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        Actor_eventBroadcastLocalizedTeamMessage_Parms Parms(EC_EventParm);
        Parms.TeamIndex=TeamIndex;
        Parms.InMessageClass=InMessageClass;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedTeamMessage),&Parms);
    }
    void eventBroadcastLocalizedMessage(class UClass* InMessageClass,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        Actor_eventBroadcastLocalizedMessage_Parms Parms(EC_EventParm);
        Parms.InMessageClass=InMessageClass;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedMessage),&Parms);
    }
    void eventPreBeginPlay()
    {
        if(IsProbing(NAME_PreBeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_PreBeginPlay),NULL);
        }
    }
    void eventTornOff()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_TornOff),NULL);
    }
    void eventOutsideWorldBounds()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OutsideWorldBounds),NULL);
    }
    void eventFellOutOfWorld(class UClass* dmgType)
    {
        Actor_eventFellOutOfWorld_Parms Parms(EC_EventParm);
        Parms.dmgType=dmgType;
        ProcessEvent(FindFunctionChecked(ENGINE_FellOutOfWorld),&Parms);
    }
    UBOOL eventOverRotated(FRotator& out_Desired,FRotator& out_Actual)
    {
        Actor_eventOverRotated_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.out_Desired=out_Desired;
        Parms.out_Actual=out_Actual;
        ProcessEvent(FindFunctionChecked(ENGINE_OverRotated),&Parms);
        out_Desired=Parms.out_Desired;
        out_Actual=Parms.out_Actual;
        return Parms.ReturnValue;
    }
    void eventRanInto(class AActor* Other)
    {
        Actor_eventRanInto_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_RanInto),&Parms);
    }
    void eventEncroachedBy(class AActor* Other)
    {
        Actor_eventEncroachedBy_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_EncroachedBy)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_EncroachedBy),&Parms);
        }
    }
    UBOOL eventEncroachingOn(class AActor* Other)
    {
        Actor_eventEncroachingOn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_EncroachingOn)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_EncroachingOn),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventCollisionChanged()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CollisionChanged),NULL);
    }
    class AActor* eventSpecialHandling(class APawn* Other)
    {
        Actor_eventSpecialHandling_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        if(IsProbing(NAME_SpecialHandling)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialHandling),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventDetach(class AActor* Other)
    {
        Actor_eventDetach_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Detach)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_Detach),&Parms);
        }
    }
    void eventAttach(class AActor* Other)
    {
        Actor_eventAttach_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Attach)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_Attach),&Parms);
        }
    }
    void eventBaseChange()
    {
        if(IsProbing(NAME_BaseChange)) {
        ProcessEvent(FindFunctionChecked(ENGINE_BaseChange),NULL);
        }
    }
    void eventBump(class AActor* Other,class UPrimitiveComponent* OtherComp,FVector HitNormal)
    {
        Actor_eventBump_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Bump)) {
        Parms.Other=Other;
        Parms.OtherComp=OtherComp;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Bump),&Parms);
        }
    }
    void eventUnTouch(class AActor* Other)
    {
        Actor_eventUnTouch_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_UnTouch)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_UnTouch),&Parms);
        }
    }
    void eventPostTouch(class AActor* Other)
    {
        Actor_eventPostTouch_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_PostTouch)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PostTouch),&Parms);
        }
    }
    void eventTouch(class AActor* Other,class UPrimitiveComponent* OtherComp,FVector HitLocation,FVector HitNormal)
    {
        Actor_eventTouch_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Touch)) {
        Parms.Other=Other;
        Parms.OtherComp=OtherComp;
        Parms.HitLocation=HitLocation;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Touch),&Parms);
        }
    }
    void eventPhysicsVolumeChange(class APhysicsVolume* NewVolume)
    {
        Actor_eventPhysicsVolumeChange_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_PhysicsVolumeChange)) {
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_PhysicsVolumeChange),&Parms);
        }
    }
    void eventLanded(FVector HitNormal,class AActor* FloorActor)
    {
        Actor_eventLanded_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Landed)) {
        Parms.HitNormal=HitNormal;
        Parms.FloorActor=FloorActor;
        ProcessEvent(FindFunctionChecked(ENGINE_Landed),&Parms);
        }
    }
    void eventFalling()
    {
        if(IsProbing(NAME_Falling)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Falling),NULL);
        }
    }
    void eventHitWall(FVector HitNormal,class AActor* Wall,class UPrimitiveComponent* WallComp)
    {
        Actor_eventHitWall_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_HitWall)) {
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        Parms.WallComp=WallComp;
        ProcessEvent(FindFunctionChecked(ENGINE_HitWall),&Parms);
        }
    }
    void eventTimer()
    {
        if(IsProbing(NAME_Timer)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Timer),NULL);
        }
    }
    void eventTick(FLOAT DeltaTime)
    {
        Actor_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    void eventLostChild(class AActor* Other)
    {
        Actor_eventLostChild_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_LostChild)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_LostChild),&Parms);
        }
    }
    void eventGainedChild(class AActor* Other)
    {
        Actor_eventGainedChild_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_GainedChild)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_GainedChild),&Parms);
        }
    }
    void eventDestroyed()
    {
        if(IsProbing(NAME_Destroyed)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Destroyed),NULL);
        }
    }
    void eventReplicatedDataBinding(FName VarName)
    {
        Actor_eventReplicatedDataBinding_Parms Parms(EC_EventParm);
        Parms.VarName=VarName;
        ProcessEvent(FindFunctionChecked(ENGINE_ReplicatedDataBinding),&Parms);
    }
    void eventReplicatedEvent(FName VarName)
    {
        Actor_eventReplicatedEvent_Parms Parms(EC_EventParm);
        Parms.VarName=VarName;
        ProcessEvent(FindFunctionChecked(ENGINE_ReplicatedEvent),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AActor,UObject,0|CLASS_NativeReplication,Engine)
	// Used to adjust box used for collision in overlap checks which are performed at a location other than the actor's current location.
	static FVector OverlapAdjust;

	// Constructors.
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();

	// UObject interface.
	virtual INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void ProcessEvent( UFunction* Function, void* Parms, void* Result=NULL );
	void ProcessState( FLOAT DeltaSeconds );
	UBOOL ProcessRemoteFunction( UFunction* Function, void* Parms, FFrame* Stack );
	void ProcessDemoRecFunction( UFunction* Function, void* Parms, FFrame* Stack );
	void InitExecution();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PreSave();
	virtual void PostLoad();
	void NetDirty(UProperty* property);

	// AActor interface.
	virtual APawn* GetPlayerPawn() const {return NULL;}
	virtual UBOOL IsPlayerPawn() const {return false;}
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
	UBOOL IsOwnedBy( const AActor *TestOwner ) const;
	UBOOL IsBlockedBy( const AActor* Other, const UPrimitiveComponent* Primitive ) const;
	UBOOL IsBasedOn( const AActor *Other ) const;

	/**
	 * Utility for finding the PrefabInstance that 'owns' this actor.
	 * If the actor is not part of a prefab instance, returns NULL.
	 * If the actor _is_ a PrefabInstance, return itself.
	 */
	class APrefabInstance* FindOwningPrefabInstance() const;

	/**
	 * @return		TRUE if the actor is in the named group, FALSE otherwise.
	 */
	UBOOL IsInGroup(const TCHAR* GroupName) const;

	/**
	 * Parses the actor's group string into a list of group names (strings).
	 * @param		OutGroups		[out] Receives the list of group names.
	 */
	void GetGroups(TArray<FString>& OutGroups) const;

	AActor* GetBase() const;

	/**
	 * Called by ApplyDeltaToActor to perform an actor class-specific operation based on widget manipulation.
	 * The default implementation is simply to translate the actor's location.
	 */
	virtual void EditorApplyTranslation(const FVector& DeltaTranslation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * Called by ApplyDeltaToActor to perform an actor class-specific operation based on widget manipulation.
	 * The default implementation is simply to modify the actor's rotation.
	 */
	virtual void EditorApplyRotation(const FRotator& DeltaRotation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * Called by ApplyDeltaToActor to perform an actor class-specific operation based on widget manipulation.
	 * The default implementation is simply to modify the actor's draw scale.
	 */
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	void EditorUpdateBase();
	void EditorUpdateAttachedActors(const TArray<AActor*>& IgnoreActors);

	// Editor specific
	UBOOL IsHiddenEd() const;
	virtual UBOOL IsSelected() const
	{
		return (UObject::IsSelected() && !bDeleteMe);
	}

	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	/** ticks the actor
	 * @return TRUE if the actor was ticked, FALSE if it was aborted (e.g. because it's in stasis)
	 */
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	/* AActor::InStasis()
	 * Called from AActor::Tick() if Actor->bStasis==true
	 * @return true if this actor ands its components can safely not be ticked.
	 */
	virtual UBOOL InStasis();
	/**
	 * bFinished is FALSE while the actor is being continually moved, and becomes TRUE on the last call.
	 * This can be used to defer computationally intensive calculations to the final PostEditMove call of
	 * eg a drag operation.
	 */
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostRename();
	virtual void Spawned();
	/** sets CollisionType to a default value based on the current collision settings of this Actor and its CollisionComponent */
	void SetDefaultCollisionType();
	/** sets collision flags based on the current CollisionType */
	void SetCollisionFromCollisionType();
	virtual void PreNetReceive();
	virtual void PostNetReceive();
	virtual void PostNetReceiveLocation();
	virtual void PostNetReceiveBase(AActor* NewBase);

	// Rendering info.

	virtual FMatrix LocalToWorld() const
	{
#if 0
		FTranslationMatrix	LToW		( -PrePivot					);
		FScaleMatrix		TempScale	( DrawScale3D * DrawScale	);
		FRotationMatrix		TempRot		( Rotation					);
		FTranslationMatrix	TempTrans	( Location					);
		LToW *= TempScale;
		LToW *= TempRot;
		LToW *= TempTrans;
		return LToW;
#else
		FMatrix Result;

		const FLOAT	SR = GMath.SinTab(Rotation.Roll),
				    SP = GMath.SinTab(Rotation.Pitch),
					SY = GMath.SinTab(Rotation.Yaw),
					CR = GMath.CosTab(Rotation.Roll),
					CP = GMath.CosTab(Rotation.Pitch),
					CY = GMath.CosTab(Rotation.Yaw);

		const FLOAT	LX = Location.X,
				    LY = Location.Y,
					LZ = Location.Z,
					PX = PrePivot.X,
					PY = PrePivot.Y,
					PZ = PrePivot.Z;

		const FLOAT	DX = DrawScale3D.X * DrawScale,
			        DY = DrawScale3D.Y * DrawScale,
					DZ = DrawScale3D.Z * DrawScale;

		Result.M[0][0] = CP * CY * DX;
		Result.M[0][1] = CP * DX * SY;
		Result.M[0][2] = DX * SP;
		Result.M[0][3] = 0.f;

		Result.M[1][0] = DY * ( CY * SP * SR - CR * SY );
		Result.M[1][1] = DY * ( CR * CY + SP * SR * SY );
		Result.M[1][2] = -CP * DY * SR;
		Result.M[1][3] = 0.f;

		Result.M[2][0] = -DZ * ( CR * CY * SP + SR * SY );
		Result.M[2][1] =  DZ * ( CY * SR - CR * SP * SY );
		Result.M[2][2] = CP * CR * DZ;
		Result.M[2][3] = 0.f;

		Result.M[3][0] = LX - CP * CY * DX * PX + CR * CY * DZ * PZ * SP - CY * DY * PY * SP * SR + CR * DY * PY * SY + DZ * PZ * SR * SY;
		Result.M[3][1] = LY - (CR * CY * DY * PY + CY * DZ * PZ * SR + CP * DX * PX * SY - CR * DZ * PZ * SP * SY + DY * PY * SP * SR * SY);
		Result.M[3][2] = LZ - (CP * CR * DZ * PZ + DX * PX * SP - CP * DY * PY * SR);
		Result.M[3][3] = 1.f;

		return Result;
#endif
	}
	virtual FMatrix WorldToLocal() const
	{
		return	FTranslationMatrix(-Location) *
				FInverseRotationMatrix(Rotation) *
				FScaleMatrix(FVector( 1.f / DrawScale3D.X, 1.f / DrawScale3D.Y, 1.f / DrawScale3D.Z) / DrawScale) *
				FTranslationMatrix(PrePivot);
	}

	/** Returns the size of the extent to use when moving the object through the world */
	FVector GetCylinderExtent() const;

	AActor* GetTopOwner();
	virtual UBOOL IsPendingKill() const
	{
		return bDeleteMe || HasAnyFlags(RF_PendingKill);
	}
	/** Fast check to see if an actor is alive by not being virtual */
	FORCEINLINE UBOOL ActorIsPendingKill(void) const
	{
		return bDeleteMe || HasAnyFlags(RF_PendingKill);
	}
	virtual void PostScriptDestroyed() {} // C++ notification that the script Destroyed() function has been called.

	// AActor collision functions.
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	UBOOL IsOverlapping( AActor *Other, FCheckResult* Hit=NULL, UPrimitiveComponent* OtherPrimitiveComponent=NULL, UPrimitiveComponent* MyPrimitiveComponent=NULL );

	FBox GetComponentsBoundingBox(UBOOL bNonColliding=0) const;

	/**
	 * This will check to see if the Actor is still in the world.  It will check things like
	 * the KillZ, SoftKillZ, outside world bounds, etc. and handle the situation.
	 **/
	void CheckStillInWorld();

	// AActor general functions.
	void UnTouchActors();
	void FindTouchingActors();
	void BeginTouch(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitLocation, const FVector &HitNormal, UPrimitiveComponent* MyComp=NULL);
	void EndTouch(AActor *Other, UBOOL NoNotifySelf);
	UBOOL IsBrush()       const;
	UBOOL IsStaticBrush() const;
	UBOOL IsVolumeBrush() const;
	UBOOL IsEncroacher() const;

	UBOOL FindInterpMoveTrack(class UInterpTrackMove** MoveTrack, class UInterpTrackInstMove** MoveTrackInst, class USeqAct_Interp** OutSeq);

	/**
	 * Returns True if an actor cannot move or be destroyed during gameplay, and can thus cast and receive static shadowing.
	 */
	UBOOL HasStaticShadowing() const { return bStatic || (bNoDelete && !bMovable); }

	/**
	 * Sets the hard attach flag by first handling the case of already being
	 * based upon another actor
	 *
	 * @param bNewHardAttach the new hard attach setting
	 */
	virtual void SetHardAttach(UBOOL bNewHardAttach);

	virtual void NotifyBump(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitNormal);
	/** notification when actor has bumped against the level */
	virtual void NotifyBumpLevel(const FVector &HitLocation, const FVector &HitNormal);

	void SetCollision( UBOOL bNewCollideActors, UBOOL bNewBlockActors, UBOOL bNewIgnoreEncroachers );
	virtual void SetBase(AActor *NewBase, FVector NewFloor = FVector(0,0,1), int bNotifyActor=1, USkeletalMeshComponent* SkelComp=NULL, FName AttachName=NAME_None );
	void UpdateTimers(FLOAT DeltaSeconds);
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual UBOOL PlayerControlled();
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual UBOOL DelayScriptReplication(FLOAT LastFullUpdateTime) { return false; }

	/** returns true if this actor should be considered relevancy owner for ReplicatedActor, which has bOnlyRelevantToOwner=true
	*/
	virtual UBOOL IsRelevancyOwnerFor(AActor* ReplicatedActor, AActor* ActorOwner);

	/** returns whether this Actor should be considered relevant because it is visible through
	 * the other side of any portals RealViewer can see
	 */
	UBOOL IsRelevantThroughPortals(APlayerController* RealViewer);

	// Level functions
	virtual void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	virtual void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	virtual void PreBeginPlay();
	virtual void PostBeginPlay();

	/*
	 * Play a sound.  Creates an AudioComponent only if the sound is determined to be audible, and replicates the sound to clients based on optional flags
	 *
	 * @param	SoundLocation	the location to play the sound; if not specified, uses the actor's location.
	 */
	void PlaySound(class USoundCue* InSoundCue, UBOOL bNotReplicated = FALSE, UBOOL bNoRepToOwner = FALSE, UBOOL bStopWhenOwnerDestroyed = FALSE, FVector* SoundLocation = NULL, UBOOL bNoRepToRelevant = FALSE);

	// Physics functions.
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor = NULL, FVector NewFloorV = FVector(0,0,1) );
	virtual void performPhysics(FLOAT DeltaSeconds);
	virtual void physProjectile(FLOAT deltaTime, INT Iterations);
	virtual void BoundProjectileVelocity();
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual void processLanded(FVector const& HitNormal, AActor *HitActor, FLOAT remainingTime, INT Iterations);
	virtual void physFalling(FLOAT deltaTime, INT Iterations);
	virtual void physWalking(FLOAT deltaTime, INT Iterations);
	virtual void physicsRotation(FLOAT deltaTime);
	inline void TwoWallAdjust(const FVector &DesiredDir, FVector &Delta, const FVector &HitNormal, const FVector &OldHitNormal, FLOAT HitTime)
	{
		if ((OldHitNormal | HitNormal) <= 0.f) //90 or less corner, so use cross product for dir
		{
			FVector NewDir = (HitNormal ^ OldHitNormal);
			NewDir = NewDir.SafeNormal();
			Delta = (Delta | NewDir) * (1.f - HitTime) * NewDir;
			if ((DesiredDir | Delta) < 0.f)
				Delta = -1.f * Delta;
		}
		else //adjust to new wall
		{
			Delta = (Delta - HitNormal * (Delta | HitNormal)) * (1.f - HitTime);
			if ((Delta | DesiredDir) <= 0.f)
				Delta = FVector(0.f,0.f,0.f);
		}
	}
	UBOOL moveSmooth(FVector const& Delta);
	virtual FRotator FindSlopeRotation(FVector const& FloorNormal, FRotator const& NewRotation);
	void UpdateRelativeRotation();
	virtual void GetNetBuoyancy(FLOAT &NetBuoyancy, FLOAT &NetFluidFriction);
	virtual void SmoothHitWall(FVector const& HitNormal, AActor *HitActor);
	virtual void stepUp(const FVector& GravDir, const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	virtual UBOOL ShrinkCollision(AActor *HitActor, UPrimitiveComponent* HitComponent, const FVector &StartLocation);
	virtual void GrowCollision() {};
	virtual UBOOL MoveWithInterpMoveTrack(UInterpTrackMove* MoveTrack, UInterpTrackInstMove* MoveInst, FLOAT CurTime, FLOAT DeltaTime);
	virtual void AdjustInterpTrackMove(FVector& Pos, FRotator& Rot, FLOAT DeltaTime) {}
	virtual void physInterpolating(FLOAT DeltaTime);
	virtual void PushedBy(AActor* Other) {};
	virtual void UpdateBasedRotation(FRotator &FinalRotation, const FRotator& ReducedRotation) {};
	virtual void ReverseBasedRotation() {};

	/** Utility to add extra forces necessary for rigid-body gravity and damping to the collision component. */
	void AddRBGravAndDamping();

	virtual void physRigidBody(FLOAT DeltaTime);
	virtual void physSoftBody(FLOAT DeltaTime);

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	/**
	* Used by the cooker to pre cache the convex data for static meshes within a given actor.
	* This data is stored with the level.
	* @param Level - The level the cache is in
	* @param TriByteCount - running total of memory usage for per-tri collision cache
	* @param TriMeshCount - running count of per-tri collision cache
	* @param HullByteCount - running total of memory usage for hull cache
	* @param HullCount - running count of hull cache
	*/
	virtual void BuildPhysStaticMeshCache(ULevel* Level,
										  INT& TriByteCount, INT& TriMeshCount, INT& HullByteCount, INT& HullCount);

	void ApplyNewRBState(const FRigidBodyState& NewState, FLOAT* AngErrorAccumulator, FVector& OutDeltaPos);
	UBOOL GetCurrentRBState(FRigidBodyState& OutState);

	/**
	 *	Event called when this Actor is involved in a rigid body collision.
	 *	bNotifyRigidBodyCollision must be true on the physics PrimitiveComponent within this Actor for this event to be called.
	 *	This base class implementation fires off the RigidBodyCollision Kismet event if attached.
	 */
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);

	/** Update information used to detect overlaps between this actor and physics objects, used for 'pushing' things */
	virtual void UpdatePushBody() {};

#if WITH_NOVODEX
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc,UPrimitiveComponent* PrimComp, const class NxGroupsMask& GroupsMask, UINT MatIndex) {}
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp) {}
	virtual void PreTermRigidBody(NxActor* nActor) {}
	virtual void SyncActorToRBPhysics();
	void SyncActorToClothPhysics();
#endif // WITH_NOVODEX

	// AnimControl Matinee Track support

	/** Used to provide information on the slots that this Actor provides for animation to Matinee. */
	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs) {}

	/**
	 *	Called by Matinee when we open it to start controlling animation on this Actor.
	 *	Is also called again when the GroupAnimSets array changes in Matinee, so must support multiple calls.
	 */
	virtual void PreviewBeginAnimControl(TArray<class UAnimSet*>& InAnimSets) {}

	/** Called each frame by Matinee to update the desired sequence by name and position within it. */
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping) {}

	/** Called each frame by Matinee to update the desired animation channel weights for this Actor. */
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos) {}

	/** Called by Matinee when we close it after we have been controlling animation on this Actor. */
	virtual void PreviewFinishAnimControl() {}

	/** Function used to control FaceFX animation in the editor (Matinee). */
	virtual void PreviewUpdateFaceFX(UBOOL bForceAnim, const FString& GroupName, const FString& SeqName, FLOAT InPosition) {}

	/** Used by Matinee playback to start a FaceFX animation playing. */
	virtual void PreviewActorPlayFaceFX(const FString& GroupName, const FString& SeqName, USoundCue* InSoundCue) {}

	/** Used by Matinee to stop current FaceFX animation playing. */
	virtual void PreviewActorStopFaceFX() {}

	/** Used in Matinee to get the AudioComponent we should play facial animation audio on. */
	virtual UAudioComponent* PreviewGetFaceFXAudioComponent() { return NULL; }

	/** Get the UFaceFXAsset that is currently being used by this Actor when playing facial animations. */
	virtual class UFaceFXAsset* PreviewGetActorFaceFXAsset() { return NULL; }

	/** Called each frame by Matinee to update the weight of a particular MorphNodeWeight. */
	virtual void PreviewSetMorphWeight(FName MorphNodeName, FLOAT MorphWeight) {}

	/** Called each frame by Matinee to update the scaling on a SkelControl. */
	virtual void PreviewSetSkelControlScale(FName SkelControlName, FLOAT Scale) {}

	// AI functions.
	int TestCanSeeMe(class APlayerController *Viewer);
	virtual INT AddMyMarker(AActor *S) { return 0; };
	virtual void ClearMarker() {};
	virtual AActor* AssociatedLevelGeometry();
	virtual UBOOL HasAssociatedLevelGeometry(AActor *Other);
	UBOOL SuggestTossVelocity(FVector* TossVelocity, const FVector& Dest, const FVector& Start, FLOAT TossSpeed, FLOAT BaseTossZ, FLOAT DesiredZPct, const FVector& CollisionSize, FLOAT TerminalVelocity, FLOAT OverrideGravityZ = 0.f);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL TouchReachSucceeded(APawn *P, const FVector &TestPosition);
	virtual UBOOL BlockedByVehicle();

	// Special editor behavior
	AActor* GetHitActor();
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
	virtual void CheckForDeprecated();

	// path creation
	virtual void PrePath() {};
	virtual void PostPath() {};

	/** tells this Actor to set its collision for the path building state
	 * for normally colliding Actors that AI should path through (e.g. doors) or vice versa
	 * @param bNowPathBuilding - whether we are now building paths
	 */
	virtual void SetCollisionForPathBuilding(UBOOL bNowPathBuilding);

	/**
	 * Return whether this actor is a builder brush or not.
	 *
	 * @return TRUE if this actor is a builder brush, FALSE otherwise
	 */
	virtual UBOOL IsABuilderBrush() const { return FALSE; }

	/**
	 * Return whether this actor is the current builder brush or not
	 *
	 * @return TRUE if htis actor is the current builder brush, FALSE otherwise
	 */
	virtual UBOOL IsCurrentBuilderBrush() const { return FALSE; }

	virtual UBOOL IsABrush() const {return FALSE;}
	virtual UBOOL IsAVolume() const {return FALSE;}
	virtual UBOOL IsAFluidSurface() const {return FALSE;}

	virtual APlayerController* GetAPlayerController() { return NULL; }
	virtual AController* GetAController() { return NULL; }
	virtual APawn* GetAPawn() { return NULL; }
	virtual const APawn* GetAPawn() const { return NULL; }
	virtual class AVehicle* GetAVehicle() { return NULL; }
	virtual AVolume* GetAVolume() { return NULL; }
	virtual class AFluidSurfaceActor* GetAFluidSurface() { return NULL; }
	virtual class AProjectile* GetAProjectile() { return NULL; }
	virtual const class AProjectile* GetAProjectile() const { return NULL; }
	virtual class APortalTeleporter* GetAPortalTeleporter() { return NULL; };

	virtual APlayerController* GetTopPlayerController()
	{
		AActor* TopActor = GetTopOwner();
		return (TopActor ? TopActor->GetAPlayerController() : NULL);
	}

	/**
	 * Verifies that neither this actor nor any of its components are RF_Unreachable and therefore pending
	 * deletion via the GC.
	 *
	 * @return TRUE if no unreachable actors are referenced, FALSE otherwise
	 */
	virtual UBOOL VerifyNoUnreachableReferences();

	virtual void ClearComponents();
	void ConditionalUpdateComponents(UBOOL bCollisionUpdate = FALSE);
protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:

	/**
	 * Flags all components as dirty if in the editor, and then calls UpdateComponents().
	 *
	 * @param	bCollisionUpdate	[opt] As per UpdateComponents; defaults to FALSE.
	 * @param	bTransformOnly		[opt] TRUE to update only the component transforms, FALSE to update the entire component.
	 */
	virtual void ConditionalForceUpdateComponents(UBOOL bCollisionUpdate = FALSE,UBOOL bTransformOnly = TRUE);

	/**
	 * Flags all components as dirty so that they will be guaranteed an update from
	 * AActor::Tick(), and also be conditionally reattached by AActor::ConditionalUpdateComponents().
	 * @param	bTransformOnly	- True if only the transform has changed.
	 */
	void MarkComponentsAsDirty(UBOOL bTransformOnly = TRUE);

	/**
	 * Works through the component arrays marking entries as pending kill so references to them
	 * will be NULL'ed.
	 *
	 * @param	bAllowComponentOverride		Whether to allow component to override marking the setting
	 */
	virtual void MarkComponentsAsPendingKill( UBOOL bAllowComponentOverride = FALSE );

	void InvalidateLightingCache();

	virtual UBOOL ActorLineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// Natives.
	DECLARE_FUNCTION(execPollSleep);
	DECLARE_FUNCTION(execPollFinishAnim);

	// Matinee
	void GetInterpFloatPropertyNames(TArray<FName> &outNames);
	void GetInterpVectorPropertyNames(TArray<FName> &outNames);
	void GetInterpColorPropertyNames(TArray<FName> &outNames);
	FLOAT* GetInterpFloatPropertyRef(FName inName);
	FVector* GetInterpVectorPropertyRef(FName inName);
	FColor* GetInterpColorPropertyRef(FName inName);

	/**
	 * Returns TRUE if this actor is contained by TestLevel.
	 * @todo seamless: update once Actor->Outer != Level
	 */
	UBOOL IsInLevel(const ULevel *TestLevel) const;
	/** Return the ULevel that this Actor is part of. */
	ULevel* GetLevel() const;

	/**
	 * Determine whether this actor is referenced by its level's GameSequence.
	 *
	 * @param	pReferencer		if specified, will be set to the SequenceObject that is referencing this actor.
	 *
	 * @return TRUE if this actor is referenced by kismet.
	 */
	UBOOL IsReferencedByKismet( class USequenceObject** pReferencer=NULL ) const;

	/**
	 *	Do anything needed to clear out cross level references; Called from ULevel::PreSave
	 */
	virtual void ClearCrossLevelReferences();

	/**
	 * Called when a level is loaded/unloaded, to get a list of all the crosslevel
	 * paths that need to be fixed up.
	 */
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel) {}

	/** Returns ptr to GUID object for this actor.  Override in child classes that actually have a GUID */
	virtual FGuid* GetGuid() { return NULL; }

	/*
	 * Route finding notifications (sent to target)
	 */
	virtual class ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder) { return NULL; }
	virtual UBOOL AnchorNeedNotBeReachable();
	virtual void NotifyAnchorFindingResult(ANavigationPoint* EndAnchor, APawn* RouteFinder) {}
	virtual UBOOL ShouldHideActor(FVector const& CameraLocation) { return FALSE; }
	/** @return whether this Actor has exactly one attached colliding component (directly or indirectly)
	 *  and that component is its CollisionComponent
	 */
	UBOOL HasSingleCollidingComponent();
	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );
	/** called when this Actor was moved because its Base moved, but after that move the Actor was
	 * encroaching on its Base
	 * @param EncroachedBase - the Actor we encroached (Base will be temporarily NULL when this function is called)
	 * @param OverlapHit - result from the overlap check that determined this Actor was encroaching
	 * @return whether the encroachment was resolved (i.e, this Actor is no longer encroaching its base)
	 */
	virtual UBOOL ResolveAttachedMoveEncroachment(AActor* EncroachedBase, const FCheckResult& OverlapHit)
	{
	 	return FALSE;
	}
};

struct FGeomSelection
{
    INT Type;
    INT Index;
    INT SelectionIndex;
    FLOAT SelStrength;
    friend FArchive& operator<<(FArchive& Ar,FGeomSelection& MyGeomSelection)
    {
        return Ar << MyGeomSelection.Type << MyGeomSelection.Index << MyGeomSelection.SelectionIndex << MyGeomSelection.SelStrength;
    }

    /** Constructors */
    FGeomSelection() {}
    FGeomSelection(EEventParm)
    {
        appMemzero(this, sizeof(FGeomSelection));
    }
};

class ABrush : public AActor
{
public:
    //## BEGIN PROPS Brush
    BYTE CsgOper;
    FColor BrushColor;
    INT PolyFlags;
    BITFIELD bColored:1;
    BITFIELD bSolidWhenSelected:1;
    class UModel* Brush;
    class UBrushComponent* BrushComponent;
    TArrayNoInit<struct FGeomSelection> SavedSelections;
    //## END PROPS Brush

    DECLARE_CLASS(ABrush,AActor,0,Engine)
	// UObject interface.
	virtual void PostLoad();

	virtual void PostEditChange(UProperty* PropertyThatChanged);

	virtual UBOOL IsABrush() const {return TRUE;}

	/**
	 * Note that the object has been modified.  If we are currently recording into the 
	 * transaction buffer (undo/redo), save a copy of this object into the buffer and 
	 * marks the package as needing to be saved.
	 *
	 * @param	bAlwaysMarkDirty	if TRUE, marks the package dirty even if we aren't
	 *								currently recording an active undo/redo transaction
	 */
	virtual void Modify(UBOOL bAlwaysMarkDirty = FALSE);

	/**
	 * Serialize function
	 *
	 * @param Ar Archive to serialize with
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	* Return whether this actor is a builder brush or not.
	*
	* @return TRUE if this actor is a builder brush, FALSE otherwise
	*/
	virtual UBOOL IsABuilderBrush() const;

	/**
	* Return whether this actor is the current builder brush or not
	*
	* @return TRUE if htis actor is the current builder brush, FALSE otherwise
	*/
	virtual UBOOL IsCurrentBuilderBrush() const;

	// ABrush interface.
	virtual void CopyPosRotScaleFrom( ABrush* Other );
	virtual void InitPosRotScale();

	void CheckForErrors();

	/**
	* Figures out the best color to use for this brushes wireframe drawing.
	*/

	virtual FColor GetWireColor() const;
};

struct Volume_eventProcessActorSetVolume_Parms
{
    class AActor* Other;
    Volume_eventProcessActorSetVolume_Parms(EEventParm)
    {
    }
};
class AVolume : public ABrush
{
public:
    //## BEGIN PROPS Volume
    class AActor* AssociatedActor;
    INT LocationPriority;
    FStringNoInit LocationName;
    BITFIELD bForcePawnWalk:1;
    BITFIELD bProcessAllActors:1;
    //## END PROPS Volume

    DECLARE_FUNCTION(execEncompasses);
    void eventProcessActorSetVolume(class AActor* Other)
    {
        Volume_eventProcessActorSetVolume_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ProcessActorSetVolume),&Parms);
    }
    DECLARE_CLASS(AVolume,ABrush,0|CLASS_NativeReplication,Engine)
	INT Encompasses(FVector point);
	void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL IsAVolume() const {return TRUE;}
	virtual AVolume* GetAVolume() { return this; }
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void PostEditImport();
};

class ABlockingVolume : public AVolume
{
public:
    //## BEGIN PROPS BlockingVolume
    BITFIELD bClampFluid:1 GCC_BITFIELD_MAGIC;
    BITFIELD bBlockCamera:1;
    //## END PROPS BlockingVolume

    DECLARE_CLASS(ABlockingVolume,AVolume,0,Engine)
	UBOOL IgnoreBlockingBy( const AActor *Other ) const;
};

class ADynamicBlockingVolume : public ABlockingVolume
{
public:
    //## BEGIN PROPS DynamicBlockingVolume
    //## END PROPS DynamicBlockingVolume

    DECLARE_CLASS(ADynamicBlockingVolume,ABlockingVolume,0,Engine)
	virtual void CheckForErrors();
};

struct FCullDistanceSizePair
{
    FLOAT Size;
    FLOAT CullDistance;

    /** Constructors */
    FCullDistanceSizePair() {}
    FCullDistanceSizePair(EEventParm)
    {
        appMemzero(this, sizeof(FCullDistanceSizePair));
    }
};

class ACullDistanceVolume : public AVolume
{
public:
    //## BEGIN PROPS CullDistanceVolume
    TArrayNoInit<struct FCullDistanceSizePair> CullDistances;
    BITFIELD bEnabled:1;
    //## END PROPS CullDistanceVolume

    DECLARE_CLASS(ACullDistanceVolume,AVolume,0,Engine)
	/**
	 * Called after change has occured - used to force update of affected primitives.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * bFinished is FALSE while the actor is being continually moved, and becomes TRUE on the last call.
	 * This can be used to defer computationally intensive calculations to the final PostEditMove call of
	 * eg a drag operation.
	 */
	virtual void PostEditMove(UBOOL bFinished);

	/**
	 * Returns whether the passed in primitive can be affected by cull distance volumes.
	 *
	 * @param	PrimitiveComponent	Component to test
	 * @return	TRUE if tested component can be affected, FALSE otherwise
	 */
	static UBOOL CanBeAffectedByVolumes( UPrimitiveComponent* PrimitiveComponent );

	/**
	 * Updates primitives affected by this volume.
	 */
	void UpdateVolume();
};

class ALevelStreamingVolume : public AVolume
{
public:
    //## BEGIN PROPS LevelStreamingVolume
    TArrayNoInit<class ULevelStreaming*> StreamingLevels;
    BITFIELD bEditorPreVisOnly:1;
    BITFIELD bDisabled:1;
    BYTE Usage GCC_BITFIELD_MAGIC;
    //## END PROPS LevelStreamingVolume

    DECLARE_CLASS(ALevelStreamingVolume,AVolume,0,Engine)
	// UObject interace.
	/**
	 * Serialize function.
	 *
	 * @param	Ar	Archive to serialize with.
	 */
	void Serialize( FArchive& Ar );

	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
};

class ALightVolume : public AVolume
{
public:
    //## BEGIN PROPS LightVolume
    //## END PROPS LightVolume

    DECLARE_CLASS(ALightVolume,AVolume,0,Engine)
	/**
	 * Called after property has changed via e.g. property window or set command.
	 *
	 * @param	PropertyThatChanged	UProperty that has been changed, NULL if unknown
	 */
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class APathBlockingVolume : public AVolume
{
public:
    //## BEGIN PROPS PathBlockingVolume
    //## END PROPS PathBlockingVolume

    DECLARE_CLASS(APathBlockingVolume,AVolume,0,Engine)
	virtual void SetCollisionForPathBuilding(UBOOL bNowPathBuilding);
};

struct PhysicsVolume_eventPawnLeavingVolume_Parms
{
    class APawn* Other;
    PhysicsVolume_eventPawnLeavingVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventPawnEnteredVolume_Parms
{
    class APawn* Other;
    PhysicsVolume_eventPawnEnteredVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventActorLeavingVolume_Parms
{
    class AActor* Other;
    PhysicsVolume_eventActorLeavingVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventActorEnteredVolume_Parms
{
    class AActor* Other;
    PhysicsVolume_eventActorEnteredVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventPhysicsChangedFor_Parms
{
    class AActor* Other;
    PhysicsVolume_eventPhysicsChangedFor_Parms(EEventParm)
    {
    }
};
class APhysicsVolume : public AVolume
{
public:
    //## BEGIN PROPS PhysicsVolume
    FVector ZoneVelocity;
    BITFIELD bVelocityAffectsWalking:1;
    BITFIELD bPainCausing:1;
    BITFIELD bAIShouldIgnorePain:1;
    BITFIELD bEntryPain:1;
    BITFIELD BACKUP_bPainCausing:1;
    BITFIELD bDestructive:1;
    BITFIELD bNoInventory:1;
    BITFIELD bMoveProjectiles:1;
    BITFIELD bBounceVelocity:1;
    BITFIELD bNeutralZone:1;
    BITFIELD bCrowdAgentsPlayDeathAnim:1;
    BITFIELD bPhysicsOnContact:1;
    BITFIELD bWaterVolume:1;
    FLOAT GroundFriction;
    FLOAT TerminalVelocity;
    FLOAT DamagePerSec;
    class UClass* DamageType;
    INT Priority;
    FLOAT FluidFriction;
    FLOAT PainInterval;
    FLOAT RigidBodyDamping;
    FLOAT MaxDampingForce;
    class AInfo* PainTimer;
    class AController* DamageInstigator;
    class APhysicsVolume* NextPhysicsVolume;
    //## END PROPS PhysicsVolume

    virtual FLOAT GetGravityZ();
    void eventPawnLeavingVolume(class APawn* Other)
    {
        PhysicsVolume_eventPawnLeavingVolume_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_PawnLeavingVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PawnLeavingVolume),&Parms);
        }
    }
    void eventPawnEnteredVolume(class APawn* Other)
    {
        PhysicsVolume_eventPawnEnteredVolume_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_PawnEnteredVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PawnEnteredVolume),&Parms);
        }
    }
    void eventActorLeavingVolume(class AActor* Other)
    {
        PhysicsVolume_eventActorLeavingVolume_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_ActorLeavingVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorLeavingVolume),&Parms);
        }
    }
    void eventActorEnteredVolume(class AActor* Other)
    {
        PhysicsVolume_eventActorEnteredVolume_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_ActorEnteredVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorEnteredVolume),&Parms);
        }
    }
    void eventPhysicsChangedFor(class AActor* Other)
    {
        PhysicsVolume_eventPhysicsChangedFor_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_PhysicsChangedFor)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PhysicsChangedFor),&Parms);
        }
    }
    DECLARE_CLASS(APhysicsVolume,AVolume,0|CLASS_NativeReplication,Engine)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL WillHurt(APawn *P);
	virtual void CheckForErrors();

	virtual FLOAT GetVolumeRBGravityZ() { return GetGravityZ(); }
};

class ADefaultPhysicsVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS DefaultPhysicsVolume
    //## END PROPS DefaultPhysicsVolume

    DECLARE_CLASS(ADefaultPhysicsVolume,APhysicsVolume,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADefaultPhysicsVolume)
};

class AGravityVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS GravityVolume
    FLOAT GravityZ;
    //## END PROPS GravityVolume

    DECLARE_CLASS(AGravityVolume,APhysicsVolume,0,Engine)
	virtual FLOAT GetGravityZ() { return GravityZ; }
};

class ALadderVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS LadderVolume
    FRotator WallDir;
    FVector LookDir;
    FVector ClimbDir;
    class ALadder* LadderList;
    BITFIELD bNoPhysicalLadder:1;
    BITFIELD bAutoPath:1;
    BITFIELD bAllowLadderStrafing:1;
    class APawn* PendingClimber;
    //## END PROPS LadderVolume

    DECLARE_CLASS(ALadderVolume,APhysicsVolume,0,Engine)
	virtual INT AddMyMarker(AActor *S);
	FVector FindTop(FVector V);
	FVector FindCenter();
};

class APortalVolume : public AVolume
{
public:
    //## BEGIN PROPS PortalVolume
    TArrayNoInit<class APortalTeleporter*> Portals;
    //## END PROPS PortalVolume

    DECLARE_CLASS(APortalVolume,AVolume,0,Engine)
	/**
	 * Removes the portal volume to world info's list of portal volumes.
	 */
	virtual void ClearComponents( void );

protected:
	/**
	 * Adds the portal volume to world info's list of portal volumes.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate = FALSE );
public:
};

class UPostProcessEffect : public UObject
{
public:
    //## BEGIN PROPS PostProcessEffect
    BITFIELD bShowInEditor:1;
    BITFIELD bShowInGame:1;
    BITFIELD bUseWorldSettings:1;
    BITFIELD bAffectsLightingOnly:1;
    FName EffectName;
    INT NodePosY;
    INT NodePosX;
    INT DrawWidth;
    INT DrawHeight;
    INT OutDrawY;
    INT InDrawY;
    BYTE SceneDPG;
    //## END PROPS PostProcessEffect

    DECLARE_CLASS(UPostProcessEffect,UObject,0,Engine)
	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 *			Will be NULL if the view didn't provide them, or the effect has bUseWorldSettings=False.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings) 
	{ 
		return NULL; 
	}

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;
};

class UAmbientOcclusionEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS AmbientOcclusionEffect
    FLinearColor OcclusionColor;
    FLOAT OcclusionPower;
    FLOAT OcclusionScale;
    FLOAT OcclusionBias;
    FLOAT MinOcclusion;
    FLOAT OcclusionRadius;
    FLOAT OcclusionAttenuation;
    BYTE OcclusionQuality;
    FLOAT OcclusionFadeoutMinDistance;
    FLOAT OcclusionFadeoutMaxDistance;
    FLOAT HaloDistanceThreshold;
    FLOAT HaloDistanceScale;
    FLOAT HaloOcclusion;
    FLOAT EdgeDistanceThreshold;
    FLOAT EdgeDistanceScale;
    FLOAT FilterDistanceScale;
    INT FilterSize;
    FLOAT HistoryConvergenceTime;
    FLOAT HistoryWeightConvergenceTime;
    //## END PROPS AmbientOcclusionEffect

    DECLARE_CLASS(UAmbientOcclusionEffect,UPostProcessEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UBloomEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS BloomEffect
    //## END PROPS BloomEffect

    DECLARE_CLASS(UBloomEffect,UPostProcessEffect,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UBloomEffect)
};

class UDOFEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS DOFEffect
    FLOAT FalloffExponent;
    FLOAT BlurKernelSize;
    FLOAT MaxNearBlurAmount;
    FLOAT MaxFarBlurAmount;
    FColor ModulateBlurColor;
    BYTE FocusType;
    FLOAT FocusInnerRadius;
    FLOAT FocusDistance;
    FVector FocusPosition;
    //## END PROPS DOFEffect

    DECLARE_ABSTRACT_CLASS(UDOFEffect,UPostProcessEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	// UObject inteface

	/** callback for changed property */
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UDOFAndBloomEffect : public UDOFEffect
{
public:
    //## BEGIN PROPS DOFAndBloomEffect
    FLOAT BloomScale;
    FLOAT SceneMultiplier;
    //## END PROPS DOFAndBloomEffect

    DECLARE_CLASS(UDOFAndBloomEffect,UDOFEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;
};

class UDOFBloomMotionBlurEffect : public UDOFAndBloomEffect
{
public:
    //## BEGIN PROPS DOFBloomMotionBlurEffect
    FLOAT MaxVelocity;
    FLOAT MotionBlurAmount;
    BITFIELD FullMotionBlur:1;
    FLOAT CameraRotationThreshold;
    FLOAT CameraTranslationThreshold;
    //## END PROPS DOFBloomMotionBlurEffect

    DECLARE_CLASS(UDOFBloomMotionBlurEffect,UDOFAndBloomEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;
};

class UUberPostProcessEffect : public UDOFBloomMotionBlurEffect
{
public:
    //## BEGIN PROPS UberPostProcessEffect
    FVector SceneShadows;
    FVector SceneHighLights;
    FVector SceneMidTones;
    FLOAT SceneDesaturation;
    //## END PROPS UberPostProcessEffect

    DECLARE_CLASS(UUberPostProcessEffect,UDOFBloomMotionBlurEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	// UObject interface

	/**
	* Called after this instance has been serialized.  UberPostProcessEffect should only
	* ever exists in the SDPG_PostProcess scene
	*/
	virtual void PostLoad();
	
	/**
	 * Called when properties change.  UberPostProcessEffect should only
	 * ever exists in the SDPG_PostProcess scene
	 */
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UMaterialEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS MaterialEffect
    class UMaterialInterface* Material;
    //## END PROPS MaterialEffect

    DECLARE_CLASS(UMaterialEffect,UPostProcessEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);
};

class UMotionBlurEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS MotionBlurEffect
    FLOAT MaxVelocity;
    FLOAT MotionBlurAmount;
    BITFIELD FullMotionBlur:1;
    FLOAT CameraRotationThreshold;
    FLOAT CameraTranslationThreshold;
    //## END PROPS MotionBlurEffect

    DECLARE_CLASS(UMotionBlurEffect,UPostProcessEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;
};

struct FPostProcessSettings
{
    BITFIELD bEnableBloom:1;
    BITFIELD bEnableDOF:1;
    BITFIELD bEnableMotionBlur:1;
    BITFIELD bEnableSceneEffect:1;
    BITFIELD bAllowAmbientOcclusion:1;
    FLOAT Bloom_Scale;
    FLOAT Bloom_InterpolationDuration;
    FLOAT DOF_FalloffExponent;
    FLOAT DOF_BlurKernelSize;
    FLOAT DOF_MaxNearBlurAmount;
    FLOAT DOF_MaxFarBlurAmount;
    FColor DOF_ModulateBlurColor;
    BYTE DOF_FocusType;
    FLOAT DOF_FocusInnerRadius;
    FLOAT DOF_FocusDistance;
    FVector DOF_FocusPosition;
    FLOAT DOF_InterpolationDuration;
    FLOAT MotionBlur_MaxVelocity;
    FLOAT MotionBlur_Amount;
    BITFIELD MotionBlur_FullMotionBlur:1;
    FLOAT MotionBlur_CameraRotationThreshold;
    FLOAT MotionBlur_CameraTranslationThreshold;
    FLOAT MotionBlur_InterpolationDuration;
    FLOAT Scene_Desaturation;
    FVector Scene_HighLights;
    FVector Scene_MidTones;
    FVector Scene_Shadows;
    FLOAT Scene_InterpolationDuration;

	FPostProcessSettings()
	{}

	FPostProcessSettings(INT A)
	{
		bEnableBloom=TRUE;
		bEnableDOF=FALSE;
		bEnableMotionBlur=TRUE;
		bEnableSceneEffect=TRUE;
		bAllowAmbientOcclusion=TRUE;

		Bloom_Scale=1;
		Bloom_InterpolationDuration=1;

		DOF_FalloffExponent=4;
		DOF_BlurKernelSize=16;
		DOF_MaxNearBlurAmount=1;
		DOF_MaxFarBlurAmount=1;
		DOF_ModulateBlurColor=FColor(255,255,255,255);
		DOF_FocusType=FOCUS_Distance;
		DOF_FocusInnerRadius=2000;
		DOF_FocusDistance=0;
		DOF_InterpolationDuration=1;

		MotionBlur_MaxVelocity=1.0f;
		MotionBlur_Amount=0.5f;
		MotionBlur_FullMotionBlur=TRUE;
		MotionBlur_CameraRotationThreshold=90.0f;
		MotionBlur_CameraTranslationThreshold=10000.0f;
		MotionBlur_InterpolationDuration=1;

		Scene_Desaturation=0;
		Scene_HighLights=FVector(1,1,1);
		Scene_MidTones=FVector(1,1,1);
		Scene_Shadows=FVector(0,0,0);
		Scene_InterpolationDuration=1;
	}

	/**
	 * Adds the values of the interplatable parameters from the given settings struct.
	 * Each entry is multiplied by scale before adding.
	 */
	void AddInterpolatable(FPostProcessSettings const& AdditiveSettings, FLOAT Scale=1.f)
	{
		Bloom_Scale += Scale * AdditiveSettings.Bloom_Scale;
		DOF_FalloffExponent += Scale * AdditiveSettings.DOF_FalloffExponent;
		DOF_BlurKernelSize += Scale * AdditiveSettings.DOF_BlurKernelSize;
		DOF_MaxNearBlurAmount += Scale * AdditiveSettings.DOF_MaxNearBlurAmount;
		DOF_MaxFarBlurAmount += Scale * AdditiveSettings.DOF_MaxFarBlurAmount;
		DOF_FocusInnerRadius += Scale * AdditiveSettings.DOF_FocusInnerRadius;
		DOF_FocusDistance += Scale * AdditiveSettings.DOF_FocusDistance;
		MotionBlur_MaxVelocity += Scale * AdditiveSettings.MotionBlur_MaxVelocity;
		MotionBlur_Amount += Scale * AdditiveSettings.MotionBlur_Amount;
		MotionBlur_CameraRotationThreshold += Scale * AdditiveSettings.MotionBlur_CameraRotationThreshold;
		MotionBlur_CameraTranslationThreshold += Scale * AdditiveSettings.MotionBlur_CameraTranslationThreshold;
		Scene_Desaturation += Scale * AdditiveSettings.Scene_Desaturation;
		Scene_HighLights += Scale * AdditiveSettings.Scene_HighLights;
		Scene_MidTones += Scale * AdditiveSettings.Scene_MidTones;
		Scene_Shadows += Scale * AdditiveSettings.Scene_Shadows;
	}

};

class APostProcessVolume : public AVolume
{
public:
    //## BEGIN PROPS PostProcessVolume
    FLOAT Priority;
    struct FPostProcessSettings Settings;
    class APostProcessVolume* NextLowerPriorityVolume;
    BITFIELD bEnabled:1;
    //## END PROPS PostProcessVolume

    DECLARE_CLASS(APostProcessVolume,AVolume,0,Engine)
	/**
	 * Routes ClearComponents call to Super and removes volume from linked list in world info.
	 */
	virtual void ClearComponents();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostLoad();
protected:
	/**
	 * Routes UpdateComponents call to Super and adds volume to linked list in world info.
	 */
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
};

struct FReverbSettings
{
    BYTE ReverbType;
    FLOAT Volume;
    FLOAT FadeTime;

    /** Constructors */
    FReverbSettings() {}
    FReverbSettings(EEventParm)
    {
        appMemzero(this, sizeof(FReverbSettings));
    }
};

class AReverbVolume : public AVolume
{
public:
    //## BEGIN PROPS ReverbVolume
    FLOAT Priority;
    struct FReverbSettings Settings;
    class AReverbVolume* NextLowerPriorityVolume;
    //## END PROPS ReverbVolume

    DECLARE_CLASS(AReverbVolume,AVolume,0,Engine)
	/**
	 * Removes the reverb volume to world info's list of reverb volumes.
	 */
	virtual void ClearComponents();

	/**
	 * callback for changed property 
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );
	
protected:
	/**
	 * Adds the reverb volume to world info's list of reverb volumes.
	 */
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
};

class ATriggerVolume : public AVolume
{
public:
    //## BEGIN PROPS TriggerVolume
    //## END PROPS TriggerVolume

    DECLARE_CLASS(ATriggerVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ATriggerVolume)
};

struct FTCameraCache
{
    FLOAT TimeStamp;
    FTPOV POV;

    /** Constructors */
    FTCameraCache() {}
    FTCameraCache(EEventParm)
    {
        appMemzero(this, sizeof(FTCameraCache));
    }
};

struct FTViewTarget
{
    class AActor* Target;
    class AController* Controller;
    FTPOV POV;
    FLOAT AspectRatio;
    class APlayerReplicationInfo* PRI;

    /** Constructors */
    FTViewTarget() {}
    FTViewTarget(EEventParm)
    {
        appMemzero(this, sizeof(FTViewTarget));
    }
};

struct FViewTargetTransitionParams
{
    FLOAT BlendTime;
    BYTE BlendFunction;
    FLOAT BlendExp;

		FViewTargetTransitionParams()
		{}
		FViewTargetTransitionParams(EEventParm)
		: BlendTime(0.f), BlendFunction(VTBlend_Cubic), BlendExp(2.f)
		{}
	
};

struct Camera_eventUpdateCamera_Parms
{
    FLOAT DeltaTime;
    Camera_eventUpdateCamera_Parms(EEventParm)
    {
    }
};
class ACamera : public AActor
{
public:
    //## BEGIN PROPS Camera
    class APlayerController* PCOwner;
    FName CameraStyle;
    FLOAT DefaultFOV;
    BITFIELD bLockedFOV:1;
    BITFIELD bConstrainAspectRatio:1;
    BITFIELD bEnableFading:1;
    BITFIELD bCamOverridePostProcess:1;
    BITFIELD bEnableColorScaling:1;
    BITFIELD bEnableColorScaleInterp:1;
    FLOAT LockedFOV;
    FLOAT ConstrainedAspectRatio;
    FLOAT DefaultAspectRatio;
    FColor FadeColor;
    FLOAT FadeAmount;
    struct FPostProcessSettings CamPostProcessSettings;
    FVector ColorScale;
    FVector DesiredColorScale;
    FVector OriginalColorScale;
    FLOAT ColorScaleInterpDuration;
    FLOAT ColorScaleInterpStartTime;
    struct FTCameraCache CameraCache;
    struct FTViewTarget ViewTarget;
    struct FTViewTarget PendingViewTarget;
    FLOAT BlendTimeToGo;
    struct FViewTargetTransitionParams BlendParams;
    TArrayNoInit<class UCameraModifier*> ModifierList;
    FLOAT FreeCamDistance;
    FVector FreeCamOffset;
    FVector2D FadeAlpha;
    FLOAT FadeTime;
    FLOAT FadeTimeRemaining;
    //## END PROPS Camera

    virtual void ApplyCameraModifiers(FLOAT DeltaTime,FTPOV& OutPOV);
    virtual void CheckViewTarget(struct FTViewTarget& VT);
    void SetViewTarget(class AActor* NewViewTarget,struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm));
    DECLARE_FUNCTION(execApplyCameraModifiers)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        ApplyCameraModifiers(DeltaTime,OutPOV);
    }
    DECLARE_FUNCTION(execCheckViewTarget)
    {
        P_GET_STRUCT_REF(struct FTViewTarget,VT);
        P_FINISH;
        CheckViewTarget(VT);
    }
    DECLARE_FUNCTION(execSetViewTarget)
    {
        P_GET_OBJECT(AActor,NewViewTarget);
        P_GET_STRUCT_OPTX(struct FViewTargetTransitionParams,TransitionParams,FViewTargetTransitionParams(EC_EventParm));
        P_FINISH;
        SetViewTarget(NewViewTarget,TransitionParams);
    }
    void eventUpdateCamera(FLOAT DeltaTime)
    {
        Camera_eventUpdateCamera_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_UpdateCamera),&Parms);
    }
    DECLARE_CLASS(ACamera,AActor,0,Engine)
	void	AssignViewTarget(AActor* NewTarget, FTViewTarget& VT, struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm));
	AActor* GetViewTarget();
	virtual UBOOL	PlayerControlled();
	virtual void	ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const {};
};

#define UCONST_MAX_ACTIVE_CAMERA_ANIMS 8

class AAnimatedCamera : public ACamera
{
public:
    //## BEGIN PROPS AnimatedCamera
    class UCameraAnimInst* AnimInstPool[8];
    TArrayNoInit<class UCameraAnimInst*> ActiveAnims;
    TArrayNoInit<class UCameraAnimInst*> FreeAnims;
    class ADynamicCameraActor* AnimCameraActor;
    class ADynamicCameraActor* AccumulatorCameraActor;
    //## END PROPS AnimatedCamera

    virtual void ApplyCameraModifiers(FLOAT DeltaTime,FTPOV& OutPOV);
    virtual void ApplyCameraModifiersNative(FLOAT DeltaTime,FTPOV& OutPOV);
    virtual class UCameraAnimInst* PlayCameraAnim(class UCameraAnim* Anim,FLOAT Rate=1.000000,FLOAT Scale=1.000000,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLoop=FALSE,UBOOL bRandomStartTime=FALSE,FLOAT Duration=0,UBOOL bSingleInstance=FALSE);
    virtual void StopAllCameraAnims(UBOOL bImmediate=FALSE);
    virtual void StopAllCameraAnimsByType(class UCameraAnim* Anim,UBOOL bImmediate=FALSE);
    virtual void StopCameraAnim(class UCameraAnimInst* AnimInst,UBOOL bImmediate=FALSE);
    DECLARE_FUNCTION(execApplyCameraModifiersNative)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        ApplyCameraModifiersNative(DeltaTime,OutPOV);
    }
    DECLARE_FUNCTION(execPlayCameraAnim)
    {
        P_GET_OBJECT(UCameraAnim,Anim);
        P_GET_FLOAT_OPTX(Rate,1.000000);
        P_GET_FLOAT_OPTX(Scale,1.000000);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLoop,FALSE);
        P_GET_UBOOL_OPTX(bRandomStartTime,FALSE);
        P_GET_FLOAT_OPTX(Duration,0);
        P_GET_UBOOL_OPTX(bSingleInstance,FALSE);
        P_FINISH;
        *(class UCameraAnimInst**)Result=PlayCameraAnim(Anim,Rate,Scale,BlendInTime,BlendOutTime,bLoop,bRandomStartTime,Duration,bSingleInstance);
    }
    DECLARE_FUNCTION(execStopAllCameraAnims)
    {
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        StopAllCameraAnims(bImmediate);
    }
    DECLARE_FUNCTION(execStopAllCameraAnimsByType)
    {
        P_GET_OBJECT(UCameraAnim,Anim);
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        StopAllCameraAnimsByType(Anim,bImmediate);
    }
    DECLARE_FUNCTION(execStopCameraAnim)
    {
        P_GET_OBJECT(UCameraAnimInst,AnimInst);
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        StopCameraAnim(AnimInst,bImmediate);
    }
    DECLARE_CLASS(AAnimatedCamera,ACamera,0,Engine)
protected:
	UCameraAnimInst* AllocCameraAnimInst();
	void ReleaseCameraAnimInst(UCameraAnimInst* Inst);
	UCameraAnimInst* FindExistingCameraAnimInst(UCameraAnim const* Anim);
	
	static void AddScaledInterpProperties(class ACameraActor const* SrcCam, class ACameraActor* DestCam, FLOAT Scale);
	static void ResetInterpProperties(class ACameraActor *CamActor);
	void ApplyInterpPropertiesFromCameraActor(class ACameraActor const* CamActor, FTPOV& OutPOV);

	void ResetTempCameraActor(class ACameraActor* CamActor) const;
public:

	virtual void ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const;
};

class ACameraActor : public AActor
{
public:
    //## BEGIN PROPS CameraActor
    BITFIELD bConstrainAspectRatio:1;
    BITFIELD bCamOverridePostProcess:1;
    FLOAT AspectRatio;
    FLOAT FOVAngle;
    struct FPostProcessSettings CamOverridePostProcess;
    class UDrawFrustumComponent* DrawFrustum;
    class UStaticMeshComponent* MeshComp;
    //## END PROPS CameraActor

    DECLARE_CLASS(ACameraActor,AActor,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// AActor interface
	virtual void Spawned();
protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:

	// ACameraActor interface
	void UpdateDrawFrustum();
};

class ADynamicCameraActor : public ACameraActor
{
public:
    //## BEGIN PROPS DynamicCameraActor
    //## END PROPS DynamicCameraActor

    DECLARE_CLASS(ADynamicCameraActor,ACameraActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADynamicCameraActor)
};

struct FBasedPosition
{
    class AActor* Base;
    FVector Position;
    FVector CachedBaseLocation;
    FRotator CachedBaseRotation;
    FVector CachedTransPosition;

		FBasedPosition()
		{
			Base = NULL;
			Position = FVector(0,0,0);
		}
		explicit FBasedPosition( class AActor *InBase, FVector& InPosition )
		{
			Set( InBase, InPosition );
		}
		// Retrieve world location of this position
		FORCEINLINE FVector operator*()
		{
			if( Base != NULL )
			{
				// If base hasn't changed location/rotation use cached transformed position
				if( CachedBaseLocation != Base->Location ||
					CachedBaseRotation != Base->Rotation )
				{
					CachedBaseLocation	= Base->Location;
					CachedBaseRotation	= Base->Rotation;
					CachedTransPosition = Base->Location + FRotationMatrix(Base->Rotation).TransformFVector(Position);
				}

				return CachedTransPosition;
			}
			return Position;
		}

		void Set( class AActor* InBase, FVector& InPosition )
		{
			if( InPosition.IsNearlyZero() )
			{
				Base = NULL;
				Position = FVector(0,0,0);
				return;
			}

			Base = (InBase && !InBase->bStatic) ? InBase : NULL;
			if( Base != NULL )
			{
				Position = FRotationMatrix(Base->Rotation).InverseTransformFVectorNoScale( InPosition - Base->Location );

				CachedBaseLocation	= Base->Location;
				CachedBaseRotation	= Base->Rotation;
				CachedTransPosition = InPosition;
			}
			else
			{
				Position = InPosition;
			}
		}
	
};

struct FVisiblePortalInfo
{
    class AActor* Source;
    class AActor* Destination;

		FVisiblePortalInfo()
		{}
		FVisiblePortalInfo(EEventParm)
		{
			appMemzero(this, sizeof(FVisiblePortalInfo));
		}
		FVisiblePortalInfo(AActor* InSource, AActor* InDest)
		: Source(InSource), Destination(InDest)
		{}

		UBOOL operator==(const FVisiblePortalInfo& Other)
		{
			return Other.Source == Source && Other.Destination == Destination;
		}
	
};

#define UCONST_LATENT_MOVETOWARD 503

struct Controller_eventCurrentLevelUnloaded_Parms
{
    Controller_eventCurrentLevelUnloaded_Parms(EEventParm)
    {
    }
};
struct Controller_eventIsInCombat_Parms
{
    UBOOL ReturnValue;
    Controller_eventIsInCombat_Parms(EEventParm)
    {
    }
};
struct Controller_eventIsSpectating_Parms
{
    UBOOL ReturnValue;
    Controller_eventIsSpectating_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyCoverAdjusted_Parms
{
    Controller_eventNotifyCoverAdjusted_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyMissedJump_Parms
{
    Controller_eventNotifyMissedJump_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyJumpApex_Parms
{
    Controller_eventNotifyJumpApex_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyBump_Parms
{
    class AActor* Other;
    FVector HitNormal;
    UBOOL ReturnValue;
    Controller_eventNotifyBump_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyFallingHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    Controller_eventNotifyFallingHitWall_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    UBOOL ReturnValue;
    Controller_eventNotifyHitWall_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyLanded_Parms
{
    FVector HitNormal;
    class AActor* FloorActor;
    UBOOL ReturnValue;
    Controller_eventNotifyLanded_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyHeadVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    UBOOL ReturnValue;
    Controller_eventNotifyHeadVolumeChange_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyPhysicsVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    Controller_eventNotifyPhysicsVolumeChange_Parms(EEventParm)
    {
    }
};
struct Controller_eventGetPlayerViewPoint_Parms
{
    FVector out_Location;
    FRotator out_Rotation;
    Controller_eventGetPlayerViewPoint_Parms(EEventParm)
    {
    }
};
struct Controller_eventHandlePathObstruction_Parms
{
    class AActor* BlockedBy;
    UBOOL ReturnValue;
    Controller_eventHandlePathObstruction_Parms(EEventParm)
    {
    }
};
struct Controller_eventMoverFinished_Parms
{
    UBOOL ReturnValue;
    Controller_eventMoverFinished_Parms(EEventParm)
    {
    }
};
struct Controller_eventAllowDetourTo_Parms
{
    class ANavigationPoint* N;
    UBOOL ReturnValue;
    Controller_eventAllowDetourTo_Parms(EEventParm)
    {
    }
};
struct Controller_eventMayFall_Parms
{
    Controller_eventMayFall_Parms(EEventParm)
    {
    }
};
struct Controller_eventLongFall_Parms
{
    Controller_eventLongFall_Parms(EEventParm)
    {
    }
};
struct Controller_eventMoveUnreachable_Parms
{
    FVector AttemptedDest;
    class AActor* AttemptedTarget;
    Controller_eventMoveUnreachable_Parms(EEventParm)
    {
    }
};
struct Controller_eventSetupSpecialPathAbilities_Parms
{
    Controller_eventSetupSpecialPathAbilities_Parms(EEventParm)
    {
    }
};
struct Controller_eventEnemyNotVisible_Parms
{
    Controller_eventEnemyNotVisible_Parms(EEventParm)
    {
    }
};
struct Controller_eventSeeMonster_Parms
{
    class APawn* Seen;
    Controller_eventSeeMonster_Parms(EEventParm)
    {
    }
};
struct Controller_eventSeePlayer_Parms
{
    class APawn* Seen;
    Controller_eventSeePlayer_Parms(EEventParm)
    {
    }
};
struct Controller_eventHearNoise_Parms
{
    FLOAT Loudness;
    class AActor* NoiseMaker;
    FName NoiseType;
    Controller_eventHearNoise_Parms(EEventParm)
    {
    }
};
struct Controller_eventStopFiring_Parms
{
    Controller_eventStopFiring_Parms(EEventParm)
    {
    }
};
struct Controller_eventRatePickup_Parms
{
    class AActor* PickupHolder;
    class UClass* inPickup;
    FLOAT ReturnValue;
    Controller_eventRatePickup_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyPostLanded_Parms
{
    Controller_eventNotifyPostLanded_Parms(EEventParm)
    {
    }
};
struct Controller_eventUnPossess_Parms
{
    Controller_eventUnPossess_Parms(EEventParm)
    {
    }
};
struct Controller_eventPossess_Parms
{
    class APawn* inPawn;
    UBOOL bVehicleTransition;
    Controller_eventPossess_Parms(EEventParm)
    {
    }
};
class AController : public AActor
{
public:
    //## BEGIN PROPS Controller
    class APawn* Pawn;
    class APlayerReplicationInfo* PlayerReplicationInfo;
    INT PlayerNum;
    class AController* NextController;
    BITFIELD bIsPlayer:1;
    BITFIELD bGodMode:1;
    BITFIELD bAffectedByHitEffects:1;
    BITFIELD bSoaking:1;
    BITFIELD bSlowerZAcquire:1;
    BITFIELD bForceStrafe:1;
    BITFIELD bNotifyPostLanded:1;
    BITFIELD bNotifyApex:1;
    BITFIELD bAdvancedTactics:1;
    BITFIELD bCanDoSpecial:1;
    BITFIELD bAdjusting:1;
    BITFIELD bPreparingMove:1;
    BITFIELD bLOSflag:1;
    BITFIELD bUsePlayerHearing:1;
    BITFIELD bNotifyFallingHitWall:1;
    BITFIELD bForceDesiredRotation:1;
    BITFIELD bPreciseDestination:1;
    BITFIELD bSeeFriendly:1;
    BITFIELD bUsingPathLanes:1;
    BYTE bFire GCC_BITFIELD_MAGIC;
    FLOAT MinHitWall;
    FLOAT MoveTimer;
    class AActor* MoveTarget;
    struct FBasedPosition DestinationPosition;
    struct FBasedPosition FocalPosition;
    class AActor* Focus;
    class AActor* GoalList[4];
    struct FBasedPosition AdjustPosition;
    class ANavigationPoint* StartSpot;
    TArrayNoInit<class ANavigationPoint*> RouteCache;
    class UReachSpec* CurrentPath;
    class UReachSpec* NextRoutePath;
    FVector CurrentPathDir;
    class AActor* RouteGoal;
    FLOAT RouteDist;
    FLOAT LastRouteFind;
    class AInterpActor* PendingMover;
    class AActor* FailedMoveTarget;
    INT MoveFailureCount;
    FLOAT GroundPitchTime;
    FVector ViewX;
    FVector ViewY;
    FVector ViewZ;
    class APawn* ShotTarget;
    class AActor* LastFailedReach;
    FLOAT FailedReachTime;
    FVector FailedReachLocation;
    FLOAT SightCounter;
    FLOAT SightCounterInterval;
    FLOAT RespawnPredictionTime;
    FLOAT InUseNodeCostMultiplier;
    INT HighJumpNodeCostModifier;
    class APawn* Enemy;
    class AActor* Target;
    TArrayNoInit<struct FVisiblePortalInfo> VisiblePortals;
    FLOAT LaneOffset;
    FRotator OldBasedRotation;
    //## END PROPS Controller

    virtual UBOOL IsLocalPlayerController();
    virtual void RouteCache_Empty();
    virtual void RouteCache_AddItem(class ANavigationPoint* Nav);
    virtual void RouteCache_InsertItem(class ANavigationPoint* Nav,INT Idx=0);
    virtual void RouteCache_RemoveItem(class ANavigationPoint* Nav);
    virtual void RouteCache_RemoveIndex(INT InIndex,INT Count=1);
    void SetBasedPosition(struct FBasedPosition& BP,FVector pos,class AActor* ForcedBase=NULL);
    FVector GetBasedPosition(struct FBasedPosition BP);
    void SetFocalPoint(FVector FP,UBOOL bOffsetFromBase=FALSE);
    FVector GetFocalPoint();
    void SetDestinationPosition(FVector Dest,UBOOL bOffsetFromBase=FALSE);
    FVector GetDestinationPosition();
    virtual void SetAdjustLocation(FVector NewLoc,UBOOL bAdjust,UBOOL bOffsetFromBase=FALSE);
    FVector GetAdjustLocation();
    UBOOL BeyondFogDistance(FVector ViewPoint,FVector OtherPoint);
    virtual BYTE GetTeamNum();
    UBOOL CanSee(class APawn* Other);
    UBOOL CanSeeByPoints(FVector ViewLocation,FVector TestLocation,FRotator ViewRotation);
    class APawn* PickTarget(class UClass* TargetClass,FLOAT& bestAim,FLOAT& bestDist,FVector FireDir,FVector projStart,FLOAT MaxRange);
    void FinishRotation();
    class AActor* FindPathTo(FVector aPoint,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    class AActor* FindPathToward(class AActor* anActor,UBOOL bWeightDetours=FALSE,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    class AActor* FindPathTowardNearest(class UClass* GoalClass,UBOOL bWeightDetours=FALSE,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    class ANavigationPoint* FindRandomDest();
    class AActor* FindPathToIntercept(class APawn* P,class AActor* InRouteGoal,UBOOL bWeightDetours=FALSE,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    UBOOL PointReachable(FVector aPoint);
    UBOOL ActorReachable(class AActor* anActor);
    UBOOL PickWallAdjust(FVector HitNormal);
    virtual void EndClimbLadder();
    UBOOL InLatentExecution(INT LatentActionNumber);
    void StopLatentExecution();
    DECLARE_FUNCTION(execIsLocalPlayerController)
    {
        P_FINISH;
        *(UBOOL*)Result=IsLocalPlayerController();
    }
    DECLARE_FUNCTION(execRouteCache_Empty)
    {
        P_FINISH;
        RouteCache_Empty();
    }
    DECLARE_FUNCTION(execRouteCache_AddItem)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        RouteCache_AddItem(Nav);
    }
    DECLARE_FUNCTION(execRouteCache_InsertItem)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_GET_INT_OPTX(Idx,0);
        P_FINISH;
        RouteCache_InsertItem(Nav,Idx);
    }
    DECLARE_FUNCTION(execRouteCache_RemoveItem)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        RouteCache_RemoveItem(Nav);
    }
    DECLARE_FUNCTION(execRouteCache_RemoveIndex)
    {
        P_GET_INT(InIndex);
        P_GET_INT_OPTX(Count,1);
        P_FINISH;
        RouteCache_RemoveIndex(InIndex,Count);
    }
    DECLARE_FUNCTION(execSetBasedPosition)
    {
        P_GET_STRUCT_REF(struct FBasedPosition,BP);
        P_GET_STRUCT(FVector,pos);
        P_GET_OBJECT_OPTX(AActor,ForcedBase,NULL);
        P_FINISH;
        SetBasedPosition(BP,pos,ForcedBase);
    }
    DECLARE_FUNCTION(execGetBasedPosition)
    {
        P_GET_STRUCT(struct FBasedPosition,BP);
        P_FINISH;
        *(FVector*)Result=GetBasedPosition(BP);
    }
    DECLARE_FUNCTION(execSetFocalPoint)
    {
        P_GET_STRUCT(FVector,FP);
        P_GET_UBOOL_OPTX(bOffsetFromBase,FALSE);
        P_FINISH;
        SetFocalPoint(FP,bOffsetFromBase);
    }
    DECLARE_FUNCTION(execGetFocalPoint)
    {
        P_FINISH;
        *(FVector*)Result=GetFocalPoint();
    }
    DECLARE_FUNCTION(execSetDestinationPosition)
    {
        P_GET_STRUCT(FVector,Dest);
        P_GET_UBOOL_OPTX(bOffsetFromBase,FALSE);
        P_FINISH;
        SetDestinationPosition(Dest,bOffsetFromBase);
    }
    DECLARE_FUNCTION(execGetDestinationPosition)
    {
        P_FINISH;
        *(FVector*)Result=GetDestinationPosition();
    }
    DECLARE_FUNCTION(execSetAdjustLocation)
    {
        P_GET_STRUCT(FVector,NewLoc);
        P_GET_UBOOL(bAdjust);
        P_GET_UBOOL_OPTX(bOffsetFromBase,FALSE);
        P_FINISH;
        SetAdjustLocation(NewLoc,bAdjust,bOffsetFromBase);
    }
    DECLARE_FUNCTION(execGetAdjustLocation)
    {
        P_FINISH;
        *(FVector*)Result=GetAdjustLocation();
    }
    DECLARE_FUNCTION(execBeyondFogDistance)
    {
        P_GET_STRUCT(FVector,ViewPoint);
        P_GET_STRUCT(FVector,OtherPoint);
        P_FINISH;
        *(UBOOL*)Result=BeyondFogDistance(ViewPoint,OtherPoint);
    }
    DECLARE_FUNCTION(execLineOfSightTo);
    DECLARE_FUNCTION(execCanSee)
    {
        P_GET_OBJECT(APawn,Other);
        P_FINISH;
        *(UBOOL*)Result=CanSee(Other);
    }
    DECLARE_FUNCTION(execCanSeeByPoints)
    {
        P_GET_STRUCT(FVector,ViewLocation);
        P_GET_STRUCT(FVector,TestLocation);
        P_GET_STRUCT(FRotator,ViewRotation);
        P_FINISH;
        *(UBOOL*)Result=CanSeeByPoints(ViewLocation,TestLocation,ViewRotation);
    }
    DECLARE_FUNCTION(execPickTarget)
    {
        P_GET_OBJECT(UClass,TargetClass);
        P_GET_FLOAT_REF(bestAim);
        P_GET_FLOAT_REF(bestDist);
        P_GET_STRUCT(FVector,FireDir);
        P_GET_STRUCT(FVector,projStart);
        P_GET_FLOAT(MaxRange);
        P_FINISH;
        *(class APawn**)Result=PickTarget(TargetClass,bestAim,bestDist,FireDir,projStart,MaxRange);
    }
    DECLARE_FUNCTION(execMoveTo);
    DECLARE_FUNCTION(execMoveToward);
    DECLARE_FUNCTION(execFinishRotation)
    {
        P_FINISH;
        FinishRotation();
    }
    DECLARE_FUNCTION(execFindPathTo)
    {
        P_GET_STRUCT(FVector,aPoint);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=FindPathTo(aPoint,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execFindPathToward)
    {
        P_GET_OBJECT(AActor,anActor);
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=FindPathToward(anActor,bWeightDetours,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execFindPathTowardNearest)
    {
        P_GET_OBJECT(UClass,GoalClass);
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=FindPathTowardNearest(GoalClass,bWeightDetours,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execFindRandomDest)
    {
        P_FINISH;
        *(class ANavigationPoint**)Result=FindRandomDest();
    }
    DECLARE_FUNCTION(execFindPathToIntercept)
    {
        P_GET_OBJECT(APawn,P);
        P_GET_OBJECT(AActor,InRouteGoal);
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=FindPathToIntercept(P,InRouteGoal,bWeightDetours,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execPointReachable)
    {
        P_GET_STRUCT(FVector,aPoint);
        P_FINISH;
        *(UBOOL*)Result=PointReachable(aPoint);
    }
    DECLARE_FUNCTION(execActorReachable)
    {
        P_GET_OBJECT(AActor,anActor);
        P_FINISH;
        *(UBOOL*)Result=ActorReachable(anActor);
    }
    DECLARE_FUNCTION(execPickWallAdjust)
    {
        P_GET_STRUCT(FVector,HitNormal);
        P_FINISH;
        *(UBOOL*)Result=PickWallAdjust(HitNormal);
    }
    DECLARE_FUNCTION(execWaitForLanding);
    DECLARE_FUNCTION(execEndClimbLadder)
    {
        P_FINISH;
        EndClimbLadder();
    }
    DECLARE_FUNCTION(execInLatentExecution)
    {
        P_GET_INT(LatentActionNumber);
        P_FINISH;
        *(UBOOL*)Result=InLatentExecution(LatentActionNumber);
    }
    DECLARE_FUNCTION(execStopLatentExecution)
    {
        P_FINISH;
        StopLatentExecution();
    }
    void eventCurrentLevelUnloaded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CurrentLevelUnloaded),NULL);
    }
    UBOOL eventIsInCombat()
    {
        Controller_eventIsInCombat_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsInCombat),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsSpectating()
    {
        Controller_eventIsSpectating_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsSpectating),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyCoverAdjusted()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyCoverAdjusted),NULL);
    }
    void eventNotifyMissedJump()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyMissedJump),NULL);
    }
    void eventNotifyJumpApex()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyJumpApex),NULL);
    }
    UBOOL eventNotifyBump(class AActor* Other,FVector HitNormal)
    {
        Controller_eventNotifyBump_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyBump)) {
        Parms.Other=Other;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyBump),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventNotifyFallingHitWall(FVector HitNormal,class AActor* Wall)
    {
        Controller_eventNotifyFallingHitWall_Parms Parms(EC_EventParm);
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyFallingHitWall),&Parms);
    }
    UBOOL eventNotifyHitWall(FVector HitNormal,class AActor* Wall)
    {
        Controller_eventNotifyHitWall_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyHitWall)) {
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHitWall),&Parms);
        }
        return Parms.ReturnValue;
    }
    UBOOL eventNotifyLanded(FVector HitNormal,class AActor* FloorActor)
    {
        Controller_eventNotifyLanded_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyLanded)) {
        Parms.HitNormal=HitNormal;
        Parms.FloorActor=FloorActor;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyLanded),&Parms);
        }
        return Parms.ReturnValue;
    }
    UBOOL eventNotifyHeadVolumeChange(class APhysicsVolume* NewVolume)
    {
        Controller_eventNotifyHeadVolumeChange_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyHeadVolumeChange)) {
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHeadVolumeChange),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventNotifyPhysicsVolumeChange(class APhysicsVolume* NewVolume)
    {
        Controller_eventNotifyPhysicsVolumeChange_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_NotifyPhysicsVolumeChange)) {
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPhysicsVolumeChange),&Parms);
        }
    }
    void eventGetPlayerViewPoint(FVector& out_Location,FRotator& out_Rotation)
    {
        Controller_eventGetPlayerViewPoint_Parms Parms(EC_EventParm);
        Parms.out_Location=out_Location;
        Parms.out_Rotation=out_Rotation;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPlayerViewPoint),&Parms);
        out_Location=Parms.out_Location;
        out_Rotation=Parms.out_Rotation;
    }
    UBOOL eventHandlePathObstruction(class AActor* BlockedBy)
    {
        Controller_eventHandlePathObstruction_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.BlockedBy=BlockedBy;
        ProcessEvent(FindFunctionChecked(ENGINE_HandlePathObstruction),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventMoverFinished()
    {
        Controller_eventMoverFinished_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MoverFinished),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventAllowDetourTo(class ANavigationPoint* N)
    {
        Controller_eventAllowDetourTo_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.N=N;
        ProcessEvent(FindFunctionChecked(ENGINE_AllowDetourTo),&Parms);
        return Parms.ReturnValue;
    }
    void eventMayFall()
    {
        if(IsProbing(NAME_MayFall)) {
        ProcessEvent(FindFunctionChecked(ENGINE_MayFall),NULL);
        }
    }
    void eventLongFall()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LongFall),NULL);
    }
    void eventMoveUnreachable(FVector AttemptedDest,class AActor* AttemptedTarget)
    {
        Controller_eventMoveUnreachable_Parms Parms(EC_EventParm);
        Parms.AttemptedDest=AttemptedDest;
        Parms.AttemptedTarget=AttemptedTarget;
        ProcessEvent(FindFunctionChecked(ENGINE_MoveUnreachable),&Parms);
    }
    void eventSetupSpecialPathAbilities()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetupSpecialPathAbilities),NULL);
    }
    void eventEnemyNotVisible()
    {
        if(IsProbing(NAME_EnemyNotVisible)) {
        ProcessEvent(FindFunctionChecked(ENGINE_EnemyNotVisible),NULL);
        }
    }
    void eventSeeMonster(class APawn* Seen)
    {
        Controller_eventSeeMonster_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_SeeMonster)) {
        Parms.Seen=Seen;
        ProcessEvent(FindFunctionChecked(ENGINE_SeeMonster),&Parms);
        }
    }
    void eventSeePlayer(class APawn* Seen)
    {
        Controller_eventSeePlayer_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_SeePlayer)) {
        Parms.Seen=Seen;
        ProcessEvent(FindFunctionChecked(ENGINE_SeePlayer),&Parms);
        }
    }
    void eventHearNoise(FLOAT Loudness,class AActor* NoiseMaker,FName NoiseType=NAME_None)
    {
        Controller_eventHearNoise_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_HearNoise)) {
        Parms.Loudness=Loudness;
        Parms.NoiseMaker=NoiseMaker;
        Parms.NoiseType=NoiseType;
        ProcessEvent(FindFunctionChecked(ENGINE_HearNoise),&Parms);
        }
    }
    void eventStopFiring()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StopFiring),NULL);
    }
    FLOAT eventRatePickup(class AActor* PickupHolder,class UClass* inPickup)
    {
        Controller_eventRatePickup_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PickupHolder=PickupHolder;
        Parms.inPickup=inPickup;
        ProcessEvent(FindFunctionChecked(ENGINE_RatePickup),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPostLanded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPostLanded),NULL);
    }
    void eventUnPossess()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_UnPossess),NULL);
    }
    void eventPossess(class APawn* inPawn,UBOOL bVehicleTransition)
    {
        Controller_eventPossess_Parms Parms(EC_EventParm);
        Parms.inPawn=inPawn;
        Parms.bVehicleTransition=bVehicleTransition ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Possess),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AController,AActor,0|CLASS_NativeReplication,Engine)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual void Spawned();

	virtual UBOOL IsPlayerOwned()
	{
	return IsPlayerOwner();
	}

	virtual UBOOL IsPlayerOwner()
	{
		return bIsPlayer;
	}
	virtual AController* GetAController() { return this; }

	// Seeing and hearing checks
	virtual UBOOL CanHear(const FVector& NoiseLoc, FLOAT Loudness, AActor *Other);
	virtual void ShowSelf();
	virtual UBOOL ShouldCheckVisibilityOf(AController* C);
	virtual DWORD SeePawn(APawn *Other, UBOOL bMaySkipChecks = TRUE);
	virtual DWORD LineOfSightTo(const AActor* Other, INT bUseLOSFlag=0, const FVector* chkLocation = NULL, UBOOL bTryAlternateTargetLoc = FALSE);
	void CheckEnemyVisible();
	virtual void HearNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType);

	AActor* HandleSpecial(AActor *bestPath);
	virtual INT AcceptNearbyPath(AActor* goal);
	virtual UReachSpec* PrepareForMove( ANavigationPoint *NavGoal, UReachSpec* Path );
	UReachSpec* GetNextRoutePath( ANavigationPoint *NavGoal );
	virtual void AdjustFromWall(FVector HitNormal, AActor* HitActor);
	void SetRouteCache( ANavigationPoint *EndPath, FLOAT StartDist, FLOAT EndDist );
	AActor* FindPath(const FVector& Point, AActor* Goal, UBOOL bWeightDetours, INT MaxPathLength, UBOOL bReturnPartial);
	/** given the passed in goal for pathfinding, set bTransientEndPoint on all NavigationPoints that are acceptable
	 * destinations on the path network
	 * @param EndAnchor the Anchor for the goal on the navigation network
	 * @param Goal the goal actor we're pathfinding toward (may be NULL)
	 * @param GoalLocation the goal world location we're pathfinding toward
	 */
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	/** gives the Controller a chance to pre-empt pathfinding with its own result (if a cached path is still valid, for example)
	 * called just before navigation network traversal, after Anchor determination and NavigationPoint transient properties are set up
	 * only called when using the 'FindEndPoint' node evaluator
	 * @param EndAnchor - Anchor for Goal on the path network
	 * @param Goal - Destination Actor we're trying to path to (may be NULL)
	 * @param GoalLocation - the goal world location we're pathfinding toward
	 * @param bWeightDetours - whether we should consider short detours for pickups and such
	 * @param BestWeight - weighting value for best node on path - if this function returns true, findPathToward() will return this value
	 * @return whether the normal pathfinding should be skipped
	 */
	virtual UBOOL OverridePathTo(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation, UBOOL bWeightDetours, FLOAT& BestWeight)
	{
		return FALSE;
	}
	AActor* SetPath(INT bInitialPath=1);
	virtual UBOOL LocalPlayerController();
	virtual UBOOL WantsLedgeCheck();
	virtual UBOOL StopAtLedge();
	virtual void PrePollMove()
	{}
	virtual void PostPollMove()
	{}
	virtual AActor* GetViewTarget();
	virtual void UpdateEnemyInfo(APawn* AcquiredEnemy) {};
	virtual void JumpOverWall(FVector WallNormal);
	virtual void UpdatePawnRotation();
	virtual UBOOL ForceReached(ANavigationPoint *Nav, const FVector& TestPosition);
	virtual FRotator SetRotationRate(FLOAT deltaTime);
	virtual FVector DesiredDirection();
	/** activates path lanes for this Controller's current movement and adjusts its destination accordingly
	 * @param DesiredLaneOffset the offset from the center of the Controller's CurrentPath that is desired
	 * 				the Controller sets its LaneOffset as close as it can get to it without
	 *				allowing any part of the Pawn's cylinder outside of the CurrentPath
	 */
	void SetPathLane(FLOAT InPathOffset);
	virtual void FailMove();

	// falling physics AI hooks
	virtual void PreAirSteering(FLOAT DeltaTime) {};
	virtual void PostAirSteering(FLOAT DeltaTime) {};
	virtual void PostPhysFalling(FLOAT DeltaTime) {};
	virtual void PostPhysWalking(FLOAT DeltaTime) {};
	virtual void PostPhysSpider(FLOAT DeltaTime) {};
	virtual UBOOL AirControlFromWall(float DeltaTime, FVector& RealAcceleration) { return FALSE; };
	virtual void NotifyJumpApex();

	virtual void PostBeginPlay();
	virtual void PostScriptDestroyed();

	virtual void ClearCrossLevelPaths(ULevel *Level);

	// Natives.
	DECLARE_FUNCTION(execPollWaitForLanding);
	DECLARE_FUNCTION(execPollMoveTo);
	virtual DECLARE_FUNCTION(execPollMoveToward);
	DECLARE_FUNCTION(execPollFinishRotation);

	virtual UBOOL ShouldOffsetCorners() { return TRUE; }
	virtual UBOOL ShouldUsePathLanes() { return TRUE; }
	virtual UBOOL ShouldIgnoreNavigationBlockingFor(const AActor* Other){ return !Other->bBlocksNavigation; }
};

struct FLocalizedStringSetting
{
    INT Id;
    INT ValueIndex;
    BYTE AdvertisementType;

    /** Constructors */
    FLocalizedStringSetting() {}
    FLocalizedStringSetting(EEventParm)
    {
        appMemzero(this, sizeof(FLocalizedStringSetting));
    }
};

struct FSettingsData
{
    BYTE Type;
    INT Value1;
    INT* Value2;

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(const FString& InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(const TCHAR* InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(INT InData);

		/**
		 * Copies the data and sets the type to DateTime
		 *
		 * @param InData1 the first part to assign
		 * @param InData2 the second part to assign
		 */
		void SetData(INT InData1,INT InData2);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(DOUBLE InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(FLOAT InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(const TArray<BYTE>& InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param Size the length of the buffer to copy
		 * @param InData the new data to assign
		 */
		void SetData(DWORD Size,const BYTE* InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(QWORD InData);

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(FString& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(INT& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(QWORD& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(FLOAT& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(TArray<BYTE>& OutData) const;

		/**
		 * Copies the data after verifying the type.
		 * NOTE: Performs a deep copy so you are repsonsible for freeing the data
		 *
		 * @param OutSize out value that receives the size of the copied data
		 * @param OutData out value that receives the copied data
		 */
		void GetData(DWORD& OutSize,BYTE** OutData) const;

		/**
		 * Copies the data into the two fields after verifying the type is DateTime
		 *
		 * @param InData1 the first part to assign
		 * @param InData2 the second part to assign
		 */
		void GetData(INT& InData1,INT& InData2) const;

		/**
		 * Increments the value by the specified amount
		 *
		 * @param IncBy the amount to increment by
		 */
		template<typename TYPE,ESettingsDataType ENUM_TYPE>
		FORCEINLINE void Increment(TYPE IncBy)
		{
			checkSlow(Type == SDT_Int32 || Type == SDT_Int64 ||
				Type == SDT_Float || Type == SDT_Double);
			if (Type == ENUM_TYPE)
			{
				*(TYPE*)&Value1 += IncBy;
			}
		}

		/**
		 * Decrements the value by the specified amount
		 *
		 * @param DecBy the amount to decrement by
		 */
		template<typename TYPE,ESettingsDataType ENUM_TYPE>
		FORCEINLINE void Decrement(TYPE DecBy)
		{
			checkSlow(Type == SDT_Int32 || Type == SDT_Int64 ||
				Type == SDT_Float || Type == SDT_Double);
			if (Type == ENUM_TYPE)
			{
				*(TYPE*)&Value1 -= DecBy;
			}
		}

		/**
		 * Cleans up the existing data and sets the type to ODT_Empty
		 */
		void CleanUp(void);

		/** Does nothing (no init version) */
		FSettingsData(void)
		{
		}

		/**
		 * Zeroes members
		 */
		FSettingsData(EEventParm) :
			Type(SDT_Empty),
			Value1(0),
			Value2(0)
		{
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsData(const FSettingsData& Other);

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsData& operator=(const FSettingsData& Other);

		/**
		 * Cleans up the data to prevent leaks
		 */
		~FSettingsData(void)
		{
			CleanUp();
		}

		/**
		 * Converts the data into a string representation
		 */
		FString ToString(void) const;

		/**
		 * Converts the string to the specified type of data for this setting
		 *
		 * @param NewValue the string value to convert
		 *
		 * @return TRUE if it was converted, FALSE otherwise
		 */
		UBOOL FromString(const FString& NewValue);

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(DOUBLE& OutData) const;

		/** @return The type as a string */
		const TCHAR* GetTypeString(void) const
		{
			switch (Type)
			{
				case SDT_Empty: return TEXT("Empty");
				case SDT_Int32: return TEXT("Int32");
				case SDT_Int64: return TEXT("Int64");
				case SDT_Double: return TEXT("Double");
				case SDT_String: return TEXT("String");
				case SDT_Float: return TEXT("Float");
				case SDT_Blob: return TEXT("Blob");
				case SDT_DateTime: return TEXT("DateTime");
			};
			return TEXT("Empty");
		}

		/**
		 * Comparison of two settings data classes
		 *
		 * @param Other the other settings data to compare against
		 *
		 * @return TRUE if they are equal, FALSE otherwise
		 */
		UBOOL operator==(const FSettingsData& Other) const;
		UBOOL operator!=(const FSettingsData& Other) const;

		/**
		 * Comparison of a value against this settings data type
		 *
		 * @param Other the value to compare against
		 *
		 * @return TRUE if they are equal (type and value), FALSE otherwise
		 */
		UBOOL operator==(const FLOAT Other) const;
		UBOOL operator!=(const FLOAT Other) const;

		/**
		 * Comparison of a value against this settings data type
		 *
		 * @param Other the value to compare against
		 *
		 * @return TRUE if they are equal (type and value), FALSE otherwise
		 */
		UBOOL operator==(const INT Other) const;
		UBOOL operator!=(const INT Other) const;

		/**
		 * Comparison of a value against this settings data type
		 *
		 * @param Other the value to compare against
		 *
		 * @return TRUE if they are equal (type and value), FALSE otherwise
		 */
		UBOOL operator==(const DOUBLE Other) const;
		UBOOL operator!=(const DOUBLE Other) const;

		/**
		 * Comparison of a value against this settings data type
		 *
		 * @param Other the value to compare against
		 *
		 * @return TRUE if they are equal (type and value), FALSE otherwise
		 */
		UBOOL operator==(const QWORD Other) const;
		UBOOL operator!=(const QWORD Other) const;

		/**
		 * Comparison of a value against this settings data type
		 *
		 * @param Other the value to compare against
		 *
		 * @return TRUE if they are equal (type and value), FALSE otherwise
		 */
		UBOOL operator==(const FString& Other) const;
		UBOOL operator!=(const FString& Other) const;

		/**
		 * Comparison of a value against this settings data type
		 *
		 * @param Other the value to compare against
		 *
		 * @return TRUE if they are equal (type and value), FALSE otherwise
		 */
		UBOOL operator==(const TCHAR* Other) const;
		UBOOL operator!=(const TCHAR* Other) const;
	
};

struct FSettingsProperty
{
    INT PropertyId;
    struct FSettingsData Data;
    BYTE AdvertisementType;

		/** Does nothing (no init version) */
		FSettingsProperty(void)
		{
		}

		/**
		 * Zeroes members
		 */
		FSettingsProperty(EEventParm) :
			PropertyId(0),
			Data(EC_EventParm)
		{
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsProperty(const FSettingsProperty& Other)
		{
			PropertyId = Other.PropertyId;
			// This will do a deep copy
			Data = Other.Data;
		}

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsProperty& operator=(const FSettingsProperty& Other)
		{
			if (&Other != this)
			{
				PropertyId = Other.PropertyId;
				// This will do a deep copy
				Data = Other.Data;
			}
			return *this;
		}
	
};

struct FStringIdToStringMapping
{
    INT Id;
    FName Name;
    BITFIELD bIsWildcard:1;

    /** Constructors */
    FStringIdToStringMapping() {}
    FStringIdToStringMapping(EEventParm)
    {
        appMemzero(this, sizeof(FStringIdToStringMapping));
    }
};

struct FLocalizedStringSettingMetaData
{
    INT Id;
    FName Name;
    FStringNoInit ColumnHeaderText;
    TArrayNoInit<struct FStringIdToStringMapping> ValueMappings;

    /** Constructors */
    FLocalizedStringSettingMetaData() {}
    FLocalizedStringSettingMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FLocalizedStringSettingMetaData));
    }
};

struct FIdToStringMapping
{
    INT Id;
    FName Name;

    /** Constructors */
    FIdToStringMapping() {}
    FIdToStringMapping(EEventParm)
    {
        appMemzero(this, sizeof(FIdToStringMapping));
    }
};

struct FSettingsPropertyPropertyMetaData
{
    INT Id;
    FName Name;
    FStringNoInit ColumnHeaderText;
    BYTE MappingType;
    TArrayNoInit<struct FIdToStringMapping> ValueMappings;
    TArrayNoInit<struct FSettingsData> PredefinedValues;
    FLOAT MinVal;
    FLOAT MaxVal;
    FLOAT RangeIncrement;

    /** Constructors */
    FSettingsPropertyPropertyMetaData() {}
    FSettingsPropertyPropertyMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FSettingsPropertyPropertyMetaData));
    }
};

struct Settings_eventNotifyPropertyValueUpdated_Parms
{
    FName PropertyName;
    Settings_eventNotifyPropertyValueUpdated_Parms(EEventParm)
    {
    }
};
struct Settings_eventNotifySettingValueUpdated_Parms
{
    FName SettingName;
    Settings_eventNotifySettingValueUpdated_Parms(EEventParm)
    {
    }
};
class USettings : public UObject
{
public:
    //## BEGIN PROPS Settings
    TArrayNoInit<struct FLocalizedStringSetting> LocalizedSettings;
    TArrayNoInit<struct FSettingsProperty> Properties;
    TArrayNoInit<struct FLocalizedStringSettingMetaData> LocalizedSettingsMappings;
    TArrayNoInit<struct FSettingsPropertyPropertyMetaData> PropertyMappings;
    FScriptDelegate __NotifySettingValueUpdated__Delegate;
    FScriptDelegate __NotifyPropertyValueUpdated__Delegate;
    //## END PROPS Settings

    void SetSettingsDataString(struct FSettingsData& Data,const FString& InString);
    void SetSettingsDataFloat(struct FSettingsData& Data,FLOAT InFloat);
    void SetSettingsDataInt(struct FSettingsData& Data,INT InInt);
    void SetSettingsDataDateTime(struct FSettingsData& Data,INT InInt1,INT InInt2);
    void SetSettingsDataBlob(struct FSettingsData& Data,TArray<BYTE>& InBlob);
    void SetSettingsData(struct FSettingsData& Data,struct FSettingsData& Data2Copy);
    void EmptySettingsData(struct FSettingsData& Data);
    FString GetSettingsDataString(struct FSettingsData& Data);
    FLOAT GetSettingsDataFloat(struct FSettingsData& Data);
    INT GetSettingsDataInt(struct FSettingsData& Data);
    void GetSettingsDataBlob(struct FSettingsData& Data,TArray<BYTE>& OutBlob);
    void GetSettingsDataDateTime(struct FSettingsData& Data,INT& OutInt1,INT& OutInt2);
    virtual void SetStringSettingValue(INT StringSettingId,INT ValueIndex,UBOOL bShouldAutoAdd=FALSE);
    virtual UBOOL GetStringSettingValue(INT StringSettingId,INT& ValueIndex);
    virtual UBOOL IncrementStringSettingValue(INT StringSettingId,INT Direction,UBOOL bShouldWrap);
    virtual UBOOL GetStringSettingValueNames(INT StringSettingId,TArray<struct FIdToStringMapping>& Values);
    virtual void SetStringSettingValueByName(FName StringSettingName,INT ValueIndex,UBOOL bShouldAutoAdd);
    virtual UBOOL GetStringSettingValueByName(FName StringSettingName,INT& ValueIndex);
    virtual UBOOL GetStringSettingId(FName StringSettingName,INT& StringSettingId);
    virtual FName GetStringSettingName(INT StringSettingId);
    virtual FString GetStringSettingColumnHeader(INT StringSettingId);
    virtual UBOOL IsWildcardStringSetting(INT StringSettingId);
    virtual FName GetStringSettingValueName(INT StringSettingId,INT ValueIndex);
    virtual FName GetStringSettingValueNameByName(FName StringSettingName);
    virtual UBOOL SetStringSettingValueFromStringByName(FName StringSettingName,const FString& NewValue);
    virtual UBOOL GetPropertyId(FName PropertyName,INT& PropertyId);
    virtual FName GetPropertyName(INT PropertyId);
    virtual FString GetPropertyColumnHeader(INT PropertyId);
    virtual FString GetPropertyAsString(INT PropertyId);
    virtual FString GetPropertyAsStringByName(FName PropertyName);
    virtual UBOOL SetPropertyFromStringByName(FName PropertyName,const FString& NewValue);
    virtual void SetFloatProperty(INT PropertyId,FLOAT Value);
    virtual UBOOL GetFloatProperty(INT PropertyId,FLOAT& Value);
    virtual void SetIntProperty(INT PropertyId,INT Value);
    virtual UBOOL GetIntProperty(INT PropertyId,INT& Value);
    virtual void SetStringProperty(INT PropertyId,const FString& Value);
    virtual UBOOL GetStringProperty(INT PropertyId,FString& Value);
    virtual UBOOL SetPropertyValueId(INT PropertyId,INT ValueId);
    virtual UBOOL GetPropertyValueId(INT PropertyId,INT& ValueId);
    virtual BYTE GetPropertyType(INT PropertyId);
    virtual void UpdateStringSettings(const TArray<struct FLocalizedStringSetting>& Settings,UBOOL bShouldAddIfMissing=TRUE);
    virtual void UpdateProperties(const TArray<struct FSettingsProperty>& Props,UBOOL bShouldAddIfMissing=TRUE);
    virtual UBOOL HasProperty(INT PropertyId);
    virtual UBOOL HasStringSetting(INT SettingId);
    virtual UBOOL GetPropertyMappingType(INT PropertyId,BYTE& OutType);
    virtual UBOOL GetPropertyRange(INT PropertyId,FLOAT& OutMinValue,FLOAT& OutMaxValue,FLOAT& RangeIncrement,BYTE& bFormatAsInt);
    virtual UBOOL SetRangedPropertyValue(INT PropertyId,FLOAT NewValue);
    virtual UBOOL GetRangedPropertyValue(INT PropertyId,FLOAT& OutValue);
    virtual void GetQoSAdvertisedProperties(TArray<struct FSettingsProperty>& QoSProps);
    virtual void GetQoSAdvertisedStringSettings(TArray<struct FLocalizedStringSetting>& QoSSettings);
    virtual void AppendDataBindingsToURL(FString& URL);
    virtual void AppendPropertiesToURL(FString& URL);
    virtual void AppendContextsToURL(FString& URL);
    virtual void BuildURL(FString& URL);
    virtual void UpdateFromURL(const FString& URL,class AGameInfo* Game);
    DECLARE_FUNCTION(execSetSettingsDataString)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_STR(InString);
        P_FINISH;
        SetSettingsDataString(Data,InString);
    }
    DECLARE_FUNCTION(execSetSettingsDataFloat)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_FLOAT(InFloat);
        P_FINISH;
        SetSettingsDataFloat(Data,InFloat);
    }
    DECLARE_FUNCTION(execSetSettingsDataInt)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_INT(InInt);
        P_FINISH;
        SetSettingsDataInt(Data,InInt);
    }
    DECLARE_FUNCTION(execSetSettingsDataDateTime)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_INT(InInt1);
        P_GET_INT(InInt2);
        P_FINISH;
        SetSettingsDataDateTime(Data,InInt1,InInt2);
    }
    DECLARE_FUNCTION(execSetSettingsDataBlob)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_TARRAY_REF(BYTE,InBlob);
        P_FINISH;
        SetSettingsDataBlob(Data,InBlob);
    }
    DECLARE_FUNCTION(execSetSettingsData)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_STRUCT_REF(struct FSettingsData,Data2Copy);
        P_FINISH;
        SetSettingsData(Data,Data2Copy);
    }
    DECLARE_FUNCTION(execEmptySettingsData)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        EmptySettingsData(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataString)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        *(FString*)Result=GetSettingsDataString(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataFloat)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        *(FLOAT*)Result=GetSettingsDataFloat(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataInt)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        *(INT*)Result=GetSettingsDataInt(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataBlob)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_TARRAY_REF(BYTE,OutBlob);
        P_FINISH;
        GetSettingsDataBlob(Data,OutBlob);
    }
    DECLARE_FUNCTION(execGetSettingsDataDateTime)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_INT_REF(OutInt1);
        P_GET_INT_REF(OutInt2);
        P_FINISH;
        GetSettingsDataDateTime(Data,OutInt1,OutInt2);
    }
    DECLARE_FUNCTION(execSetStringSettingValue)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL_OPTX(bShouldAutoAdd,FALSE);
        P_FINISH;
        SetStringSettingValue(StringSettingId,ValueIndex,bShouldAutoAdd);
    }
    DECLARE_FUNCTION(execGetStringSettingValue)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT_REF(ValueIndex);
        P_FINISH;
        *(UBOOL*)Result=GetStringSettingValue(StringSettingId,ValueIndex);
    }
    DECLARE_FUNCTION(execIncrementStringSettingValue)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT(Direction);
        P_GET_UBOOL(bShouldWrap);
        P_FINISH;
        *(UBOOL*)Result=IncrementStringSettingValue(StringSettingId,Direction,bShouldWrap);
    }
    DECLARE_FUNCTION(execGetStringSettingValueNames)
    {
        P_GET_INT(StringSettingId);
        P_GET_TARRAY_REF(struct FIdToStringMapping,Values);
        P_FINISH;
        *(UBOOL*)Result=GetStringSettingValueNames(StringSettingId,Values);
    }
    DECLARE_FUNCTION(execSetStringSettingValueByName)
    {
        P_GET_NAME(StringSettingName);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL(bShouldAutoAdd);
        P_FINISH;
        SetStringSettingValueByName(StringSettingName,ValueIndex,bShouldAutoAdd);
    }
    DECLARE_FUNCTION(execGetStringSettingValueByName)
    {
        P_GET_NAME(StringSettingName);
        P_GET_INT_REF(ValueIndex);
        P_FINISH;
        *(UBOOL*)Result=GetStringSettingValueByName(StringSettingName,ValueIndex);
    }
    DECLARE_FUNCTION(execGetStringSettingId)
    {
        P_GET_NAME(StringSettingName);
        P_GET_INT_REF(StringSettingId);
        P_FINISH;
        *(UBOOL*)Result=GetStringSettingId(StringSettingName,StringSettingId);
    }
    DECLARE_FUNCTION(execGetStringSettingName)
    {
        P_GET_INT(StringSettingId);
        P_FINISH;
        *(FName*)Result=GetStringSettingName(StringSettingId);
    }
    DECLARE_FUNCTION(execGetStringSettingColumnHeader)
    {
        P_GET_INT(StringSettingId);
        P_FINISH;
        *(FString*)Result=GetStringSettingColumnHeader(StringSettingId);
    }
    DECLARE_FUNCTION(execIsWildcardStringSetting)
    {
        P_GET_INT(StringSettingId);
        P_FINISH;
        *(UBOOL*)Result=IsWildcardStringSetting(StringSettingId);
    }
    DECLARE_FUNCTION(execGetStringSettingValueName)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT(ValueIndex);
        P_FINISH;
        *(FName*)Result=GetStringSettingValueName(StringSettingId,ValueIndex);
    }
    DECLARE_FUNCTION(execGetStringSettingValueNameByName)
    {
        P_GET_NAME(StringSettingName);
        P_FINISH;
        *(FName*)Result=GetStringSettingValueNameByName(StringSettingName);
    }
    DECLARE_FUNCTION(execSetStringSettingValueFromStringByName)
    {
        P_GET_NAME(StringSettingName);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetStringSettingValueFromStringByName(StringSettingName,NewValue);
    }
    DECLARE_FUNCTION(execGetPropertyId)
    {
        P_GET_NAME(PropertyName);
        P_GET_INT_REF(PropertyId);
        P_FINISH;
        *(UBOOL*)Result=GetPropertyId(PropertyName,PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyName)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(FName*)Result=GetPropertyName(PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyColumnHeader)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(FString*)Result=GetPropertyColumnHeader(PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyAsString)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(FString*)Result=GetPropertyAsString(PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyAsStringByName)
    {
        P_GET_NAME(PropertyName);
        P_FINISH;
        *(FString*)Result=GetPropertyAsStringByName(PropertyName);
    }
    DECLARE_FUNCTION(execSetPropertyFromStringByName)
    {
        P_GET_NAME(PropertyName);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetPropertyFromStringByName(PropertyName,NewValue);
    }
    DECLARE_FUNCTION(execSetFloatProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT(Value);
        P_FINISH;
        SetFloatProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execGetFloatProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=GetFloatProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execSetIntProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_INT(Value);
        P_FINISH;
        SetIntProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execGetIntProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_INT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=GetIntProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execSetStringProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_STR(Value);
        P_FINISH;
        SetStringProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execGetStringProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_STR_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=GetStringProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execSetPropertyValueId)
    {
        P_GET_INT(PropertyId);
        P_GET_INT(ValueId);
        P_FINISH;
        *(UBOOL*)Result=SetPropertyValueId(PropertyId,ValueId);
    }
    DECLARE_FUNCTION(execGetPropertyValueId)
    {
        P_GET_INT(PropertyId);
        P_GET_INT_REF(ValueId);
        P_FINISH;
        *(UBOOL*)Result=GetPropertyValueId(PropertyId,ValueId);
    }
    DECLARE_FUNCTION(execGetPropertyType)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(BYTE*)Result=GetPropertyType(PropertyId);
    }
    DECLARE_FUNCTION(execUpdateStringSettings)
    {
        P_GET_TARRAY_REF(struct FLocalizedStringSetting,Settings);
        P_GET_UBOOL_OPTX(bShouldAddIfMissing,TRUE);
        P_FINISH;
        UpdateStringSettings(Settings,bShouldAddIfMissing);
    }
    DECLARE_FUNCTION(execUpdateProperties)
    {
        P_GET_TARRAY_REF(struct FSettingsProperty,Props);
        P_GET_UBOOL_OPTX(bShouldAddIfMissing,TRUE);
        P_FINISH;
        UpdateProperties(Props,bShouldAddIfMissing);
    }
    DECLARE_FUNCTION(execHasProperty)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(UBOOL*)Result=HasProperty(PropertyId);
    }
    DECLARE_FUNCTION(execHasStringSetting)
    {
        P_GET_INT(SettingId);
        P_FINISH;
        *(UBOOL*)Result=HasStringSetting(SettingId);
    }
    DECLARE_FUNCTION(execGetPropertyMappingType)
    {
        P_GET_INT(PropertyId);
        P_GET_BYTE_REF(OutType);
        P_FINISH;
        *(UBOOL*)Result=GetPropertyMappingType(PropertyId,OutType);
    }
    DECLARE_FUNCTION(execGetPropertyRange)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT_REF(OutMinValue);
        P_GET_FLOAT_REF(OutMaxValue);
        P_GET_FLOAT_REF(RangeIncrement);
        P_GET_BYTE_REF(bFormatAsInt);
        P_FINISH;
        *(UBOOL*)Result=GetPropertyRange(PropertyId,OutMinValue,OutMaxValue,RangeIncrement,bFormatAsInt);
    }
    DECLARE_FUNCTION(execSetRangedPropertyValue)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetRangedPropertyValue(PropertyId,NewValue);
    }
    DECLARE_FUNCTION(execGetRangedPropertyValue)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetRangedPropertyValue(PropertyId,OutValue);
    }
    DECLARE_FUNCTION(execGetQoSAdvertisedProperties)
    {
        P_GET_TARRAY_REF(struct FSettingsProperty,QoSProps);
        P_FINISH;
        GetQoSAdvertisedProperties(QoSProps);
    }
    DECLARE_FUNCTION(execGetQoSAdvertisedStringSettings)
    {
        P_GET_TARRAY_REF(struct FLocalizedStringSetting,QoSSettings);
        P_FINISH;
        GetQoSAdvertisedStringSettings(QoSSettings);
    }
    DECLARE_FUNCTION(execAppendDataBindingsToURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        AppendDataBindingsToURL(URL);
    }
    DECLARE_FUNCTION(execAppendPropertiesToURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        AppendPropertiesToURL(URL);
    }
    DECLARE_FUNCTION(execAppendContextsToURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        AppendContextsToURL(URL);
    }
    DECLARE_FUNCTION(execBuildURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        BuildURL(URL);
    }
    DECLARE_FUNCTION(execUpdateFromURL)
    {
        P_GET_STR_REF(URL);
        P_GET_OBJECT(AGameInfo,Game);
        P_FINISH;
        UpdateFromURL(URL,Game);
    }
    void delegateNotifyPropertyValueUpdated(FName PropertyName)
    {
        Settings_eventNotifyPropertyValueUpdated_Parms Parms(EC_EventParm);
        Parms.PropertyName=PropertyName;
        ProcessDelegate(ENGINE_NotifyPropertyValueUpdated,&__NotifyPropertyValueUpdated__Delegate,&Parms);
    }
    void delegateNotifySettingValueUpdated(FName SettingName)
    {
        Settings_eventNotifySettingValueUpdated_Parms Parms(EC_EventParm);
        Parms.SettingName=SettingName;
        ProcessDelegate(ENGINE_NotifySettingValueUpdated,&__NotifySettingValueUpdated__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(USettings,UObject,0,Engine)
	/**
	 * Finds the specified property
	 *
	 * @param PropertyId to search for
	 *
	 * @return pointer to the property or NULL if not found
	 */
	FORCEINLINE FSettingsProperty* FindProperty(INT PropertyId)
	{
		for (INT PropertyIndex = 0; PropertyIndex < Properties.Num(); PropertyIndex++)
		{
			FSettingsProperty& Property = Properties(PropertyIndex);
			if (Property.PropertyId == PropertyId)
			{
				return &Property;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified localized string setting
	 *
	 * @param SettingId id of the setting to search for
	 *
	 * @return pointer to the string setting or NULL if not found
	 */
	FORCEINLINE FLocalizedStringSetting* FindStringSetting(INT SettingId)
	{
		for (INT SettingsIndex = 0; SettingsIndex < LocalizedSettings.Num(); SettingsIndex++)
		{
			FLocalizedStringSetting& Setting = LocalizedSettings(SettingsIndex);
			if (Setting.Id == SettingId)
			{
				return &Setting;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified localized string setting's meta data
	 *
	 * @param SettingId id of the setting to search the meta data for
	 *
	 * @return pointer to the string meta data or NULL if not found
	 */
	FORCEINLINE FLocalizedStringSettingMetaData* FindStringSettingMetaData(INT SettingId)
	{
		for (INT MetaDataIndex = 0; MetaDataIndex < LocalizedSettingsMappings.Num(); MetaDataIndex++)
		{
			FLocalizedStringSettingMetaData& MetaData = LocalizedSettingsMappings(MetaDataIndex);
			if (MetaData.Id == SettingId)
			{
				return &MetaData;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified property's meta data
	 *
	 * @param PropertyId id of the property to search the meta data for
	 *
	 * @return pointer to the property meta data or NULL if not found
	 */
	FORCEINLINE FSettingsPropertyPropertyMetaData* FindPropertyMetaData(INT PropertyId)
	{
		for (INT MetaDataIndex = 0; MetaDataIndex < PropertyMappings.Num(); MetaDataIndex++)
		{
			FSettingsPropertyPropertyMetaData& MetaData = PropertyMappings(MetaDataIndex);
			if (MetaData.Id == PropertyId)
			{
				return &MetaData;
			}
		}
		return NULL;
	}

	/** Finalize the clean up process */
	virtual void FinishDestroy(void);
};

struct FUniqueNetId
{
    QWORD Uid;

		/**
		 * The noinit version of the ctor
		 */
		FORCEINLINE FUniqueNetId(void)
		{
		}

		/**
		 * Zeros the data in the struct
		 *
		 * @param ignored. only present to allow zeroing of data
		 */
		FORCEINLINE FUniqueNetId(EEventParm)
		{
			Uid = (QWORD)0;
		}

		/**
		 * Zeros the data in the struct
		 *
		 * @param ignored. only present to allow zeroing of data
		 */
		FORCEINLINE FUniqueNetId(DWORD)
		{
			Uid = (QWORD)0;
		}

		/** Copy constructor */
		FORCEINLINE FUniqueNetId(const FUniqueNetId& Other)
		{
			Uid = Other.Uid;
		}

		/**
		 * Compares the IDs for equality
		 *
		 * @param Id the value to compare
		 *
		 * @returns TRUE if they are equal, FALSE otherwise
		 */
		FORCEINLINE UBOOL operator==(const FUniqueNetId& Id) const
		{
			return Uid == Id.Uid;
		}

		/**
		 * Converts a DWORD into our type in network byte order
		 *
		 * @param Id the value to assign
		 */
		FORCEINLINE FUniqueNetId& operator=(const DWORD Id)
		{
#if WITH_PANORAMA || XBOX
			check(0 && "Bad conversion loses data");
#else
			Uid = Id;
#endif
			return *this;
		}

		/**
		 * Converts the unique id to a DWORD
		 *
		 * @return unique id as a DWORD
		 */
		FORCEINLINE DWORD ToDWORD(void) const
		{
#if WITH_PANORAMA || XBOX
			check(0 && "Bad conversion loses data");
			return 0;
#else
			return Uid & 0xFFFFFFFF;
#endif
		}

		/**
		 * Accessor for determining whether this net id has been assigned a value.
		 */
		FORCEINLINE UBOOL HasValue() const
		{
			return (QWORD)0 != Uid;
		}
	
};

struct FFriendsQuery
{
    struct FUniqueNetId UniqueId;
    BITFIELD bIsFriend:1;

    /** Constructors */
    FFriendsQuery() {}
    FFriendsQuery(EEventParm)
    {
        appMemzero(this, sizeof(FFriendsQuery));
    }
};

struct FOnlineFriend
{
    struct FUniqueNetId UniqueId;
    QWORD SessionId;
    FStringNoInit NickName;
    FStringNoInit PresenceInfo;
    BYTE FriendState;
    BITFIELD bIsOnline:1 GCC_BITFIELD_MAGIC;
    BITFIELD bIsPlaying:1;
    BITFIELD bIsPlayingThisGame:1;
    BITFIELD bIsJoinable:1;
    BITFIELD bHasVoiceSupport:1;
    BITFIELD bHaveInvited:1;
    BITFIELD bHasInvitedYou:1;

		/**
		 * Zeroes members
		 */
		FOnlineFriend(void)
		{
			appMemzero(this,sizeof(FOnlineFriend));
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineFriend(const FOnlineFriend& Other)
		{
			appMemzero(this,sizeof(FOnlineFriend));
			appMemcpy(&UniqueId,&Other.UniqueId,sizeof(FUniqueNetId));
			SessionId = Other.SessionId;
			NickName = Other.NickName;
			PresenceInfo = Other.PresenceInfo;
			FriendState = Other.FriendState;
			bIsOnline = Other.bIsOnline;
			bIsPlaying = Other.bIsPlaying;
			bIsPlayingThisGame = Other.bIsPlayingThisGame;
			bIsJoinable = Other.bIsJoinable;
			bHasVoiceSupport = Other.bHasVoiceSupport;
			bHaveInvited = Other.bHaveInvited;
			bHasInvitedYou = Other.bHasInvitedYou;
		}

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineFriend& operator=(const FOnlineFriend& Other)
		{
			if (this != &Other)
			{
				appMemcpy(&UniqueId,&Other.UniqueId,sizeof(FUniqueNetId));
				SessionId = Other.SessionId;
				NickName = Other.NickName;
				PresenceInfo = Other.PresenceInfo;
				FriendState = Other.FriendState;
				bIsOnline = Other.bIsOnline;
				bIsPlaying = Other.bIsPlaying;
				bIsPlayingThisGame = Other.bIsPlayingThisGame;
				bIsJoinable = Other.bIsJoinable;
				bHasVoiceSupport = Other.bHasVoiceSupport;
				bHaveInvited = Other.bHaveInvited;
				bHasInvitedYou = Other.bHasInvitedYou;
			}
			return *this;
		}
	
};

struct FOnlineContent
{
    INT UserIndex;
    FStringNoInit FriendlyName;
    FStringNoInit ContentPath;
    TArrayNoInit<FString> ContentPackages;
    TArrayNoInit<FString> ContentFiles;

    /** Constructors */
    FOnlineContent() {}
    FOnlineContent(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineContent));
    }
};

struct FOnlineRegistrant
{
    struct FUniqueNetId PlayerNetId;

		/**
		 * The noinit version of the ctor
		 */
		FORCEINLINE FOnlineRegistrant(void)
		{
		}

		/**
		 * Inits it to the player id specified
		 *
		 * @param InId sets the player id
		 */
		FORCEINLINE FOnlineRegistrant(const FUniqueNetId InId) :
			PlayerNetId(InId)
		{
		}

		/**
		 * Compares the player IDs for equality
		 *
		 * @param Id the value to compare
		 *
		 * @returns TRUE if they are equal, FALSE otherwise
		 */
		FORCEINLINE UBOOL operator==(const FOnlineRegistrant& Other) const
		{
			return PlayerNetId == Other.PlayerNetId;
		}
	
};

struct FOnlineArbitrationRegistrant : public FOnlineRegistrant
{
    QWORD MachineId;
    INT Trustworthiness;

    /** Constructors */
    FOnlineArbitrationRegistrant() {}
    FOnlineArbitrationRegistrant(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineArbitrationRegistrant));
    }
};

struct FOnlinePlayerScore
{
    struct FUniqueNetId PlayerID;
    INT TeamID;
    INT Score;

    /** Constructors */
    FOnlinePlayerScore() {}
    FOnlinePlayerScore(EEventParm)
    {
        appMemzero(this, sizeof(FOnlinePlayerScore));
    }
};

struct FLocalTalker
{
    BITFIELD bHasVoice:1;
    BITFIELD bHasNetworkedVoice:1;
    BITFIELD bIsRecognizingSpeech:1;
    BITFIELD bWasTalking:1;
    BITFIELD bIsRegistered:1;

    /** Constructors */
    FLocalTalker() {}
    FLocalTalker(EEventParm)
    {
        appMemzero(this, sizeof(FLocalTalker));
    }
};

struct FRemoteTalker
{
    struct FUniqueNetId TalkerId;
    BITFIELD bWasTalking:1;
    BITFIELD bIsRegistered:1;

    /** Constructors */
    FRemoteTalker() {}
    FRemoteTalker(EEventParm)
    {
        appMemzero(this, sizeof(FRemoteTalker));
    }
};

struct FOnlineFriendMessage
{
    struct FUniqueNetId SendingPlayerId;
    FStringNoInit SendingPlayerNick;
    BITFIELD bIsFriendInvite:1;
    BITFIELD bIsGameInvite:1;
    BITFIELD bWasAccepted:1;
    BITFIELD bWasDenied:1;
    FStringNoInit Message;

    /** Constructors */
    FOnlineFriendMessage() {}
    FOnlineFriendMessage(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineFriendMessage));
    }
};

struct FNamedInterface
{
    FName InterfaceName;
    class UObject* InterfaceObject;

    /** Constructors */
    FNamedInterface() {}
    FNamedInterface(EEventParm)
    {
        appMemzero(this, sizeof(FNamedInterface));
    }
};

struct FNamedInterfaceDef
{
    FName InterfaceName;
    FStringNoInit InterfaceClassName;

    /** Constructors */
    FNamedInterfaceDef() {}
    FNamedInterfaceDef(EEventParm)
    {
        appMemzero(this, sizeof(FNamedInterfaceDef));
    }
};

struct FTitleFile
{
    FStringNoInit Filename;
    BYTE AsyncState;
    TArrayNoInit<BYTE> Data;

    /** Constructors */
    FTitleFile() {}
    FTitleFile(EEventParm)
    {
        appMemzero(this, sizeof(FTitleFile));
    }
};

struct FCommunityContentFile
{
    INT ContentId;
    INT FileId;
    INT ContentType;
    INT FileSize;
    struct FUniqueNetId Owner;
    INT DownloadCount;
    FLOAT AverageRating;
    INT RatingCount;
    INT LastRatingGiven;
    FStringNoInit LocalFilePath;

    /** Constructors */
    FCommunityContentFile() {}
    FCommunityContentFile(EEventParm)
    {
        appMemzero(this, sizeof(FCommunityContentFile));
    }
};

struct FCommunityContentMetadata
{
    INT ContentType;
    TArrayNoInit<struct FSettingsProperty> MetadataItems;

    /** Constructors */
    FCommunityContentMetadata() {}
    FCommunityContentMetadata(EEventParm)
    {
        appMemzero(this, sizeof(FCommunityContentMetadata));
    }
};

struct FNamedSession
{
    FName SessionName;
    void* SessionInfo;
    class UOnlineGameSettings* GameSettings;
    TArrayNoInit<struct FOnlineRegistrant> Registrants;
    TArrayNoInit<struct FOnlineArbitrationRegistrant> ArbitrationRegistrants;

    /** Constructors */
    FNamedSession() {}
    FNamedSession(EEventParm)
    {
        appMemzero(this, sizeof(FNamedSession));
    }
};

struct FAchievementDetails
{
    INT Id;
    FStringNoInit AchievementName;
    FStringNoInit Description;
    FStringNoInit HowTo;
    class USurface* Image;
    INT GamerPoints;
    BITFIELD bIsSecret:1;
    BITFIELD bWasAchievedOnline:1;
    BITFIELD bWasAchievedOffline:1;

    /** Constructors */
    FAchievementDetails() {}
    FAchievementDetails(EEventParm)
    {
        appMemzero(this, sizeof(FAchievementDetails));
    }
};

struct OnlineSubsystem_eventGetNamedInterface_Parms
{
    FName InterfaceName;
    class UObject* ReturnValue;
    OnlineSubsystem_eventGetNamedInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetNamedInterface_Parms
{
    FName InterfaceName;
    class UObject* NewInterface;
    OnlineSubsystem_eventSetNamedInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetNewsInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetNewsInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetStatsInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetStatsInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetVoiceInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetVoiceInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetContentInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetContentInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetGameInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetGameInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetSystemInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetSystemInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetPlayerInterfaceEx_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetPlayerInterfaceEx_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetPlayerInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetPlayerInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetAccountInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetAccountInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventExit_Parms
{
    OnlineSubsystem_eventExit_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventPostInit_Parms
{
    UBOOL ReturnValue;
    OnlineSubsystem_eventPostInit_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventInit_Parms
{
    UBOOL ReturnValue;
    OnlineSubsystem_eventInit_Parms(EEventParm)
    {
    }
};
class UOnlineSubsystem : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS OnlineSubsystem
    TScriptInterface<class IInterface> AccountInterface;
    TScriptInterface<class IInterface> PlayerInterface;
    TScriptInterface<class IInterface> PlayerInterfaceEx;
    TScriptInterface<class IInterface> SystemInterface;
    TScriptInterface<class IInterface> GameInterface;
    TScriptInterface<class IInterface> ContentInterface;
    TScriptInterface<class IInterface> VoiceInterface;
    TScriptInterface<class IInterface> StatsInterface;
    TScriptInterface<class IInterface> NewsInterface;
    TArrayNoInit<struct FNamedInterface> NamedInterfaces;
    TArrayNoInit<struct FNamedInterfaceDef> NamedInterfaceDefs;
    TArrayNoInit<struct FNamedSession> Sessions;
    BITFIELD bUseBuildIdOverride:1;
    INT BuildIdOverride;
    FStringNoInit IniLocPatcherClassName;
    class UIniLocPatcher* Patcher;
    //## END PROPS OnlineSubsystem

    virtual UBOOL Init();
    INT GetBuildUniqueId();
    DECLARE_FUNCTION(execInit)
    {
        P_FINISH;
        *(UBOOL*)Result=Init();
    }
    DECLARE_FUNCTION(execUniqueNetIdToString)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,IdToConvert);
        P_FINISH;
        *(FString*)Result=UniqueNetIdToString(IdToConvert);
    }
    DECLARE_FUNCTION(execStringToUniqueNetId)
    {
        P_GET_STR(UniqueNetIdString);
        P_GET_STRUCT_REF(struct FUniqueNetId,out_UniqueId);
        P_FINISH;
        *(UBOOL*)Result=StringToUniqueNetId(UniqueNetIdString,out_UniqueId);
    }
    DECLARE_FUNCTION(execAreUniqueNetIdsEqual)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,NetIdA);
        P_GET_STRUCT_REF(struct FUniqueNetId,NetIdB);
        P_FINISH;
        *(UBOOL*)Result=AreUniqueNetIdsEqual(NetIdA,NetIdB);
    }
    DECLARE_FUNCTION(execGetBuildUniqueId)
    {
        P_FINISH;
        *(INT*)Result=GetBuildUniqueId();
    }
    class UObject* eventGetNamedInterface(FName InterfaceName)
    {
        OnlineSubsystem_eventGetNamedInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.InterfaceName=InterfaceName;
        ProcessEvent(FindFunctionChecked(ENGINE_GetNamedInterface),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetNamedInterface(FName InterfaceName,class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetNamedInterface_Parms Parms(EC_EventParm);
        Parms.InterfaceName=InterfaceName;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetNamedInterface),&Parms);
    }
    UBOOL eventSetNewsInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetNewsInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetNewsInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetStatsInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetStatsInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetStatsInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetVoiceInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetVoiceInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetVoiceInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetContentInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetContentInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetContentInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetGameInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetGameInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetGameInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetSystemInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetSystemInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSystemInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetPlayerInterfaceEx(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetPlayerInterfaceEx_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPlayerInterfaceEx),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetPlayerInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetPlayerInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPlayerInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetAccountInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetAccountInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAccountInterface),&Parms);
        return Parms.ReturnValue;
    }
    void eventExit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Exit),NULL);
    }
    UBOOL eventPostInit()
    {
        OnlineSubsystem_eventPostInit_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_PostInit),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInit()
    {
        OnlineSubsystem_eventInit_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Init),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UOnlineSubsystem,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Here to complete the interface but needs to be overriden
	 *
	 * @param ignored
	 */
	virtual void Tick(FLOAT)
	{
		check(0 && "Must be overridden");
	}

	/**
	 * Generates a string representation of a UniqueNetId struct.
	 *
	 * @param	IdToConvert		the unique net id that should be converted to a string.
	 *
	 * @return	the specified UniqueNetId represented as a string.
	 */
	static FString UniqueNetIdToString( const FUniqueNetId& IdToConvert );

	/**
	 * Converts a string representing a UniqueNetId into a UniqueNetId struct.
	 *
	 * @param	UniqueNetIdString	the string containing the text representation of the unique id.
	 * @param	out_UniqueId		will receive the UniqueNetId generated from the string.
	 *
	 * @return	TRUE if the string was successfully converted into a UniqueNetId; FALSE if the string was not a valid UniqueNetId.
	 */
	static UBOOL StringToUniqueNetId( const FString& UniqueNetIdString, FUniqueNetId& out_UniqueId );

	/**
	 * @return	TRUE if the netids are the same
	 */
	static UBOOL AreUniqueNetIdsEqual( const FUniqueNetId& NetIdA, const FUniqueNetId& NetIdB );

	/**
	 * Handle downloaded content in a platform-independent way
	 *
	 * @param Content The content descriptor that describes the downloaded content files
	 *
	 * @param return TRUE is successful
	 */
	virtual UBOOL ProcessDownloadedContent(const FOnlineContent& Content);

	/**
	 * Flush downloaded content for all users, making the engine stop using the content
	 *
	 * @param MaxNumUsers Platform specific max number of users to flush (this will iterate over all users from 0 to MaxNumUsers, as well as NO_USER
	 */
	virtual void FlushAllDownloadedContent(INT MaxNumUsers);

	/**
	 * Searches the named session array for the specified session
	 *
	 * @param SessionName the name to search for
	 *
	 * @return pointer to the struct if found, NULL otherwise
	 */
	inline FNamedSession* GetNamedSession(FName SessionName)
	{
		for (INT SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
		{
			if (Sessions(SearchIndex).SessionName == SessionName)
			{
				return &Sessions(SearchIndex);
			}
		}
		return NULL;
	}

	/**
	 * Searches the named session array for the specified session
	 *
	 * @param SessionName the name to search for
	 *
	 * @return TRUE if found, FALSE otherwise
	 */
	inline UBOOL HasNamedSession(FName SessionName)
	{
		return GetNamedSession(SessionName) != NULL;
	}

	/**
	 * Adds a new named session to the list
	 *
	 * @param SessionName the name to search for
	 * @param GameSettings the game settings to add
	 *
	 * @return a pointer to the struct that was added
	 */
	inline FNamedSession* AddNamedSession(FName SessionName,UOnlineGameSettings* GameSettings)
	{
		INT AddIndex = Sessions.AddZeroed();
		Sessions(AddIndex).SessionName = SessionName;
		Sessions(AddIndex).GameSettings = GameSettings;
		return &Sessions(AddIndex);
	}

	/**
	 * Searches the named session array for the specified session and removes it
	 *
	 * @param SessionName the name to search for
	 */
	virtual void RemoveNamedSession(FName SessionName)
	{
		for (INT SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
		{
			if (Sessions(SearchIndex).SessionName == SessionName)
			{
				Sessions.Remove(SearchIndex);
				return;
			}
		}
	}
};

struct FOnlineGameSearchResult
{
    class UOnlineGameSettings* GameSettings;
    void* PlatformData;

		/** Default constructor does nothing and is here for NoInit types */
		FOnlineGameSearchResult()
		{
		}

		/** Zeroing constructor */
		FOnlineGameSearchResult(EEventParm) :
			GameSettings(NULL),
			PlatformData(NULL)
		{
		}
	
};

struct FOverrideSkill
{
    INT LeaderboardId;
    TArrayNoInit<struct FUniqueNetId> Players;
    TArrayNoInit<DOUBLE> Mus;
    TArrayNoInit<DOUBLE> Sigmas;

    /** Constructors */
    FOverrideSkill() {}
    FOverrideSkill(EEventParm)
    {
        appMemzero(this, sizeof(FOverrideSkill));
    }
};

struct FNamedObjectProperty
{
    FName ObjectPropertyName;
    FStringNoInit ObjectPropertyValue;

    /** Constructors */
    FNamedObjectProperty() {}
    FNamedObjectProperty(EEventParm)
    {
        appMemzero(this, sizeof(FNamedObjectProperty));
    }
};

struct FOnlineGameSearchParameter
{
    INT EntryId;
    FName ObjectPropertyName;
    BYTE EntryType;
    BYTE ComparisonType;

    /** Constructors */
    FOnlineGameSearchParameter() {}
    FOnlineGameSearchParameter(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchParameter));
    }
};

struct FOnlineGameSearchSortClause
{
    INT EntryId;
    FName ObjectPropertyName;
    BYTE EntryType;
    BYTE SortType;

    /** Constructors */
    FOnlineGameSearchSortClause() {}
    FOnlineGameSearchSortClause(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchSortClause));
    }
};

struct FOnlineGameSearchORClause
{
    TArrayNoInit<struct FOnlineGameSearchParameter> OrParams;

    /** Constructors */
    FOnlineGameSearchORClause() {}
    FOnlineGameSearchORClause(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchORClause));
    }
};

struct FOnlineGameSearchQuery
{
    TArrayNoInit<struct FOnlineGameSearchORClause> OrClauses;
    TArrayNoInit<struct FOnlineGameSearchSortClause> SortClauses;

    /** Constructors */
    FOnlineGameSearchQuery() {}
    FOnlineGameSearchQuery(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchQuery));
    }
};

struct OnlineGameSearch_eventSortSearchResults_Parms
{
    OnlineGameSearch_eventSortSearchResults_Parms(EEventParm)
    {
    }
};
class UOnlineGameSearch : public USettings
{
public:
    //## BEGIN PROPS OnlineGameSearch
    INT MaxSearchResults;
    struct FLocalizedStringSetting Query;
    BITFIELD bIsLanQuery:1;
    BITFIELD bUsesArbitration:1;
    BITFIELD bIsSearchInProgress:1;
    class UClass* GameSettingsClass;
    TArrayNoInit<struct FOnlineGameSearchResult> Results;
    struct FOverrideSkill ManualSkillOverride;
    TArrayNoInit<struct FNamedObjectProperty> NamedProperties;
    struct FOnlineGameSearchQuery FilterQuery;
    FStringNoInit AdditionalSearchCriteria;
    //## END PROPS OnlineGameSearch

    void eventSortSearchResults()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SortSearchResults),NULL);
    }
    DECLARE_CLASS(UOnlineGameSearch,USettings,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineGameSearch)
};

class UOnlineGameSettings : public USettings
{
public:
    //## BEGIN PROPS OnlineGameSettings
    INT NumPublicConnections;
    INT NumPrivateConnections;
    INT NumOpenPublicConnections;
    INT NumOpenPrivateConnections;
    QWORD ServerNonce;
    BITFIELD bShouldAdvertise:1;
    BITFIELD bIsLanMatch:1;
    BITFIELD bUsesStats:1;
    BITFIELD bAllowJoinInProgress:1;
    BITFIELD bAllowInvites:1;
    BITFIELD bUsesPresence:1;
    BITFIELD bAllowJoinViaPresence:1;
    BITFIELD bAllowJoinViaPresenceFriendsOnly:1;
    BITFIELD bUsesArbitration:1;
    BITFIELD bWasFromInvite:1;
    BITFIELD bIsDedicated:1;
    BITFIELD bHasSkillUpdateInProgress:1;
    FStringNoInit OwningPlayerName;
    struct FUniqueNetId OwningPlayerId;
    INT PingInMs;
    FLOAT MatchQuality;
    BYTE GameState;
    INT BuildUniqueId;
    //## END PROPS OnlineGameSettings

    DECLARE_CLASS(UOnlineGameSettings,USettings,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineGameSettings)
};

struct FClientAdjustment
{
    FLOAT TimeStamp;
    BYTE newPhysics;
    FVector NewLoc;
    FVector NewVel;
    class AActor* NewBase;
    FVector NewFloor;
    BYTE bAckGoodMove;

    /** Constructors */
    FClientAdjustment() {}
    FClientAdjustment(EEventParm)
    {
        appMemzero(this, sizeof(FClientAdjustment));
    }
};

struct FInputEntry
{
    BYTE Type;
    FLOAT Value;
    FLOAT TimeDelta;
    BYTE Action;

    /** Constructors */
    FInputEntry() {}
    FInputEntry(EEventParm)
    {
        appMemzero(this, sizeof(FInputEntry));
    }
};

struct FInputMatchRequest
{
    TArrayNoInit<struct FInputEntry> Inputs;
    class AActor* MatchActor;
    FName MatchFuncName;
    FName FailedFuncName;
    FName RequestName;
    INT MatchIdx;
    FLOAT LastMatchTime;

    /** Constructors */
    FInputMatchRequest() {}
    FInputMatchRequest(EEventParm)
    {
        appMemzero(this, sizeof(FInputMatchRequest));
    }
};

struct FDebugTextInfo
{
    class AActor* SrcActor;
    FVector SrcActorOffset;
    FVector SrcActorDesiredOffset;
    FStringNoInit DebugText;
    FLOAT TimeRemaining;
    FLOAT Duration;
    FColor TextColor;

    /** Constructors */
    FDebugTextInfo() {}
    FDebugTextInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDebugTextInfo));
    }
};

#define UCONST_MAXCLIENTUPDATEINTERVAL 0.25
#define UCONST_CLIENTADJUSTUPDATECOST 180.0
#define UCONST_MAXVEHICLEPOSITIONERRORSQUARED 900.0
#define UCONST_MAXNEARZEROVELOCITYSQUARED 9.0
#define UCONST_MAXPOSITIONERRORSQUARED 3.0

struct PlayerController_eventBugItAI_Parms
{
    FString ScreenShotDescription;
    PlayerController_eventBugItAI_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventBugIt_Parms
{
    FString ScreenShotDescription;
    PlayerController_eventBugIt_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSpawnCameraLensEffect_Parms
{
    class UClass* LensEffectEmitterClass;
    PlayerController_eventClientSpawnCameraLensEffect_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventGetAchievementProgression_Parms
{
    INT AchievementId;
    FLOAT CurrentValue;
    FLOAT MaxValue;
    UBOOL ReturnValue;
    PlayerController_eventGetAchievementProgression_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPrestreamTextures_Parms
{
    class AActor* ForcedActor;
    FLOAT ForceDuration;
    UBOOL bEnableStreaming;
    PlayerController_eventClientPrestreamTextures_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetForceMipLevelsToBeResident_Parms
{
    class UMaterialInterface* Material;
    FLOAT ForceDuration;
    PlayerController_eventClientSetForceMipLevelsToBeResident_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSoakPause_Parms
{
    class APawn* P;
    PlayerController_eventSoakPause_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventRemoveDebugText_Parms
{
    class AActor* SrcActor;
    PlayerController_eventRemoveDebugText_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventAddDebugText_Parms
{
    FString DebugText;
    class AActor* SrcActor;
    FLOAT Duration;
    FVector Offset;
    FVector DesiredOffset;
    FColor TextColor;
    UBOOL bSkipOverwriteCheck;
    PlayerController_eventAddDebugText_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientWasKicked_Parms
{
    PlayerController_eventClientWasKicked_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventNotifyDirectorControl_Parms
{
    UBOOL bNowControlling;
    PlayerController_eventNotifyDirectorControl_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerUnmutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventServerUnmutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerMutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventServerMutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientUnmutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventClientUnmutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientMutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventClientMutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventGetSeamlessTravelActorList_Parms
{
    UBOOL bToEntry;
    TArray<class AActor*> ActorList;
    PlayerController_eventGetSeamlessTravelActorList_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetBlockOnAsyncLoading_Parms
{
    PlayerController_eventClientSetBlockOnAsyncLoading_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientFlushLevelStreaming_Parms
{
    PlayerController_eventClientFlushLevelStreaming_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientCancelPendingMapChange_Parms
{
    PlayerController_eventClientCancelPendingMapChange_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientCommitMapChange_Parms
{
    UBOOL bShouldSkipLevelStartupEvent;
    UBOOL bShouldSkipLevelBeginningEvent;
    PlayerController_eventClientCommitMapChange_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPrepareMapChange_Parms
{
    FName LevelName;
    UBOOL bFirst;
    UBOOL bLast;
    PlayerController_eventClientPrepareMapChange_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerUpdateLevelVisibility_Parms
{
    FName PackageName;
    UBOOL bIsVisible;
    PlayerController_eventServerUpdateLevelVisibility_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventLevelStreamingStatusChanged_Parms
{
    class ULevelStreaming* LevelObject;
    UBOOL bNewShouldBeLoaded;
    UBOOL bNewShouldBeVisible;
    UBOOL bNewShouldBlockOnLoad;
    PlayerController_eventLevelStreamingStatusChanged_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientForceGarbageCollection_Parms
{
    PlayerController_eventClientForceGarbageCollection_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventIsLookInputIgnored_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventIsLookInputIgnored_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventIsMoveInputIgnored_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventIsMoveInputIgnored_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientStopForceFeedbackWaveform_Parms
{
    class UForceFeedbackWaveform* FFWaveform;
    PlayerController_eventClientStopForceFeedbackWaveform_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPlayForceFeedbackWaveform_Parms
{
    class UForceFeedbackWaveform* FFWaveform;
    PlayerController_eventClientPlayForceFeedbackWaveform_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPlayRumble_Parms
{
    const class UAnimNotify_Rumble* TheAnimNotify;
    PlayerController_eventPlayRumble_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventLimitViewRotation_Parms
{
    FRotator ViewRotation;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    FRotator ReturnValue;
    PlayerController_eventLimitViewRotation_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSpawnPlayerCamera_Parms
{
    PlayerController_eventSpawnPlayerCamera_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetViewTarget_Parms
{
    class AActor* A;
    struct FViewTargetTransitionParams TransitionParams;
    PlayerController_eventClientSetViewTarget_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventGetFOVAngle_Parms
{
    FLOAT ReturnValue;
    PlayerController_eventGetFOVAngle_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventCameraLookAtFinished_Parms
{
    class USeqAct_CameraLookAt* Action;
    PlayerController_eventCameraLookAtFinished_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPlayerTick_Parms
{
    FLOAT DeltaTime;
    PlayerController_eventPlayerTick_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventNotifyLoadedWorld_Parms
{
    FName WorldPackageName;
    UBOOL bFinalDest;
    PlayerController_eventNotifyLoadedWorld_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerNotifyLoadedWorld_Parms
{
    FName WorldPackageName;
    PlayerController_eventServerNotifyLoadedWorld_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSetProgressTime_Parms
{
    FLOAT T;
    PlayerController_eventSetProgressTime_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSetProgressMessage_Parms
{
    BYTE MessageType;
    FString Message;
    FString Title;
    PlayerController_eventSetProgressMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventConditionalPause_Parms
{
    UBOOL bDesiredPauseState;
    PlayerController_eventConditionalPause_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventCanUnpause_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventCanUnpause_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSendClientAdjustment_Parms
{
    PlayerController_eventSendClientAdjustment_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetCameraFade_Parms
{
    UBOOL bEnableFading;
    FColor FadeColor;
    FVector2D FadeAlpha;
    FLOAT FadeTime;
    PlayerController_eventClientSetCameraFade_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventResetCameraMode_Parms
{
    PlayerController_eventResetCameraMode_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPreClientTravel_Parms
{
    FString PendingURL;
    BYTE TravelType;
    UBOOL bIsSeamlessTravel;
    PlayerController_eventPreClientTravel_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClearOnlineDelegates_Parms
{
    PlayerController_eventClearOnlineDelegates_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventTeamMessage_Parms
{
    class APlayerReplicationInfo* PRI;
    FString S;
    FName Type;
    FLOAT MsgLifeTime;
    PlayerController_eventTeamMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientMessage_Parms
{
    FString S;
    FName Type;
    FLOAT MsgLifeTime;
    PlayerController_eventClientMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventKismet_ClientStopSound_Parms
{
    class USoundCue* ASound;
    class AActor* SourceActor;
    FLOAT FadeOutTime;
    PlayerController_eventKismet_ClientStopSound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventKismet_ClientPlaySound_Parms
{
    class USoundCue* ASound;
    class AActor* SourceActor;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    FLOAT FadeInTime;
    UBOOL bSuppressSubtitles;
    UBOOL bSuppressSpatialization;
    PlayerController_eventKismet_ClientPlaySound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientHearSound_Parms
{
    class USoundCue* ASound;
    class AActor* SourceActor;
    FVector SourceLocation;
    UBOOL bStopWhenOwnerDestroyed;
    UBOOL bIsOccluded;
    PlayerController_eventClientHearSound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPlaySound_Parms
{
    class USoundCue* ASound;
    PlayerController_eventClientPlaySound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventReceiveLocalizedMessage_Parms
{
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    PlayerController_eventReceiveLocalizedMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventInitUniquePlayerId_Parms
{
    PlayerController_eventInitUniquePlayerId_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventInitInputSystem_Parms
{
    PlayerController_eventInitInputSystem_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventKickWarning_Parms
{
    PlayerController_eventKickWarning_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPreRender_Parms
{
    class UCanvas* Canvas;
    PlayerController_eventPreRender_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventReceivedPlayer_Parms
{
    PlayerController_eventReceivedPlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerProcessConvolve_Parms
{
    FString C;
    INT H;
    PlayerController_eventServerProcessConvolve_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientConvolve_Parms
{
    FString C;
    INT H;
    PlayerController_eventClientConvolve_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientTravel_Parms
{
    FString URL;
    BYTE TravelType;
    UBOOL bSeamless;
    FGuid MapPackageGuid;
    PlayerController_eventClientTravel_Parms(EEventParm)
    {
    }
};
class APlayerController : public AController
{
public:
    //## BEGIN PROPS PlayerController
    class UPlayer* Player;
    class ACamera* PlayerCamera;
    class UClass* CameraClass;
    class ADebugCameraController* DebugCameraControllerRef;
    class UClass* DebugCameraControllerClass;
    class UClass* PlayerOwnerDataStoreClass;
    class UPlayerOwnerDataStore* CurrentPlayerData;
    BITFIELD bFrozen:1;
    BITFIELD bPressedJump:1;
    BITFIELD bDoubleJump:1;
    BITFIELD bUpdatePosition:1;
    BITFIELD bUpdating:1;
    BITFIELD bNeverSwitchOnPickup:1;
    BITFIELD bCheatFlying:1;
    BITFIELD bCameraPositionLocked:1;
    BITFIELD bNoTextToSpeechVoiceMessages:1;
    BITFIELD bTextToSpeechTeamMessagesOnly:1;
    BITFIELD bShortConnectTimeOut:1;
    BITFIELD bPendingDestroy:1;
    BITFIELD bWasSpeedHack:1;
    BITFIELD bWasSaturated:1;
    BITFIELD bDynamicNetSpeed:1;
    BITFIELD bAimingHelp:1;
    BITFIELD bClientSimulatingViewTarget:1;
    BITFIELD bHasVoiceHandshakeCompleted:1;
    BITFIELD bCinematicMode:1;
    BITFIELD bCinemaDisableInputMove:1;
    BITFIELD bCinemaDisableInputLook:1;
    BITFIELD bIgnoreNetworkMessages:1;
    BITFIELD bReplicateAllPawns:1;
    BITFIELD bIsUsingStreamingVolumes:1;
    BITFIELD bIsExternalUIOpen:1;
    BITFIELD bIsControllerConnected:1;
    BITFIELD bCheckSoundOcclusion:1;
    BITFIELD bLogHearSoundOverflow:1;
    BITFIELD bCheckRelevancyThroughPortals:1;
    BITFIELD bReceivedUniqueId:1;
    FLOAT MaxResponseTime;
    FLOAT WaitDelay;
    class APawn* AcknowledgedPawn;
    BYTE DoubleClickDir;
    BYTE bIgnoreMoveInput;
    BYTE bIgnoreLookInput;
    BYTE bRun;
    BYTE bDuck;
    BYTE NetPlayerIndex;
    class AActor* ViewTarget;
    class APlayerReplicationInfo* RealViewTarget;
    class UInterpTrackInstDirector* ControllingDirTrackInst;
    FLOAT FOVAngle;
    FLOAT DesiredFOV;
    FLOAT DefaultFOV;
    FLOAT LODDistanceFactor;
    FRotator TargetViewRotation;
    FLOAT TargetEyeHeight;
    FRotator BlendedTargetViewRotation;
    class AHUD* myHUD;
    class UClass* SavedMoveClass;
    class USavedMove* SavedMoves;
    class USavedMove* FreeMoves;
    class USavedMove* PendingMove;
    FVector LastAckedAccel;
    FLOAT CurrentTimeStamp;
    FLOAT LastUpdateTime;
    FLOAT ServerTimeStamp;
    FLOAT TimeMargin;
    FLOAT ClientUpdateTime;
    FLOAT MaxTimeMargin;
    FLOAT LastActiveTime;
    INT ClientCap;
    FLOAT DynamicPingThreshold;
    FLOAT LastPingUpdate;
    FLOAT OldPing;
    FLOAT LastSpeedHackLog;
    struct FClientAdjustment PendingAdjustment;
    FStringNoInit ProgressMessage[2];
    FLOAT ProgressTimeOut;
    FStringNoInit QuickSaveString;
    FStringNoInit NoPauseMessage;
    FStringNoInit ViewingFrom;
    FStringNoInit OwnCamera;
    INT GroundPitch;
    FVector OldFloor;
    class UCheatManager* CheatManager;
    class UClass* CheatClass;
    class UPlayerInput* PlayerInput;
    class UClass* InputClass;
    FVector FailedPathStart;
    class UCylinderComponent* CylinderComponent;
    FStringNoInit ForceFeedbackManagerClassName;
    class UForceFeedbackManager* ForceFeedbackManager;
    TArrayNoInit<class UInteraction*> Interactions;
    TArrayNoInit<struct FUniqueNetId> VoiceMuteList;
    TArrayNoInit<struct FUniqueNetId> GameplayVoiceMuteList;
    TArrayNoInit<struct FUniqueNetId> VoicePacketFilter;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> VoiceInterface;
    class UUIDataStore_OnlinePlayerData* OnlinePlayerData;
    FLOAT InteractDistance;
    FName DelayedJoinSessionName;
    TArrayNoInit<struct FInputMatchRequest> InputRequests;
    FLOAT LastBroadcastTime;
    FStringNoInit LastBroadcastString[4];
    TArrayNoInit<FName> PendingMapChangeLevelNames;
    class ACoverReplicator* MyCoverReplicator;
    TArrayNoInit<struct FDebugTextInfo> DebugTextList;
    FLOAT SpectatorCameraSpeed;
    class UNetConnection* PendingSwapConnection;
    FLOAT MinRespawnDelay;
    INT MaxConcurrentHearSounds;
    TArrayNoInit<class UAudioComponent*> HearSoundActiveComponents;
    TArrayNoInit<class UAudioComponent*> HearSoundPoolComponents;
    TArrayNoInit<class AActor*> HiddenActors;
    FLOAT LastSpectatorStateSynchTime;
    FScriptDelegate __CanUnpause__Delegate;
    //## END PROPS PlayerController

    void SetNetSpeed(INT NewSpeed);
    FString GetPlayerNetworkAddress();
    FString GetServerNetworkAddress();
    virtual FString ConsoleCommand(const FString& Command,UBOOL bWriteToLog=TRUE);
    virtual void ClientTravel(const FString& URL,BYTE TravelType,UBOOL bSeamless=FALSE,FGuid MapPackageGuid=FGuid(EC_EventParm));
    void UpdateURL(const FString& NewOption,const FString& NewValue,UBOOL bSave1Default);
    FString GetDefaultURL(const FString& Option);
    virtual void CopyToClipboard(const FString& Text);
    virtual FString PasteFromClipboard();
    virtual void SetAllowMatureLanguage(UBOOL bAllowMatureLanguge);
    virtual void SetAudioGroupVolume(FName GroupName,FLOAT Volume);
    void ClientConvolve(const FString& C,INT H);
    void ServerProcessConvolve(const FString& C,INT H);
    UBOOL CheckSpeedHack(FLOAT DeltaTime);
    INT FindStairRotation(FLOAT DeltaTime);
    virtual void CleanUpAudioComponents();
    virtual UBOOL IsControllerTiltActive() const;
    virtual void SetControllerTiltDesiredIfAvailable(UBOOL bActive);
    virtual void SetControllerTiltActive(UBOOL bActive);
    virtual void SetOnlyUseControllerTiltInput(UBOOL bActive);
    virtual void SetUseTiltForwardAndBack(UBOOL bActive);
    virtual UBOOL IsKeyboardAvailable() const;
    virtual UBOOL IsMouseAvailable() const;
    virtual class UAudioComponent* GetPooledAudioComponent(class USoundCue* ASound,class AActor* SourceActor,UBOOL bStopWhenOwnerDestroyed,UBOOL bUseLocation=FALSE,FVector SourceLocation=FVector(EC_EventParm));
    virtual class USoundCue* CreateTTSSoundCue(const FString& StrToSpeak,class APlayerReplicationInfo* PRI);
    void ServerNotifyLoadedWorld(FName WorldPackageName);
    UBOOL HasClientLoadedCurrentWorld();
    virtual UBOOL IsLocalPlayerController();
    virtual void SetViewTarget(class AActor* NewViewTarget,struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm));
    virtual class AActor* GetViewTarget();
    void ClientUpdateLevelStreamingStatus(FName PackageName,UBOOL bNewShouldBeLoaded,UBOOL bNewShouldBeVisible,UBOOL bNewShouldBlockOnLoad);
    void ServerUpdateLevelVisibility(FName PackageName,UBOOL bIsVisible);
    void ClientFlushLevelStreaming();
    UBOOL IsPlayerMuted(const struct FUniqueNetId& Sender);
    class APlayerController* GetPlayerControllerFromNetId(struct FUniqueNetId PlayerNetId);
    virtual void SetShowSubtitles(UBOOL bValue);
    virtual UBOOL IsShowingSubtitles();
    virtual void ShowSurvey(const FString& QuestionId,const FString& Context);
    virtual FVector GetFVectorFromString(const FString& InStr);
    virtual FRotator GetFRotatorFromString(const FString& InStr);
    virtual void LogOutBugItGoToLogFile(const FString& InScreenShotDesc,const FString& InGoString,const FString& InLocString);
    virtual void LogOutBugItAIGoToLogFile(const FString& InScreenShotDesc,const FString& InGoString,const FString& InLocString);
    DECLARE_FUNCTION(execSetNetSpeed)
    {
        P_GET_INT(NewSpeed);
        P_FINISH;
        SetNetSpeed(NewSpeed);
    }
    DECLARE_FUNCTION(execGetPlayerNetworkAddress)
    {
        P_FINISH;
        *(FString*)Result=GetPlayerNetworkAddress();
    }
    DECLARE_FUNCTION(execGetServerNetworkAddress)
    {
        P_FINISH;
        *(FString*)Result=GetServerNetworkAddress();
    }
    DECLARE_FUNCTION(execClientTravel)
    {
        P_GET_STR(URL);
        P_GET_BYTE(TravelType);
        P_GET_UBOOL_OPTX(bSeamless,FALSE);
        P_GET_STRUCT_OPTX(FGuid,MapPackageGuid,FGuid(EC_EventParm));
        P_FINISH;
        ClientTravel(URL,TravelType,bSeamless,MapPackageGuid);
    }
    DECLARE_FUNCTION(execUpdateURL)
    {
        P_GET_STR(NewOption);
        P_GET_STR(NewValue);
        P_GET_UBOOL(bSave1Default);
        P_FINISH;
        UpdateURL(NewOption,NewValue,bSave1Default);
    }
    DECLARE_FUNCTION(execGetDefaultURL)
    {
        P_GET_STR(Option);
        P_FINISH;
        *(FString*)Result=GetDefaultURL(Option);
    }
    DECLARE_FUNCTION(execCopyToClipboard)
    {
        P_GET_STR(Text);
        P_FINISH;
        CopyToClipboard(Text);
    }
    DECLARE_FUNCTION(execPasteFromClipboard)
    {
        P_FINISH;
        *(FString*)Result=PasteFromClipboard();
    }
    DECLARE_FUNCTION(execSetAllowMatureLanguage)
    {
        P_GET_UBOOL(bAllowMatureLanguge);
        P_FINISH;
        SetAllowMatureLanguage(bAllowMatureLanguge);
    }
    DECLARE_FUNCTION(execSetAudioGroupVolume)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(Volume);
        P_FINISH;
        SetAudioGroupVolume(GroupName,Volume);
    }
    DECLARE_FUNCTION(execClientConvolve)
    {
        P_GET_STR(C);
        P_GET_INT(H);
        P_FINISH;
        ClientConvolve(C,H);
    }
    DECLARE_FUNCTION(execServerProcessConvolve)
    {
        P_GET_STR(C);
        P_GET_INT(H);
        P_FINISH;
        ServerProcessConvolve(C,H);
    }
    DECLARE_FUNCTION(execCheckSpeedHack)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        *(UBOOL*)Result=CheckSpeedHack(DeltaTime);
    }
    DECLARE_FUNCTION(execFindStairRotation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        *(INT*)Result=FindStairRotation(DeltaTime);
    }
    DECLARE_FUNCTION(execCleanUpAudioComponents)
    {
        P_FINISH;
        CleanUpAudioComponents();
    }
    DECLARE_FUNCTION(execIsControllerTiltActive)
    {
        P_FINISH;
        *(UBOOL*)Result=IsControllerTiltActive();
    }
    DECLARE_FUNCTION(execSetControllerTiltDesiredIfAvailable)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        SetControllerTiltDesiredIfAvailable(bActive);
    }
    DECLARE_FUNCTION(execSetControllerTiltActive)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        SetControllerTiltActive(bActive);
    }
    DECLARE_FUNCTION(execSetOnlyUseControllerTiltInput)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        SetOnlyUseControllerTiltInput(bActive);
    }
    DECLARE_FUNCTION(execSetUseTiltForwardAndBack)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        SetUseTiltForwardAndBack(bActive);
    }
    DECLARE_FUNCTION(execIsKeyboardAvailable)
    {
        P_FINISH;
        *(UBOOL*)Result=IsKeyboardAvailable();
    }
    DECLARE_FUNCTION(execIsMouseAvailable)
    {
        P_FINISH;
        *(UBOOL*)Result=IsMouseAvailable();
    }
    DECLARE_FUNCTION(execGetPooledAudioComponent)
    {
        P_GET_OBJECT(USoundCue,ASound);
        P_GET_OBJECT(AActor,SourceActor);
        P_GET_UBOOL(bStopWhenOwnerDestroyed);
        P_GET_UBOOL_OPTX(bUseLocation,FALSE);
        P_GET_STRUCT_OPTX(FVector,SourceLocation,FVector(EC_EventParm));
        P_FINISH;
        *(class UAudioComponent**)Result=GetPooledAudioComponent(ASound,SourceActor,bStopWhenOwnerDestroyed,bUseLocation,SourceLocation);
    }
    DECLARE_FUNCTION(execCreateTTSSoundCue)
    {
        P_GET_STR(StrToSpeak);
        P_GET_OBJECT(APlayerReplicationInfo,PRI);
        P_FINISH;
        *(class USoundCue**)Result=CreateTTSSoundCue(StrToSpeak,PRI);
    }
    DECLARE_FUNCTION(execServerNotifyLoadedWorld)
    {
        P_GET_NAME(WorldPackageName);
        P_FINISH;
        ServerNotifyLoadedWorld(WorldPackageName);
    }
    DECLARE_FUNCTION(execHasClientLoadedCurrentWorld)
    {
        P_FINISH;
        *(UBOOL*)Result=HasClientLoadedCurrentWorld();
    }
    DECLARE_FUNCTION(execSetViewTarget)
    {
        P_GET_OBJECT(AActor,NewViewTarget);
        P_GET_STRUCT_OPTX(struct FViewTargetTransitionParams,TransitionParams,FViewTargetTransitionParams(EC_EventParm));
        P_FINISH;
        SetViewTarget(NewViewTarget,TransitionParams);
    }
    DECLARE_FUNCTION(execGetViewTarget)
    {
        P_FINISH;
        *(class AActor**)Result=GetViewTarget();
    }
    DECLARE_FUNCTION(execClientUpdateLevelStreamingStatus)
    {
        P_GET_NAME(PackageName);
        P_GET_UBOOL(bNewShouldBeLoaded);
        P_GET_UBOOL(bNewShouldBeVisible);
        P_GET_UBOOL(bNewShouldBlockOnLoad);
        P_FINISH;
        ClientUpdateLevelStreamingStatus(PackageName,bNewShouldBeLoaded,bNewShouldBeVisible,bNewShouldBlockOnLoad);
    }
    DECLARE_FUNCTION(execServerUpdateLevelVisibility)
    {
        P_GET_NAME(PackageName);
        P_GET_UBOOL(bIsVisible);
        P_FINISH;
        ServerUpdateLevelVisibility(PackageName,bIsVisible);
    }
    DECLARE_FUNCTION(execClientFlushLevelStreaming)
    {
        P_FINISH;
        ClientFlushLevelStreaming();
    }
    DECLARE_FUNCTION(execIsPlayerMuted)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,Sender);
        P_FINISH;
        *(UBOOL*)Result=IsPlayerMuted(Sender);
    }
    DECLARE_FUNCTION(execGetPlayerControllerFromNetId)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerNetId);
        P_FINISH;
        *(class APlayerController**)Result=GetPlayerControllerFromNetId(PlayerNetId);
    }
    DECLARE_FUNCTION(execSetShowSubtitles)
    {
        P_GET_UBOOL(bValue);
        P_FINISH;
        SetShowSubtitles(bValue);
    }
    DECLARE_FUNCTION(execIsShowingSubtitles)
    {
        P_FINISH;
        *(UBOOL*)Result=IsShowingSubtitles();
    }
    DECLARE_FUNCTION(execShowSurvey)
    {
        P_GET_STR(QuestionId);
        P_GET_STR(Context);
        P_FINISH;
        ShowSurvey(QuestionId,Context);
    }
    DECLARE_FUNCTION(execGetFVectorFromString)
    {
        P_GET_STR(InStr);
        P_FINISH;
        *(FVector*)Result=GetFVectorFromString(InStr);
    }
    DECLARE_FUNCTION(execGetFRotatorFromString)
    {
        P_GET_STR(InStr);
        P_FINISH;
        *(FRotator*)Result=GetFRotatorFromString(InStr);
    }
    DECLARE_FUNCTION(execLogOutBugItGoToLogFile)
    {
        P_GET_STR(InScreenShotDesc);
        P_GET_STR(InGoString);
        P_GET_STR(InLocString);
        P_FINISH;
        LogOutBugItGoToLogFile(InScreenShotDesc,InGoString,InLocString);
    }
    DECLARE_FUNCTION(execLogOutBugItAIGoToLogFile)
    {
        P_GET_STR(InScreenShotDesc);
        P_GET_STR(InGoString);
        P_GET_STR(InLocString);
        P_FINISH;
        LogOutBugItAIGoToLogFile(InScreenShotDesc,InGoString,InLocString);
    }
    void eventBugItAI(const FString& ScreenShotDescription=TEXT(""))
    {
        PlayerController_eventBugItAI_Parms Parms(EC_EventParm);
        Parms.ScreenShotDescription=ScreenShotDescription;
        ProcessEvent(FindFunctionChecked(ENGINE_BugItAI),&Parms);
    }
    void eventBugIt(const FString& ScreenShotDescription=TEXT(""))
    {
        PlayerController_eventBugIt_Parms Parms(EC_EventParm);
        Parms.ScreenShotDescription=ScreenShotDescription;
        ProcessEvent(FindFunctionChecked(ENGINE_BugIt),&Parms);
    }
    void eventClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass)
    {
        PlayerController_eventClientSpawnCameraLensEffect_Parms Parms(EC_EventParm);
        Parms.LensEffectEmitterClass=LensEffectEmitterClass;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSpawnCameraLensEffect),&Parms);
    }
    UBOOL eventGetAchievementProgression(INT AchievementId,FLOAT& CurrentValue,FLOAT& MaxValue)
    {
        PlayerController_eventGetAchievementProgression_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AchievementId=AchievementId;
        Parms.CurrentValue=CurrentValue;
        Parms.MaxValue=MaxValue;
        ProcessEvent(FindFunctionChecked(ENGINE_GetAchievementProgression),&Parms);
        CurrentValue=Parms.CurrentValue;
        MaxValue=Parms.MaxValue;
        return Parms.ReturnValue;
    }
    void eventClientPrestreamTextures(class AActor* ForcedActor,FLOAT ForceDuration,UBOOL bEnableStreaming)
    {
        PlayerController_eventClientPrestreamTextures_Parms Parms(EC_EventParm);
        Parms.ForcedActor=ForcedActor;
        Parms.ForceDuration=ForceDuration;
        Parms.bEnableStreaming=bEnableStreaming ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPrestreamTextures),&Parms);
    }
    void eventClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material,FLOAT ForceDuration)
    {
        PlayerController_eventClientSetForceMipLevelsToBeResident_Parms Parms(EC_EventParm);
        Parms.Material=Material;
        Parms.ForceDuration=ForceDuration;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetForceMipLevelsToBeResident),&Parms);
    }
    void eventSoakPause(class APawn* P)
    {
        PlayerController_eventSoakPause_Parms Parms(EC_EventParm);
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(ENGINE_SoakPause),&Parms);
    }
    void eventRemoveDebugText(class AActor* SrcActor)
    {
        PlayerController_eventRemoveDebugText_Parms Parms(EC_EventParm);
        Parms.SrcActor=SrcActor;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveDebugText),&Parms);
    }
    void eventAddDebugText(const FString& DebugText,class AActor* SrcActor=NULL,FLOAT Duration=-1.000000,FVector Offset=FVector(EC_EventParm),FVector DesiredOffset=FVector(EC_EventParm),FColor TextColor=FColor(EC_EventParm),UBOOL bSkipOverwriteCheck=FALSE)
    {
        PlayerController_eventAddDebugText_Parms Parms(EC_EventParm);
        Parms.DebugText=DebugText;
        Parms.SrcActor=SrcActor;
        Parms.Duration=Duration;
        Parms.Offset=Offset;
        Parms.DesiredOffset=DesiredOffset;
        Parms.TextColor=TextColor;
        Parms.bSkipOverwriteCheck=bSkipOverwriteCheck ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_AddDebugText),&Parms);
    }
    void eventClientWasKicked()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientWasKicked),NULL);
    }
    void eventNotifyDirectorControl(UBOOL bNowControlling)
    {
        PlayerController_eventNotifyDirectorControl_Parms Parms(EC_EventParm);
        Parms.bNowControlling=bNowControlling ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyDirectorControl),&Parms);
    }
    void eventServerUnmutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventServerUnmutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerUnmutePlayer),&Parms);
    }
    void eventServerMutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventServerMutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerMutePlayer),&Parms);
    }
    void eventClientUnmutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventClientUnmutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientUnmutePlayer),&Parms);
    }
    void eventClientMutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventClientMutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMutePlayer),&Parms);
    }
    void eventGetSeamlessTravelActorList(UBOOL bToEntry,TArray<class AActor*>& ActorList)
    {
        PlayerController_eventGetSeamlessTravelActorList_Parms Parms(EC_EventParm);
        Parms.bToEntry=bToEntry ? FIRST_BITFIELD : FALSE;
        Parms.ActorList=ActorList;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSeamlessTravelActorList),&Parms);
        ActorList=Parms.ActorList;
    }
    void eventClientSetBlockOnAsyncLoading()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetBlockOnAsyncLoading),NULL);
    }
    void eventClientFlushLevelStreaming()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientFlushLevelStreaming),NULL);
    }
    void eventClientCancelPendingMapChange()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientCancelPendingMapChange),NULL);
    }
    void eventClientCommitMapChange(UBOOL bShouldSkipLevelStartupEvent=FALSE,UBOOL bShouldSkipLevelBeginningEvent=FALSE)
    {
        PlayerController_eventClientCommitMapChange_Parms Parms(EC_EventParm);
        Parms.bShouldSkipLevelStartupEvent=bShouldSkipLevelStartupEvent ? FIRST_BITFIELD : FALSE;
        Parms.bShouldSkipLevelBeginningEvent=bShouldSkipLevelBeginningEvent ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientCommitMapChange),&Parms);
    }
    void eventClientPrepareMapChange(FName LevelName,UBOOL bFirst,UBOOL bLast)
    {
        PlayerController_eventClientPrepareMapChange_Parms Parms(EC_EventParm);
        Parms.LevelName=LevelName;
        Parms.bFirst=bFirst ? FIRST_BITFIELD : FALSE;
        Parms.bLast=bLast ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPrepareMapChange),&Parms);
    }
    void eventServerUpdateLevelVisibility(FName PackageName,UBOOL bIsVisible)
    {
        PlayerController_eventServerUpdateLevelVisibility_Parms Parms(EC_EventParm);
        Parms.PackageName=PackageName;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerUpdateLevelVisibility),&Parms);
    }
    void eventLevelStreamingStatusChanged(class ULevelStreaming* LevelObject,UBOOL bNewShouldBeLoaded,UBOOL bNewShouldBeVisible,UBOOL bNewShouldBlockOnLoad)
    {
        PlayerController_eventLevelStreamingStatusChanged_Parms Parms(EC_EventParm);
        Parms.LevelObject=LevelObject;
        Parms.bNewShouldBeLoaded=bNewShouldBeLoaded ? FIRST_BITFIELD : FALSE;
        Parms.bNewShouldBeVisible=bNewShouldBeVisible ? FIRST_BITFIELD : FALSE;
        Parms.bNewShouldBlockOnLoad=bNewShouldBlockOnLoad ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_LevelStreamingStatusChanged),&Parms);
    }
    void eventClientForceGarbageCollection()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientForceGarbageCollection),NULL);
    }
    UBOOL eventIsLookInputIgnored()
    {
        PlayerController_eventIsLookInputIgnored_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsLookInputIgnored),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsMoveInputIgnored()
    {
        PlayerController_eventIsMoveInputIgnored_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsMoveInputIgnored),&Parms);
        return Parms.ReturnValue;
    }
    void eventClientStopForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform=NULL)
    {
        PlayerController_eventClientStopForceFeedbackWaveform_Parms Parms(EC_EventParm);
        Parms.FFWaveform=FFWaveform;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientStopForceFeedbackWaveform),&Parms);
    }
    void eventClientPlayForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform)
    {
        PlayerController_eventClientPlayForceFeedbackWaveform_Parms Parms(EC_EventParm);
        Parms.FFWaveform=FFWaveform;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPlayForceFeedbackWaveform),&Parms);
    }
    void eventPlayRumble(const class UAnimNotify_Rumble* TheAnimNotify)
    {
        PlayerController_eventPlayRumble_Parms Parms(EC_EventParm);
        Parms.TheAnimNotify=TheAnimNotify;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayRumble),&Parms);
    }
    FRotator eventLimitViewRotation(FRotator ViewRotation,FLOAT ViewPitchMin,FLOAT ViewPitchMax)
    {
        PlayerController_eventLimitViewRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.ViewRotation=ViewRotation;
        Parms.ViewPitchMin=ViewPitchMin;
        Parms.ViewPitchMax=ViewPitchMax;
        ProcessEvent(FindFunctionChecked(ENGINE_LimitViewRotation),&Parms);
        return Parms.ReturnValue;
    }
    void eventSpawnPlayerCamera()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnPlayerCamera),NULL);
    }
    void eventClientSetViewTarget(class AActor* A,struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm))
    {
        PlayerController_eventClientSetViewTarget_Parms Parms(EC_EventParm);
        Parms.A=A;
        Parms.TransitionParams=TransitionParams;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetViewTarget),&Parms);
    }
    FLOAT eventGetFOVAngle()
    {
        PlayerController_eventGetFOVAngle_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFOVAngle),&Parms);
        return Parms.ReturnValue;
    }
    void eventCameraLookAtFinished(class USeqAct_CameraLookAt* Action)
    {
        PlayerController_eventCameraLookAtFinished_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_CameraLookAtFinished),&Parms);
    }
    void eventPlayerTick(FLOAT DeltaTime)
    {
        PlayerController_eventPlayerTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_PlayerTick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerTick),&Parms);
        }
    }
    void eventNotifyLoadedWorld(FName WorldPackageName,UBOOL bFinalDest)
    {
        PlayerController_eventNotifyLoadedWorld_Parms Parms(EC_EventParm);
        Parms.WorldPackageName=WorldPackageName;
        Parms.bFinalDest=bFinalDest ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyLoadedWorld),&Parms);
    }
    void eventServerNotifyLoadedWorld(FName WorldPackageName)
    {
        PlayerController_eventServerNotifyLoadedWorld_Parms Parms(EC_EventParm);
        Parms.WorldPackageName=WorldPackageName;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerNotifyLoadedWorld),&Parms);
    }
    void eventSetProgressTime(FLOAT T)
    {
        PlayerController_eventSetProgressTime_Parms Parms(EC_EventParm);
        Parms.T=T;
        ProcessEvent(FindFunctionChecked(ENGINE_SetProgressTime),&Parms);
    }
    void eventSetProgressMessage(BYTE MessageType,const FString& Message,const FString& Title=TEXT(""))
    {
        PlayerController_eventSetProgressMessage_Parms Parms(EC_EventParm);
        Parms.MessageType=MessageType;
        Parms.Message=Message;
        Parms.Title=Title;
        ProcessEvent(FindFunctionChecked(ENGINE_SetProgressMessage),&Parms);
    }
    void eventConditionalPause(UBOOL bDesiredPauseState)
    {
        PlayerController_eventConditionalPause_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ConditionalPause),&Parms);
    }
    UBOOL delegateCanUnpause()
    {
        PlayerController_eventCanUnpause_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessDelegate(ENGINE_CanUnpause,&__CanUnpause__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void eventSendClientAdjustment()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SendClientAdjustment),NULL);
    }
    void eventClientSetCameraFade(UBOOL bEnableFading,FColor FadeColor=FColor(EC_EventParm),FVector2D FadeAlpha=FVector2D(EC_EventParm),FLOAT FadeTime=0)
    {
        PlayerController_eventClientSetCameraFade_Parms Parms(EC_EventParm);
        Parms.bEnableFading=bEnableFading ? FIRST_BITFIELD : FALSE;
        Parms.FadeColor=FadeColor;
        Parms.FadeAlpha=FadeAlpha;
        Parms.FadeTime=FadeTime;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetCameraFade),&Parms);
    }
    void eventResetCameraMode()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResetCameraMode),NULL);
    }
    void eventPreClientTravel(const FString& PendingURL,BYTE TravelType,UBOOL bIsSeamlessTravel)
    {
        PlayerController_eventPreClientTravel_Parms Parms(EC_EventParm);
        Parms.PendingURL=PendingURL;
        Parms.TravelType=TravelType;
        Parms.bIsSeamlessTravel=bIsSeamlessTravel ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_PreClientTravel),&Parms);
    }
    void eventClearOnlineDelegates()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClearOnlineDelegates),NULL);
    }
    void eventTeamMessage(class APlayerReplicationInfo* PRI,const FString& S,FName Type,FLOAT MsgLifeTime=0)
    {
        PlayerController_eventTeamMessage_Parms Parms(EC_EventParm);
        Parms.PRI=PRI;
        Parms.S=S;
        Parms.Type=Type;
        Parms.MsgLifeTime=MsgLifeTime;
        ProcessEvent(FindFunctionChecked(ENGINE_TeamMessage),&Parms);
    }
    void eventClientMessage(const FString& S,FName Type=NAME_None,FLOAT MsgLifeTime=0)
    {
        PlayerController_eventClientMessage_Parms Parms(EC_EventParm);
        Parms.S=S;
        Parms.Type=Type;
        Parms.MsgLifeTime=MsgLifeTime;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMessage),&Parms);
    }
    void eventKismet_ClientStopSound(class USoundCue* ASound,class AActor* SourceActor,FLOAT FadeOutTime)
    {
        PlayerController_eventKismet_ClientStopSound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        Parms.SourceActor=SourceActor;
        Parms.FadeOutTime=FadeOutTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Kismet_ClientStopSound),&Parms);
    }
    void eventKismet_ClientPlaySound(class USoundCue* ASound,class AActor* SourceActor,FLOAT VolumeMultiplier,FLOAT PitchMultiplier,FLOAT FadeInTime,UBOOL bSuppressSubtitles,UBOOL bSuppressSpatialization)
    {
        PlayerController_eventKismet_ClientPlaySound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        Parms.SourceActor=SourceActor;
        Parms.VolumeMultiplier=VolumeMultiplier;
        Parms.PitchMultiplier=PitchMultiplier;
        Parms.FadeInTime=FadeInTime;
        Parms.bSuppressSubtitles=bSuppressSubtitles ? FIRST_BITFIELD : FALSE;
        Parms.bSuppressSpatialization=bSuppressSpatialization ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Kismet_ClientPlaySound),&Parms);
    }
    void eventClientHearSound(class USoundCue* ASound,class AActor* SourceActor,FVector SourceLocation,UBOOL bStopWhenOwnerDestroyed,UBOOL bIsOccluded=FALSE)
    {
        PlayerController_eventClientHearSound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        Parms.SourceActor=SourceActor;
        Parms.SourceLocation=SourceLocation;
        Parms.bStopWhenOwnerDestroyed=bStopWhenOwnerDestroyed ? FIRST_BITFIELD : FALSE;
        Parms.bIsOccluded=bIsOccluded ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientHearSound),&Parms);
    }
    void eventClientPlaySound(class USoundCue* ASound)
    {
        PlayerController_eventClientPlaySound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPlaySound),&Parms);
    }
    void eventReceiveLocalizedMessage(class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        PlayerController_eventReceiveLocalizedMessage_Parms Parms(EC_EventParm);
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_ReceiveLocalizedMessage),&Parms);
    }
    void eventInitUniquePlayerId()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_InitUniquePlayerId),NULL);
    }
    void eventInitInputSystem()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_InitInputSystem),NULL);
    }
    void eventKickWarning()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_KickWarning),NULL);
    }
    void eventPreRender(class UCanvas* Canvas)
    {
        PlayerController_eventPreRender_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PreRender),&Parms);
    }
    void eventReceivedPlayer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ReceivedPlayer),NULL);
    }
    void eventServerProcessConvolve(const FString& C,INT H)
    {
        PlayerController_eventServerProcessConvolve_Parms Parms(EC_EventParm);
        Parms.C=C;
        Parms.H=H;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerProcessConvolve),&Parms);
    }
    void eventClientConvolve(const FString& C,INT H)
    {
        PlayerController_eventClientConvolve_Parms Parms(EC_EventParm);
        Parms.C=C;
        Parms.H=H;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientConvolve),&Parms);
    }
    void eventClientTravel(const FString& URL,BYTE TravelType,UBOOL bSeamless=FALSE,FGuid MapPackageGuid=FGuid(EC_EventParm))
    {
        PlayerController_eventClientTravel_Parms Parms(EC_EventParm);
        Parms.URL=URL;
        Parms.TravelType=TravelType;
        Parms.bSeamless=bSeamless ? FIRST_BITFIELD : FALSE;
        Parms.MapPackageGuid=MapPackageGuid;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientTravel),&Parms);
    }
    DECLARE_CLASS(APlayerController,AController,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	//  PlayerController interface.
	void SetPlayer( UPlayer* Player );
	void UpdateViewTarget(AActor* NewViewTarget);
	virtual void SmoothTargetViewRotation(APawn* TargetPawn, FLOAT DeltaSeconds);
	/** allows the game code an opportunity to modify post processing settings
	 * @param PPSettings - the post processing settings to apply
	 */
	virtual void ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const;

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual UBOOL LocalPlayerController();
	virtual UBOOL WantsLedgeCheck();
	virtual UBOOL StopAtLedge();
	virtual APlayerController* GetAPlayerController() { return this; }
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
	virtual UBOOL HearSound(USoundCue* InSoundCue, AActor* SoundPlayer, const FVector& SoundLocation, UBOOL bStopWhenOwnerDestroyed);
	/** checks whether the passed in SoundPlayer is valid for replicating in a HearSound() call and sets it to NULL if not */
	void ValidateSoundPlayer(AActor*& SoundPlayer);
	virtual void PostScriptDestroyed();
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);

	/** disables SeePlayer() and SeeMonster() checks for PlayerController, since they aren't used for most games */
	virtual UBOOL ShouldCheckVisibilityOf(AController* C) { return FALSE; }
	virtual void UpdateHiddenActors(FVector ViewLocation) {}
	virtual void HearNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType);

	/**
	 * Sets the Matinee director track instance that's currently possessing this player controller
	 *
	 * @param   NewControllingDirector    The director track instance that's now controlling this player controller (or NULL for none)
	 */
	void SetControllingDirector( UInterpTrackInstDirector* NewControllingDirector );

	/**
	 * Returns the Matinee director track that's currently possessing this player controller, or NULL for none
	 */
	UInterpTrackInstDirector* GetControllingDirector();

};

class ACrowdReplicationActor : public AActor
{
public:
    //## BEGIN PROPS CrowdReplicationActor
    class USeqAct_CrowdSpawner* Spawner;
    BITFIELD bSpawningActive:1;
    INT DestroyAllCount;
    //## END PROPS CrowdReplicationActor

    DECLARE_CLASS(ACrowdReplicationActor,AActor,0|CLASS_NativeReplication,Engine)
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

struct DroppedPickup_eventSetPickupParticles_Parms
{
    class UParticleSystemComponent* PickupParticles;
    DroppedPickup_eventSetPickupParticles_Parms(EEventParm)
    {
    }
};
struct DroppedPickup_eventSetPickupMesh_Parms
{
    class UPrimitiveComponent* PickupMesh;
    DroppedPickup_eventSetPickupMesh_Parms(EEventParm)
    {
    }
};
class ADroppedPickup : public AActor
{
public:
    //## BEGIN PROPS DroppedPickup
    class AInventory* Inventory;
    class UClass* InventoryClass;
    class ANavigationPoint* PickupCache;
    BITFIELD bFadeOut:1;
    //## END PROPS DroppedPickup

    void AddToNavigation();
    void RemoveFromNavigation();
    DECLARE_FUNCTION(execAddToNavigation)
    {
        P_FINISH;
        AddToNavigation();
    }
    DECLARE_FUNCTION(execRemoveFromNavigation)
    {
        P_FINISH;
        RemoveFromNavigation();
    }
    void eventSetPickupParticles(class UParticleSystemComponent* PickupParticles)
    {
        DroppedPickup_eventSetPickupParticles_Parms Parms(EC_EventParm);
        Parms.PickupParticles=PickupParticles;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPickupParticles),&Parms);
    }
    void eventSetPickupMesh(class UPrimitiveComponent* PickupMesh)
    {
        DroppedPickup_eventSetPickupMesh_Parms Parms(EC_EventParm);
        Parms.PickupMesh=PickupMesh;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPickupMesh),&Parms);
    }
    DECLARE_CLASS(ADroppedPickup,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADroppedPickup)
};

class ADynamicSMActor : public AActor
{
public:
    //## BEGIN PROPS DynamicSMActor
    class UStaticMeshComponent* StaticMeshComponent;
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    class UStaticMesh* ReplicatedMesh;
    class UMaterialInterface* ReplicatedMaterial;
    BITFIELD bForceStaticDecals:1;
    BITFIELD bPawnCanBaseOn:1;
    BITFIELD bSafeBaseIfAsleep:1;
    FVector ReplicatedMeshTranslation;
    FRotator ReplicatedMeshRotation;
    FVector ReplicatedMeshScale3D;
    //## END PROPS DynamicSMActor

    DECLARE_ABSTRACT_CLASS(ADynamicSMActor,AActor,0,Engine)
	/**
	* Function that gets called from within Map_Check to allow this actor to check itself
	* for any potential errors and register them with map check dialog.
	*/
	virtual void CheckForErrors();

protected:
/**
     * This function actually does the work for the GetDetailInfo and is virtual.
     * It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
     **/
	virtual FString GetDetailedInfoInternal() const;
};

class AInterpActor : public ADynamicSMActor
{
public:
    //## BEGIN PROPS InterpActor
    BITFIELD bShouldSaveForCheckpoint:1;
    BITFIELD bMonitorMover:1;
    BITFIELD bMonitorZVelocity:1;
    BITFIELD bDestroyProjectilesOnEncroach:1;
    BITFIELD bContinueOnEncroachPhysicsObject:1;
    BITFIELD bStopOnEncroach:1;
    BITFIELD bShouldShadowParentAllAttachedActors:1;
    class ANavigationPoint* MyMarker;
    FLOAT MaxZVelocity;
    FLOAT StayOpenTime;
    class USoundCue* OpenSound;
    class USoundCue* OpeningAmbientSound;
    class USoundCue* OpenedSound;
    class USoundCue* CloseSound;
    class USoundCue* ClosingAmbientSound;
    class USoundCue* ClosedSound;
    class UAudioComponent* AmbientSoundComponent;
    //## END PROPS InterpActor

    virtual void SetShadowParentOnAllAttachedComponents();
    DECLARE_FUNCTION(execSetShadowParentOnAllAttachedComponents)
    {
        P_FINISH;
        SetShadowParentOnAllAttachedComponents();
    }
    DECLARE_CLASS(AInterpActor,ADynamicSMActor,0,Engine)
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
	virtual void TickSpecial(FLOAT DeltaSeconds);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
};

struct Emitter_eventSetTemplate_Parms
{
    class UParticleSystem* NewTemplate;
    UBOOL bDestroyOnFinish;
    Emitter_eventSetTemplate_Parms(EEventParm)
    {
    }
};
class AEmitter : public AActor
{
public:
    //## BEGIN PROPS Emitter
    class UParticleSystemComponent* ParticleSystemComponent;
    BITFIELD bDestroyOnSystemFinish:1;
    BITFIELD bPostUpdateTickGroup:1;
    BITFIELD bCurrentlyActive:1;
    //## END PROPS Emitter

    DECLARE_FUNCTION(execSetTemplate);
    void eventSetTemplate(class UParticleSystem* NewTemplate,UBOOL bDestroyOnFinish=FALSE)
    {
        Emitter_eventSetTemplate_Parms Parms(EC_EventParm);
        Parms.NewTemplate=NewTemplate;
        Parms.bDestroyOnFinish=bDestroyOnFinish ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTemplate),&Parms);
    }
    DECLARE_CLASS(AEmitter,AActor,0,Engine)
	void SetTemplate(UParticleSystem* NewTemplate, UBOOL bDestroyOnFinish=false);
	void AutoPopulateInstanceProperties();

	// AActor interface.
	virtual void Spawned();
	virtual void PostBeginPlay();
	/**
	 *	ticks the actor
	 *	@param	DeltaTime	The time slice of this tick
	 *	@param	TickType	The type of tick that is happening
	 *
	 *	@return	TRUE if the actor was ticked, FALSE if it was aborted (e.g. because it's in stasis)
	 */
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();

	/**
	 * This will return detail info about this specific object. (e.g. AudioComponent will return the name of the cue,
	 * ParticleSystemComponent will return the name of the ParticleSystem)  The idea here is that in many places
	 * you have a component of interest but what you really want is some characteristic that you can use to track
	 * down where it came from.
	 *
	 */
	virtual FString GetDetailedInfoInternal() const;

};

struct FEmitterBaseInfo
{
    class UParticleSystemComponent* PSC;
    class AActor* Base;
    FVector RelativeLocation;
    FRotator RelativeRotation;

    /** Constructors */
    FEmitterBaseInfo() {}
    FEmitterBaseInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEmitterBaseInfo));
    }
};

class AEmitterPool : public AActor
{
public:
    //## BEGIN PROPS EmitterPool
    class UParticleSystemComponent* PSCTemplate;
    TArrayNoInit<class UParticleSystemComponent*> PoolComponents;
    TArrayNoInit<class UParticleSystemComponent*> ActiveComponents;
    INT MaxActiveEffects;
    BITFIELD bLogPoolOverflow:1;
    BITFIELD bLogPoolOverflowList:1;
    TArrayNoInit<struct FEmitterBaseInfo> RelativePSCs;
    FLOAT SMC_MIC_ReductionTime;
    FLOAT SMC_MIC_CurrentReductionTime;
    INT IdealStaticMeshComponents;
    INT IdealMaterialInstanceConstants;
    TArrayNoInit<class UStaticMeshComponent*> FreeSMComponents;
    TArrayNoInit<class UMaterialInstanceConstant*> FreeMatInstConsts;
    //## END PROPS EmitterPool

    void ReturnToPool(class UParticleSystemComponent* PSC);
    void FreeStaticMeshComponents(class UParticleSystemComponent* PSC);
    class UStaticMeshComponent* GetFreeStaticMeshComponent(UBOOL bCreateNewObject=TRUE);
    void FreeMaterialInstanceConstants(class UStaticMeshComponent* SMC);
    class UMaterialInstanceConstant* GetFreeMatInstConsts(UBOOL bCreateNewObject=TRUE);
    class UParticleSystemComponent* GetPooledComponent(class UParticleSystem* EmitterTemplate);
    DECLARE_FUNCTION(execReturnToPool)
    {
        P_GET_OBJECT(UParticleSystemComponent,PSC);
        P_FINISH;
        ReturnToPool(PSC);
    }
    DECLARE_FUNCTION(execFreeStaticMeshComponents)
    {
        P_GET_OBJECT(UParticleSystemComponent,PSC);
        P_FINISH;
        FreeStaticMeshComponents(PSC);
    }
    DECLARE_FUNCTION(execGetFreeStaticMeshComponent)
    {
        P_GET_UBOOL_OPTX(bCreateNewObject,TRUE);
        P_FINISH;
        *(class UStaticMeshComponent**)Result=GetFreeStaticMeshComponent(bCreateNewObject);
    }
    DECLARE_FUNCTION(execFreeMaterialInstanceConstants)
    {
        P_GET_OBJECT(UStaticMeshComponent,SMC);
        P_FINISH;
        FreeMaterialInstanceConstants(SMC);
    }
    DECLARE_FUNCTION(execGetFreeMatInstConsts)
    {
        P_GET_UBOOL_OPTX(bCreateNewObject,TRUE);
        P_FINISH;
        *(class UMaterialInstanceConstant**)Result=GetFreeMatInstConsts(bCreateNewObject);
    }
    DECLARE_FUNCTION(execGetPooledComponent)
    {
        P_GET_OBJECT(UParticleSystem,EmitterTemplate);
        P_FINISH;
        *(class UParticleSystemComponent**)Result=GetPooledComponent(EmitterTemplate);
    }
    DECLARE_CLASS(AEmitterPool,AActor,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void TickSpecial(FLOAT DeltaTime);
};

struct FConsoleMessage
{
    FStringNoInit Text;
    FColor TextColor;
    FLOAT MessageLife;
    class APlayerReplicationInfo* PRI;

    /** Constructors */
    FConsoleMessage() {}
    FConsoleMessage(EEventParm)
    {
        appMemzero(this, sizeof(FConsoleMessage));
    }
};

struct FHudLocalizedMessage
{
    class UClass* Message;
    FStringNoInit StringMessage;
    INT Switch;
    FLOAT EndOfLife;
    FLOAT Lifetime;
    FLOAT PosY;
    FColor DrawColor;
    INT FontSize;
    class UFont* StringFont;
    FLOAT DX;
    FLOAT DY;
    BITFIELD Drawn:1;
    INT Count;
    class UObject* OptionalObject;

    /** Constructors */
    FHudLocalizedMessage() {}
    FHudLocalizedMessage(EEventParm)
    {
        appMemzero(this, sizeof(FHudLocalizedMessage));
    }
};

struct HUD_eventOnLostFocusPause_Parms
{
    UBOOL Enable;
    HUD_eventOnLostFocusPause_Parms(EEventParm)
    {
    }
};
struct HUD_eventPostRender_Parms
{
    HUD_eventPostRender_Parms(EEventParm)
    {
    }
};
class AHUD : public AActor
{
public:
    //## BEGIN PROPS HUD
    FColor WhiteColor;
    FColor GreenColor;
    FColor RedColor;
    class APlayerController* PlayerOwner;
    class AHUD* HudOwner;
    class APlayerReplicationInfo* ViewedInfo;
    FLOAT ProgressFadeTime;
    FColor MOTDColor;
    class AScoreBoard* ScoreBoard;
    BITFIELD LostFocusPaused:1;
    BITFIELD bShowHUD:1;
    BITFIELD bShowScores:1;
    BITFIELD bShowDebugInfo:1;
    BITFIELD bShowBadConnectionAlert:1;
    BITFIELD bMessageBeep:1;
    FLOAT HudCanvasScale;
    TArrayNoInit<struct FConsoleMessage> ConsoleMessages;
    FColor ConsoleColor;
    INT ConsoleMessageCount;
    INT ConsoleFontSize;
    INT MessageFontOffset;
    INT MaxHUDAreaMessageCount;
    struct FHudLocalizedMessage LocalMessages[8];
    FLOAT ConsoleMessagePosX;
    FLOAT ConsoleMessagePosY;
    class UCanvas* Canvas;
    FLOAT LastHUDRenderTime;
    FLOAT RenderDelta;
    FLOAT SizeX;
    FLOAT SizeY;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT RatioX;
    FLOAT RatioY;
    TArrayNoInit<FName> DebugDisplay;
    //## END PROPS HUD

    void Draw3DLine(FVector Start,FVector End,FColor LineColor);
    void Draw2DLine(INT X1,INT Y1,INT X2,INT Y2,FColor LineColor);
    DECLARE_FUNCTION(execDraw3DLine)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FVector,End);
        P_GET_STRUCT(FColor,LineColor);
        P_FINISH;
        Draw3DLine(Start,End,LineColor);
    }
    DECLARE_FUNCTION(execDraw2DLine)
    {
        P_GET_INT(X1);
        P_GET_INT(Y1);
        P_GET_INT(X2);
        P_GET_INT(Y2);
        P_GET_STRUCT(FColor,LineColor);
        P_FINISH;
        Draw2DLine(X1,Y1,X2,Y2,LineColor);
    }
    void eventOnLostFocusPause(UBOOL Enable)
    {
        HUD_eventOnLostFocusPause_Parms Parms(EC_EventParm);
        Parms.Enable=Enable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_OnLostFocusPause),&Parms);
    }
    void eventPostRender()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),NULL);
    }
    DECLARE_CLASS(AHUD,AActor,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AHUD)
};

struct FKeyValuePair
{
    FString Key;
    FString Value;
    friend FArchive& operator<<(FArchive& Ar,FKeyValuePair& MyKeyValuePair)
    {
        return Ar << MyKeyValuePair.Key << MyKeyValuePair.Value;
    }

    /** Constructors */
    FKeyValuePair() {}
    FKeyValuePair(EEventParm)
    {
        appMemzero(this, sizeof(FKeyValuePair));
    }
};

struct FPlayerResponseLine
{
    INT PlayerNum;
    INT PlayerID;
    FString PlayerName;
    INT Ping;
    INT Score;
    INT StatsID;
    TArray<struct FKeyValuePair> PlayerInfo;
    friend FArchive& operator<<(FArchive& Ar,FPlayerResponseLine& MyPlayerResponseLine)
    {
        return Ar << MyPlayerResponseLine.PlayerNum << MyPlayerResponseLine.PlayerID << MyPlayerResponseLine.PlayerName << MyPlayerResponseLine.Ping << MyPlayerResponseLine.Score << MyPlayerResponseLine.StatsID << MyPlayerResponseLine.PlayerInfo;
    }

    /** Constructors */
    FPlayerResponseLine()
    : PlayerNum(0)
    , PlayerID(0)
    , Ping(0)
    , Score(0)
    , StatsID(0)
    {}
    FPlayerResponseLine(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerResponseLine));
    }
};

struct FServerResponseLine
{
    INT ServerID;
    FString IP;
    INT Port;
    INT QueryPort;
    FString ServerName;
    FString MapName;
    FString GameType;
    INT CurrentPlayers;
    INT MaxPlayers;
    INT Ping;
    TArray<struct FKeyValuePair> ServerInfo;
    TArray<struct FPlayerResponseLine> PlayerInfo;
    friend FArchive& operator<<(FArchive& Ar,FServerResponseLine& MyServerResponseLine)
    {
        return Ar << MyServerResponseLine.ServerID << MyServerResponseLine.IP << MyServerResponseLine.Port << MyServerResponseLine.QueryPort << MyServerResponseLine.ServerName << MyServerResponseLine.MapName << MyServerResponseLine.GameType << MyServerResponseLine.CurrentPlayers << MyServerResponseLine.MaxPlayers << MyServerResponseLine.Ping << MyServerResponseLine.ServerInfo << MyServerResponseLine.PlayerInfo;
    }

    /** Constructors */
    FServerResponseLine()
    : ServerID(0)
    , Port(0)
    , QueryPort(0)
    , CurrentPlayers(0)
    , MaxPlayers(0)
    , Ping(0)
    {}
    FServerResponseLine(EEventParm)
    {
        appMemzero(this, sizeof(FServerResponseLine));
    }
};

class AInfo : public AActor
{
public:
    //## BEGIN PROPS Info
    //## END PROPS Info

    DECLARE_ABSTRACT_CLASS(AInfo,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInfo)
};

#define UCONST_BLOCKEDPATHCOST 10000000

class UReachSpec : public UObject
{
public:
    //## BEGIN PROPS ReachSpec
    struct FNavigationOctreeObject* NavOctreeObject;
    INT Distance;
    FVector Direction;
    class ANavigationPoint* Start;
    struct FActorReference End;
    INT CollisionRadius;
    INT CollisionHeight;
    INT reachFlags;
    INT MaxLandingVelocity;
    BYTE bPruned;
    BYTE PathColorIndex;
    BITFIELD bAddToNavigationOctree:1 GCC_BITFIELD_MAGIC;
    BITFIELD bCanCutCorners:1;
    BITFIELD bCheckForObstructions:1;
    BITFIELD bSkipPrune:1;
    BITFIELD bDisabled:1;
    TArrayNoInit<class UClass*> PruneSpecList;
    class AActor* BlockedBy;
    //## END PROPS ReachSpec

    DECLARE_FUNCTION(execCostFor);
    DECLARE_FUNCTION(execGetEnd);
    DECLARE_FUNCTION(execGetDirection);
    DECLARE_CLASS(UReachSpec,UObject,0,Engine)
	/*
	supports() -
	returns true if it supports the requirements of aPawn.  Distance is not considered.
	*/
	inline UBOOL supports (INT iRadius, INT iHeight, INT moveFlags, INT iMaxFallVelocity)
	{
		return ( (CollisionRadius >= iRadius)
			&& (CollisionHeight >= iHeight)
			&& ((reachFlags & moveFlags) == reachFlags)
			&& (MaxLandingVelocity <= iMaxFallVelocity) );
	}

	FVector GetDirection();

	/** CostFor()
	Returns the "cost" in unreal units
	for Pawn P to travel from the start to the end of this reachspec
	*/
	virtual INT CostFor( APawn* P );
	/** AdjustedCostFor
	*	Used by NewBestPathTo for heuristic weighting
	*/
	virtual INT AdjustedCostFor( APawn* P, const FVector& StartToGoalDir, ANavigationPoint* Goal, INT Cost );
	virtual UBOOL PrepareForMove( AController * C );
	virtual UBOOL IsForced() { return false; }
	virtual UBOOL IsProscribed() const { return false; }
	virtual INT defineFor (class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout);
	int operator<= (const UReachSpec &Spec);
	virtual FPlane PathColor();
	virtual void AddToDebugRenderProxy(class FDebugRenderSceneProxy* DRSP);
	int findBestReachable(class AScout *Scout);
	UBOOL ShouldPruneAgainst( UReachSpec* Spec );

	/** If bAddToNavigationOctree is true, adds the ReachSpec to the navigation octree */
	void AddToNavigationOctree();
	void RemoveFromNavigationOctree();
	/** returns whether TestBox overlaps the path this ReachSpec represents
	 * @note this function assumes that TestBox has already passed a bounding box overlap check
	 * @param TestBox the box to check
	 * @return true if the box doesn't overlap this path, false if it does
	 */
	UBOOL NavigationOverlapCheck(const FBox& TestBox);
	/** returns whether Point is within MaxDist units of the path this ReachSpec represents
	 * @param Point the point to check
	 * @param MaxDist the maximum distance the point can be from the path
	 * @return true if the point is within MaxDist units, false otherwise
	 */
	UBOOL IsOnPath(const FVector& Point, FLOAT MaxDist);
	/** returns whether this path is currently blocked and unusable to the given pawn */
	UBOOL IsBlockedFor(APawn* P);

	virtual void FinishDestroy();

	/** Get path size for a forced path between Start/End */
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, class AScout* Scout );

	/** return TRUE if it's safe to skip ahead past this edge, FALSE otherwise */
	virtual UBOOL CanBeSkipped( APawn* P )
	{
		return TRUE;
	}

	//debug
	FString PrintDebugInfo();
};

class UAdvancedReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS AdvancedReachSpec
    //## END PROPS AdvancedReachSpec

    DECLARE_CLASS(UAdvancedReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// purple path = advanced
		return FPlane(1.f,0.f,1.f, 0.f);
	}
	virtual INT CostFor(APawn* P);
};

class UCeilingReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS CeilingReachSpec
    //## END PROPS CeilingReachSpec

    DECLARE_CLASS(UCeilingReachSpec,UReachSpec,0,Engine)
	virtual INT CostFor( APawn* P );
	virtual INT AdjustedCostFor( APawn* P, const FVector& StartToGoalDir, ANavigationPoint* Goal, INT Cost );
};

class UForcedReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS ForcedReachSpec
    //## END PROPS ForcedReachSpec

    DECLARE_CLASS(UForcedReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// yellow for forced paths
		return FPlane(1.f, 1.f, 0.f, 0.f);
	}

	virtual UBOOL IsForced() { return true; }
	virtual UBOOL PrepareForMove( AController * C );
	virtual INT CostFor(APawn* P);
};

class UCoverSlipReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS CoverSlipReachSpec
    BYTE SpecDirection;
    //## END PROPS CoverSlipReachSpec

    DECLARE_CLASS(UCoverSlipReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, class AScout* Scout );
};

class UFloorToCeilingReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS FloorToCeilingReachSpec
    //## END PROPS FloorToCeilingReachSpec

    DECLARE_CLASS(UFloorToCeilingReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual INT AdjustedCostFor( APawn* P, const FVector& StartToGoalDir, ANavigationPoint* Goal, INT Cost );
};

class UMantleReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS MantleReachSpec
    BITFIELD bClimbUp:1;
    //## END PROPS MantleReachSpec

    DECLARE_CLASS(UMantleReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, AScout* Scout );
	void ReInitialize();
	virtual UBOOL CanBeSkipped( APawn* P );
};

class USlotToSlotReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS SlotToSlotReachSpec
    BYTE SpecDirection;
    //## END PROPS SlotToSlotReachSpec

    DECLARE_CLASS(USlotToSlotReachSpec,UForcedReachSpec,0,Engine)
	virtual INT defineFor( class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout );
	virtual INT CostFor(APawn* P);
	virtual UBOOL CanBeSkipped( APawn* P );
	virtual UBOOL PrepareForMove(AController * C);
};

class USwatTurnReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS SwatTurnReachSpec
    BYTE SpecDirection;
    //## END PROPS SwatTurnReachSpec

    DECLARE_CLASS(USwatTurnReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual INT defineFor( class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout );
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, class AScout* Scout );
};

class UWallTransReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS WallTransReachSpec
    //## END PROPS WallTransReachSpec

    DECLARE_CLASS(UWallTransReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
};

class ULadderReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS LadderReachSpec
    //## END PROPS LadderReachSpec

    DECLARE_CLASS(ULadderReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// light purple = ladder
		return FPlane(1.f,0.5f, 1.f,0.f);
	}
	virtual INT CostFor(APawn* P);
};

class UProscribedReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS ProscribedReachSpec
    //## END PROPS ProscribedReachSpec

    DECLARE_CLASS(UProscribedReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// red is reserved for proscribed paths
		return FPlane(1.f, 0.f, 0.f, 0.f);
	}

	virtual UBOOL IsProscribed() const { return TRUE; }
	virtual INT CostFor(APawn* P);
};

class UTeleportReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS TeleportReachSpec
    //## END PROPS TeleportReachSpec

    DECLARE_CLASS(UTeleportReachSpec,UReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
};

struct FNavigationOctreeObject
{
    FBox BoundingBox;
    FVector BoxCenter;
    class FNavigationOctreeNode* OctreeNode;

	 enum ENavOctreeObjectType
	 {
	 	NAV_NavigationPoint = 0x01,
	 	NAV_ReachSpec = 0x02,
	 	NAV_CoverSlotMarker = 0x04,
	 };
	 private:
	 	UObject* Owner;
	 	BYTE OwnerType;
	 public:
	 	/** constructor, makes sure OctreeNode is NULL */
	 	FNavigationOctreeObject()
	 	: OctreeNode(NULL), Owner(NULL), OwnerType(0)
	 	{}
	 	/** destructor, removes us from the octree if we're still there */
	 	~FNavigationOctreeObject();
		/** sets the object's owner and initializes the OwnerType for fast cast to common types */
		void SetOwner(UObject* InOwner);

		/** sets the object's bounding box
		 * if the object is currently in the octree, re-adds it
		 * @param InBoundingBox the new bounding box to use
		 */
		void SetBox(const FBox& InBoundingBox);

		/** overlap check function called after the axis aligned bounding box check succeeds
		 * allows for more precise checks for certain object types
		 * @param TestBox the box to check
		 * @return true if the box doesn't overlap this object, false if it does
		 */
		UBOOL OverlapCheck(const FBox& TestBox);

		/** templated accessor to Owner, to avoid casting for common cases
		 * @note T must be UObject or a subclass, or this function will not compile
		 */
		template<class T> FORCEINLINE T* GetOwner()
		{
			return Cast<T>(Owner);
		}
		//@note the specializations for this template are in UnPath.h because they must be outside the struct definition

		void Serialize(FArchive& Ar);
	
};

struct FDebugNavCost
{
    FStringNoInit Desc;
    INT Cost;

		/** constructors */
		FDebugNavCost() {}
		FDebugNavCost(EEventParm)
		{
			appMemzero(this, sizeof(FDebugNavCost));
		}
		UBOOL operator==(const FDebugNavCost& Other)
		{
			return (Other.Cost == Cost && Other.Desc == Desc);
		}
	
};

#define UCONST_INFINITE_PATH_COST 10000000

struct NavigationPoint_eventGetDebugAbbrev_Parms
{
    FString ReturnValue;
    NavigationPoint_eventGetDebugAbbrev_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventSuggestMovePreparation_Parms
{
    class APawn* Other;
    UBOOL ReturnValue;
    NavigationPoint_eventSuggestMovePreparation_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventDetourWeight_Parms
{
    class APawn* Other;
    FLOAT PathWeight;
    FLOAT ReturnValue;
    NavigationPoint_eventDetourWeight_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventAccept_Parms
{
    class AActor* Incoming;
    class AActor* Source;
    UBOOL ReturnValue;
    NavigationPoint_eventAccept_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventSpecialCost_Parms
{
    class APawn* Seeker;
    class UReachSpec* Path;
    INT ReturnValue;
    NavigationPoint_eventSpecialCost_Parms(EEventParm)
    {
    }
};
class ANavigationPoint : public AActor
{
public:
    //## BEGIN PROPS NavigationPoint
    BITFIELD bEndPoint:1;
    BITFIELD bTransientEndPoint:1;
    BITFIELD bHideEditorPaths:1;
    BITFIELD bCanReach:1;
    BITFIELD bBlocked:1;
    BITFIELD bOneWayPath:1;
    BITFIELD bNeverUseStrafing:1;
    BITFIELD bAlwaysUseStrafing:1;
    BITFIELD bForceNoStrafing:1;
    BITFIELD bAutoBuilt:1;
    BITFIELD bSpecialMove:1;
    BITFIELD bNoAutoConnect:1;
    BITFIELD bNotBased:1;
    BITFIELD bPathsChanged:1;
    BITFIELD bDestinationOnly:1;
    BITFIELD bSourceOnly:1;
    BITFIELD bSpecialForced:1;
    BITFIELD bMustBeReachable:1;
    BITFIELD bBlockable:1;
    BITFIELD bFlyingPreferred:1;
    BITFIELD bMayCausePain:1;
    BITFIELD bAlreadyVisited:1;
    BITFIELD bVehicleDestination:1;
    BITFIELD bMakeSourceOnly:1;
    BITFIELD bMustTouchToReach:1;
    BITFIELD bCanWalkOnToReach:1;
    BITFIELD bBuildLongPaths:1;
    BITFIELD bBlockedForVehicles:1;
    BITFIELD bPreferredVehiclePath:1;
    BITFIELD bCrowdPath:1;
    BITFIELD bHasCrossLevelPaths:1;
    BITFIELD bShouldSaveForCheckpoint:1;
    struct FNavigationOctreeObject NavOctreeObject;
    TArrayNoInit<class UReachSpec*> PathList;
    TArrayNoInit<struct FActorReference> EditorProscribedPaths;
    TArrayNoInit<struct FActorReference> EditorForcedPaths;
    TArrayNoInit<struct FActorReference> Volumes;
    TArrayNoInit<class AVolume*> VolumeList;
    INT visitedWeight;
    INT bestPathWeight;
    class ANavigationPoint* nextNavigationPoint;
    class ANavigationPoint* nextOrdered;
    class ANavigationPoint* prevOrdered;
    class ANavigationPoint* previousPath;
    INT Cost;
    INT ExtraCost;
    INT TransientCost;
    INT FearCost;
    TArrayNoInit<struct FDebugNavCost> CostArray;
    class ADroppedPickup* InventoryCache;
    FLOAT InventoryDist;
    FLOAT LastDetourWeight;
    class UCylinderComponent* CylinderComponent;
    class AObjective* NearestObjective;
    FLOAT ObjectiveDistance;
    FCylinder MaxPathSize;
    FGuid NavGuid;
    class USpriteComponent* GoodSprite;
    class USpriteComponent* BadSprite;
    INT NetworkID;
    class APawn* AnchoredPawn;
    FLOAT LastAnchoredPawnTime;
    //## END PROPS NavigationPoint

    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    class UReachSpec* GetReachSpecTo(class ANavigationPoint* Nav,class UClass* SpecClass=NULL);
    virtual UBOOL IsUsableAnchorFor(class APawn* P);
    virtual UBOOL CanTeleport(class AActor* A);
    UBOOL GetAllNavInRadius(class AActor* ChkActor,FVector ChkPoint,FLOAT Radius,TArray<class ANavigationPoint*>& out_NavList,UBOOL bSkipBlocked=FALSE,INT inNetworkID=-1,FCylinder MinSize=FCylinder(EC_EventParm));
    UBOOL IsOnDifferentNetwork(class ANavigationPoint* Nav);
    DECLARE_FUNCTION(execGetReachSpecTo)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_GET_OBJECT_OPTX(UClass,SpecClass,NULL);
        P_FINISH;
        *(class UReachSpec**)Result=GetReachSpecTo(Nav,SpecClass);
    }
    DECLARE_FUNCTION(execIsUsableAnchorFor)
    {
        P_GET_OBJECT(APawn,P);
        P_FINISH;
        *(UBOOL*)Result=IsUsableAnchorFor(P);
    }
    DECLARE_FUNCTION(execCanTeleport)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=CanTeleport(A);
    }
    DECLARE_FUNCTION(execGetAllNavInRadius)
    {
        P_GET_OBJECT(AActor,ChkActor);
        P_GET_STRUCT(FVector,ChkPoint);
        P_GET_FLOAT(Radius);
        P_GET_TARRAY_REF(class ANavigationPoint*,out_NavList);
        P_GET_UBOOL_OPTX(bSkipBlocked,FALSE);
        P_GET_INT_OPTX(inNetworkID,-1);
        P_GET_STRUCT_OPTX(FCylinder,MinSize,FCylinder(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=GetAllNavInRadius(ChkActor,ChkPoint,Radius,out_NavList,bSkipBlocked,inNetworkID,MinSize);
    }
    DECLARE_FUNCTION(execIsOnDifferentNetwork)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        *(UBOOL*)Result=IsOnDifferentNetwork(Nav);
    }
    FString eventGetDebugAbbrev()
    {
        NavigationPoint_eventGetDebugAbbrev_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDebugAbbrev),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSuggestMovePreparation(class APawn* Other)
    {
        NavigationPoint_eventSuggestMovePreparation_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_SuggestMovePreparation),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventDetourWeight(class APawn* Other,FLOAT PathWeight)
    {
        NavigationPoint_eventDetourWeight_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Other=Other;
        Parms.PathWeight=PathWeight;
        ProcessEvent(FindFunctionChecked(ENGINE_DetourWeight),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventAccept(class AActor* Incoming,class AActor* Source)
    {
        NavigationPoint_eventAccept_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Incoming=Incoming;
        Parms.Source=Source;
        ProcessEvent(FindFunctionChecked(ENGINE_Accept),&Parms);
        return Parms.ReturnValue;
    }
    INT eventSpecialCost(class APawn* Seeker,class UReachSpec* Path)
    {
        NavigationPoint_eventSpecialCost_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Seeker=Seeker;
        Parms.Path=Path;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialCost),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(ANavigationPoint,AActor,0,Engine)
	virtual void	addReachSpecs(class AScout *Scout, UBOOL bOnlyChanged=0);
	virtual UClass* GetReachSpecClass( ANavigationPoint* Nav, UClass* DefaultReachSpecClass ) { return DefaultReachSpecClass; }

	virtual void InitForPathFinding() {};
	virtual void ClearPaths();
	virtual void FindBase();
	virtual void PostScriptDestroyed();
protected:
 	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
	void PostEditMove(UBOOL bFinished);
	void Spawned();
	void CleanUpPruned();
	INT PrunePaths();
	// more aggressive (and expensive) path pruning routine ( should only be called from editor )
	INT AggressivePrunePaths();
	INT SecondPassAggressivePrunePaths();
	virtual UBOOL CanPrunePath(INT index) { return TRUE; }
	void UpdateMaxPathSize();
	UBOOL FindAlternatePath(UReachSpec* StraightPath, INT AccumulatedDistance);
	virtual UBOOL ShouldBeBased();
	void CheckForErrors();
	virtual void ReviewPath(APawn* Scout);
	UBOOL CanReach(ANavigationPoint *Dest, FLOAT Dist, UBOOL bUseFlag, UBOOL bAllowFlying);
	virtual UBOOL CheckSatisfactoryConnection(ANavigationPoint* Other);
	void ClearForPathFinding();
	virtual INT AddMyMarker(AActor *S);
	virtual class APickupFactory* GetAPickupFactory() { return NULL; }
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	virtual void SetVolumes();
	virtual UReachSpec* ForcePathTo(ANavigationPoint *Nav, AScout *Scout = NULL, UClass* ReachSpecClass = NULL );
	virtual void AddForcedSpecs( AScout *Scout );
	virtual UBOOL ProscribePathTo(ANavigationPoint *Nav, AScout *Scout = NULL);
	/** returns whether a ReachSpec can be built from this node to Nav
	 * @param Nav the NavigationPoint to check if we can build a path to
	 * @param bCheckDistance whether or not we should check if Nav is close enough (MAXPATHDIST)
	 * @return true if a ReachSpec can be built from this node to Nav, false otherwise
	 */
	virtual UBOOL CanConnectTo(ANavigationPoint* Nav, UBOOL bCheckDistance);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL TouchReachSucceeded(APawn *P, const FVector& TestPosition);
	virtual UBOOL GetUpDir( FVector &V ) { return 0; }

	/** builds long range paths (> MAXPATHDIST) between this node and all other reachable nodes
	 * for which a straight path would be significantly shorter or the only way to reach that node
	 * done in a separate pass at the end because it's expensive and so we want to early out in the maximum number
	 * of cases (e.g. if suitable short range paths already get there)
	 */
	void AddLongPaths(AScout* Scout, UBOOL bOnlyChanged);

	void AddToNavigationOctree();
	void RemoveFromNavigationOctree();
	virtual UBOOL PlaceScout(class AScout *Scout);

	/** returns the position the AI should move toward to reach this actor */
	FVector GetDestination(AController* C);

	virtual void OnAddToPrefab();

	/** Checks to make sure the navigation is at a valid point */
	void Validate();

	/** sorts the PathList by distance, shortest first */
	void SortPathList();

	/** Serialize function
	 * @param Ar Archive to serialize with
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	 * Fills the array of any nav references needing to be fixed up.
	 */
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);
	virtual void ClearCrossLevelReferences();
	virtual FGuid* GetGuid() { return &NavGuid; }

	/**
	 * Sets the network ID for this nav and all connected navs.
	 */
	virtual void SetNetworkID(INT InNetworkID);
	static void BuildNetworkIDs();

	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);

	/**
	 * Works through the component arrays marking entries as pending kill so references to them
	 * will be NULL'ed.
	 *
	 * @param	bAllowComponentOverride		Whether to allow component to override marking the setting
	 */
	virtual void MarkComponentsAsPendingKill(UBOOL bAllowComponentOverride = FALSE);
};

struct FCoverReference : public FActorReference
{
    INT SlotIdx;
    INT Direction;

    /** Constructors */
    FCoverReference() {}
    FCoverReference(EEventParm)
    {
        appMemzero(this, sizeof(FCoverReference));
    }
};

struct FLinkSlotHelper
{
    class ACoverLink* Link;
    TArrayNoInit<INT> Slots;

    /** Constructors */
    FLinkSlotHelper() {}
    FLinkSlotHelper(EEventParm)
    {
        appMemzero(this, sizeof(FLinkSlotHelper));
    }
};

struct FCoverInfo
{
    class ACoverLink* Link;
    INT SlotIdx;

		UBOOL operator==(const FCoverInfo &Other)
		{
			return (this->Link == Other.Link && this->SlotIdx == Other.SlotIdx);
		}
	
};

struct FTargetInfo
{
    class AActor* Target;
    INT SlotIdx;
    INT Direction;

    /** Constructors */
    FTargetInfo() {}
    FTargetInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTargetInfo));
    }
};

struct FCovPosInfo
{
    class ACoverLink* Link;
    INT LtSlotIdx;
    INT RtSlotIdx;
    FLOAT LtToRtPct;
    FVector Location;
    FVector Normal;
    FVector Tangent;

    /** Constructors */
    FCovPosInfo() {}
    FCovPosInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCovPosInfo));
    }
};

struct FFireLinkItem
{
    BYTE SrcType;
    BYTE SrcAction;
    BYTE DestType;
    BYTE DestAction;

    /** Constructors */
    FFireLinkItem() {}
    FFireLinkItem(EEventParm)
    {
        appMemzero(this, sizeof(FFireLinkItem));
    }
};

struct FFireLink
{
    struct FActorReference TargetMarker;
    TArrayNoInit<struct FFireLinkItem> Items;
    FVector LastTargetMarkerLocation;
    FVector LastSrcMarkerLocation;
    BITFIELD bFallbackLink:1;

    /** Constructors */
    FFireLink() {}
    FFireLink(EEventParm)
    {
        appMemzero(this, sizeof(FFireLink));
    }
};

struct FExposedLink
{
    struct FActorReference TargetMarker;
    BYTE ExposedScale;

    /** Constructors */
    FExposedLink() {}
    FExposedLink(EEventParm)
    {
        appMemzero(this, sizeof(FExposedLink));
    }
};

struct FDangerLink
{
    struct FActorReference DangerNav;
    INT DangerCost;

    /** Constructors */
    FDangerLink() {}
    FDangerLink(EEventParm)
    {
        appMemzero(this, sizeof(FDangerLink));
    }
};

struct FCoverSlot
{
    class APawn* SlotOwner;
    FLOAT SlotValidAfterTime;
    BYTE ForceCoverType;
    BYTE CoverType;
    FVector LocationOffset;
    FRotator RotationOffset;
    TArrayNoInit<BYTE> Actions;
    TArrayNoInit<struct FFireLink> FireLinks;
    TArrayNoInit<struct FFireLink> ForcedFireLinks;
    TArrayNoInit<struct FFireLink> RejectedFireLinks;
    TArrayNoInit<struct FExposedLink> ExposedFireLinks;
    TArrayNoInit<struct FDangerLink> DangerLinks;
    struct FCoverReference MantleTarget;
    TArrayNoInit<struct FCoverReference> TurnTarget;
    TArrayNoInit<struct FCoverReference> SlipTarget;
    TArrayNoInit<struct FCoverReference> OverlapClaims;
    BITFIELD bLeanLeft:1;
    BITFIELD bLeanRight:1;
    BITFIELD bForceCanPopUp:1;
    BITFIELD bCanPopUp:1;
    BITFIELD bCanMantle:1;
    BITFIELD bCanClimbUp:1;
    BITFIELD bForceCanCoverSlip_Left:1;
    BITFIELD bForceCanCoverSlip_Right:1;
    BITFIELD bCanCoverSlip_Left:1;
    BITFIELD bCanCoverSlip_Right:1;
    BITFIELD bCanSwatTurn_Left:1;
    BITFIELD bCanSwatTurn_Right:1;
    BITFIELD bEnabled:1;
    BITFIELD bAllowPopup:1;
    BITFIELD bAllowMantle:1;
    BITFIELD bAllowCoverSlip:1;
    BITFIELD bAllowClimbUp:1;
    BITFIELD bAllowSwatTurn:1;
    BITFIELD bForceNoGroundAdjust:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bSelected:1;
    INT ExtraCost;
    FLOAT LeanTraceDist;
    class ACoverSlotMarker* SlotMarker;
    BYTE LocationDescription;
    BITFIELD bFailedToFindSurface:1 GCC_BITFIELD_MAGIC;

    /** Constructors */
    FCoverSlot() {}
    FCoverSlot(EEventParm)
    {
        appMemzero(this, sizeof(FCoverSlot));
    }
};

#define UCONST_COVERLINK_DangerDist 1536.f
#define UCONST_COVERLINK_EdgeExposureDot 0.85f
#define UCONST_COVERLINK_EdgeCheckDot 0.25f
#define UCONST_COVERLINK_ExposureDot 0.4f

struct CoverLink_eventGetDebugString_Parms
{
    INT SlotIdx;
    FString ReturnValue;
    CoverLink_eventGetDebugString_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetSlotEnabled_Parms
{
    INT SlotIdx;
    UBOOL bEnable;
    CoverLink_eventSetSlotEnabled_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetDisabled_Parms
{
    UBOOL bNewDisabled;
    CoverLink_eventSetDisabled_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventUnClaim_Parms
{
    class APawn* OldClaim;
    INT SlotIdx;
    UBOOL bUnclaimAll;
    UBOOL ReturnValue;
    CoverLink_eventUnClaim_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventClaim_Parms
{
    class APawn* NewClaim;
    INT SlotIdx;
    UBOOL ReturnValue;
    CoverLink_eventClaim_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetInvalidUntil_Parms
{
    INT SlotIdx;
    FLOAT TimeToBecomeValid;
    CoverLink_eventSetInvalidUntil_Parms(EEventParm)
    {
    }
};
class ACoverLink : public ANavigationPoint
{
public:
    //## BEGIN PROPS CoverLink
    TArrayNoInit<struct FCoverSlot> Slots;
    TArrayNoInit<class APawn*> Claims;
    BITFIELD bDisabled:1;
    BITFIELD bClaimAllSlots:1;
    BITFIELD bAutoSort:1;
    BITFIELD bAutoAdjust:1;
    BITFIELD bCircular:1;
    BITFIELD bLooped:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bDynamicCover:1;
    BITFIELD bDebug_FireLinks:1;
    BITFIELD bDebug_ExposedLinks:1;
    BITFIELD bDebug_DangerLinks:1;
    FLOAT InvalidateDistance;
    FLOAT MaxFireLinkDist;
    FVector CircularOrigin;
    FLOAT CircularRadius;
    FLOAT AlignDist;
    FLOAT StandHeight;
    FLOAT MidHeight;
    FVector StandingLeanOffset;
    FVector CrouchLeanOffset;
    FVector PopupOffset;
    FLOAT SlipDist;
    FLOAT TurnDist;
    FLOAT DangerScale;
    class ACoverLink* NextCoverLink;
    BYTE LocationDescription;
    //## END PROPS CoverLink

    FVector GetSlotLocation(INT SlotIdx,UBOOL bForceUseOffset=FALSE);
    FRotator GetSlotRotation(INT SlotIdx,UBOOL bForceUseOffset=FALSE);
    FVector GetSlotViewPoint(INT SlotIdx,BYTE Type=0,BYTE Action=0);
    class ACoverSlotMarker* GetSlotMarker(INT SlotIdx);
    UBOOL IsExposedTo(INT SlotIdx,struct FCoverInfo ChkSlot,FLOAT& out_ExposedScale);
    UBOOL IsValidClaim(class APawn* ChkClaim,INT SlotIdx,UBOOL bSkipTeamCheck=FALSE,UBOOL bSkipOverlapCheck=FALSE);
    UBOOL FindSlots(FVector CheckLocation,FLOAT MaxDistance,INT& LeftSlotIdx,INT& RightSlotIdx);
    UBOOL IsEdgeSlot(INT SlotIdx,UBOOL bIgnoreLeans=FALSE);
    UBOOL IsLeftEdgeSlot(INT SlotIdx,UBOOL bIgnoreLeans);
    UBOOL IsRightEdgeSlot(INT SlotIdx,UBOOL bIgnoreLeans);
    INT GetSlotIdxToLeft(INT SlotIdx,INT Cnt=1);
    INT GetSlotIdxToRight(INT SlotIdx,INT Cnt=1);
    void GetSlotActions(INT SlotIdx,TArray<BYTE>& Actions);
    UBOOL AutoAdjustSlot(INT SlotIdx,UBOOL bOnlyCheckLeans);
    UBOOL IsEnabled();
    INT AddCoverSlot(FVector SlotLocation,FRotator SlotRotation,INT SlotIdx=-1,UBOOL bForceSlotUpdate=FALSE);
    BYTE GetLocationDescription(INT SlotIdx);
    DECLARE_FUNCTION(execGetSlotLocation)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bForceUseOffset,FALSE);
        P_FINISH;
        *(FVector*)Result=GetSlotLocation(SlotIdx,bForceUseOffset);
    }
    DECLARE_FUNCTION(execGetSlotRotation)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bForceUseOffset,FALSE);
        P_FINISH;
        *(FRotator*)Result=GetSlotRotation(SlotIdx,bForceUseOffset);
    }
    DECLARE_FUNCTION(execGetSlotViewPoint)
    {
        P_GET_INT(SlotIdx);
        P_GET_BYTE_OPTX(Type,0);
        P_GET_BYTE_OPTX(Action,0);
        P_FINISH;
        *(FVector*)Result=GetSlotViewPoint(SlotIdx,Type,Action);
    }
    DECLARE_FUNCTION(execGetSlotMarker)
    {
        P_GET_INT(SlotIdx);
        P_FINISH;
        *(class ACoverSlotMarker**)Result=GetSlotMarker(SlotIdx);
    }
    DECLARE_FUNCTION(execIsExposedTo)
    {
        P_GET_INT(SlotIdx);
        P_GET_STRUCT(struct FCoverInfo,ChkSlot);
        P_GET_FLOAT_REF(out_ExposedScale);
        P_FINISH;
        *(UBOOL*)Result=IsExposedTo(SlotIdx,ChkSlot,out_ExposedScale);
    }
    DECLARE_FUNCTION(execIsValidClaim)
    {
        P_GET_OBJECT(APawn,ChkClaim);
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bSkipTeamCheck,FALSE);
        P_GET_UBOOL_OPTX(bSkipOverlapCheck,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsValidClaim(ChkClaim,SlotIdx,bSkipTeamCheck,bSkipOverlapCheck);
    }
    DECLARE_FUNCTION(execFindSlots)
    {
        P_GET_STRUCT(FVector,CheckLocation);
        P_GET_FLOAT(MaxDistance);
        P_GET_INT_REF(LeftSlotIdx);
        P_GET_INT_REF(RightSlotIdx);
        P_FINISH;
        *(UBOOL*)Result=FindSlots(CheckLocation,MaxDistance,LeftSlotIdx,RightSlotIdx);
    }
    DECLARE_FUNCTION(execIsEdgeSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bIgnoreLeans,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsEdgeSlot(SlotIdx,bIgnoreLeans);
    }
    DECLARE_FUNCTION(execIsLeftEdgeSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bIgnoreLeans);
        P_FINISH;
        *(UBOOL*)Result=IsLeftEdgeSlot(SlotIdx,bIgnoreLeans);
    }
    DECLARE_FUNCTION(execIsRightEdgeSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bIgnoreLeans);
        P_FINISH;
        *(UBOOL*)Result=IsRightEdgeSlot(SlotIdx,bIgnoreLeans);
    }
    DECLARE_FUNCTION(execGetSlotIdxToLeft)
    {
        P_GET_INT(SlotIdx);
        P_GET_INT_OPTX(Cnt,1);
        P_FINISH;
        *(INT*)Result=GetSlotIdxToLeft(SlotIdx,Cnt);
    }
    DECLARE_FUNCTION(execGetSlotIdxToRight)
    {
        P_GET_INT(SlotIdx);
        P_GET_INT_OPTX(Cnt,1);
        P_FINISH;
        *(INT*)Result=GetSlotIdxToRight(SlotIdx,Cnt);
    }
    DECLARE_FUNCTION(execGetFireLinkTo);
    DECLARE_FUNCTION(execHasFireLinkTo);
    DECLARE_FUNCTION(execGetSlotActions)
    {
        P_GET_INT(SlotIdx);
        P_GET_TARRAY_REF(BYTE,Actions);
        P_FINISH;
        GetSlotActions(SlotIdx,Actions);
    }
    DECLARE_FUNCTION(execAutoAdjustSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bOnlyCheckLeans);
        P_FINISH;
        *(UBOOL*)Result=AutoAdjustSlot(SlotIdx,bOnlyCheckLeans);
    }
    DECLARE_FUNCTION(execIsEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsEnabled();
    }
    DECLARE_FUNCTION(execAddCoverSlot)
    {
        P_GET_STRUCT(FVector,SlotLocation);
        P_GET_STRUCT(FRotator,SlotRotation);
        P_GET_INT_OPTX(SlotIdx,-1);
        P_GET_UBOOL_OPTX(bForceSlotUpdate,FALSE);
        P_FINISH;
        *(INT*)Result=AddCoverSlot(SlotLocation,SlotRotation,SlotIdx,bForceSlotUpdate);
    }
    DECLARE_FUNCTION(execGetLocationDescription)
    {
        P_GET_INT(SlotIdx);
        P_FINISH;
        *(BYTE*)Result=GetLocationDescription(SlotIdx);
    }
    FString eventGetDebugString(INT SlotIdx)
    {
        CoverLink_eventGetDebugString_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDebugString),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetSlotEnabled(INT SlotIdx,UBOOL bEnable)
    {
        CoverLink_eventSetSlotEnabled_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        Parms.bEnable=bEnable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSlotEnabled),&Parms);
    }
    void eventSetDisabled(UBOOL bNewDisabled)
    {
        CoverLink_eventSetDisabled_Parms Parms(EC_EventParm);
        Parms.bNewDisabled=bNewDisabled ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetDisabled),&Parms);
    }
    UBOOL eventUnClaim(class APawn* OldClaim,INT SlotIdx,UBOOL bUnclaimAll)
    {
        CoverLink_eventUnClaim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.OldClaim=OldClaim;
        Parms.SlotIdx=SlotIdx;
        Parms.bUnclaimAll=bUnclaimAll ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_UnClaim),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventClaim(class APawn* NewClaim,INT SlotIdx)
    {
        CoverLink_eventClaim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewClaim=NewClaim;
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(ENGINE_Claim),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetInvalidUntil(INT SlotIdx,FLOAT TimeToBecomeValid)
    {
        CoverLink_eventSetInvalidUntil_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        Parms.TimeToBecomeValid=TimeToBecomeValid;
        ProcessEvent(FindFunctionChecked(ENGINE_SetInvalidUntil),&Parms);
    }
    DECLARE_CLASS(ACoverLink,ANavigationPoint,0,Engine)
	struct FFireLinkInfo
	{
		class ACoverLink*	Link;
		INT					SlotIdx;
		FCoverSlot*			Slot;
		FVector				SlotLocation;
		FRotator			SlotRotation;
		FVector				X, Y, Z;
		TArray<BYTE>		Types;
		TArray<BYTE>		Actions;

		INT*				out_FireLinkIdx;

		FFireLinkInfo( ACoverLink* InLink, INT InSlotIdx, INT* InIdx = NULL )
		{
			Link			= InLink;
			SlotIdx			= InSlotIdx;
			Slot			= &Link->Slots(SlotIdx);
			out_FireLinkIdx = InIdx;

			if( Slot->bLeanLeft )
			{
				Actions.AddItem( CA_LeanLeft );
			}
			if( Slot->bLeanRight )
			{
				Actions.AddItem( CA_LeanRight );
			}
			if( Slot->bCanPopUp && Slot->CoverType == CT_MidLevel )
			{
				Actions.AddItem( CA_PopUp );
			}

			Types.AddItem( Slot->CoverType );
			if( Slot->CoverType == CT_Standing )
			{
				Types.AddItem( CT_MidLevel );
			}

			SlotLocation = Link->GetSlotLocation(SlotIdx);
			SlotRotation = Link->GetSlotRotation(SlotIdx);
			FRotationMatrix(SlotRotation).GetAxes(X,Y,Z);
		}
	};

	void PreBeginPlay();
	virtual void PostEditChange( UProperty* PropertyThatChanged );
	void BuildSlotInfo(INT SlotIdx);
	void SortSlots();
	void BuildFireLinks( AScout* Scout );
	void BuildOtherLinks( AScout* Scout );
	UBOOL GetFireActions( FFireLinkInfo& Info, ACoverSlotMarker* TestMarker, UBOOL bFill = TRUE );
	UBOOL CanFireLinkHit( const FVector &ViewPt, const FVector &TargetLoc, UBOOL bDebugLines = FALSE );

	UBOOL GetExposedInfo( ACoverSlotMarker* SrcMarker, ACoverSlotMarker* DestMarker, FLOAT& out_ExposedScale );

	virtual UBOOL GetFireLinkTo( INT SlotIdx, FCoverInfo& ChkCover, BYTE ChkActin, BYTE ChkType, INT& out_FireLinkIdx, TArray<INT>& Items );
	virtual UBOOL HasFireLinkTo( INT SlotIdx, FCoverInfo& ChkCover, UBOOL bAllowFallbackLinks = FALSE );
	FLOAT GetSlotHeight(INT SlotIdx);
	virtual void CheckForErrors();
	virtual UBOOL IsFireLinkValid( INT SlotIdx, FFireLink* FireLink );
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);

	virtual INT AddMyMarker(AActor *S);
	UBOOL IsOverlapSlotClaimed( APawn *ChkClaim, INT SlotIdx, UBOOL bSkipTeamCheck );

	static FCoverSlot* CoverInfoToSlotPtr( FCoverInfo& InSlot );
	static FCoverSlot* CoverRefToSlotPtr( FCoverReference& InRef );

	UBOOL FindCoverEdges(const FVector& StartLoc, FVector AxisX, FVector AxisY, FVector AxisZ);
	INT AddCoverSlot(FVector& SlotLocation, FRotator& SlotRotation, FCoverSlot Slot, INT SlotIdx = -1);
	void EditorAutoSetup(FVector Direction,FVector *HitL = NULL, FVector *HitN = NULL);
	void ClearExposedFireLinks();

};

class ACoverSlotMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS CoverSlotMarker
    struct FCoverInfo OwningSlot;
    BITFIELD bLastChoice:1;
    BITFIELD bIgnoreSizeLimits:1;
    //## END PROPS CoverSlotMarker

    virtual FVector GetSlotLocation();
    virtual FRotator GetSlotRotation();
    virtual void SetSlotEnabled(UBOOL bEnable);
    UBOOL IsValidClaim(class APawn* ChkClaim,UBOOL bSkipTeamCheck=FALSE,UBOOL bSkipOverlapCheck=FALSE);
    DECLARE_FUNCTION(execGetSlotLocation)
    {
        P_FINISH;
        *(FVector*)Result=GetSlotLocation();
    }
    DECLARE_FUNCTION(execGetSlotRotation)
    {
        P_FINISH;
        *(FRotator*)Result=GetSlotRotation();
    }
    DECLARE_FUNCTION(execSetSlotEnabled)
    {
        P_GET_UBOOL(bEnable);
        P_FINISH;
        SetSlotEnabled(bEnable);
    }
    DECLARE_FUNCTION(execIsValidClaim)
    {
        P_GET_OBJECT(APawn,ChkClaim);
        P_GET_UBOOL_OPTX(bSkipTeamCheck,FALSE);
        P_GET_UBOOL_OPTX(bSkipOverlapCheck,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsValidClaim(ChkClaim,bSkipTeamCheck,bSkipOverlapCheck);
    }
    DECLARE_CLASS(ACoverSlotMarker,ANavigationPoint,0,Engine)
	virtual void addReachSpecs(AScout* Scout, UBOOL bOnlyChanged);
	virtual void AddForcedSpecs( AScout *Scout );
	virtual UBOOL CanConnectTo(ANavigationPoint* Nav, UBOOL bCheckDistance);
	virtual UBOOL ShouldBeBased()
	{
		// don't base since we're set directly to the slot location
		return FALSE;
	}

	UBOOL PlaceScout(AScout *Scout);
	virtual UBOOL CanPrunePath(INT index);
	virtual UClass* GetReachSpecClass( ANavigationPoint* Nav, UClass* ReachSpecClass );
};

class ADoorMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS DoorMarker
    class AInterpActor* MyDoor;
    BYTE DoorType;
    class AActor* DoorTrigger;
    BITFIELD bWaitUntilCompletelyOpened:1;
    BITFIELD bInitiallyClosed:1;
    BITFIELD bBlockedWhenClosed:1;
    BITFIELD bDoorOpen:1;
    BITFIELD bTempDisabledCollision:1;
    //## END PROPS DoorMarker

    DECLARE_CLASS(ADoorMarker,ANavigationPoint,0,Engine)
	virtual AActor* AssociatedLevelGeometry();
	virtual UBOOL HasAssociatedLevelGeometry(AActor* Other);
	virtual void PrePath();
	virtual void PostPath();
	virtual void FindBase();
	virtual void CheckForErrors();
};

class ADynamicAnchor : public ANavigationPoint
{
public:
    //## BEGIN PROPS DynamicAnchor
    class AController* CurrentUser;
    //## END PROPS DynamicAnchor

    DECLARE_CLASS(ADynamicAnchor,ANavigationPoint,0,Engine)
	/** initializes us with the given user and creates ReachSpecs to connect ourselves to the given endpoints,
	 * using the given ReachSpec as a template
	 * @param InUser the Controller that will be using us for navigation
	 * @param Point1 the first NavigationPoint to connect to
	 * @param Point2 the second NavigationPoint to connect to
	 * @param SpecTemplate the ReachSpec to use as a template for the ReachSpecs we create
	 */
	void Initialize(AController* InUser, ANavigationPoint* Point1, ANavigationPoint* Point2, UReachSpec* SpecTemplate);
	void InitHelper( ANavigationPoint* Start, ANavigationPoint* End, INT NewHeight, INT NewRadius, UReachSpec* SpecTemplate );

	virtual void PostScriptDestroyed();

	virtual void TickSpecial(FLOAT DeltaSeconds);
};

class ALadder : public ANavigationPoint
{
public:
    //## BEGIN PROPS Ladder
    class ALadderVolume* MyLadder;
    class ALadder* LadderList;
    //## END PROPS Ladder

    DECLARE_CLASS(ALadder,ANavigationPoint,0,Engine)
	virtual UBOOL CanConnectTo(ANavigationPoint* Dest, UBOOL bCheckDistance);
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
	void InitForPathFinding();
	void ClearPaths();
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
};

class AAutoLadder : public ALadder
{
public:
    //## BEGIN PROPS AutoLadder
    //## END PROPS AutoLadder

    DECLARE_CLASS(AAutoLadder,ALadder,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AAutoLadder)
};

class ALiftCenter : public ANavigationPoint
{
public:
    //## BEGIN PROPS LiftCenter
    class AInterpActor* MyLift;
    FLOAT MaxDist2D;
    FVector LiftOffset;
    BITFIELD bJumpLift:1;
    FLOAT CollisionHeight;
    class ATrigger* LiftTrigger;
    //## END PROPS LiftCenter

    DECLARE_CLASS(ALiftCenter,ANavigationPoint,0,Engine)
	virtual void ReviewPath(APawn* Scout);
	virtual UBOOL ShouldBeBased();
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged);
	void FindBase();
};

class ALiftExit : public ANavigationPoint
{
public:
    //## BEGIN PROPS LiftExit
    class ALiftCenter* MyLiftCenter;
    BITFIELD bExitOnly:1;
    //## END PROPS LiftExit

    DECLARE_CLASS(ALiftExit,ANavigationPoint,0,Engine)
	virtual void ReviewPath(APawn* Scout);
};

class AMantleMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS MantleMarker
    struct FCoverInfo OwningSlot;
    //## END PROPS MantleMarker

    DECLARE_CLASS(AMantleMarker,ANavigationPoint,0,Engine)
	virtual UBOOL	CanConnectTo( ANavigationPoint* Nav, UBOOL bCheckDistance );
};

class AObjective : public ANavigationPoint
{
public:
    //## BEGIN PROPS Objective
    //## END PROPS Objective

    DECLARE_ABSTRACT_CLASS(AObjective,ANavigationPoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AObjective)
};

class APathNode : public ANavigationPoint
{
public:
    //## BEGIN PROPS PathNode
    //## END PROPS PathNode

    DECLARE_CLASS(APathNode,ANavigationPoint,0,Engine)
	virtual INT AddMyMarker(AActor *S);
};

class AVolumePathNode : public APathNode
{
public:
    //## BEGIN PROPS VolumePathNode
    FLOAT StartingRadius;
    FLOAT StartingHeight;
    //## END PROPS VolumePathNode

    DECLARE_CLASS(AVolumePathNode,APathNode,0,Engine)
	virtual UBOOL CanConnectTo(ANavigationPoint* Dest, UBOOL bCheckDistance);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged);
	virtual UBOOL ShouldBeBased();
	virtual void InitForPathFinding();
	virtual void ReviewPath(APawn* Scout);
	virtual UBOOL CanPrunePath(INT index);
};

class APickupFactory : public ANavigationPoint
{
public:
    //## BEGIN PROPS PickupFactory
    BITFIELD bOnlyReplicateHidden:1;
    BITFIELD bPickupHidden:1;
    BITFIELD bPredictRespawns:1;
    BITFIELD bIsSuperItem:1;
    class UClass* InventoryType;
    FLOAT RespawnEffectTime;
    FLOAT MaxDesireability;
    class UPrimitiveComponent* PickupMesh;
    class APickupFactory* ReplacementFactory;
    class APickupFactory* OriginalFactory;
    //## END PROPS PickupFactory

    DECLARE_ABSTRACT_CLASS(APickupFactory,ANavigationPoint,0|CLASS_NativeReplication,Engine)
	virtual APickupFactory* GetAPickupFactory() { return this; }
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);
};

class APlayerStart : public ANavigationPoint
{
public:
    //## BEGIN PROPS PlayerStart
    BITFIELD bEnabled:1;
    BITFIELD bPrimaryStart:1;
    //## END PROPS PlayerStart

    DECLARE_CLASS(APlayerStart,ANavigationPoint,0,Engine)
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
};

class APortalMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS PortalMarker
    class APortalTeleporter* MyPortal;
    //## END PROPS PortalMarker

    virtual UBOOL CanTeleport(class AActor* A);
    DECLARE_CLASS(APortalMarker,ANavigationPoint,0,Engine)
	virtual void addReachSpecs(AScout* Scout, UBOOL bOnlyChanged);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
};

class ATeleporter : public ANavigationPoint
{
public:
    //## BEGIN PROPS Teleporter
    FStringNoInit URL;
    FName ProductRequired;
    BITFIELD bChangesVelocity:1;
    BITFIELD bChangesYaw:1;
    BITFIELD bReversesX:1;
    BITFIELD bReversesY:1;
    BITFIELD bReversesZ:1;
    BITFIELD bEnabled:1;
    BITFIELD bCanTeleportVehicles:1;
    FVector TargetVelocity;
    FLOAT LastFired;
    //## END PROPS Teleporter

    virtual UBOOL CanTeleport(class AActor* A);
    DECLARE_CLASS(ATeleporter,ANavigationPoint,0,Engine)
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
};

class ACoverGroup : public AInfo
{
public:
    //## BEGIN PROPS CoverGroup
    TArrayNoInit<struct FActorReference> CoverLinkRefs;
    FLOAT AutoSelectRadius;
    FLOAT AutoSelectHeight;
    //## END PROPS CoverGroup

    virtual void EnableGroup();
    virtual void DisableGroup();
    virtual void ToggleGroup();
    DECLARE_FUNCTION(execEnableGroup)
    {
        P_FINISH;
        EnableGroup();
    }
    DECLARE_FUNCTION(execDisableGroup)
    {
        P_FINISH;
        DisableGroup();
    }
    DECLARE_FUNCTION(execToggleGroup)
    {
        P_FINISH;
        ToggleGroup();
    }
    DECLARE_CLASS(ACoverGroup,AInfo,0,Engine)
	void AutoFillGroup( ECoverGroupFillAction CGFA, TArray<ACoverLink*>& Links );
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);

	virtual void PostLoad();
	virtual void CheckForErrors();
};

class AFileWriter : public AInfo
{
public:
    //## BEGIN PROPS FileWriter
    FArchive* ArchivePtr;
    FStringNoInit Filename;
    BYTE FileType;
    BITFIELD bFlushEachWrite:1 GCC_BITFIELD_MAGIC;
    //## END PROPS FileWriter

    UBOOL OpenFile(const FString& InFilename,BYTE InFileType=0,const FString& InExtension=TEXT(""),UBOOL bUnique=FALSE,UBOOL bIncludeTimeStamp=FALSE);
    void CloseFile();
    void Logf(const FString& logString);
    DECLARE_FUNCTION(execOpenFile)
    {
        P_GET_STR(InFilename);
        P_GET_BYTE_OPTX(InFileType,0);
        P_GET_STR_OPTX(InExtension,TEXT(""));
        P_GET_UBOOL_OPTX(bUnique,FALSE);
        P_GET_UBOOL_OPTX(bIncludeTimeStamp,FALSE);
        P_FINISH;
        *(UBOOL*)Result=OpenFile(InFilename,InFileType,InExtension,bUnique,bIncludeTimeStamp);
    }
    DECLARE_FUNCTION(execCloseFile)
    {
        P_FINISH;
        CloseFile();
    }
    DECLARE_FUNCTION(execLogf)
    {
        P_GET_STR(logString);
        P_FINISH;
        Logf(logString);
    }
    DECLARE_CLASS(AFileWriter,AInfo,0,Engine)
	virtual void BeginDestroy();
};

class AFileLog : public AFileWriter
{
public:
    //## BEGIN PROPS FileLog
    //## END PROPS FileLog

    DECLARE_CLASS(AFileLog,AFileWriter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AFileLog)
};

struct GameInfo_eventStartAutomatedMapTestTimer_Parms
{
    GameInfo_eventStartAutomatedMapTestTimer_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventMatineeCancelled_Parms
{
    GameInfo_eventMatineeCancelled_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventHandleSeamlessTravelPlayer_Parms
{
    class AController* C;
    GameInfo_eventHandleSeamlessTravelPlayer_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPostSeamlessTravel_Parms
{
    GameInfo_eventPostSeamlessTravel_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGetSeamlessTravelActorList_Parms
{
    UBOOL bToEntry;
    TArray<class AActor*> ActorList;
    GameInfo_eventGetSeamlessTravelActorList_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPostCommitMapChange_Parms
{
    GameInfo_eventPostCommitMapChange_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPreCommitMapChange_Parms
{
    FString PreviousMapName;
    FString NextMapName;
    GameInfo_eventPreCommitMapChange_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventBroadcastLocalizedTeam_Parms
{
    INT TeamIndex;
    class AActor* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    GameInfo_eventBroadcastLocalizedTeam_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventBroadcastLocalized_Parms
{
    class AActor* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    GameInfo_eventBroadcastLocalized_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventBroadcast_Parms
{
    class AActor* Sender;
    FString msg;
    FName Type;
    GameInfo_eventBroadcast_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventAddDefaultInventory_Parms
{
    class APawn* P;
    GameInfo_eventAddDefaultInventory_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventAcceptInventory_Parms
{
    class APawn* PlayerPawn;
    GameInfo_eventAcceptInventory_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPreExit_Parms
{
    GameInfo_eventPreExit_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPostLogin_Parms
{
    class APlayerController* NewPlayer;
    GameInfo_eventPostLogin_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventLogin_Parms
{
    FString Portal;
    FString Options;
    FString ErrorMessage;
    class APlayerController* ReturnValue;
    GameInfo_eventLogin_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPreLogin_Parms
{
    FString Options;
    FString Address;
    FString ErrorMessage;
    GameInfo_eventPreLogin_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGetBeaconText_Parms
{
    FString ReturnValue;
    GameInfo_eventGetBeaconText_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventNotifyPendingConnectionLost_Parms
{
    GameInfo_eventNotifyPendingConnectionLost_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventInitGame_Parms
{
    FString Options;
    FString ErrorMessage;
    GameInfo_eventInitGame_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventSetGameType_Parms
{
    FString MapName;
    FString Options;
    FString Portal;
    class UClass* ReturnValue;
    GameInfo_eventSetGameType_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGetDefaultGameClassPath_Parms
{
    FString MapName;
    FString Options;
    FString Portal;
    FString ReturnValue;
    GameInfo_eventGetDefaultGameClassPath_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventClearPause_Parms
{
    GameInfo_eventClearPause_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventCanUnpause_Parms
{
    UBOOL ReturnValue;
    GameInfo_eventCanUnpause_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventKickIdler_Parms
{
    class APlayerController* PC;
    GameInfo_eventKickIdler_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGameEnding_Parms
{
    GameInfo_eventGameEnding_Parms(EEventParm)
    {
    }
};
class AGameInfo : public AInfo
{
public:
    //## BEGIN PROPS GameInfo
    BITFIELD bRestartLevel:1;
    BITFIELD bPauseable:1;
    BITFIELD bTeamGame:1;
    BITFIELD bGameEnded:1;
    BITFIELD bOverTime:1;
    BITFIELD bDelayedStart:1;
    BITFIELD bWaitingToStartMatch:1;
    BITFIELD bChangeLevels:1;
    BITFIELD bAlreadyChanged:1;
    BITFIELD bLoggingGame:1;
    BITFIELD bAdminCanPause:1;
    BITFIELD bGameRestarted:1;
    BITFIELD bLevelChange:1;
    BITFIELD bKickLiveIdlers:1;
    BITFIELD bUsingArbitration:1;
    BITFIELD bHasArbitratedHandshakeBegun:1;
    BITFIELD bNeedsEndGameHandshake:1;
    BITFIELD bIsEndGameHandshakeComplete:1;
    BITFIELD bHasEndGameHandshakeBegun:1;
    BITFIELD bFixedPlayerStart:1;
    BITFIELD bAutomatedPerfTesting:1;
    BITFIELD bAutoContinueToNextRound:1;
    BITFIELD bUsingAutomatedTestingMapList:1;
    BITFIELD bAutomatedTestingWithOpen:1;
    BITFIELD bCheckingForFragmentation:1;
    BITFIELD bCheckingForMemLeaks:1;
    BITFIELD bDoingASentinelRun:1;
    BITFIELD bDoFearCostFallOff:1;
    BITFIELD bUseSeamlessTravel:1;
    BITFIELD bHasNetworkError:1;
    BITFIELD bRequiresPushToTalk:1;
    BITFIELD bSentinelStreamingLevelStillLoading:1;
    INT AutomatedPerfRemainingTime;
    INT AutomatedTestingMapIndex;
    TArrayNoInit<FString> AutomatedMapTestingList;
    INT NumAutomatedMapTestingCycles;
    INT NumberOfMatchesPlayed;
    INT NumMapListCyclesDone;
    FStringNoInit AutomatedTestingExecCommandToRunAtStartMatch;
    FStringNoInit AutomatedMapTestingTransitionMap;
    FStringNoInit CauseEventCommand;
    FStringNoInit SentinelTaskDescription;
    FStringNoInit SentinelTaskParameter;
    FStringNoInit SentinelTagDesc;
    FStringNoInit BugLocString;
    FStringNoInit BugRotString;
    TArrayNoInit<class APlayerController*> PendingArbitrationPCs;
    TArrayNoInit<class APlayerController*> ArbitrationPCs;
    FLOAT ArbitrationHandshakeTimeout;
    FLOAT GameDifficulty;
    INT GoreLevel;
    FLOAT GameSpeed;
    class UClass* DefaultPawnClass;
    class UClass* ScoreBoardType;
    class UClass* HUDType;
    INT MaxSpectators;
    INT MaxSpectatorsAllowed;
    INT NumSpectators;
    INT MaxPlayers;
    INT MaxPlayersAllowed;
    INT NumPlayers;
    INT NumBots;
    INT NumTravellingPlayers;
    INT CurrentID;
    FStringNoInit DefaultPlayerName;
    FStringNoInit GameName;
    FLOAT FearCostFallOff;
    INT GoalScore;
    INT MaxLives;
    INT TimeLimit;
    class UClass* DeathMessageClass;
    class UClass* GameMessageClass;
    class AMutator* BaseMutator;
    class UClass* AccessControlClass;
    class AAccessControl* AccessControl;
    class AGameRules* GameRulesModifiers;
    class UClass* BroadcastHandlerClass;
    class ABroadcastHandler* BroadcastHandler;
    class UClass* PlayerControllerClass;
    class UClass* PlayerReplicationInfoClass;
    FStringNoInit DialogueManagerClass;
    class ADialogueManager* DialogueManager;
    class UClass* GameReplicationInfoClass;
    class AGameReplicationInfo* GameReplicationInfo;
    FLOAT MaxIdleTime;
    FLOAT MaxTimeMargin;
    FLOAT TimeMarginSlack;
    FLOAT MinTimeMargin;
    TArrayNoInit<class APlayerReplicationInfo*> InactivePRIArray;
    TArrayNoInit<FScriptDelegate> Pausers;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> GameInterface;
    class UClass* OnlineStatsWriteClass;
    INT LeaderboardId;
    INT ArbitratedLeaderboardId;
    class ACoverReplicator* CoverReplicatorBase;
    class UClass* OnlineGameSettingsClass;
    FStringNoInit ServerOptions;
    INT AdjustedNetSpeed;
    FLOAT LastNetSpeedUpdateTime;
    INT TotalNetBandwidth;
    INT MinDynamicBandwidth;
    INT MaxDynamicBandwidth;
    class APlayerController* SentinelPC;
    class APawn* SentinelPawn;
    TArrayNoInit<class ANavigationPoint*> SentinelNavArray;
    TArrayNoInit<FVector> SentinelTravelArray;
    INT SentinelNavigationIdx;
    INT SentinelIdx;
    INT NumRotationsIncrement;
    INT TravelPointsIncrement;
    FScriptDelegate __CanUnpause__Delegate;
    //## END PROPS GameInfo

    void DoNavFearCostFallOff();
    virtual FString GetNetworkNumber();
    void ForceClearUnpauseDelegates(class AActor* PauseActor);
    void SwapPlayerControllers(class APlayerController* OldPC,class APlayerController* NewPC);
    virtual void BeginSentinelRun(const FString& TaskDescription,const FString& TaskParameter,const FString& TagDesc);
    virtual void AddSentinelPerTimePeriodStats(const FVector InLocation,const FRotator InRotation);
    virtual void EndSentinelRun(BYTE RunResult);
    virtual void DoSentinelActionPerLoadedMap();
    virtual void HandlePerLoadedMapAudioStats();
    virtual void GetTravelLocations(FName LevelName,class APlayerController* PC,TArray<FVector>& TravelPoints);
    virtual void DoSentinel_MemoryAtSpecificLocation(const FVector InLocation,const FRotator InRotation);
    virtual void DoSentinel_PerfAtSpecificLocation(const FVector InLocation,const FRotator InRotation);
    DECLARE_FUNCTION(execDoNavFearCostFallOff)
    {
        P_FINISH;
        DoNavFearCostFallOff();
    }
    DECLARE_FUNCTION(execGetNetworkNumber)
    {
        P_FINISH;
        *(FString*)Result=GetNetworkNumber();
    }
    DECLARE_FUNCTION(execForceClearUnpauseDelegates)
    {
        P_GET_OBJECT(AActor,PauseActor);
        P_FINISH;
        ForceClearUnpauseDelegates(PauseActor);
    }
    DECLARE_FUNCTION(execSwapPlayerControllers)
    {
        P_GET_OBJECT(APlayerController,OldPC);
        P_GET_OBJECT(APlayerController,NewPC);
        P_FINISH;
        SwapPlayerControllers(OldPC,NewPC);
    }
    DECLARE_FUNCTION(execBeginSentinelRun)
    {
        P_GET_STR(TaskDescription);
        P_GET_STR(TaskParameter);
        P_GET_STR(TagDesc);
        P_FINISH;
        BeginSentinelRun(TaskDescription,TaskParameter,TagDesc);
    }
    DECLARE_FUNCTION(execAddSentinelPerTimePeriodStats)
    {
        P_GET_STRUCT(FVector,InLocation);
        P_GET_STRUCT(FRotator,InRotation);
        P_FINISH;
        AddSentinelPerTimePeriodStats(InLocation,InRotation);
    }
    DECLARE_FUNCTION(execEndSentinelRun)
    {
        P_GET_BYTE(RunResult);
        P_FINISH;
        EndSentinelRun(RunResult);
    }
    DECLARE_FUNCTION(execDoSentinelActionPerLoadedMap)
    {
        P_FINISH;
        DoSentinelActionPerLoadedMap();
    }
    DECLARE_FUNCTION(execHandlePerLoadedMapAudioStats)
    {
        P_FINISH;
        HandlePerLoadedMapAudioStats();
    }
    DECLARE_FUNCTION(execGetTravelLocations)
    {
        P_GET_NAME(LevelName);
        P_GET_OBJECT(APlayerController,PC);
        P_GET_TARRAY_REF(FVector,TravelPoints);
        P_FINISH;
        GetTravelLocations(LevelName,PC,TravelPoints);
    }
    DECLARE_FUNCTION(execDoSentinel_MemoryAtSpecificLocation)
    {
        P_GET_STRUCT(FVector,InLocation);
        P_GET_STRUCT(FRotator,InRotation);
        P_FINISH;
        DoSentinel_MemoryAtSpecificLocation(InLocation,InRotation);
    }
    DECLARE_FUNCTION(execDoSentinel_PerfAtSpecificLocation)
    {
        P_GET_STRUCT(FVector,InLocation);
        P_GET_STRUCT(FRotator,InRotation);
        P_FINISH;
        DoSentinel_PerfAtSpecificLocation(InLocation,InRotation);
    }
    void eventStartAutomatedMapTestTimer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StartAutomatedMapTestTimer),NULL);
    }
    void eventMatineeCancelled()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MatineeCancelled),NULL);
    }
    void eventHandleSeamlessTravelPlayer(class AController*& C)
    {
        GameInfo_eventHandleSeamlessTravelPlayer_Parms Parms(EC_EventParm);
        Parms.C=C;
        ProcessEvent(FindFunctionChecked(ENGINE_HandleSeamlessTravelPlayer),&Parms);
        C=Parms.C;
    }
    void eventPostSeamlessTravel()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostSeamlessTravel),NULL);
    }
    void eventGetSeamlessTravelActorList(UBOOL bToEntry,TArray<class AActor*>& ActorList)
    {
        GameInfo_eventGetSeamlessTravelActorList_Parms Parms(EC_EventParm);
        Parms.bToEntry=bToEntry ? FIRST_BITFIELD : FALSE;
        Parms.ActorList=ActorList;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSeamlessTravelActorList),&Parms);
        ActorList=Parms.ActorList;
    }
    void eventPostCommitMapChange()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostCommitMapChange),NULL);
    }
    void eventPreCommitMapChange(const FString& PreviousMapName,const FString& NextMapName)
    {
        GameInfo_eventPreCommitMapChange_Parms Parms(EC_EventParm);
        Parms.PreviousMapName=PreviousMapName;
        Parms.NextMapName=NextMapName;
        ProcessEvent(FindFunctionChecked(ENGINE_PreCommitMapChange),&Parms);
    }
    void eventBroadcastLocalizedTeam(INT TeamIndex,class AActor* Sender,class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        GameInfo_eventBroadcastLocalizedTeam_Parms Parms(EC_EventParm);
        Parms.TeamIndex=TeamIndex;
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedTeam),&Parms);
    }
    void eventBroadcastLocalized(class AActor* Sender,class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        GameInfo_eventBroadcastLocalized_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalized),&Parms);
    }
    void eventBroadcast(class AActor* Sender,const FString& msg,FName Type=NAME_None)
    {
        GameInfo_eventBroadcast_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.msg=msg;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_Broadcast),&Parms);
    }
    void eventAddDefaultInventory(class APawn* P)
    {
        GameInfo_eventAddDefaultInventory_Parms Parms(EC_EventParm);
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(ENGINE_AddDefaultInventory),&Parms);
    }
    void eventAcceptInventory(class APawn* PlayerPawn)
    {
        GameInfo_eventAcceptInventory_Parms Parms(EC_EventParm);
        Parms.PlayerPawn=PlayerPawn;
        ProcessEvent(FindFunctionChecked(ENGINE_AcceptInventory),&Parms);
    }
    void eventPreExit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PreExit),NULL);
    }
    void eventPostLogin(class APlayerController* NewPlayer)
    {
        GameInfo_eventPostLogin_Parms Parms(EC_EventParm);
        Parms.NewPlayer=NewPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_PostLogin),&Parms);
    }
    class APlayerController* eventLogin(const FString& Portal,const FString& Options,FString& ErrorMessage)
    {
        GameInfo_eventLogin_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Portal=Portal;
        Parms.Options=Options;
        Parms.ErrorMessage=ErrorMessage;
        ProcessEvent(FindFunctionChecked(ENGINE_Login),&Parms);
        ErrorMessage=Parms.ErrorMessage;
        return Parms.ReturnValue;
    }
    void eventPreLogin(const FString& Options,const FString& Address,FString& ErrorMessage)
    {
        GameInfo_eventPreLogin_Parms Parms(EC_EventParm);
        Parms.Options=Options;
        Parms.Address=Address;
        Parms.ErrorMessage=ErrorMessage;
        ProcessEvent(FindFunctionChecked(ENGINE_PreLogin),&Parms);
        ErrorMessage=Parms.ErrorMessage;
    }
    FString eventGetBeaconText()
    {
        GameInfo_eventGetBeaconText_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetBeaconText),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPendingConnectionLost()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPendingConnectionLost),NULL);
    }
    void eventInitGame(const FString& Options,FString& ErrorMessage)
    {
        GameInfo_eventInitGame_Parms Parms(EC_EventParm);
        Parms.Options=Options;
        Parms.ErrorMessage=ErrorMessage;
        ProcessEvent(FindFunctionChecked(ENGINE_InitGame),&Parms);
        ErrorMessage=Parms.ErrorMessage;
    }
    class UClass* eventSetGameType(const FString& MapName,const FString& Options,const FString& Portal)
    {
        GameInfo_eventSetGameType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.MapName=MapName;
        Parms.Options=Options;
        Parms.Portal=Portal;
        ProcessEvent(FindFunctionChecked(ENGINE_SetGameType),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGetDefaultGameClassPath(const FString& MapName,const FString& Options,const FString& Portal)
    {
        GameInfo_eventGetDefaultGameClassPath_Parms Parms(EC_EventParm);
        Parms.MapName=MapName;
        Parms.Options=Options;
        Parms.Portal=Portal;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDefaultGameClassPath),&Parms);
        return Parms.ReturnValue;
    }
    void eventClearPause()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClearPause),NULL);
    }
    UBOOL delegateCanUnpause()
    {
        GameInfo_eventCanUnpause_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessDelegate(ENGINE_CanUnpause,&__CanUnpause__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void eventKickIdler(class APlayerController* PC)
    {
        GameInfo_eventKickIdler_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_KickIdler),&Parms);
    }
    void eventGameEnding()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_GameEnding),NULL);
    }
    DECLARE_CLASS(AGameInfo,AInfo,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/** called on the default object of the class specified by DefaultGame in the [Engine.GameInfo] section of Game.ini
	 * whenever worlds are saved.
	 * Gives the game a chance to add supported gametypes to the WorldInfo's GameTypesSupportedOnThisMap array
	 * (used for console cooking)
	 * @param Info: the WorldInfo of the world being saved
	 */
	virtual void AddSupportedGameTypes(AWorldInfo* Info, const TCHAR* WorldFilename) const
	{
	}
};

class AInternetInfo : public AInfo
{
public:
    //## BEGIN PROPS InternetInfo
    //## END PROPS InternetInfo

    DECLARE_CLASS(AInternetInfo,AInfo,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInternetInfo)
};

class AMutator : public AInfo
{
public:
    //## BEGIN PROPS Mutator
    class AMutator* NextMutator;
    TArrayNoInit<FString> GroupNames;
    BITFIELD bUserAdded:1;
    //## END PROPS Mutator

    DECLARE_ABSTRACT_CLASS(AMutator,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AMutator)
};

class APotentialClimbWatcher : public AInfo
{
public:
    //## BEGIN PROPS PotentialClimbWatcher
    //## END PROPS PotentialClimbWatcher

    DECLARE_CLASS(APotentialClimbWatcher,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APotentialClimbWatcher)
};

class AReplicationInfo : public AInfo
{
public:
    //## BEGIN PROPS ReplicationInfo
    //## END PROPS ReplicationInfo

    DECLARE_ABSTRACT_CLASS(AReplicationInfo,AInfo,0,Engine)
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct GameReplicationInfo_eventShouldShowGore_Parms
{
    UBOOL ReturnValue;
    GameReplicationInfo_eventShouldShowGore_Parms(EEventParm)
    {
    }
};
class AGameReplicationInfo : public AReplicationInfo
{
public:
    //## BEGIN PROPS GameReplicationInfo
    class UClass* GameClass;
    class UCurrentGameDataStore* CurrentGameData;
    BITFIELD bStopCountDown:1;
    BITFIELD bMatchHasBegun:1;
    BITFIELD bMatchIsOver:1;
    BITFIELD bNeedsOnlineCleanup:1;
    BITFIELD bIsArbitrated:1;
    BITFIELD bTrackStats:1;
    INT RemainingTime;
    INT ElapsedTime;
    INT RemainingMinute;
    FLOAT SecondCount;
    INT GoalScore;
    INT TimeLimit;
    INT MaxLives;
    TArrayNoInit<class ATeamInfo*> Teams;
    FStringNoInit ServerName;
    FStringNoInit ShortName;
    FStringNoInit AdminName;
    FStringNoInit AdminEmail;
    INT ServerRegion;
    FStringNoInit MessageOfTheDay;
    class AActor* Winner;
    TArrayNoInit<class APlayerReplicationInfo*> PRIArray;
    TArrayNoInit<class APlayerReplicationInfo*> InactivePRIArray;
    INT MatchID;
    //## END PROPS GameReplicationInfo

    virtual UBOOL OnSameTeam(class AActor* A,class AActor* B);
    DECLARE_FUNCTION(execOnSameTeam)
    {
        P_GET_OBJECT(AActor,A);
        P_GET_OBJECT(AActor,B);
        P_FINISH;
        *(UBOOL*)Result=OnSameTeam(A,B);
    }
    UBOOL eventShouldShowGore()
    {
        GameReplicationInfo_eventShouldShowGore_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ShouldShowGore),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AGameReplicationInfo,AReplicationInfo,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct FAutomatedTestingDatum
{
    INT NumberOfMatchesPlayed;
    INT NumMapListCyclesDone;

    /** Constructors */
    FAutomatedTestingDatum() {}
    FAutomatedTestingDatum(EEventParm)
    {
        appMemzero(this, sizeof(FAutomatedTestingDatum));
    }
};

struct PlayerReplicationInfo_eventSetPlayerName_Parms
{
    FString S;
    PlayerReplicationInfo_eventSetPlayerName_Parms(EEventParm)
    {
    }
};
class APlayerReplicationInfo : public AReplicationInfo
{
public:
    //## BEGIN PROPS PlayerReplicationInfo
    FLOAT Score;
    FLOAT Deaths;
    BYTE Ping;
    BYTE TTSSpeaker;
    BYTE PacketLoss;
    class AActor* PlayerLocationHint;
    INT NumLives;
    FStringNoInit PlayerName;
    FStringNoInit PlayerAlias;
    FStringNoInit OldName;
    INT PlayerID;
    class ATeamInfo* Team;
    INT SplitscreenIndex;
    BITFIELD bAdmin:1;
    BITFIELD bIsFemale:1;
    BITFIELD bIsSpectator:1;
    BITFIELD bOnlySpectator:1;
    BITFIELD bWaitingPlayer:1;
    BITFIELD bReadyToPlay:1;
    BITFIELD bOutOfLives:1;
    BITFIELD bBot:1;
    BITFIELD bHasFlag:1;
    BITFIELD bHasBeenWelcomed:1;
    BITFIELD bIsInactive:1;
    BITFIELD bFromPreviousLevel:1;
    BITFIELD bControllerVibrationAllowed:1;
    INT StartTime;
    FStringNoInit StringDead;
    FStringNoInit StringSpectating;
    FStringNoInit StringUnknown;
    INT Kills;
    class UClass* GameMessageClass;
    FLOAT ExactPing;
    FStringNoInit SavedNetworkAddress;
    struct FUniqueNetId UniqueId;
    INT PlayerSkill;
    FName SessionName;
    struct FAutomatedTestingDatum AutomatedTestingData;
    //## END PROPS PlayerReplicationInfo

    UBOOL AreUniqueNetIdsEqual(class APlayerReplicationInfo* OtherPRI);
    virtual FString GetPlayerAlias();
    void UpdatePing(FLOAT TimeStamp);
    virtual BYTE GetTeamNum();
    DECLARE_FUNCTION(execAreUniqueNetIdsEqual)
    {
        P_GET_OBJECT(APlayerReplicationInfo,OtherPRI);
        P_FINISH;
        *(UBOOL*)Result=AreUniqueNetIdsEqual(OtherPRI);
    }
    DECLARE_FUNCTION(execGetPlayerAlias)
    {
        P_FINISH;
        *(FString*)Result=GetPlayerAlias();
    }
    DECLARE_FUNCTION(execUpdatePing)
    {
        P_GET_FLOAT(TimeStamp);
        P_FINISH;
        UpdatePing(TimeStamp);
    }
    void eventSetPlayerName(const FString& S)
    {
        PlayerReplicationInfo_eventSetPlayerName_Parms Parms(EC_EventParm);
        Parms.S=S;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPlayerName),&Parms);
    }
    DECLARE_CLASS(APlayerReplicationInfo,AReplicationInfo,0|CLASS_NativeReplication,Engine)
	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class ATeamInfo : public AReplicationInfo
{
public:
    //## BEGIN PROPS TeamInfo
    FStringNoInit TeamName;
    INT Size;
    FLOAT Score;
    INT TeamIndex;
    FColor TeamColor;
    //## END PROPS TeamInfo

    virtual BYTE GetTeamNum();
    DECLARE_CLASS(ATeamInfo,AReplicationInfo,0|CLASS_NativeReplication,Engine)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class ARoute : public AInfo
{
public:
    //## BEGIN PROPS Route
    BYTE RouteType;
    TArrayNoInit<struct FNavReference> NavList;
    TArrayNoInit<struct FActorReference> RouteList;
    FLOAT FudgeFactor;
    //## END PROPS Route

    INT ResolveRouteIndex(INT Idx,BYTE RouteDirection,BYTE& out_bComplete,BYTE& out_bReverse);
    INT MoveOntoRoutePath(class APawn* P,BYTE RouteDirection=0,FLOAT DistFudgeFactor=1.000000);
    DECLARE_FUNCTION(execResolveRouteIndex)
    {
        P_GET_INT(Idx);
        P_GET_BYTE(RouteDirection);
        P_GET_BYTE_REF(out_bComplete);
        P_GET_BYTE_REF(out_bReverse);
        P_FINISH;
        *(INT*)Result=ResolveRouteIndex(Idx,RouteDirection,out_bComplete,out_bReverse);
    }
    DECLARE_FUNCTION(execMoveOntoRoutePath)
    {
        P_GET_OBJECT(APawn,P);
        P_GET_BYTE_OPTX(RouteDirection,0);
        P_GET_FLOAT_OPTX(DistFudgeFactor,1.000000);
        P_FINISH;
        *(INT*)Result=MoveOntoRoutePath(P,RouteDirection,DistFudgeFactor);
    }
    DECLARE_CLASS(ARoute,AInfo,0,Engine)
	virtual void PostLoad();

	void AutoFillRoute( ERouteFillAction RFA, TArray<ANavigationPoint*>& Points );
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);
	virtual void CheckForErrors();
};

class AZoneInfo : public AInfo
{
public:
    //## BEGIN PROPS ZoneInfo
    FLOAT KillZ;
    FLOAT SoftKill;
    class UClass* KillZDamageType;
    BITFIELD bSoftKillZ:1;
    //## END PROPS ZoneInfo

    DECLARE_CLASS(AZoneInfo,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AZoneInfo)
};

struct FMusicTrackStruct
{
    class USoundCue* TheSoundCue;
    BITFIELD bAutoPlay:1;
    BITFIELD bPersistentAcrossLevels:1;
    FLOAT FadeInTime;
    FLOAT FadeInVolumeLevel;
    FLOAT FadeOutTime;
    FLOAT FadeOutVolumeLevel;

    /** Constructors */
    FMusicTrackStruct() {}
    FMusicTrackStruct(EEventParm)
    {
        appMemzero(this, sizeof(FMusicTrackStruct));
    }
};

class UMusicTrackDataStructures : public UObject
{
public:
    //## BEGIN PROPS MusicTrackDataStructures
    //## END PROPS MusicTrackDataStructures

    DECLARE_CLASS(UMusicTrackDataStructures,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UMusicTrackDataStructures)
};

struct FNetViewer
{
    class APlayerController* InViewer;
    class AActor* Viewer;
    FVector ViewLocation;
    FVector ViewDir;

		FNetViewer(UNetConnection* InConnection, FLOAT DeltaSeconds);
	
};

struct FCompartmentRunList
{
    BITFIELD RigidBody:1;
    BITFIELD Fluid:1;
    BITFIELD Cloth:1;
    BITFIELD SoftBody:1;

    /** Constructors */
    FCompartmentRunList() {}
    FCompartmentRunList(EEventParm)
    {
        appMemzero(this, sizeof(FCompartmentRunList));
    }
};

struct FPhysXSimulationProperties
{
    BITFIELD bUseHardware:1;
    BITFIELD bFixedTimeStep:1;
    FLOAT TimeStep;
    INT MaxSubSteps;

    /** Constructors */
    FPhysXSimulationProperties() {}
    FPhysXSimulationProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXSimulationProperties));
    }
};

struct FPhysXSceneProperties
{
    struct FPhysXSimulationProperties PrimaryScene;
    struct FPhysXSimulationProperties CompartmentRigidBody;
    struct FPhysXSimulationProperties CompartmentFluid;
    struct FPhysXSimulationProperties CompartmentCloth;
    struct FPhysXSimulationProperties CompartmentSoftBody;

    /** Constructors */
    FPhysXSceneProperties() {}
    FPhysXSceneProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXSceneProperties));
    }
};

struct FPhysXEmitterVerticalProperties
{
    BITFIELD bDisableLod:1;
    INT ParticlesLodMin;
    INT ParticlesLodMax;
    INT PacketsPerPhysXParticleSystemMax;
    BITFIELD bApplyCylindricalPacketCulling:1;
    FLOAT SpawnLodVsFifoBias;

    /** Constructors */
    FPhysXEmitterVerticalProperties() {}
    FPhysXEmitterVerticalProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXEmitterVerticalProperties));
    }
};

struct FPhysXVerticalProperties
{
    struct FPhysXEmitterVerticalProperties Emitters;

    /** Constructors */
    FPhysXVerticalProperties() {}
    FPhysXVerticalProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXVerticalProperties));
    }
};

struct FWorldFractureSettings
{
    FLOAT ChanceOfPhysicsChunkOverride;
    BITFIELD bEnableChanceOfPhysicsChunkOverride:1;
    BITFIELD bLimitExplosionChunkSize:1;
    FLOAT MaxExplosionChunkSize;
    BITFIELD bLimitDamageChunkSize:1;
    FLOAT MaxDamageChunkSize;
    INT MaxNumFacturedChunksToSpawnInAFrame;
    FLOAT FractureExplosionVelScale;

    /** Constructors */
    FWorldFractureSettings() {}
    FWorldFractureSettings(EEventParm)
    {
        appMemzero(this, sizeof(FWorldFractureSettings));
    }
};

struct FScreenMessageString
{
    INT Key;
    FString ScreenMessage;
    FColor DisplayColor;
    FLOAT TimeToDisplay;
    FLOAT CurrentTimeDisplayed;

    /** Constructors */
    FScreenMessageString()
    : Key(0)
    , TimeToDisplay(0)
    , CurrentTimeDisplayed(0)
    {}
    FScreenMessageString(EEventParm)
    {
        appMemzero(this, sizeof(FScreenMessageString));
    }
};

struct WorldInfo_eventServerTravel_Parms
{
    FString URL;
    UBOOL bAbsolute;
    UBOOL bShouldSkipGameNotify;
    WorldInfo_eventServerTravel_Parms(EEventParm)
    {
    }
};
class AWorldInfo : public AZoneInfo
{
public:
    //## BEGIN PROPS WorldInfo
    struct FPostProcessSettings DefaultPostProcessSettings;
    FLOAT SquintModeKernelSize;
    class APostProcessVolume* HighestPriorityPostProcessVolume;
    struct FReverbSettings DefaultReverbSettings;
    class AReverbVolume* HighestPriorityReverbVolume;
    TArrayNoInit<class APortalVolume*> PortalVolumes;
    TArrayNoInit<class ULevelStreaming*> StreamingLevels;
    BITFIELD bMapNeedsLightingFullyRebuilt:1;
    BITFIELD bMapHasPathingErrors:1;
    BITFIELD bRequestedBlockOnAsyncLoading:1;
    BITFIELD bBegunPlay:1;
    BITFIELD bPlayersOnly:1;
    BITFIELD bDropDetail:1;
    BITFIELD bAggressiveLOD:1;
    BITFIELD bStartup:1;
    BITFIELD bPathsRebuilt:1;
    BITFIELD bHasPathNodes:1;
    BITFIELD bIsMenuLevel:1;
    BITFIELD bUseConsoleInput:1;
    BITFIELD bNoDefaultInventoryForPlayer:1;
    BITFIELD bNoPathWarnings:1;
    BITFIELD bHighPriorityLoading:1;
    BITFIELD bHighPriorityLoadingLocal:1;
    BITFIELD bSupportDoubleBufferedPhysics:1;
    BITFIELD bEnableChanceOfPhysicsChunkOverride:1;
    BITFIELD bLimitExplosionChunkSize:1;
    BITFIELD bLimitDamageChunkSize:1;
    BITFIELD bAllowModulateBetterShadows:1;
    BITFIELD bAllowLightEnvSphericalHarmonicLights:1;
    BITFIELD bIncreaseFogNearPrecision:1;
    DOUBLE LastTimeUnbuiltLightingWasEncountered;
    class UBookMark* BookMarks[10];
    TArrayNoInit<class UClipPadEntry*> ClipPadEntries;
    FLOAT TimeDilation;
    FLOAT DemoPlayTimeDilation;
    FLOAT TimeSeconds;
    FLOAT RealTimeSeconds;
    FLOAT AudioTimeSeconds;
    FLOAT DeltaSeconds;
    FLOAT PauseDelay;
    FLOAT RealTimeToUnPause;
    class APlayerReplicationInfo* Pauser;
    FStringNoInit VisibleGroups;
    FStringNoInit SelectedGroups;
    class UTexture2D* DefaultTexture;
    class UTexture2D* WireframeTexture;
    class UTexture2D* WhiteSquareTexture;
    class UTexture2D* LargeVertex;
    class UTexture2D* BSPVertex;
    TArrayNoInit<FString> DeferredExecs;
    class AGameReplicationInfo* GRI;
    BYTE NetMode;
    BYTE NextTravelType;
    FStringNoInit ComputerName;
    FStringNoInit EngineVersion;
    FStringNoInit MinNetVersion;
    class AGameInfo* Game;
    FLOAT StallZ;
    FLOAT WorldGravityZ;
    FLOAT DefaultGravityZ;
    FLOAT GlobalGravityZ;
    FLOAT RBPhysicsGravityScaling;
    class ANavigationPoint* NavigationPointList;
    class AController* ControllerList;
    class APawn* PawnList;
    class ACoverLink* CoverList;
    FLOAT MoveRepSize;
    TArrayNoInit<struct FNetViewer> ReplicationViewers;
    FStringNoInit NextURL;
    FLOAT NextSwitchCountdown;
    INT PackedLightAndShadowMapTextureSize;
    FVector DefaultColorScale;
    TArrayNoInit<class UClass*> GameTypesSupportedOnThisMap;
    TArrayNoInit<class UObject*> ClientDestroyedActorContent;
    TArrayNoInit<FName> PreparingLevelNames;
    FName CommittedPersistentLevelName;
    class UAudioComponent* MusicComp;
    struct FMusicTrackStruct CurrentMusicTrack;
    struct FMusicTrackStruct ReplicatedMusicTrack;
    FStringNoInit Title;
    FStringNoInit Author;
protected:
    class UMapInfo* MyMapInfo;
public:
    FStringNoInit EmitterPoolClassPath;
    class AEmitterPool* MyEmitterPool;
    FStringNoInit DecalManagerClassPath;
    class ADecalManager* MyDecalManager;
    FStringNoInit FractureManagerClassPath;
    class AFractureManager* MyFractureManager;
    FLOAT MaxPhysicsDeltaTime;
    INT MaxPhysicsSubsteps;
    struct FPhysXSceneProperties PhysicsProperties;
    TArrayNoInit<struct FCompartmentRunList> CompartmentRunFrames;
    class UPhysicsLODVerticalEmitter* EmitterVertical;
    class UPhysicsLODVerticalDestructible* DestructibleVertical;
    struct FPhysXVerticalProperties VerticalProperties;
    FLOAT ChanceOfPhysicsChunkOverride;
    FLOAT MaxExplosionChunkSize;
    FLOAT MaxDamageChunkSize;
    FLOAT FractureExplosionVelScale;
    INT MaxNumFacturedChunksToSpawnInAFrame;
    INT NumFacturedChunksSpawnedThisFrame;
    FLOAT FracturedMeshWeaponDamage;
    TMap<INT, FScreenMessageString> ScreenMessages;
    TArrayNoInit<struct FScreenMessageString> PriorityScreenMessages;
    //## END PROPS WorldInfo

    void UpdateMusicTrack(struct FMusicTrackStruct NewMusicTrack);
    virtual FLOAT GetGravityZ();
    class USequence* GetGameSequence() const;
    void SetLevelRBGravity(FVector NewGrav);
    virtual FString GetLocalURL() const;
    UBOOL IsDemoBuild() const;
    UBOOL IsConsoleBuild(BYTE ConsoleType=0) const;
    UBOOL IsPlayInEditor() const;
    void ForceGarbageCollection(UBOOL bFullPurge=FALSE);
    void VerifyNavList();
    virtual FString GetAddressURL() const;
    void NotifyMatchStarted(UBOOL bShouldActivateLevelStartupEvents=TRUE,UBOOL bShouldActivateLevelBeginningEvents=TRUE,UBOOL bShouldActivateLevelLoadedEvents=FALSE);
    void PrepareMapChange(const TArray<FName>& LevelNames);
    UBOOL IsPreparingMapChange();
    UBOOL IsMapChangeReady();
    void CancelPendingMapChange();
    void CommitMapChange(UBOOL bShouldSkipLevelStartupEvent=FALSE,UBOOL bShouldSkipLevelBeginningEvent=FALSE);
    void SeamlessTravel(const FString& URL,UBOOL bAbsolute=FALSE,FGuid MapPackageGuid=FGuid(EC_EventParm));
    UBOOL IsInSeamlessTravel();
    void SetSeamlessTravelMidpointPause(UBOOL bNowPaused);
    class UMapInfo* GetMapInfo();
    void SetMapInfo(class UMapInfo* NewMapInfo);
    FString GetMapName(UBOOL bIncludePrefix=FALSE);
    BYTE GetDetailMode();
    UBOOL IsRecordingDemo();
    UBOOL IsPlayingDemo();
    virtual void DoMemoryTracking();
    void AddOnScreenDebugMessage(INT Key,FLOAT TimeToDisplay,FColor DisplayColor,const FString& DebugMessage);
    UBOOL OnScreenDebugMessageExists(INT Key);
    struct FWorldFractureSettings GetWorldFractureSettings() const;
    DECLARE_FUNCTION(execIsMenuLevel);
    DECLARE_FUNCTION(execUpdateMusicTrack)
    {
        P_GET_STRUCT(struct FMusicTrackStruct,NewMusicTrack);
        P_FINISH;
        UpdateMusicTrack(NewMusicTrack);
    }
    DECLARE_FUNCTION(execGetGameSequence)
    {
        P_FINISH;
        *(class USequence**)Result=GetGameSequence();
    }
    DECLARE_FUNCTION(execSetLevelRBGravity)
    {
        P_GET_STRUCT(FVector,NewGrav);
        P_FINISH;
        SetLevelRBGravity(NewGrav);
    }
    DECLARE_FUNCTION(execGetLocalURL)
    {
        P_FINISH;
        *(FString*)Result=GetLocalURL();
    }
    DECLARE_FUNCTION(execIsDemoBuild)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDemoBuild();
    }
    DECLARE_FUNCTION(execIsConsoleBuild)
    {
        P_GET_BYTE_OPTX(ConsoleType,0);
        P_FINISH;
        *(UBOOL*)Result=IsConsoleBuild(ConsoleType);
    }
    DECLARE_FUNCTION(execIsPlayInEditor)
    {
        P_FINISH;
        *(UBOOL*)Result=IsPlayInEditor();
    }
    DECLARE_FUNCTION(execForceGarbageCollection)
    {
        P_GET_UBOOL_OPTX(bFullPurge,FALSE);
        P_FINISH;
        ForceGarbageCollection(bFullPurge);
    }
    DECLARE_FUNCTION(execVerifyNavList)
    {
        P_FINISH;
        VerifyNavList();
    }
    DECLARE_FUNCTION(execGetAddressURL)
    {
        P_FINISH;
        *(FString*)Result=GetAddressURL();
    }
    DECLARE_FUNCTION(execAllNavigationPoints);
    DECLARE_FUNCTION(execRadiusNavigationPoints);
    DECLARE_FUNCTION(execNavigationPointCheck);
    DECLARE_FUNCTION(execAllControllers);
    DECLARE_FUNCTION(execAllPawns);
    DECLARE_FUNCTION(execNotifyMatchStarted)
    {
        P_GET_UBOOL_OPTX(bShouldActivateLevelStartupEvents,TRUE);
        P_GET_UBOOL_OPTX(bShouldActivateLevelBeginningEvents,TRUE);
        P_GET_UBOOL_OPTX(bShouldActivateLevelLoadedEvents,FALSE);
        P_FINISH;
        NotifyMatchStarted(bShouldActivateLevelStartupEvents,bShouldActivateLevelBeginningEvents,bShouldActivateLevelLoadedEvents);
    }
    DECLARE_FUNCTION(execPrepareMapChange)
    {
        P_GET_TARRAY_REF(FName,LevelNames);
        P_FINISH;
        PrepareMapChange(LevelNames);
    }
    DECLARE_FUNCTION(execIsPreparingMapChange)
    {
        P_FINISH;
        *(UBOOL*)Result=IsPreparingMapChange();
    }
    DECLARE_FUNCTION(execIsMapChangeReady)
    {
        P_FINISH;
        *(UBOOL*)Result=IsMapChangeReady();
    }
    DECLARE_FUNCTION(execCancelPendingMapChange)
    {
        P_FINISH;
        CancelPendingMapChange();
    }
    DECLARE_FUNCTION(execCommitMapChange)
    {
        P_GET_UBOOL_OPTX(bShouldSkipLevelStartupEvent,FALSE);
        P_GET_UBOOL_OPTX(bShouldSkipLevelBeginningEvent,FALSE);
        P_FINISH;
        CommitMapChange(bShouldSkipLevelStartupEvent,bShouldSkipLevelBeginningEvent);
    }
    DECLARE_FUNCTION(execSeamlessTravel)
    {
        P_GET_STR(URL);
        P_GET_UBOOL_OPTX(bAbsolute,FALSE);
        P_GET_STRUCT_OPTX(FGuid,MapPackageGuid,FGuid(EC_EventParm));
        P_FINISH;
        SeamlessTravel(URL,bAbsolute,MapPackageGuid);
    }
    DECLARE_FUNCTION(execIsInSeamlessTravel)
    {
        P_FINISH;
        *(UBOOL*)Result=IsInSeamlessTravel();
    }
    DECLARE_FUNCTION(execSetSeamlessTravelMidpointPause)
    {
        P_GET_UBOOL(bNowPaused);
        P_FINISH;
        SetSeamlessTravelMidpointPause(bNowPaused);
    }
    DECLARE_FUNCTION(execGetMapInfo)
    {
        P_FINISH;
        *(class UMapInfo**)Result=GetMapInfo();
    }
    DECLARE_FUNCTION(execSetMapInfo)
    {
        P_GET_OBJECT(UMapInfo,NewMapInfo);
        P_FINISH;
        SetMapInfo(NewMapInfo);
    }
    DECLARE_FUNCTION(execGetMapName)
    {
        P_GET_UBOOL_OPTX(bIncludePrefix,FALSE);
        P_FINISH;
        *(FString*)Result=GetMapName(bIncludePrefix);
    }
    DECLARE_FUNCTION(execGetDetailMode)
    {
        P_FINISH;
        *(BYTE*)Result=GetDetailMode();
    }
    DECLARE_FUNCTION(execIsRecordingDemo)
    {
        P_FINISH;
        *(UBOOL*)Result=IsRecordingDemo();
    }
    DECLARE_FUNCTION(execIsPlayingDemo)
    {
        P_FINISH;
        *(UBOOL*)Result=IsPlayingDemo();
    }
    DECLARE_FUNCTION(execDoMemoryTracking)
    {
        P_FINISH;
        DoMemoryTracking();
    }
    DECLARE_FUNCTION(execAddOnScreenDebugMessage)
    {
        P_GET_INT(Key);
        P_GET_FLOAT(TimeToDisplay);
        P_GET_STRUCT(FColor,DisplayColor);
        P_GET_STR(DebugMessage);
        P_FINISH;
        AddOnScreenDebugMessage(Key,TimeToDisplay,DisplayColor,DebugMessage);
    }
    DECLARE_FUNCTION(execOnScreenDebugMessageExists)
    {
        P_GET_INT(Key);
        P_FINISH;
        *(UBOOL*)Result=OnScreenDebugMessageExists(Key);
    }
    DECLARE_FUNCTION(execGetWorldFractureSettings)
    {
        P_FINISH;
        *(struct FWorldFractureSettings*)Result=GetWorldFractureSettings();
    }
    void eventServerTravel(const FString& URL,UBOOL bAbsolute=FALSE,UBOOL bShouldSkipGameNotify=FALSE)
    {
        WorldInfo_eventServerTravel_Parms Parms(EC_EventParm);
        Parms.URL=URL;
        Parms.bAbsolute=bAbsolute ? FIRST_BITFIELD : FALSE;
        Parms.bShouldSkipGameNotify=bShouldSkipGameNotify ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerTravel),&Parms);
    }
    DECLARE_CLASS(AWorldInfo,AZoneInfo,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	// UObject interface.

	/**
	 * Called when a property on this object has been modified externally
	 *
	 * @param PropertyThatChanged the property that was modified
	 */
	void PostEditChange(UProperty* PropertyThatChanged);

	void PostLoad();

	/**
	 * Called after GWorld has been set. Used to load, but not associate, all
	 * levels in the world in the Editor and at least create linkers in the game.
	 * Should only be called against GWorld::PersistentLevel's WorldInfo.
	 */
	void LoadSecondaryLevels();

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void CheckForErrors();

	// Level functions
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	APhysicsVolume* GetDefaultPhysicsVolume();
	APhysicsVolume* GetPhysicsVolume(const FVector& Loc, AActor *A, UBOOL bUseTouch);
	FLOAT GetRBGravityZ();

	/**
	 * Finds the post process settings to use for a given view location, taking into account the world's default
	 * settings and the post process volumes in the world.
	 * @param	ViewLocation			Current view location.
	 * @param	bUseVolumes				Whether to use the world's post process volumes
	 * @param	OutPostProcessSettings	Upon return, the post process settings for a camera at ViewLocation.
	 * @return	If the settings came from a post process volume, the post process volume is returned.
	 */
	APostProcessVolume* GetPostProcessSettings(const FVector& ViewLocation,UBOOL bUseVolumes,FPostProcessSettings& OutPostProcessSettings);

	/** Checks whether modulate-better shadows are allowed in this world. */
	UBOOL GetModulateBetterShadowsAllowed();

	/** Checks whether spherical harmonic lights are allowed in this world. */
	UBOOL GetSHLightsAllowed();

	/** Checks whether to increase precision close to the camera at the cost of distant precision */
	UBOOL GetIncreaseFogNearPrecision();

	/**
	 * Finds the reverb settings to use for a given view location, taking into account the world's default
	 * settings and the reverb volumes in the world.
	 *
	 * @param	ViewLocation			Current view location.
	 * @param	bUseVolumes				Whether to use the world's reverb volumes.
	 * @param	OutReverbSettings		[out] Upon return, the reverb settings for a camera at ViewLocation.
	 * @return							If the settings came from a reverb volume, the reverb volume is returned.
	 */
	AReverbVolume* GetReverbSettings(const FVector& ViewLocation, UBOOL bUseVolumes, struct FReverbSettings& OutReverbSettings);

	/**
	 * Finds the portal volume actor at a given location
	 */
	APortalVolume* GetPortalVolume( const FVector& Location );

	/**
	 * Remap sound locations through portals
	 */
	FVector RemapLocationThroughPortals( const FVector& SourceLocation, const FVector& ListenerLocation );

	/**
	 * Sets bMapNeedsLightingFullyRebuild to the specified value.  Marks the worldinfo package dirty if the value changed.
	 *
	 * @param	bInMapNeedsLightingFullyRebuild			The new value.
	 */
	void SetMapNeedsLightingFullyRebuilt(UBOOL bInMapNeedsLightingFullyRebuild);

	/**
     * @return Whether or not we can spawn more fractured chunks this frame
	 **/
	UBOOL CanSpawnMoreFracturedChunksThisFrame() const;

	/**
	* Determines whether a map is the default local map.
	*
	* @param	MapName	if specified, checks whether MapName is the default local map; otherwise, checks the currently loaded map.
	*
	* @return	TRUE if the map is the default local (or front-end) map.
	*/
	UBOOL IsMenuLevel( FString MapName=TEXT("") );
};

class AInventory : public AActor
{
public:
    //## BEGIN PROPS Inventory
    class AInventory* Inventory;
    class AInventoryManager* InvManager;
    FStringNoInit ItemName;
    BITFIELD bRenderOverlays:1;
    BITFIELD bReceiveOwnerEvents:1;
    BITFIELD bDropOnDeath:1;
    BITFIELD bDelayedSpawn:1;
    BITFIELD bPredictRespawns:1;
    FLOAT RespawnTime;
    FLOAT MaxDesireability;
    FStringNoInit PickupMessage;
    class USoundCue* PickupSound;
    FStringNoInit PickupForce;
    class UClass* DroppedPickupClass;
    class UPrimitiveComponent* DroppedPickupMesh;
    class UPrimitiveComponent* PickupFactoryMesh;
    class UParticleSystemComponent* DroppedPickupParticles;
    //## END PROPS Inventory

    DECLARE_ABSTRACT_CLASS(AInventory,AActor,0|CLASS_NativeReplication,Engine)
	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct Weapon_eventGetPhysicalFireStartLoc_Parms
{
    FVector AimDir;
    FVector ReturnValue;
    Weapon_eventGetPhysicalFireStartLoc_Parms(EEventParm)
    {
    }
};
struct Weapon_eventGetMuzzleLoc_Parms
{
    FVector ReturnValue;
    Weapon_eventGetMuzzleLoc_Parms(EEventParm)
    {
    }
};
struct Weapon_eventGetTraceRange_Parms
{
    FLOAT ReturnValue;
    Weapon_eventGetTraceRange_Parms(EEventParm)
    {
    }
};
struct Weapon_eventIsFiring_Parms
{
    UBOOL ReturnValue;
    Weapon_eventIsFiring_Parms(EEventParm)
    {
    }
};
class AWeapon : public AInventory
{
public:
    //## BEGIN PROPS Weapon
    BYTE CurrentFireMode;
    TArrayNoInit<FName> FiringStatesArray;
    TArrayNoInit<BYTE> WeaponFireTypes;
    TArrayNoInit<class UClass*> WeaponProjectiles;
    TArrayNoInit<FLOAT> FireInterval;
    TArrayNoInit<FLOAT> Spread;
    TArrayNoInit<FLOAT> InstantHitDamage;
    TArrayNoInit<FLOAT> InstantHitMomentum;
    TArrayNoInit<class UClass*> InstantHitDamageTypes;
    FLOAT EquipTime;
    FLOAT PutDownTime;
    FVector FireOffset;
    BITFIELD bWeaponPutDown:1;
    BITFIELD bCanThrow:1;
    BITFIELD bWasOptionalSet:1;
    BITFIELD bWasDoNotActivate:1;
    BITFIELD bInstantHit:1;
    BITFIELD bMeleeWeapon:1;
    FLOAT WeaponRange;
    class UMeshComponent* Mesh;
    FLOAT DefaultAnimSpeed;
    FLOAT Priority;
    class AAIController* AIController;
    TArrayNoInit<BYTE> ShouldFireOnRelease;
    FLOAT AIRating;
    FLOAT CachedMaxRange;
    //## END PROPS Weapon

    virtual FVector GetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm));
    DECLARE_FUNCTION(execGetPhysicalFireStartLoc)
    {
        P_GET_STRUCT_OPTX(FVector,AimDir,FVector(EC_EventParm));
        P_FINISH;
        *(FVector*)Result=GetPhysicalFireStartLoc(AimDir);
    }
    FVector eventGetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm))
    {
        Weapon_eventGetPhysicalFireStartLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.AimDir=AimDir;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPhysicalFireStartLoc),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetMuzzleLoc()
    {
        Weapon_eventGetMuzzleLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetMuzzleLoc),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventGetTraceRange()
    {
        Weapon_eventGetTraceRange_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetTraceRange),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsFiring()
    {
        Weapon_eventIsFiring_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsFiring),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AWeapon,AInventory,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AWeapon)
};

struct InventoryManager_eventDiscardInventory_Parms
{
    InventoryManager_eventDiscardInventory_Parms(EEventParm)
    {
    }
};
struct InventoryManager_eventFindInventoryType_Parms
{
    class UClass* DesiredClass;
    UBOOL bAllowSubclass;
    class AInventory* ReturnValue;
    InventoryManager_eventFindInventoryType_Parms(EEventParm)
    {
    }
};
class AInventoryManager : public AActor
{
public:
    //## BEGIN PROPS InventoryManager
    class AInventory* InventoryChain;
    class AWeapon* PendingWeapon;
    class AWeapon* LastAttemptedSwitchToWeapon;
    BITFIELD bMustHoldWeapon:1;
    TArrayNoInit<INT> PendingFire;
    //## END PROPS InventoryManager

    DECLARE_FUNCTION(execInventoryActors);
    void eventDiscardInventory()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_DiscardInventory),NULL);
    }
    class AInventory* eventFindInventoryType(class UClass* DesiredClass,UBOOL bAllowSubclass=FALSE)
    {
        InventoryManager_eventFindInventoryType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.DesiredClass=DesiredClass;
        Parms.bAllowSubclass=bAllowSubclass ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_FindInventoryType),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AInventoryManager,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInventoryManager)
};

class AKeypoint : public AActor
{
public:
    //## BEGIN PROPS Keypoint
    //## END PROPS Keypoint

    DECLARE_ABSTRACT_CLASS(AKeypoint,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AKeypoint)
};

class AClipMarker : public AKeypoint
{
public:
    //## BEGIN PROPS ClipMarker
    //## END PROPS ClipMarker

    DECLARE_CLASS(AClipMarker,AKeypoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AClipMarker)
};

class APolyMarker : public AKeypoint
{
public:
    //## BEGIN PROPS PolyMarker
    //## END PROPS PolyMarker

    DECLARE_CLASS(APolyMarker,AKeypoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APolyMarker)
};

class ALight : public AActor
{
public:
    //## BEGIN PROPS Light
    class ULightComponent* LightComponent;
    BITFIELD bEnabled:1;
    //## END PROPS Light

    DECLARE_CLASS(ALight,AActor,0,Engine)
public:
	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();

	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

	/**
	 * For this type of light, set the values which would make it affect Dynamic Primitives.
	 **/
	virtual void SetValuesForLight_DynamicAffecting();

	/**
	 * For this type of light, set the values which would make it affect Static Primitives.
	 **/
	virtual void SetValuesForLight_StaticAffecting();

	/**
	 * For this type of light, set the values which would make it affect Dynamic and Static Primitives.
	 **/
	virtual void SetValuesForLight_DynamicAndStaticAffecting();

	/**
	 * Returns true if the light supports being toggled off and on on-the-fly
	 *
	 * @return For 'toggleable' lights, returns true
	 */
	virtual UBOOL IsToggleable() const
	{
		// By default, lights are not toggleable.  You can override this in derived classes.
		return FALSE;
	}
};

class ADirectionalLight : public ALight
{
public:
    //## BEGIN PROPS DirectionalLight
    //## END PROPS DirectionalLight

    DECLARE_CLASS(ADirectionalLight,ALight,0,Engine)
public:
	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();
};

class ADirectionalLightToggleable : public ADirectionalLight
{
public:
    //## BEGIN PROPS DirectionalLightToggleable
    //## END PROPS DirectionalLightToggleable

    DECLARE_CLASS(ADirectionalLightToggleable,ADirectionalLight,0,Engine)
public:
	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

	/** 
	 * Static affecting Toggleables can't have UseDirectLightmaps=TRUE  So even tho they are not "free" 
	 * lightmapped data, they still are classified as static as it is the best they can be.
	 **/
	virtual void SetValuesForLight_StaticAffecting();

	/**
	 * Returns true if the light supports being toggled off and on on-the-fly
	 *
	 * @return For 'toggleable' lights, returns true
	 **/
	virtual UBOOL IsToggleable() const
	{
		// DirectionalLightToggleable supports being toggled on the fly!
		return TRUE;
	}
};

class APointLight : public ALight
{
public:
    //## BEGIN PROPS PointLight
    //## END PROPS PointLight

    DECLARE_CLASS(APointLight,ALight,0,Engine)
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

	/**
	 * Called after this actor has been pasted into a level.  Attempts to catch cases where designers are pasting in really old
	 * T3D data that was created when component instancing wasn't working correctly.
	 */
	virtual void PostEditImport();
};

class APointLightMovable : public APointLight
{
public:
    //## BEGIN PROPS PointLightMovable
    //## END PROPS PointLightMovable

    DECLARE_CLASS(APointLightMovable,APointLight,0,Engine)
public:
	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();
};

class APointLightToggleable : public APointLight
{
public:
    //## BEGIN PROPS PointLightToggleable
    //## END PROPS PointLightToggleable

    DECLARE_CLASS(APointLightToggleable,APointLight,0,Engine)
public:
	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

	/**
	 * Static affecting Toggleables can't have UseDirectLightmaps=TRUE  So even tho they are not "free"
	 * lightmapped data, they still are classified as static as it is the best they can be.
	 **/
	virtual void SetValuesForLight_StaticAffecting();

	/**
	 * Returns true if the light supports being toggled off and on on-the-fly
	 *
	 * @return For 'toggleable' lights, returns true
	 **/
	virtual UBOOL IsToggleable() const
	{
		// PointLightToggleable supports being toggled on the fly!
		return TRUE;
	}
};

class ASkyLight : public ALight
{
public:
    //## BEGIN PROPS SkyLight
    //## END PROPS SkyLight

    DECLARE_CLASS(ASkyLight,ALight,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASkyLight)
};

class ASkyLightToggleable : public ASkyLight
{
public:
    //## BEGIN PROPS SkyLightToggleable
    //## END PROPS SkyLightToggleable

    DECLARE_CLASS(ASkyLightToggleable,ASkyLight,0,Engine)
public:
	/**
	 * Returns true if the light supports being toggled off and on on-the-fly
	 *
	 * @return For 'toggleable' lights, returns true
	 **/
	virtual UBOOL IsToggleable() const
	{
		// SkyLightToggleable supports being toggled on the fly!
		return TRUE;
	}
};

class ASpotLight : public ALight
{
public:
    //## BEGIN PROPS SpotLight
    //## END PROPS SpotLight

    DECLARE_CLASS(ASpotLight,ALight,0,Engine)
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

	/**
	 * Called after this actor has been pasted into a level.  Attempts to catch cases where designers are pasting in really old
	 * T3D data that was created when component instancing wasn't working correctly.
	 */
	virtual void PostEditImport();
};

class ASpotLightMovable : public ASpotLight
{
public:
    //## BEGIN PROPS SpotLightMovable
    //## END PROPS SpotLightMovable

    DECLARE_CLASS(ASpotLightMovable,ASpotLight,0,Engine)
public:
	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

};

class ASpotLightToggleable : public ASpotLight
{
public:
    //## BEGIN PROPS SpotLightToggleable
    //## END PROPS SpotLightToggleable

    DECLARE_CLASS(ASpotLightToggleable,ASpotLight,0,Engine)
public:
	/**
	 * This will determine which icon should be displayed for this light.
	 **/
	virtual void DetermineAndSetEditorIcon();

	/**
	 * Static affecting Toggleables can't have UseDirectLightmaps=TRUE  So even tho they are not "free"
	 * lightmapped data, they still are classified as static as it is the best they can be.
	 **/
	virtual void SetValuesForLight_StaticAffecting();

	/**
	 * Returns true if the light supports being toggled off and on on-the-fly
	 *
	 * @return For 'toggleable' lights, returns true
	 **/
	virtual UBOOL IsToggleable() const
	{
		// SpotLightToggleable supports being toggled on the fly!
		return TRUE;
	}
};

class AStaticLightCollectionActor : public ALight
{
public:
    //## BEGIN PROPS StaticLightCollectionActor
    TArrayNoInit<class ULightComponent*> LightComponents;
    INT MaxLightComponents;
    //## END PROPS StaticLightCollectionActor

    DECLARE_CLASS(AStaticLightCollectionActor,ALight,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/* === AActor interface === */
	/**
	 * Updates the CachedLocalToWorld transform for all attached components.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate=FALSE );


	/* === UObject interface === */
	/**
	 * Serializes the LocalToWorld transforms for the StaticMeshComponents contained in this actor.
	 */
	virtual void Serialize( FArchive& Ar );
};

class AMaterialInstanceActor : public AActor
{
public:
    //## BEGIN PROPS MaterialInstanceActor
    class UMaterialInstanceConstant* MatInst;
    //## END PROPS MaterialInstanceActor

    DECLARE_CLASS(AMaterialInstanceActor,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AMaterialInstanceActor)
};

struct MatineeActor_eventUpdate_Parms
{
    MatineeActor_eventUpdate_Parms(EEventParm)
    {
    }
};
class AMatineeActor : public AActor
{
public:
    //## BEGIN PROPS MatineeActor
    class USeqAct_Interp* InterpAction;
    BITFIELD bIsPlaying:1;
    BITFIELD bReversePlayback:1;
    BITFIELD bPaused:1;
    FLOAT PlayRate;
    FLOAT Position;
    //## END PROPS MatineeActor

    void eventUpdate()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Update),NULL);
    }
    DECLARE_CLASS(AMatineeActor,AActor,0|CLASS_NativeReplication,Engine)
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void TickSpecial(FLOAT DeltaTime);
	virtual void PreNetReceive();
	virtual void PostNetReceive();
};

class ANote : public AActor
{
public:
    //## BEGIN PROPS Note
    FStringNoInit Text;
    //## END PROPS Note

    DECLARE_CLASS(ANote,AActor,0,Engine)
	void CheckForErrors();
};

struct Pawn_eventSoakPause_Parms
{
    Pawn_eventSoakPause_Parms(EEventParm)
    {
    }
};
struct Pawn_eventMessagePlayer_Parms
{
    FString msg;
    Pawn_eventMessagePlayer_Parms(EEventParm)
    {
    }
};
struct Pawn_eventCreateInventory_Parms
{
    class UClass* NewInvClass;
    UBOOL bDoNotActivate;
    class AInventory* ReturnValue;
    Pawn_eventCreateInventory_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStopDriving_Parms
{
    class AVehicle* V;
    Pawn_eventStopDriving_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStartDriving_Parms
{
    class AVehicle* V;
    Pawn_eventStartDriving_Parms(EEventParm)
    {
    }
};
struct Pawn_eventPlayFootStepSound_Parms
{
    INT FootDown;
    Pawn_eventPlayFootStepSound_Parms(EEventParm)
    {
    }
};
struct Pawn_eventBreathTimer_Parms
{
    Pawn_eventBreathTimer_Parms(EEventParm)
    {
    }
};
struct Pawn_eventHeadVolumeChange_Parms
{
    class APhysicsVolume* newHeadVolume;
    Pawn_eventHeadVolumeChange_Parms(EEventParm)
    {
    }
};
struct Pawn_eventIsSameTeam_Parms
{
    class APawn* Other;
    UBOOL ReturnValue;
    Pawn_eventIsSameTeam_Parms(EEventParm)
    {
    }
};
struct Pawn_eventTakeRadiusDamageOnBones_Parms
{
    class AController* InstigatedBy;
    FLOAT BaseDamage;
    FLOAT DamageRadius;
    class UClass* DamageType;
    FLOAT Momentum;
    FVector HurtOrigin;
    UBOOL bFullDamage;
    class AActor* DamageCauser;
    TArray<FName> Bones;
    UBOOL ReturnValue;
    Pawn_eventTakeRadiusDamageOnBones_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStuckOnPawn_Parms
{
    class APawn* OtherPawn;
    Pawn_eventStuckOnPawn_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStartCrouch_Parms
{
    FLOAT HeightAdjust;
    Pawn_eventStartCrouch_Parms(EEventParm)
    {
    }
};
struct Pawn_eventEndCrouch_Parms
{
    FLOAT HeightAdjust;
    Pawn_eventEndCrouch_Parms(EEventParm)
    {
    }
};
struct Pawn_eventModifyVelocity_Parms
{
    FLOAT DeltaTime;
    FVector OldVelocity;
    Pawn_eventModifyVelocity_Parms(EEventParm)
    {
    }
};
struct Pawn_eventClientMessage_Parms
{
    FString S;
    FName Type;
    Pawn_eventClientMessage_Parms(EEventParm)
    {
    }
};
struct Pawn_eventInFreeCam_Parms
{
    UBOOL ReturnValue;
    Pawn_eventInFreeCam_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetBaseAimRotation_Parms
{
    FRotator ReturnValue;
    Pawn_eventGetBaseAimRotation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetWeaponStartTraceLocation_Parms
{
    class AWeapon* CurrentWeapon;
    FVector ReturnValue;
    Pawn_eventGetWeaponStartTraceLocation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetPawnViewLocation_Parms
{
    FVector ReturnValue;
    Pawn_eventGetPawnViewLocation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetViewRotation_Parms
{
    FRotator ReturnValue;
    Pawn_eventGetViewRotation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventSetWalking_Parms
{
    UBOOL bNewIsWalking;
    Pawn_eventSetWalking_Parms(EEventParm)
    {
    }
};
class APawn : public AActor
{
public:
    //## BEGIN PROPS Pawn
    FLOAT MaxStepHeight;
    FLOAT MaxJumpHeight;
    FLOAT WalkableFloorZ;
    class AController* Controller;
    class APawn* NextPawn;
    FLOAT NetRelevancyTime;
    class APlayerController* LastRealViewer;
    class AActor* LastViewer;
    BITFIELD bUpAndOut:1;
    BITFIELD bIsWalking:1;
    BITFIELD bWantsToCrouch:1;
    BITFIELD bIsCrouched:1;
    BITFIELD bTryToUncrouch:1;
    BITFIELD bCanCrouch:1;
    BITFIELD bCrawler:1;
    BITFIELD bReducedSpeed:1;
    BITFIELD bJumpCapable:1;
    BITFIELD bCanJump:1;
    BITFIELD bCanWalk:1;
    BITFIELD bCanSwim:1;
    BITFIELD bCanFly:1;
    BITFIELD bCanClimbLadders:1;
    BITFIELD bCanStrafe:1;
    BITFIELD bAvoidLedges:1;
    BITFIELD bStopAtLedges:1;
    BITFIELD bSimulateGravity:1;
    BITFIELD bIgnoreForces:1;
    BITFIELD bCanWalkOffLedges:1;
    BITFIELD bCanBeBaseForPawns:1;
    BITFIELD bSimGravityDisabled:1;
    BITFIELD bDirectHitWall:1;
    BITFIELD bPushesRigidBodies:1;
    BITFIELD bForceFloorCheck:1;
    BITFIELD bForceKeepAnchor:1;
    BITFIELD bCanMantle:1;
    BITFIELD bCanClimbUp:1;
    BITFIELD bCanClimbCeilings:1;
    BITFIELD bCanSwatTurn:1;
    BITFIELD bCanLeap:1;
    BITFIELD bCanCoverSlip:1;
    BITFIELD bDisplayPathErrors:1;
    BITFIELD bIsFemale:1;
    BITFIELD bCanPickupInventory:1;
    BITFIELD bAmbientCreature:1;
    BITFIELD bLOSHearing:1;
    BITFIELD bMuffledHearing:1;
    BITFIELD bDontPossess:1;
    BITFIELD bAutoFire:1;
    BITFIELD bRollToDesired:1;
    BITFIELD bStationary:1;
    BITFIELD bCachedRelevant:1;
    BITFIELD bSpecialHUD:1;
    BITFIELD bNoWeaponFiring:1;
    BITFIELD bCanUse:1;
    BITFIELD bModifyReachSpecCost:1;
    BITFIELD bModifyNavPointDest:1;
    BITFIELD bPathfindsAsVehicle:1;
    BITFIELD bRunPhysicsWithNoController:1;
    BITFIELD bForceMaxAccel:1;
    BITFIELD bForceRMVelocity:1;
    BITFIELD bForceRegularVelocity:1;
    BITFIELD bPlayedDeath:1;
    FLOAT UncrouchTime;
    FLOAT CrouchHeight;
    FLOAT CrouchRadius;
    INT FullHeight;
    FLOAT NonPreferredVehiclePathMultiplier;
    BYTE PathSearchType;
    BYTE RemoteViewPitch;
    BYTE FlashCount;
    BYTE FiringMode;
    class UPathConstraint* PathConstraintList;
    class UPathGoalEvaluator* PathGoalList;
    FLOAT DesiredSpeed;
    FLOAT MaxDesiredSpeed;
    FLOAT HearingThreshold;
    FLOAT Alertness;
    FLOAT SightRadius;
    FLOAT PeripheralVision;
    FLOAT AvgPhysicsTime;
    FLOAT Mass;
    FLOAT Buoyancy;
    FLOAT MeleeRange;
    class ANavigationPoint* Anchor;
    class ANavigationPoint* LastAnchor;
    FLOAT FindAnchorFailedTime;
    FLOAT LastValidAnchorTime;
    FLOAT DestinationOffset;
    FLOAT NextPathRadius;
    FVector SerpentineDir;
    FLOAT SerpentineDist;
    FLOAT SerpentineTime;
    FLOAT SpawnTime;
    INT MaxPitchLimit;
    FLOAT GroundSpeed;
    FLOAT WaterSpeed;
    FLOAT AirSpeed;
    FLOAT LadderSpeed;
    FLOAT AccelRate;
    FLOAT JumpZ;
    FLOAT OutofWaterZ;
    FLOAT MaxOutOfWaterStepHeight;
    FLOAT AirControl;
    FLOAT WalkingPct;
    FLOAT CrouchedPct;
    FLOAT MaxFallSpeed;
    FLOAT AIMaxFallSpeedFactor;
    FLOAT BaseEyeHeight;
    FLOAT EyeHeight;
    FVector Floor;
    FLOAT SplashTime;
    FLOAT OldZ;
    class APhysicsVolume* HeadVolume;
    INT Health;
    INT HealthMax;
    FLOAT BreathTime;
    FLOAT UnderWaterTime;
    FLOAT LastPainTime;
    FVector RMVelocity;
    FVector noise1spot;
    FLOAT noise1time;
    class APawn* noise1other;
    FLOAT noise1loudness;
    FVector noise2spot;
    FLOAT noise2time;
    class APawn* noise2other;
    FLOAT noise2loudness;
    FLOAT SoundDampening;
    FLOAT DamageScaling;
    FStringNoInit MenuName;
    class UClass* ControllerClass;
    class APlayerReplicationInfo* PlayerReplicationInfo;
    class ALadderVolume* OnLadder;
    FName LandMovementState;
    FName WaterMovementState;
    class APlayerStart* LastStartSpot;
    FLOAT LastStartTime;
    FVector TakeHitLocation;
    class UClass* HitDamageType;
    FVector TearOffMomentum;
    class USkeletalMeshComponent* Mesh;
    class UCylinderComponent* CylinderComponent;
    FLOAT RBPushRadius;
    FLOAT RBPushStrength;
    class AVehicle* DrivenVehicle;
    FLOAT AlwaysRelevantDistanceSquared;
    FLOAT VehicleCheckRadius;
    class AController* LastHitBy;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    INT AllowedYawError;
    class UClass* InventoryManagerClass;
    class AInventoryManager* InvManager;
    class AWeapon* Weapon;
    FVector FlashLocation;
    FVector LastFiringFlashLocation;
    INT ShotCount;
    class UPrimitiveComponent* PreRagdollCollisionComponent;
    FPointer PhysicsPushBody;
    INT FailedLandingCount;
    //## END PROPS Pawn

    void SetBasedPosition(struct FBasedPosition& BP,FVector pos,class AActor* ForcedBase=NULL);
    FVector GetBasedPosition(struct FBasedPosition BP);
    virtual UBOOL IsAliveAndWell() const;
    virtual FVector AdjustDestination(class AActor* GoalActor,FVector Dest=FVector(EC_EventParm));
    UBOOL ValidAnchor();
    virtual UBOOL SuggestJumpVelocity(FVector& JumpVelocity,FVector Destination,FVector Start);
    virtual UBOOL IsValidTargetFor(const class AController* C) const;
    virtual UBOOL IsValidEnemyTargetFor(const class APlayerReplicationInfo* PRI,UBOOL bNoPRIisEnemy) const;
    virtual UBOOL IsInvisible();
    void SetRemoteViewPitch(INT NewRemoteViewPitch);
    virtual void SetAnchor(class ANavigationPoint* NewAnchor);
    virtual class ANavigationPoint* GetBestAnchor(class AActor* TestActor,FVector TestLocation,UBOOL bStartPoint,UBOOL bOnlyCheckVisible,FLOAT& out_Dist);
    virtual UBOOL ReachedDestination(class AActor* Goal);
    virtual UBOOL ReachedPoint(FVector Point,class AActor* NewAnchor);
    virtual void ForceCrouch();
    virtual void SetPushesRigidBodies(UBOOL NewPush);
    virtual UBOOL ReachedDesiredRotation();
    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    virtual UBOOL InitRagdoll();
    virtual UBOOL TermRagdoll();
    UBOOL IsHumanControlled();
    UBOOL IsLocallyControlled();
    virtual UBOOL IsPlayerPawn() const;
    virtual FRotator GetViewRotation();
    virtual FVector GetPawnViewLocation();
    virtual BYTE GetTeamNum();
    virtual class AVehicle* GetVehicleBase();
    virtual void ClearConstraints();
    virtual void AddPathConstraint(class UPathConstraint* Constraint);
    virtual void AddGoalEvaluator(class UPathGoalEvaluator* Evaluator);
    virtual void IncrementPathStep(INT Cnt,class UCanvas* C);
    virtual void IncrementPathChild(INT Cnt,class UCanvas* C);
    virtual void DrawPathStep(class UCanvas* C);
    virtual void ClearPathStep();
    DECLARE_FUNCTION(execSetBasedPosition)
    {
        P_GET_STRUCT_REF(struct FBasedPosition,BP);
        P_GET_STRUCT(FVector,pos);
        P_GET_OBJECT_OPTX(AActor,ForcedBase,NULL);
        P_FINISH;
        SetBasedPosition(BP,pos,ForcedBase);
    }
    DECLARE_FUNCTION(execGetBasedPosition)
    {
        P_GET_STRUCT(struct FBasedPosition,BP);
        P_FINISH;
        *(FVector*)Result=GetBasedPosition(BP);
    }
    DECLARE_FUNCTION(execIsAliveAndWell)
    {
        P_FINISH;
        *(UBOOL*)Result=IsAliveAndWell();
    }
    DECLARE_FUNCTION(execAdjustDestination)
    {
        P_GET_OBJECT(AActor,GoalActor);
        P_GET_STRUCT_OPTX(FVector,Dest,FVector(EC_EventParm));
        P_FINISH;
        *(FVector*)Result=AdjustDestination(GoalActor,Dest);
    }
    DECLARE_FUNCTION(execValidAnchor)
    {
        P_FINISH;
        *(UBOOL*)Result=ValidAnchor();
    }
    DECLARE_FUNCTION(execSuggestJumpVelocity)
    {
        P_GET_STRUCT_REF(FVector,JumpVelocity);
        P_GET_STRUCT(FVector,Destination);
        P_GET_STRUCT(FVector,Start);
        P_FINISH;
        *(UBOOL*)Result=SuggestJumpVelocity(JumpVelocity,Destination,Start);
    }
    DECLARE_FUNCTION(execIsValidTargetFor)
    {
        P_GET_OBJECT(AController,C);
        P_FINISH;
        *(UBOOL*)Result=IsValidTargetFor(C);
    }
    DECLARE_FUNCTION(execIsValidEnemyTargetFor)
    {
        P_GET_OBJECT(APlayerReplicationInfo,PRI);
        P_GET_UBOOL(bNoPRIisEnemy);
        P_FINISH;
        *(UBOOL*)Result=IsValidEnemyTargetFor(PRI,bNoPRIisEnemy);
    }
    DECLARE_FUNCTION(execIsInvisible)
    {
        P_FINISH;
        *(UBOOL*)Result=IsInvisible();
    }
    DECLARE_FUNCTION(execSetRemoteViewPitch)
    {
        P_GET_INT(NewRemoteViewPitch);
        P_FINISH;
        SetRemoteViewPitch(NewRemoteViewPitch);
    }
    DECLARE_FUNCTION(execSetAnchor)
    {
        P_GET_OBJECT(ANavigationPoint,NewAnchor);
        P_FINISH;
        SetAnchor(NewAnchor);
    }
    DECLARE_FUNCTION(execGetBestAnchor)
    {
        P_GET_OBJECT(AActor,TestActor);
        P_GET_STRUCT(FVector,TestLocation);
        P_GET_UBOOL(bStartPoint);
        P_GET_UBOOL(bOnlyCheckVisible);
        P_GET_FLOAT_REF(out_Dist);
        P_FINISH;
        *(class ANavigationPoint**)Result=GetBestAnchor(TestActor,TestLocation,bStartPoint,bOnlyCheckVisible,out_Dist);
    }
    DECLARE_FUNCTION(execReachedDestination)
    {
        P_GET_OBJECT(AActor,Goal);
        P_FINISH;
        *(UBOOL*)Result=ReachedDestination(Goal);
    }
    DECLARE_FUNCTION(execReachedPoint)
    {
        P_GET_STRUCT(FVector,Point);
        P_GET_OBJECT(AActor,NewAnchor);
        P_FINISH;
        *(UBOOL*)Result=ReachedPoint(Point,NewAnchor);
    }
    DECLARE_FUNCTION(execForceCrouch)
    {
        P_FINISH;
        ForceCrouch();
    }
    DECLARE_FUNCTION(execSetPushesRigidBodies)
    {
        P_GET_UBOOL(NewPush);
        P_FINISH;
        SetPushesRigidBodies(NewPush);
    }
    DECLARE_FUNCTION(execReachedDesiredRotation)
    {
        P_FINISH;
        *(UBOOL*)Result=ReachedDesiredRotation();
    }
    DECLARE_FUNCTION(execInitRagdoll)
    {
        P_FINISH;
        *(UBOOL*)Result=InitRagdoll();
    }
    DECLARE_FUNCTION(execTermRagdoll)
    {
        P_FINISH;
        *(UBOOL*)Result=TermRagdoll();
    }
    DECLARE_FUNCTION(execIsHumanControlled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsHumanControlled();
    }
    DECLARE_FUNCTION(execIsLocallyControlled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsLocallyControlled();
    }
    DECLARE_FUNCTION(execIsPlayerPawn)
    {
        P_FINISH;
        *(UBOOL*)Result=IsPlayerPawn();
    }
    DECLARE_FUNCTION(execGetViewRotation)
    {
        P_FINISH;
        *(FRotator*)Result=GetViewRotation();
    }
    DECLARE_FUNCTION(execGetPawnViewLocation)
    {
        P_FINISH;
        *(FVector*)Result=GetPawnViewLocation();
    }
    DECLARE_FUNCTION(execGetVehicleBase)
    {
        P_FINISH;
        *(class AVehicle**)Result=GetVehicleBase();
    }
    DECLARE_FUNCTION(execClearConstraints)
    {
        P_FINISH;
        ClearConstraints();
    }
    DECLARE_FUNCTION(execAddPathConstraint)
    {
        P_GET_OBJECT(UPathConstraint,Constraint);
        P_FINISH;
        AddPathConstraint(Constraint);
    }
    DECLARE_FUNCTION(execAddGoalEvaluator)
    {
        P_GET_OBJECT(UPathGoalEvaluator,Evaluator);
        P_FINISH;
        AddGoalEvaluator(Evaluator);
    }
    DECLARE_FUNCTION(execIncrementPathStep)
    {
        P_GET_INT(Cnt);
        P_GET_OBJECT(UCanvas,C);
        P_FINISH;
        IncrementPathStep(Cnt,C);
    }
    DECLARE_FUNCTION(execIncrementPathChild)
    {
        P_GET_INT(Cnt);
        P_GET_OBJECT(UCanvas,C);
        P_FINISH;
        IncrementPathChild(Cnt,C);
    }
    DECLARE_FUNCTION(execDrawPathStep)
    {
        P_GET_OBJECT(UCanvas,C);
        P_FINISH;
        DrawPathStep(C);
    }
    DECLARE_FUNCTION(execClearPathStep)
    {
        P_FINISH;
        ClearPathStep();
    }
    void eventSoakPause()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SoakPause),NULL);
    }
    void eventMessagePlayer(const FString& msg)
    {
        Pawn_eventMessagePlayer_Parms Parms(EC_EventParm);
        Parms.msg=msg;
        ProcessEvent(FindFunctionChecked(ENGINE_MessagePlayer),&Parms);
    }
    class AInventory* eventCreateInventory(class UClass* NewInvClass,UBOOL bDoNotActivate=FALSE)
    {
        Pawn_eventCreateInventory_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.NewInvClass=NewInvClass;
        Parms.bDoNotActivate=bDoNotActivate ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateInventory),&Parms);
        return Parms.ReturnValue;
    }
    void eventStopDriving(class AVehicle* V)
    {
        Pawn_eventStopDriving_Parms Parms(EC_EventParm);
        Parms.V=V;
        ProcessEvent(FindFunctionChecked(ENGINE_StopDriving),&Parms);
    }
    void eventStartDriving(class AVehicle* V)
    {
        Pawn_eventStartDriving_Parms Parms(EC_EventParm);
        Parms.V=V;
        ProcessEvent(FindFunctionChecked(ENGINE_StartDriving),&Parms);
    }
    void eventPlayFootStepSound(INT FootDown)
    {
        Pawn_eventPlayFootStepSound_Parms Parms(EC_EventParm);
        Parms.FootDown=FootDown;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayFootStepSound),&Parms);
    }
    void eventBreathTimer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_BreathTimer),NULL);
    }
    void eventHeadVolumeChange(class APhysicsVolume* newHeadVolume)
    {
        Pawn_eventHeadVolumeChange_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_HeadVolumeChange)) {
        Parms.newHeadVolume=newHeadVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_HeadVolumeChange),&Parms);
        }
    }
    UBOOL eventIsSameTeam(class APawn* Other)
    {
        Pawn_eventIsSameTeam_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_IsSameTeam),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventTakeRadiusDamageOnBones(class AController* InstigatedBy,FLOAT BaseDamage,FLOAT DamageRadius,class UClass* DamageType,FLOAT Momentum,FVector HurtOrigin,UBOOL bFullDamage,class AActor* DamageCauser,const TArray<FName>& Bones)
    {
        Pawn_eventTakeRadiusDamageOnBones_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InstigatedBy=InstigatedBy;
        Parms.BaseDamage=BaseDamage;
        Parms.DamageRadius=DamageRadius;
        Parms.DamageType=DamageType;
        Parms.Momentum=Momentum;
        Parms.HurtOrigin=HurtOrigin;
        Parms.bFullDamage=bFullDamage ? FIRST_BITFIELD : FALSE;
        Parms.DamageCauser=DamageCauser;
        Parms.Bones=Bones;
        ProcessEvent(FindFunctionChecked(ENGINE_TakeRadiusDamageOnBones),&Parms);
        return Parms.ReturnValue;
    }
    void eventStuckOnPawn(class APawn* OtherPawn)
    {
        Pawn_eventStuckOnPawn_Parms Parms(EC_EventParm);
        Parms.OtherPawn=OtherPawn;
        ProcessEvent(FindFunctionChecked(ENGINE_StuckOnPawn),&Parms);
    }
    void eventStartCrouch(FLOAT HeightAdjust)
    {
        Pawn_eventStartCrouch_Parms Parms(EC_EventParm);
        Parms.HeightAdjust=HeightAdjust;
        ProcessEvent(FindFunctionChecked(ENGINE_StartCrouch),&Parms);
    }
    void eventEndCrouch(FLOAT HeightAdjust)
    {
        Pawn_eventEndCrouch_Parms Parms(EC_EventParm);
        Parms.HeightAdjust=HeightAdjust;
        ProcessEvent(FindFunctionChecked(ENGINE_EndCrouch),&Parms);
    }
    void eventModifyVelocity(FLOAT DeltaTime,FVector OldVelocity)
    {
        Pawn_eventModifyVelocity_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_ModifyVelocity)) {
        Parms.DeltaTime=DeltaTime;
        Parms.OldVelocity=OldVelocity;
        ProcessEvent(FindFunctionChecked(ENGINE_ModifyVelocity),&Parms);
        }
    }
    void eventClientMessage(const FString& S,FName Type=NAME_None)
    {
        Pawn_eventClientMessage_Parms Parms(EC_EventParm);
        Parms.S=S;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMessage),&Parms);
    }
    UBOOL eventInFreeCam()
    {
        Pawn_eventInFreeCam_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InFreeCam),&Parms);
        return Parms.ReturnValue;
    }
    FRotator eventGetBaseAimRotation()
    {
        Pawn_eventGetBaseAimRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetBaseAimRotation),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetWeaponStartTraceLocation(class AWeapon* CurrentWeapon=NULL)
    {
        Pawn_eventGetWeaponStartTraceLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.CurrentWeapon=CurrentWeapon;
        ProcessEvent(FindFunctionChecked(ENGINE_GetWeaponStartTraceLocation),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetPawnViewLocation()
    {
        Pawn_eventGetPawnViewLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetPawnViewLocation),&Parms);
        return Parms.ReturnValue;
    }
    FRotator eventGetViewRotation()
    {
        Pawn_eventGetViewRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetViewRotation),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetWalking(UBOOL bNewIsWalking)
    {
        Pawn_eventSetWalking_Parms Parms(EC_EventParm);
        Parms.bNewIsWalking=bNewIsWalking ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetWalking),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(APawn,AActor,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	// declare type for node evaluation functions
	typedef FLOAT ( *NodeEvaluator ) (ANavigationPoint*, APawn*, FLOAT);

	virtual void PostBeginPlay();
	virtual void PostScriptDestroyed();

	// AActor interface.
	virtual void EditorApplyRotation(const FRotator& DeltaRotation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	APawn* GetPlayerPawn() const;
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	virtual UBOOL DelayScriptReplication(FLOAT LastFullUpdateTime);
	virtual INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void NotifyBump(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitNormal);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickSpecial( FLOAT DeltaSeconds );
	UBOOL PlayerControlled();
	void SetBase(AActor *NewBase, FVector NewFloor = FVector(0,0,1), int bNotifyActor=1, USkeletalMeshComponent* SkelComp=NULL, FName BoneName=NAME_None );
	virtual void CheckForErrors();
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	UBOOL CacheNetRelevancy(UBOOL bIsRelevant, APlayerController* RealViewer, AActor* Viewer);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual void PreNetReceive();
	virtual void PostNetReceiveLocation();
	virtual APawn* GetAPawn() { return this; }
	virtual const APawn* GetAPawn() const { return this; }

	/**
	 * Sets the hard attach flag by first handling the case of already being
	 * based upon another actor
	 *
	 * @param bNewHardAttach the new hard attach setting
	 */
	virtual void SetHardAttach(UBOOL bNewHardAttach);

	// Level functions
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );

	// AI sensing
	virtual void CheckNoiseHearing(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType=NAME_None );
	virtual FLOAT DampenNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType=NAME_None );


	// Latent movement
	virtual void setMoveTimer(FVector MoveDir);
	FLOAT GetMaxSpeed();
	virtual UBOOL moveToward(const FVector &Dest, AActor *GoalActor);
	virtual UBOOL IsGlider();
	virtual void rotateToward(FVector FocalPoint);
	UBOOL PickWallAdjust(FVector WallHitNormal, AActor* HitActor);
	void StartNewSerpentine(const FVector& Dir, const FVector& Start);
	void ClearSerpentine();
	virtual UBOOL SharingVehicleWith(APawn *P);
	void InitSerpentine();
	virtual void HandleSerpentineMovement(FVector& out_Direction, FLOAT Distance, const FVector& Dest);

	// reach tests
	virtual UBOOL ReachedDestination(const FVector &Start, const FVector &Dest, AActor* GoalActor);
	virtual int pointReachable(FVector aPoint, int bKnowVisible=0);
	virtual int actorReachable(AActor *Other, UBOOL bKnowVisible=0, UBOOL bNoAnchorCheck=0);
	virtual int Reachable(FVector aPoint, AActor* GoalActor);
	int walkReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	int flyReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	int swimReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	int ladderReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	INT spiderReachable( const FVector &Dest, const FVector &Start, INT reachFlags, AActor* GoalActor );
	FVector GetGravityDirection();
	virtual UBOOL TryJumpUp(FVector Dir, FVector Destination, DWORD TraceFlags, UBOOL bNoVisibility);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL ReachThresholdTest(const FVector &TestPosition, const FVector &Dest, AActor* GoalActor, FLOAT UpThresholdAdjust, FLOAT DownThresholdAdjust, FLOAT ThresholdAdjust);
	virtual UBOOL SetHighJumpFlag() { return false; }

	// movement component tests (used by reach tests)
	void TestMove(const FVector &Delta, FVector &CurrentPosition, FCheckResult& Hit, const FVector &CollisionExtent);
	FVector GetDefaultCollisionSize();
	FVector GetCrouchSize();
	ETestMoveResult walkMove(FVector Delta, FVector &CurrentPosition, const FVector &CollisionExtent, FCheckResult& Hit, AActor* GoalActor, FLOAT threshold);
	ETestMoveResult flyMove(FVector Delta, FVector &CurrentPosition, AActor* GoalActor, FLOAT threshold);
	ETestMoveResult swimMove(FVector Delta, FVector &CurrentPosition, AActor* GoalActor, FLOAT threshold);
	virtual ETestMoveResult FindBestJump(FVector Dest, FVector &CurrentPosition);
	virtual ETestMoveResult FindJumpUp(FVector Direction, FVector &CurrentPosition);
	ETestMoveResult HitGoal(AActor *GoalActor);
	virtual UBOOL HurtByDamageType(class UClass* DamageType);
	UBOOL CanCrouchWalk( const FVector& StartLocation, const FVector& EndLocation, AActor* HitActor );
	/** updates the highest landing Z axis velocity encountered during a reach test */
	virtual void SetMaxLandingVelocity(FLOAT NewLandingVelocity) {}

	// Path finding
	UBOOL GeneratePath();
	FLOAT findPathToward(AActor *goal, FVector GoalLocation, NodeEvaluator NodeEval, FLOAT BestWeight, UBOOL bWeightDetours, INT MaxPathLength = 0, UBOOL bReturnPartial = FALSE, INT SoftMaxNodes = 200);
	ANavigationPoint* BestPathTo(NodeEvaluator NodeEval, ANavigationPoint *start, FLOAT *Weight, UBOOL bWeightDetours, INT MaxPathLength = 0, INT SoftMaxNodes = 200);
	virtual ANavigationPoint* CheckDetour(ANavigationPoint* BestDest, ANavigationPoint* Start, UBOOL bWeightDetours);
	virtual INT calcMoveFlags();
	/** returns the maximum falling speed an AI will accept along a path */
	FORCEINLINE FLOAT GetAIMaxFallSpeed() { return MaxFallSpeed * AIMaxFallSpeedFactor; }
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	virtual FLOAT SecondRouteAttempt(ANavigationPoint* Anchor, ANavigationPoint* EndAnchor, NodeEvaluator NodeEval, FLOAT BestWeight, AActor *goal, const FVector& GoalLocation, FLOAT StartDist, FLOAT EndDist, INT MaxPathLength, INT SoftMaxNodes);
	/** finds the closest NavigationPoint within MAXPATHDIST that is usable by this pawn and directly reachable to/from TestLocation
	 * @param TestActor the Actor to find an anchor for
	 * @param TestLocation the location to find an anchor for
	 * @param bStartPoint true if we're finding the start point for a path search, false if we're finding the end point
	 * @param bOnlyCheckVisible if true, only check visibility - skip reachability test
	 * @param Dist (out) if an anchor is found, set to the distance TestLocation is from it. Set to 0.f if the anchor overlaps TestLocation
	 * @return a suitable anchor on the navigation network for reaching TestLocation, or NULL if no such point exists
	 */
	ANavigationPoint* FindAnchor(AActor* TestActor, const FVector& TestLocation, UBOOL bStartPoint, UBOOL bOnlyCheckVisible, FLOAT& Dist);
	virtual INT		ModifyCostForReachSpec( UReachSpec* Spec, INT Cost ) { return 0; }
	virtual void	InitForPathfinding( AActor* Goal, ANavigationPoint* EndAnchor ) {}
	// allows pawn subclasses to veto anchor validity
	virtual UBOOL	IsValidAnchor( ANavigationPoint* AnchorCandidate ){ return TRUE; }

	/*
	 * Route finding notifications (sent to target)
	 */
	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);
	virtual UBOOL AnchorNeedNotBeReachable();
	virtual void NotifyAnchorFindingResult(ANavigationPoint* EndAnchor, APawn* RouteFinder);

	// Pawn physics modes
	virtual void performPhysics(FLOAT DeltaSeconds);
	/** Called in PerformPhysics(), after StartNewPhysics() is done moving the Actor, and before the PendingTouch() event is dispatched. */
	virtual void PostProcessPhysics( FLOAT DeltaSeconds, const FVector& OldVelocity );
	virtual FVector CheckForLedges(FVector AccelDir, FVector Delta, FVector GravDir, int &bCheckedFall, int &bMustJump );
	virtual void physWalking(FLOAT deltaTime, INT Iterations);
	virtual void physFlying(FLOAT deltaTime, INT Iterations);
	void physSwimming(FLOAT deltaTime, INT Iterations);
	void physFalling(FLOAT deltaTime, INT Iterations);
	void physSpider(FLOAT deltaTime, INT Iterations);
	void physLadder(FLOAT deltaTime, INT Iterations);
	virtual void startNewPhysics(FLOAT deltaTime, INT Iterations);
	virtual void GetNetBuoyancy(FLOAT &NetBuoyancy, FLOAT &NetFluidFriction);
	void startSwimming(FVector OldLocation, FVector OldVelocity, FLOAT timeTick, FLOAT remainingTime, INT Iterations);
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);
	void processLanded(FVector const& HitNormal, AActor *HitActor, FLOAT remainingTime, INT Iterations);
	virtual void SetPostLandedPhysics(AActor *HitActor, FVector HitNormal);
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual void Crouch(INT bClientSimulation=0);
	virtual void UnCrouch(INT bClientSimulation=0);
	FRotator FindSlopeRotation(FVector FloorNormal, FRotator NewRotation);
	void SmoothHitWall(FVector const& HitNormal, AActor *HitActor);
	FVector NewFallVelocity(FVector OldVelocity, FVector OldAcceleration, FLOAT timeTick);
	void stepUp(const FVector& GravDir, const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	virtual FLOAT MaxSpeedModifier();
	virtual FVector CalculateSlopeSlide(const FVector& Adjusted, const FCheckResult& Hit);
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
	virtual void PushedBy(AActor* Other);
	virtual void UpdateBasedRotation(FRotator &FinalRotation, const FRotator& ReducedRotation);
	virtual void ReverseBasedRotation();

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	/** Update information used to detect overlaps between this actor and physics objects, used for 'pushing' things */
	virtual void UpdatePushBody();

	/** Called when the push body 'sensor' overlaps a physics body. Allows you to add a force to that body to move it. */
	virtual void ProcessPushNotify(const FRigidBodyCollisionInfo& PushedInfo, const TArray<FRigidBodyContactInfo>& ContactInfos);

	virtual UBOOL HasAudibleAmbientSound(const FVector& SrcLocation) { return false; }

	//superville: Chance for pawn to say he has reached a location w/o touching it (ie cover slot)
	virtual UBOOL HasReached( ANavigationPoint *Nav, UBOOL& bFinalDecision ) { return FALSE; }

	virtual FVector GetIdealCameraOrigin()
	{
		return FVector(Location.X,Location.Y,Location.Z + BaseEyeHeight);
	}

protected:
	virtual void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);

private:
	UBOOL Pick3DWallAdjust(FVector WallHitNormal, AActor* HitActor);
	FLOAT Swim(FVector Delta, FCheckResult &Hit);
	FVector findWaterLine(FVector Start, FVector End);
	void SpiderstepUp(const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	int findNewFloor(FVector OldLocation, FLOAT deltaTime, FLOAT remainingTime, INT Iterations);
	int checkFloor(FVector Dir, FCheckResult &Hit);
};

struct FPathSizeInfo
{
    FName Desc;
    FLOAT Radius;
    FLOAT Height;
    FLOAT CrouchHeight;
    BYTE PathColor;

    /** Constructors */
    FPathSizeInfo() {}
    FPathSizeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPathSizeInfo));
    }
};

class AScout : public APawn
{
public:
    //## BEGIN PROPS Scout
    TArrayNoInit<struct FPathSizeInfo> PathSizes;
    FLOAT TestJumpZ;
    FLOAT TestGroundSpeed;
    FLOAT TestMaxFallSpeed;
    FLOAT TestFallSpeed;
    FLOAT MaxLandingVelocity;
    INT MinNumPlayerStarts;
    class UClass* DefaultReachSpecClass;
    //## END PROPS Scout

    DECLARE_CLASS(AScout,APawn,0|CLASS_Transient|CLASS_Config,Engine)
	NO_DEFAULT_CONSTRUCTOR(AScout)

	virtual void InitForPathing( ANavigationPoint* Start, ANavigationPoint* End )
	{
		Physics = PHYS_Walking;
		JumpZ = TestJumpZ;
		bCanWalk = 1;
		bJumpCapable = 1;
		bCanJump = 1;
		bCanSwim = 1;
		bCanClimbLadders = 1;
		bCanFly = 0;
		GroundSpeed = TestGroundSpeed;
		MaxFallSpeed = TestMaxFallSpeed;
	}

	virtual FVector GetSize(FName desc)
	{
		for (INT idx = 0; idx < PathSizes.Num(); idx++)
		{
			if (PathSizes(idx).Desc == desc)
			{
				return FVector(PathSizes(idx).Radius,PathSizes(idx).Height,0.f);
			}
		}
		return FVector(PathSizes(0).Radius,PathSizes(0).Height,0.f);
	}

	virtual FVector GetDefaultForcedPathSize(UReachSpec* Spec)
	{
		return GetSize(FName(TEXT("Common"),FNAME_Find));
	}

	/** returns the largest size in the PathSizes list */
	FVector GetMaxSize();

	virtual void SetPathColor(UReachSpec* ReachSpec)
	{
		FVector CommonSize = GetSize(FName(TEXT("Common"),FNAME_Find));
		if ( ReachSpec->CollisionRadius >= CommonSize.X )
		{
			FVector MaxSize = GetSize(FName(TEXT("Max"),FNAME_Find));
			if ( ReachSpec->CollisionRadius >= MaxSize.X )
			{
				ReachSpec->PathColorIndex = 2;
			}
			else
			{
				ReachSpec->PathColorIndex = 1;
			}
		}
		else
		{
			ReachSpec->PathColorIndex = 0;
		}
	}

	virtual void AddSpecialPaths(INT NumPaths, UBOOL bOnlyChanged) {};
	virtual void PostBeginPlay();
	virtual void SetPrototype();
	/** updates the highest landing Z axis velocity encountered during a reach test */
	virtual void SetMaxLandingVelocity(FLOAT NewLandingVelocity)
	{
		if (-NewLandingVelocity > MaxLandingVelocity)
		{
			MaxLandingVelocity = -NewLandingVelocity;
		}
	}

	virtual UClass* GetDefaultReachSpecClass() { return DefaultReachSpecClass; }

	/**
	* Toggles collision on all actors for path building.
	*/
	virtual void SetPathCollision(UBOOL bEnabled);

	/**
	* Moves all interp actors to the path building position.
	*/
	virtual void UpdateInterpActors(UBOOL &bProblemsMoving, TArray<USeqAct_Interp*> &InterpActs);

	/**
	* Moves all updated interp actors back to their original position.
	*/
	virtual void RestoreInterpActors(TArray<USeqAct_Interp*> &InterpActs);

	/**
	* Clears all the paths and rebuilds them.
	*
	* @param	bReviewPaths	If TRUE, review paths if any were created.
	* @param	bShowMapCheck	If TRUE, conditionally show the Map Check dialog.
	*/
	virtual void DefinePaths(UBOOL bReviewPaths, UBOOL bShowMapCheck);

	/**
	* Clears all pathing information in the level.
	*/
	virtual void UndefinePaths();

	virtual void AddLongReachSpecs( INT NumPaths );

	virtual void PrunePaths(INT NumPaths);

	// interface to allow easy overides of path prune behavior (without copy+pasting ;) )
	virtual INT PrunePathsForNav(ANavigationPoint* Nav);
	// called after PrunePathsForNav is called on all pathnodes 
	virtual INT SecondPassPrunePathsForNav(ANavigationPoint* Nav){return 0;}


	virtual void ReviewPaths();

	virtual void Exec( const TCHAR* Str );
	virtual void AdjustCover( UBOOL bFromDefinePaths = FALSE );
	virtual void BuildCover(  UBOOL bFromDefinePaths = FALSE );
	virtual void FinishPathBuild();

protected:
	/**
	* Builds the per-level nav lists and then assembles the world list.
	*/
	void BuildNavLists();
};

struct Vehicle_eventGetEntryLocation_Parms
{
    FVector ReturnValue;
    Vehicle_eventGetEntryLocation_Parms(EEventParm)
    {
    }
};
struct Vehicle_eventDriverLeave_Parms
{
    UBOOL bForceLeave;
    UBOOL ReturnValue;
    Vehicle_eventDriverLeave_Parms(EEventParm)
    {
    }
};
struct Vehicle_eventContinueOnFoot_Parms
{
    UBOOL ReturnValue;
    Vehicle_eventContinueOnFoot_Parms(EEventParm)
    {
    }
};
class AVehicle : public APawn
{
public:
    //## BEGIN PROPS Vehicle
    class APawn* Driver;
    BITFIELD bDriving:1;
    BITFIELD bDriverIsVisible:1;
    BITFIELD bAttachDriver:1;
    BITFIELD bTurnInPlace:1;
    BITFIELD bSeparateTurretFocus:1;
    BITFIELD bFollowLookDir:1;
    BITFIELD bHasHandbrake:1;
    BITFIELD bScriptedRise:1;
    BITFIELD bDuckObstacles:1;
    BITFIELD bAvoidReversing:1;
    BITFIELD bRetryPathfindingWithDriver:1;
    BITFIELD bIgnoreStallZ:1;
    BITFIELD bDoExtraNetRelevancyTraces:1;
    TArrayNoInit<FVector> ExitPositions;
    FLOAT ExitRadius;
    FVector ExitOffset;
    FLOAT Steering;
    FLOAT Throttle;
    FLOAT Rise;
    FVector TargetLocationAdjustment;
    FLOAT DriverDamageMult;
    FLOAT MomentumMult;
    class UClass* CrushedDamageType;
    FLOAT MinCrushSpeed;
    FLOAT ForceCrushPenetration;
    BYTE StuckCount;
    FLOAT ThrottleTime;
    FLOAT StuckTime;
    FLOAT OldSteering;
    FLOAT OnlySteeringStartTime;
    FLOAT OldThrottle;
    FLOAT AIMoveCheckTime;
    FLOAT VehicleMovingTime;
    FLOAT TurnTime;
    //## END PROPS Vehicle

    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL,UBOOL bRequestAlternateLoc=FALSE) const;
    FVector eventGetEntryLocation()
    {
        Vehicle_eventGetEntryLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetEntryLocation),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventDriverLeave(UBOOL bForceLeave)
    {
        Vehicle_eventDriverLeave_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.bForceLeave=bForceLeave ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_DriverLeave),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventContinueOnFoot()
    {
        Vehicle_eventContinueOnFoot_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ContinueOnFoot),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AVehicle,APawn,0|CLASS_Config|CLASS_NativeReplication,Engine)
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual ANavigationPoint* CheckDetour(ANavigationPoint* BestDest, ANavigationPoint* Start, UBOOL bWeightDetours);
	virtual void performPhysics(FLOAT DeltaSeconds);
	virtual UBOOL HasRelevantDriver();
	virtual AVehicle* GetAVehicle() { return this; }

	/** returns true if this actor should be considered relevancy owner for ReplicatedActor, which has bOnlyRelevantToOwner=true
	*/
	virtual UBOOL IsRelevancyOwnerFor(AActor* ReplicatedActor, AActor* ActorOwner);

	// AI Interface
	virtual void setMoveTimer(FVector MoveDir);
	virtual UBOOL IsStuck();
	virtual UBOOL AdjustFlight(FLOAT ZDiff, UBOOL bFlyingDown, FLOAT Distance, AActor* GoalActor);
	virtual void SteerVehicle(FVector Direction);
	virtual void AdjustThrottle( FLOAT Distance );
	virtual UBOOL moveToward(const FVector &Dest, AActor *GoalActor);
	virtual void rotateToward(FVector FocalPoint);
	virtual UBOOL JumpOutCheck(AActor *GoalActor, FLOAT Distance, FLOAT ZDiff);
	virtual FLOAT GetMaxRiseForce();
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	virtual FLOAT SecondRouteAttempt(ANavigationPoint* Anchor, ANavigationPoint* EndAnchor, NodeEvaluator NodeEval, FLOAT BestWeight, AActor *goal, const FVector& GoalLocation, FLOAT StartDist, FLOAT EndDist, INT MaxPathLength, INT SoftMaxNodes);
	virtual UBOOL IsGlider();
};

class AProjectile : public AActor
{
public:
    //## BEGIN PROPS Projectile
    FLOAT Speed;
    FLOAT MaxSpeed;
    BITFIELD bSwitchToZeroCollision:1;
    BITFIELD bBlockedByInstigator:1;
    BITFIELD bBegunPlay:1;
    BITFIELD bRotationFollowsVelocity:1;
    BITFIELD bNotBlockedByShield:1;
    class AActor* ZeroCollider;
    class UPrimitiveComponent* ZeroColliderComponent;
    FLOAT Damage;
    FLOAT DamageRadius;
    FLOAT MomentumTransfer;
    class UClass* MyDamageType;
    class USoundCue* SpawnSound;
    class USoundCue* ImpactSound;
    class AController* InstigatorController;
    class AActor* ImpactedActor;
    FLOAT NetCullDistanceSquared;
    class UCylinderComponent* CylinderComponent;
    //## END PROPS Projectile

    virtual BYTE GetTeamNum();
    DECLARE_ABSTRACT_CLASS(AProjectile,AActor,0,Engine)
	void BoundProjectileVelocity();
	virtual UBOOL ShrinkCollision(AActor *HitActor, UPrimitiveComponent* HitComponent, const FVector &StartLocation);
	virtual void GrowCollision();
	virtual AProjectile* GetAProjectile() { return this; }
	virtual const AProjectile* GetAProjectile() const { return this; }
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
	virtual void physProjectile(FLOAT DeltaTime, INT Iterations);
};

class ASceneCaptureActor : public AActor
{
public:
    //## BEGIN PROPS SceneCaptureActor
    class USceneCaptureComponent* SceneCapture;
    //## END PROPS SceneCaptureActor

    DECLARE_ABSTRACT_CLASS(ASceneCaptureActor,AActor,0,Engine)
	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents() {}

	// UObject interface

	/** 
	* Callback for a property change
	* @param PropertyThatChanged - updated property
	*/
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/** 
	* Called after object load
	*/
	virtual void PostLoad();

	// AActor interface.

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
};

class ASceneCapture2DActor : public ASceneCaptureActor
{
public:
    //## BEGIN PROPS SceneCapture2DActor
    class UDrawFrustumComponent* DrawFrustum;
    //## END PROPS SceneCapture2DActor

    DECLARE_CLASS(ASceneCapture2DActor,ASceneCaptureActor,0,Engine)
	// SceneCaptureActor interface

	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents();
};

class ASceneCaptureCubeMapActor : public ASceneCaptureActor
{
public:
    //## BEGIN PROPS SceneCaptureCubeMapActor
    class UStaticMeshComponent* StaticMesh;
    class UMaterialInstanceConstant* CubeMaterialInst;
    //## END PROPS SceneCaptureCubeMapActor

    DECLARE_CLASS(ASceneCaptureCubeMapActor,ASceneCaptureActor,0,Engine)
	// SceneCaptureActor interface

	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents();

	// AActor interface

	virtual void Spawned();

	// UObject interface

	virtual void FinishDestroy();
	virtual void PostLoad();

private:

	/**
	* Init the helper components 
	*/
	virtual void Init();
};

class ASceneCaptureReflectActor : public ASceneCaptureActor
{
public:
    //## BEGIN PROPS SceneCaptureReflectActor
    class UStaticMeshComponent* StaticMesh;
    class UMaterialInstanceConstant* ReflectMaterialInst;
    //## END PROPS SceneCaptureReflectActor

    DECLARE_CLASS(ASceneCaptureReflectActor,ASceneCaptureActor,0,Engine)
	// SceneCaptureActor interface

	/**
	* Update any components used by this actor
	*/
	virtual void SyncComponents();

	// AActor interface

	virtual void Spawned();

	// UObject interface

	virtual void FinishDestroy();
	virtual void PostLoad();

private:

	/**
	* Init the helper components
	*/
	virtual void Init();
};

class ASceneCapturePortalActor : public ASceneCaptureReflectActor
{
public:
    //## BEGIN PROPS SceneCapturePortalActor
    //## END PROPS SceneCapturePortalActor

    DECLARE_CLASS(ASceneCapturePortalActor,ASceneCaptureReflectActor,0,Engine)
	// SceneCaptureActor interface

	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents();
};

class APortalTeleporter : public ASceneCapturePortalActor
{
public:
    //## BEGIN PROPS PortalTeleporter
    class APortalTeleporter* SisterPortal;
    INT TextureResolutionX;
    INT TextureResolutionY;
    class APortalMarker* MyMarker;
    BITFIELD bMovablePortal:1;
    BITFIELD bAlwaysTeleportNonPawns:1;
    BITFIELD bCanTeleportVehicles:1;
    //## END PROPS PortalTeleporter

    UBOOL TransformActor(class AActor* A);
    FVector TransformVectorDir(FVector V);
    FVector TransformHitLocation(FVector HitLocation);
    class UTextureRenderTarget2D* CreatePortalTexture();
    DECLARE_FUNCTION(execTransformActor)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=TransformActor(A);
    }
    DECLARE_FUNCTION(execTransformVectorDir)
    {
        P_GET_STRUCT(FVector,V);
        P_FINISH;
        *(FVector*)Result=TransformVectorDir(V);
    }
    DECLARE_FUNCTION(execTransformHitLocation)
    {
        P_GET_STRUCT(FVector,HitLocation);
        P_FINISH;
        *(FVector*)Result=TransformHitLocation(HitLocation);
    }
    DECLARE_FUNCTION(execCreatePortalTexture)
    {
        P_FINISH;
        *(class UTextureRenderTarget2D**)Result=CreatePortalTexture();
    }
    DECLARE_ABSTRACT_CLASS(APortalTeleporter,ASceneCapturePortalActor,0,Engine)
	virtual APortalTeleporter* GetAPortalTeleporter() { return this; };
	virtual void Spawned();
	virtual void PostLoad();
	virtual void CheckForErrors();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual INT AddMyMarker(AActor* S);
	virtual void TickSpecial(FLOAT DeltaTime);
	UBOOL CanTeleport(AActor* A);
};

class AStaticMeshActorBase : public AActor
{
public:
    //## BEGIN PROPS StaticMeshActorBase
    //## END PROPS StaticMeshActorBase

    DECLARE_ABSTRACT_CLASS(AStaticMeshActorBase,AActor,0,Engine)
	/**
	 * Initializes this actor when play begins.  This version marks the actor as ready to execute script, but skips
	 * the rest of the stuff that actors normally do in PostBeginPlay().
	 */
	virtual void PostBeginPlay();
};

class AStaticMeshActor : public AStaticMeshActorBase
{
public:
    //## BEGIN PROPS StaticMeshActor
    class UStaticMeshComponent* StaticMeshComponent;
    //## END PROPS StaticMeshActor

    DECLARE_CLASS(AStaticMeshActor,AStaticMeshActorBase,0,Engine)
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();

protected:
	/** 
	* This function actually does the work for the GetDetailInfo and is virtual.  
	* It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
	**/
	virtual FString GetDetailedInfoInternal() const;
};

class AStaticMeshCollectionActor : public AStaticMeshActorBase
{
public:
    //## BEGIN PROPS StaticMeshCollectionActor
    TArrayNoInit<class UStaticMeshComponent*> StaticMeshComponents;
    INT MaxStaticMeshComponents;
    //## END PROPS StaticMeshCollectionActor

    DECLARE_CLASS(AStaticMeshCollectionActor,AStaticMeshActorBase,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/* === AActor interface === */
	/**
	 * Updates the CachedLocalToWorld transform for all attached components.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate=FALSE );


	/* === UObject interface === */
	/**
	 * Serializes the LocalToWorld transforms for the StaticMeshComponents contained in this actor.
	 */
	virtual void Serialize( FArchive& Ar );
};

struct FSMMaterialSetterDatum
{
    INT MaterialIndex;
    class UMaterialInterface* TheMaterial;

    /** Constructors */
    FSMMaterialSetterDatum() {}
    FSMMaterialSetterDatum(EEventParm)
    {
        appMemzero(this, sizeof(FSMMaterialSetterDatum));
    }
};

class AStaticMeshActorBasedOnExtremeContent : public AActor
{
public:
    //## BEGIN PROPS StaticMeshActorBasedOnExtremeContent
    class UStaticMeshComponent* StaticMeshComponent;
    TArrayNoInit<struct FSMMaterialSetterDatum> ExtremeContent;
    TArrayNoInit<struct FSMMaterialSetterDatum> NonExtremeContent;
    //## END PROPS StaticMeshActorBasedOnExtremeContent

    DECLARE_CLASS(AStaticMeshActorBasedOnExtremeContent,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AStaticMeshActorBasedOnExtremeContent)
};

class ATrigger : public AActor
{
public:
    //## BEGIN PROPS Trigger
    class UCylinderComponent* CylinderComponent;
    BITFIELD bRecentlyTriggered:1;
    FLOAT AITriggerDelay;
    //## END PROPS Trigger

    DECLARE_CLASS(ATrigger,AActor,0,Engine)
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class UActorFactory : public UObject
{
public:
    //## BEGIN PROPS ActorFactory
    class UClass* GameplayActorClass;
    FStringNoInit MenuName;
    INT MenuPriority;
    class UClass* NewActorClass;
    BITFIELD bPlaceable:1;
    FStringNoInit SpecificGameName;
    //## END PROPS ActorFactory

    DECLARE_ABSTRACT_CLASS(UActorFactory,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/** Called to actual create an actor at the supplied location/rotation, using the properties in the ActorFactory */
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	virtual void PostEditChange( UProperty* PropertyThatChanged );


	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings. 
	 * Used to determine if we should add to context menu for example.
	 *
	 * @param	OutErrorMsg		Receivews localized error string name if returning FALSE.
	 */
	virtual UBOOL CanCreateActor(FString& OutErrorMsg) { return TRUE; }

	/** Fill in parameters automatically, possibly using the specified selection set. */
	virtual void AutoFillFields(class USelection* Selection) {}

	/** Name to put on context menu. */
	virtual FString GetMenuName() { return MenuName; }

	virtual AActor* GetDefaultActor();
	
    protected:
        /**
		 * This will check whether there is enough space to spawn an character.
		 * Additionally it will check the ActorFactoryData to for any overrides 
		 * ( e.g. bCheckSpawnCollision )
		 *
		 * @return if there is enough space to spawn character at this location
		 **/
		UBOOL IsEnoughRoomToSpawnPawn( const FVector* const Location, const class USeqAct_ActorFactory* const ActorFactoryData ) const;

};

class UActorFactoryAI : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAI
    class UClass* ControllerClass;
    class UClass* PawnClass;
    FStringNoInit PawnName;
    BITFIELD bGiveDefaultInventory:1;
    TArrayNoInit<class UClass*> InventoryList;
    INT TeamIndex;
    //## END PROPS ActorFactoryAI

    DECLARE_CLASS(UActorFactoryAI,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	virtual AActor* GetDefaultActor();
};

class UActorFactoryAmbientSound : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSound
    class USoundCue* AmbientSoundCue;
    //## END PROPS ActorFactoryAmbientSound

    DECLARE_CLASS(UActorFactoryAmbientSound,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryAmbientSoundMovable : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundMovable
    class USoundCue* AmbientSoundCue;
    //## END PROPS ActorFactoryAmbientSoundMovable

    DECLARE_CLASS(UActorFactoryAmbientSoundMovable,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor( FString& OutErrorMsg );
	virtual void AutoFillFields( class USelection* Selection );
	virtual FString GetMenuName( void );
};

class UActorFactoryAmbientSoundSimple : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundSimple
    class USoundNodeWave* SoundNodeWave;
    //## END PROPS ActorFactoryAmbientSoundSimple

    DECLARE_CLASS(UActorFactoryAmbientSoundSimple,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryArchetype : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryArchetype
    class AActor* ArchetypeActor;
    //## END PROPS ActorFactoryArchetype

    DECLARE_CLASS(UActorFactoryArchetype,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
	virtual AActor* GetDefaultActor();
};

class UActorFactoryCoverLink : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryCoverLink
    //## END PROPS ActorFactoryCoverLink

    DECLARE_CLASS(UActorFactoryCoverLink,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryCoverLink)
};

class UActorFactoryDynamicSM : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryDynamicSM
    class UStaticMesh* StaticMesh;
    FVector DrawScale3D;
    BITFIELD bNoEncroachCheck:1;
    BITFIELD bNotifyRigidBodyCollision:1;
    BITFIELD bUseCompartment:1;
    BITFIELD bCastDynamicShadow:1;
    BYTE CollisionType GCC_BITFIELD_MAGIC;
    //## END PROPS ActorFactoryDynamicSM

    DECLARE_ABSTRACT_CLASS(UActorFactoryDynamicSM,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
	virtual void PostLoad();
};

class UActorFactoryMover : public UActorFactoryDynamicSM
{
public:
    //## BEGIN PROPS ActorFactoryMover
    //## END PROPS ActorFactoryMover

    DECLARE_CLASS(UActorFactoryMover,UActorFactoryDynamicSM,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryMover)
};

class UActorFactoryRigidBody : public UActorFactoryDynamicSM
{
public:
    //## BEGIN PROPS ActorFactoryRigidBody
    BITFIELD bStartAwake:1 GCC_BITFIELD_MAGIC;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bLocalSpaceInitialVelocity:1;
    BITFIELD bEnableStayUprightSpring:1;
    FVector InitialVelocity;
    class UDistributionVector* AdditionalVelocity;
    class UDistributionVector* InitialAngularVelocity;
    BYTE RBChannel;
    FLOAT StayUprightTorqueFactor;
    FLOAT StayUprightMaxTorque;
    //## END PROPS ActorFactoryRigidBody

    DECLARE_CLASS(UActorFactoryRigidBody,UActorFactoryDynamicSM,0|CLASS_Config,Engine)
	// UObject interface
	virtual void PostLoad();

	// ActorFactoryRigidBody
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UActorFactoryEmitter : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryEmitter
    class UParticleSystem* ParticleSystem;
    //## END PROPS ActorFactoryEmitter

    DECLARE_CLASS(UActorFactoryEmitter,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryFracturedStaticMesh : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryFracturedStaticMesh
    class UFracturedStaticMesh* FracturedStaticMesh;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryFracturedStaticMesh

    DECLARE_CLASS(UActorFactoryFracturedStaticMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryLensFlare : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryLensFlare
    class ULensFlare* LensFlareObject;
    //## END PROPS ActorFactoryLensFlare

    DECLARE_CLASS(UActorFactoryLensFlare,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryLight : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryLight
    //## END PROPS ActorFactoryLight

    DECLARE_CLASS(UActorFactoryLight,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryLight)
};

class UActorFactoryPathNode : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPathNode
    //## END PROPS ActorFactoryPathNode

    DECLARE_CLASS(UActorFactoryPathNode,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPathNode)
};

class UActorFactoryPhysicsAsset : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPhysicsAsset
    class UPhysicsAsset* PhysicsAsset;
    class USkeletalMesh* SkeletalMesh;
    BITFIELD bStartAwake:1;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bNotifyRigidBodyCollision:1;
    BITFIELD bUseCompartment:1;
    BITFIELD bCastDynamicShadow:1;
    FVector InitialVelocity;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryPhysicsAsset

    DECLARE_CLASS(UActorFactoryPhysicsAsset,UActorFactory,0|CLASS_Config,Engine)
	virtual void PreSave();

	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryPhysXDestructible : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPhysXDestructible
    class UPhysXDestructible* PhysXDestructible;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryPhysXDestructible

    DECLARE_CLASS(UActorFactoryPhysXDestructible,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryPlayerStart : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPlayerStart
    //## END PROPS ActorFactoryPlayerStart

    DECLARE_CLASS(UActorFactoryPlayerStart,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPlayerStart)
};

class UActorFactorySkeletalMesh : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactorySkeletalMesh
    class USkeletalMesh* SkeletalMesh;
    class UAnimSet* AnimSet;
    FName AnimSequenceName;
    //## END PROPS ActorFactorySkeletalMesh

    DECLARE_CLASS(UActorFactorySkeletalMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryStaticMesh : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryStaticMesh
    class UStaticMesh* StaticMesh;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryStaticMesh

    DECLARE_CLASS(UActorFactoryStaticMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryTrigger : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryTrigger
    //## END PROPS ActorFactoryTrigger

    DECLARE_CLASS(UActorFactoryTrigger,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryTrigger)
};

class UActorFactoryVehicle : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryVehicle
    class UClass* VehicleClass;
    //## END PROPS ActorFactoryVehicle

    DECLARE_CLASS(UActorFactoryVehicle,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	virtual AActor* GetDefaultActor();
};

class UBookMark : public UObject
{
public:
    //## BEGIN PROPS BookMark
    FVector Location;
    FRotator Rotation;
    //## END PROPS BookMark

    DECLARE_CLASS(UBookMark,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UBookMark)
};

class UCameraAnim : public UObject
{
public:
    //## BEGIN PROPS CameraAnim
    class UInterpGroup* CameraInterpGroup;
    FLOAT AnimLength;
    FBox BoundingBox;
    //## END PROPS CameraAnim

    DECLARE_CLASS(UCameraAnim,UObject,0,Engine)
protected:
	void CalcLocalAABB();

public:
	/** Overridden to calculate the bbox at save time. */
	virtual void PreSave();
	virtual void PostLoad();

	UBOOL CreateFromInterpGroup(class UInterpGroup* SrcGroup, class USeqAct_Interp* Interp);
	FBox GetAABB(FVector const& BaseLoc, FRotator const& BaseRot, FLOAT Scale) const;
};

class UCameraAnimInst : public UObject
{
public:
    //## BEGIN PROPS CameraAnimInst
    class UCameraAnim* CamAnim;
    class UInterpGroupInst* InterpGroupInst;
    FLOAT CurTime;
    BITFIELD bLooping:1;
    BITFIELD bFinished:1;
    BITFIELD bAutoReleaseWhenFinished:1;
    BITFIELD bBlendingIn:1;
    BITFIELD bBlendingOut:1;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    FLOAT CurBlendInTime;
    FLOAT CurBlendOutTime;
    FLOAT PlayRate;
    FLOAT BasePlayScale;
    FLOAT TransientScaleModifier;
    FLOAT CurrentBlendWeight;
    FLOAT RemainingTime;
    class UInterpTrackMove* MoveTrack;
    class UInterpTrackInstMove* MoveInst;
    class UAnimNodeSequence* SourceAnimNode;
    //## END PROPS CameraAnimInst

    void Play(class UCameraAnim* Anim,class AActor* CamActor,FLOAT InRate,FLOAT InScale,FLOAT InBlendInTime,FLOAT InBlendOutTime,UBOOL bInLoop,UBOOL bRandomStartTime,FLOAT Duration=0);
    void Update(FLOAT NewRate,FLOAT NewScale,FLOAT NewBlendInTime,FLOAT NewBlendOutTime,FLOAT NewDuration=0);
    void AdvanceAnim(FLOAT DeltaTime,UBOOL bJump);
    void Stop(UBOOL bImmediate=FALSE);
    void ApplyTransientScaling(FLOAT Scalar);
    DECLARE_FUNCTION(execPlay)
    {
        P_GET_OBJECT(UCameraAnim,Anim);
        P_GET_OBJECT(AActor,CamActor);
        P_GET_FLOAT(InRate);
        P_GET_FLOAT(InScale);
        P_GET_FLOAT(InBlendInTime);
        P_GET_FLOAT(InBlendOutTime);
        P_GET_UBOOL(bInLoop);
        P_GET_UBOOL(bRandomStartTime);
        P_GET_FLOAT_OPTX(Duration,0);
        P_FINISH;
        Play(Anim,CamActor,InRate,InScale,InBlendInTime,InBlendOutTime,bInLoop,bRandomStartTime,Duration);
    }
    DECLARE_FUNCTION(execUpdate)
    {
        P_GET_FLOAT(NewRate);
        P_GET_FLOAT(NewScale);
        P_GET_FLOAT(NewBlendInTime);
        P_GET_FLOAT(NewBlendOutTime);
        P_GET_FLOAT_OPTX(NewDuration,0);
        P_FINISH;
        Update(NewRate,NewScale,NewBlendInTime,NewBlendOutTime,NewDuration);
    }
    DECLARE_FUNCTION(execAdvanceAnim)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_UBOOL(bJump);
        P_FINISH;
        AdvanceAnim(DeltaTime,bJump);
    }
    DECLARE_FUNCTION(execStop)
    {
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        Stop(bImmediate);
    }
    DECLARE_FUNCTION(execApplyTransientScaling)
    {
        P_GET_FLOAT(Scalar);
        P_FINISH;
        ApplyTransientScaling(Scalar);
    }
    DECLARE_CLASS(UCameraAnimInst,UObject,0,Engine)
	void RegisterAnimNode(class UAnimNodeSequence* AnimNode);
};

class UCameraMode : public UObject
{
public:
    //## BEGIN PROPS CameraMode
    //## END PROPS CameraMode

    DECLARE_CLASS(UCameraMode,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCameraMode)
};

struct CameraModifier_eventDisableModifier_Parms
{
    CameraModifier_eventDisableModifier_Parms(EEventParm)
    {
    }
};
class UCameraModifier : public UObject
{
public:
    //## BEGIN PROPS CameraModifier
    BITFIELD bDisabled:1;
    BITFIELD bPendingDisable:1;
    BITFIELD bDebug:1;
    class ACamera* CameraOwner;
    //## END PROPS CameraModifier

    virtual UBOOL ModifyCamera(class ACamera* Camera,FLOAT DeltaTime,FTPOV& OutPOV);
    virtual UBOOL IsDisabled() const;
    DECLARE_FUNCTION(execModifyCamera)
    {
        P_GET_OBJECT(ACamera,Camera);
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        *(UBOOL*)Result=ModifyCamera(Camera,DeltaTime,OutPOV);
    }
    DECLARE_FUNCTION(execIsDisabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsDisabled();
    }
    void eventDisableModifier()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_DisableModifier),NULL);
    }
    DECLARE_CLASS(UCameraModifier,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCameraModifier)
};

class UCheatManager : public UObject
{
public:
    //## BEGIN PROPS CheatManager
    //## END PROPS CheatManager

    DECLARE_CLASS(UCheatManager,UObject,0,Engine)
    DECLARE_WITHIN(APlayerController)
    NO_DEFAULT_CONSTRUCTOR(UCheatManager)
};

class UClipPadEntry : public UObject
{
public:
    //## BEGIN PROPS ClipPadEntry
    FStringNoInit Title;
    FStringNoInit Text;
    //## END PROPS ClipPadEntry

    DECLARE_CLASS(UClipPadEntry,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UClipPadEntry)
};

class UCodecMovie : public UObject
{
public:
    //## BEGIN PROPS CodecMovie
    FLOAT PlaybackDuration;
    //## END PROPS CodecMovie

    DECLARE_ABSTRACT_CLASS(UCodecMovie,UObject,0|CLASS_Transient,Engine)
	// Can't have pure virtual functions in classes declared in *Classes.h due to DECLARE_CLASS macro being used.

	// CodecMovie interface

	/**
	* Not all codec implementations are available
	*
	* @return TRUE if the current codec is supported
	*/
	virtual UBOOL IsSupported() { return FALSE; }

	/**
	 * Returns the movie width.
	 *
	 * @return width of movie.
	 */
	virtual UINT GetSizeX() { return 0; }
	/**
	 * Returns the movie height.
	 *
	 * @return height of movie.
	 */
	virtual UINT GetSizeY()	{ return 0; }
	/** 
	 * Returns the movie format.
	 *
	 * @return format of movie.
	 */
	virtual EPixelFormat GetFormat();
	/**
	 * Returns the framerate the movie was encoded at.
	 *
	 * @return framerate the movie was encoded at.
	 */
	virtual FLOAT GetFrameRate() { return 0; }
	
	/**
	 * Initializes the decoder to stream from disk.
	 *
	 * @param	Filename	Filename of compressed media.
	 * @param	Offset		Offset into file to look for the beginning of the compressed data.
	 * @param	Size		Size of compressed data.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( const FString& Filename, DWORD Offset, DWORD Size ) { return FALSE; }
	/**
	 * Initializes the decoder to stream from memory.
	 *
	 * @param	Source		Beginning of memory block holding compressed data.
	 * @param	Size		Size of memory block.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( void* Source, DWORD Size ) { return FALSE; }	
	/**
	 * Tears down stream.
	 */	
	virtual void Close() {}

	/**
	 * Resets the stream to its initial state so it can be played again from the beginning.
	 */
	virtual void ResetStream() {}
	/**
	 * Queues the request to retrieve the next frame.
	 *
 	 * @param InTextureMovieResource - output from movie decoding is written to this resource
	 */
	virtual void GetFrame( class FTextureMovieResource* InTextureMovieResource ) {}
	/**
	 * Returns the playback time of the movie.
	 *
	 * @return playback duration of movie.
	 */
	virtual FLOAT GetDuration() { return PlaybackDuration; }
	/** 
	* Begin playback of the movie stream 
	*
	* @param bLooping - if TRUE then the movie loops back to the start when finished
	* @param bOneFrameOnly - if TRUE then the decoding is paused after the first frame is processed 
	*/
	virtual void Play(UBOOL bLooping, UBOOL bOneFrameOnly) {}
	/** 
	* Pause or resume the movie playback.
	*
	* @param bPause - if TRUE then decoding will be paused otherwise it resumes
	*/
	virtual void Pause(UBOOL bPause) {}
	/**
	* Stop playback from the movie stream 
	*/ 
	virtual void Stop() {}
	
	/**
	* Release any dynamic rendering resources created by this codec
	*/
	virtual void ReleaseDynamicResources() {}
};

class UCodecMovieFallback : public UCodecMovie
{
public:
    //## BEGIN PROPS CodecMovieFallback
    FLOAT CurrentTime;
    //## END PROPS CodecMovieFallback

    DECLARE_CLASS(UCodecMovieFallback,UCodecMovie,0|CLASS_Transient,Engine)
	// CodecMovie interface

	/**
	* Not all codec implementations are available
	* @return TRUE if the current codec is supported
	*/
	virtual UBOOL IsSupported();
	/**
	 * Returns the movie width.
	 *
	 * @return width of movie.
	 */
	virtual UINT GetSizeX();
	/**
	 * Returns the movie height.
	 *
	 * @return height of movie.
	 */
	virtual UINT GetSizeY();
	/** 
	 * Returns the movie format.
	 *
	 * @return format of movie.
	 */
	virtual EPixelFormat GetFormat();
	/**
	 * Returns the framerate the movie was encoded at.
	 *
	 * @return framerate the movie was encoded at.
	 */
	virtual FLOAT GetFrameRate();	
	/**
	 * Initializes the decoder to stream from disk.
	 *
	 * @param	Filename	Filename of compressed media.
	 * @param	Offset		Offset into file to look for the beginning of the compressed data.
	 * @param	Size		Size of compressed data.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( const FString& Filename, DWORD Offset, DWORD Size );
	/**
	 * Initializes the decoder to stream from memory.
	 *
	 * @param	Source		Beginning of memory block holding compressed data.
	 * @param	Size		Size of memory block.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( void* Source, DWORD Size );
	/**
	* Resets the stream to its initial state so it can be played again from the beginning.
	*/
	virtual void ResetStream();
	/**
	* Queues the request to retrieve the next frame.
	*
	* @param InTextureMovieResource - output from movie decoding is written to this resource
	*/
	virtual void GetFrame( class FTextureMovieResource* InTextureMovieResource );
};

class UHeightFogComponent : public UActorComponent
{
public:
    //## BEGIN PROPS HeightFogComponent
    BITFIELD bEnabled:1 GCC_BITFIELD_MAGIC;
    FLOAT Height;
    FLOAT Density;
    FLOAT LightBrightness;
    FColor LightColor;
    FLOAT ExtinctionDistance;
    FLOAT StartDistance;
    //## END PROPS HeightFogComponent

    void SetEnabled(UBOOL bSetEnabled);
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bSetEnabled);
        P_FINISH;
        SetEnabled(bSetEnabled);
    }
    DECLARE_CLASS(UHeightFogComponent,UActorComponent,0,Engine)
protected:
	// ActorComponent interface.
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
public:
};

class UDirectionalLightComponent : public ULightComponent
{
public:
    //## BEGIN PROPS DirectionalLightComponent
    FLOAT TraceDistance;
    //## END PROPS DirectionalLightComponent

    DECLARE_CLASS(UDirectionalLightComponent,ULightComponent,0,Engine)
	virtual FLightSceneInfo* CreateSceneInfo() const;
	virtual FVector4 GetPosition() const;
	virtual ELightComponentType GetLightType() const;
};

class UPointLightComponent : public ULightComponent
{
public:
    //## BEGIN PROPS PointLightComponent
    FLOAT ShadowRadiusMultiplier;
    FLOAT Radius;
    FLOAT FalloffExponent;
    FLOAT ShadowFalloffExponent;
    FLOAT MinShadowFalloffRadius;
    FMatrix CachedParentToWorld;
    FVector Translation;
    class UDrawLightRadiusComponent* PreviewLightRadius;
    //## END PROPS PointLightComponent

    void SetTranslation(FVector NewTranslation);
    DECLARE_FUNCTION(execSetTranslation)
    {
        P_GET_STRUCT(FVector,NewTranslation);
        P_FINISH;
        SetTranslation(NewTranslation);
    }
    DECLARE_CLASS(UPointLightComponent,ULightComponent,0,Engine)
protected:
	/**
	 * Updates the light's PreviewLightRadius.
	 */
	void UpdatePreviewLightRadius();

	// UActorComponent interface.
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
public:

	// ULightComponent interface.
	virtual FLightSceneInfo* CreateSceneInfo() const;
	virtual UBOOL AffectsBounds(const FBoxSphereBounds& Bounds) const;
	virtual FVector4 GetPosition() const;
	virtual FBox GetBoundingBox() const;
	virtual FLinearColor GetDirectIntensity(const FVector& Point) const;
	virtual ELightComponentType GetLightType() const;

	// update the LocalToWorld matrix
	virtual void SetTransformedToWorld();

	/**
	 * Called after property has changed via e.g. property window or set command.
	 *
	 * @param	PropertyThatChanged	UProperty that has been changed, NULL if unknown
	 */
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	virtual void PostLoad();
};

class USpotLightComponent : public UPointLightComponent
{
public:
    //## BEGIN PROPS SpotLightComponent
    FLOAT InnerConeAngle;
    FLOAT OuterConeAngle;
    class UDrawLightConeComponent* PreviewInnerCone;
    class UDrawLightConeComponent* PreviewOuterCone;
    //## END PROPS SpotLightComponent

    DECLARE_CLASS(USpotLightComponent,UPointLightComponent,0,Engine)
	// UActorComponent interface.
	virtual void Attach();

	// ULightComponent interface.
	virtual FLightSceneInfo* CreateSceneInfo() const;
	virtual UBOOL AffectsBounds(const FBoxSphereBounds& Bounds) const;
	virtual FLinearColor GetDirectIntensity(const FVector& Point) const;
	virtual ELightComponentType GetLightType() const;
	virtual void PostLoad();
};

class USkyLightComponent : public ULightComponent
{
public:
    //## BEGIN PROPS SkyLightComponent
    FLOAT LowerBrightness;
    FColor LowerColor;
    //## END PROPS SkyLightComponent

    DECLARE_CLASS(USkyLightComponent,ULightComponent,0,Engine)
	/**
	 * Called when a property is being changed.
	 *
	 * @param PropertyThatChanged	Property that changed or NULL if unknown or multiple
	 */
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	/**
	 * Called after data has been serialized.
	 */
	virtual void PostLoad();

	// ULightComponent interface.
	virtual FLightSceneInfo* CreateSceneInfo() const;
	virtual FVector4 GetPosition() const;
	virtual ELightComponentType GetLightType() const;
};

class USphericalHarmonicLightComponent : public ULightComponent
{
public:
    //## BEGIN PROPS SphericalHarmonicLightComponent
    FSHVectorRGB WorldSpaceIncidentLighting;
    BITFIELD bRenderBeforeModShadows:1;
    //## END PROPS SphericalHarmonicLightComponent

    DECLARE_CLASS(USphericalHarmonicLightComponent,ULightComponent,0,Engine)
	// ULightComponent interface.
	virtual FLightSceneInfo* CreateSceneInfo() const;
	virtual FVector4 GetPosition() const;
	virtual ELightComponentType GetLightType() const;
};

class ULightEnvironmentComponent : public UActorComponent
{
public:
    //## BEGIN PROPS LightEnvironmentComponent
protected:
    BITFIELD bEnabled:1 GCC_BITFIELD_MAGIC;
public:
    BITFIELD bForceNonCompositeDynamicLights:1;
protected:
    TArrayNoInit<class UPrimitiveComponent*> AffectedComponents;
public:
    //## END PROPS LightEnvironmentComponent

    void SetEnabled(UBOOL bNewEnabled);
    UBOOL IsEnabled() const;
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bNewEnabled);
        P_FINISH;
        SetEnabled(bNewEnabled);
    }
    DECLARE_FUNCTION(execIsEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsEnabled();
    }
    DECLARE_CLASS(ULightEnvironmentComponent,UActorComponent,0,Engine)
	/**
	 * Signals to the light environment that a light has changed, so the environment may need to be updated.
	 * @param Light - The light that changed.
	 */
	virtual void UpdateLight(const ULightComponent* Light) {}

	// Methods that update AffectedComponents
	void AddAffectedComponent(UPrimitiveComponent* NewComponent);
	void RemoveAffectedComponent(UPrimitiveComponent* OldComponent);
};

class UDynamicLightEnvironmentComponent : public ULightEnvironmentComponent
{
public:
    //## BEGIN PROPS DynamicLightEnvironmentComponent
    class FDynamicLightEnvironmentState* State;
    FLOAT InvisibleUpdateTime;
    FLOAT MinTimeBetweenFullUpdates;
    INT NumVolumeVisibilitySamples;
    FLinearColor AmbientShadowColor;
    FVector AmbientShadowSourceDirection;
    FLinearColor AmbientGlow;
    FLOAT LightDesaturation;
    FLOAT LightDistance;
    FLOAT ShadowDistance;
    BITFIELD bCastShadows:1;
    BITFIELD bCompositeShadowsFromDynamicLights:1;
    BITFIELD bDynamic:1;
    BITFIELD bSynthesizeDirectionalLight:1;
    BITFIELD bSynthesizeSHLight:1;
    BITFIELD bForceAllowLightEnvSphericalHarmonicLights:1;
    BITFIELD bRequiresNonLatentUpdates:1;
    BITFIELD bTraceFromClosestBoundsPoint:1;
    BITFIELD bOverrideOwnerBounds:1;
    BITFIELD bOverrideOwnerLightingChannels:1;
    FLOAT ModShadowFadeoutTime;
    FLOAT ModShadowFadeoutExponent;
    INT MinShadowResolution;
    INT MaxShadowResolution;
    INT ShadowFadeResolution;
    BYTE ShadowFilterQuality;
    BYTE LightShadowMode;
    FLOAT BouncedLightingFactor;
    FLOAT MinShadowAngle;
    FBoxSphereBounds OverriddenBounds;
    FLightingChannelContainer OverriddenLightingChannels;
    //## END PROPS DynamicLightEnvironmentComponent

    DECLARE_CLASS(UDynamicLightEnvironmentComponent,ULightEnvironmentComponent,0,Engine)
	// UObject interface.
	virtual void FinishDestroy();
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize(FArchive& Ar);

	// UActorComponent interface.
	virtual void Tick(FLOAT DeltaTime);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	
	// ULightEnvironmentComponent interface.
	virtual void UpdateLight(const ULightComponent* Light);

	/* Forces a full update the of the dynamic and static environments on the next Tick. */
	void ResetEnvironment();

	friend class FDynamicLightEnvironmentState;
};

class UDrawConeComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS DrawConeComponent
    FColor ConeColor;
    FLOAT ConeRadius;
    FLOAT ConeAngle;
    INT ConeSides;
    //## END PROPS DrawConeComponent

    DECLARE_CLASS(UDrawConeComponent,UPrimitiveComponent,0,Engine)
	// UPrimitiveComponent interface.
	/**
	 * Creates a proxy to represent the primitive to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
};

class UDrawLightConeComponent : public UDrawConeComponent
{
public:
    //## BEGIN PROPS DrawLightConeComponent
    //## END PROPS DrawLightConeComponent

    DECLARE_CLASS(UDrawLightConeComponent,UDrawConeComponent,0,Engine)
	/**
	 * Creates a proxy to represent the primitive to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class USceneCaptureComponent : public UActorComponent
{
public:
    //## BEGIN PROPS SceneCaptureComponent
    BITFIELD bEnablePostProcess:1 GCC_BITFIELD_MAGIC;
    BITFIELD bEnableFog:1;
    BITFIELD bUseMainScenePostProcessSettings:1;
    BITFIELD bSkipUpdateIfOwnerOccluded:1;
    BITFIELD bNeedsSceneUpdate:1;
    FColor ClearColor;
    BYTE ViewMode;
    INT SceneLOD;
    FLOAT FrameRate;
    class UPostProcessChain* PostProcess;
    FLOAT MaxUpdateDist;
    FLOAT MaxStreamingUpdateDist;
    FCaptureSceneInfo* CaptureInfo;
    FSceneViewStateInterface* ViewState;
    //## END PROPS SceneCaptureComponent

    void SetFrameRate(FLOAT NewFrameRate);
    DECLARE_FUNCTION(execSetFrameRate)
    {
        P_GET_FLOAT(NewFrameRate);
        P_FINISH;
        SetFrameRate(NewFrameRate);
    }
    DECLARE_ABSTRACT_CLASS(USceneCaptureComponent,UActorComponent,0,Engine)
protected:

	/**
	* Constructor
	*/
	USceneCaptureComponent();

	// UActorComponent interface.

	/**
	* Adds a capture proxy for this component to the scene
	*/
	virtual void Attach();

	/**
	* Removes a capture proxy for thsi component from the scene
	*/
	virtual void Detach( UBOOL bWillReattach = FALSE );

	/**
	* Tick the component to handle updates
	*/
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Sets the ParentToWorld transform the component is attached to.
	 * @param ParentToWorld - The ParentToWorld transform the component is attached to.
	 */
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);

	virtual void FinishDestroy();

public:
	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe() { return NULL; }

	/**
	* Map the various capture view settings to show flags.
	*/
	virtual EShowFlags GetSceneShowFlags();
};

class USceneCapture2DComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCapture2DComponent
    class UTextureRenderTarget2D* TextureTarget;
    FLOAT FieldOfView;
    FLOAT NearPlane;
    FLOAT FarPlane;
    BITFIELD bUpdateMatrices:1;
    FMatrix ViewMatrix;
    FMatrix ProjMatrix;
    //## END PROPS SceneCapture2DComponent

    void SetView(FVector NewLocation,FRotator NewRotation);
    DECLARE_FUNCTION(execSetCaptureParameters);
    DECLARE_FUNCTION(execSetView)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        SetView(NewLocation,NewRotation);
    }
    DECLARE_CLASS(USceneCapture2DComponent,USceneCaptureComponent,0,Engine)
protected:

	// UActorComponent interface

	/**
	* Attach a new 2d capture component
	*/
	virtual void Attach();

	/**
	 * Sets the ParentToWorld transform the component is attached to.
	 * @param ParentToWorld - The ParentToWorld transform the component is attached to.
	 */
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);

public:

	/**
	* Constructor
	*/
	USceneCapture2DComponent() :
		ViewMatrix(FMatrix::Identity),
		ProjMatrix(FMatrix::Identity)
		{}

	/**
	* Update the projection matrix using the fov,near,far,aspect
	*/
	void UpdateProjMatrix();

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class USceneCaptureCubeMapComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCaptureCubeMapComponent
    class UTextureRenderTargetCube* TextureTarget;
    FLOAT NearPlane;
    FLOAT FarPlane;
    FVector WorldLocation;
    //## END PROPS SceneCaptureCubeMapComponent

    DECLARE_CLASS(USceneCaptureCubeMapComponent,USceneCaptureComponent,0,Engine)
protected:

	// UActorComponent interface.

	/**
	* Attach a new cube capture component
	*/
	virtual void Attach();

	/**
	 * Sets the ParentToWorld transform the component is attached to.
	 * @param ParentToWorld - The ParentToWorld transform the component is attached to.
	 */
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);

public:
	
	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class USceneCapturePortalComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCapturePortalComponent
    class UTextureRenderTarget2D* TextureTarget;
    FLOAT ScaleFOV;
    class AActor* ViewDestination;
    //## END PROPS SceneCapturePortalComponent

    DECLARE_FUNCTION(execSetCaptureParameters);
    DECLARE_CLASS(USceneCapturePortalComponent,USceneCaptureComponent,0,Engine)
public:

	// UActorComponent interface

	/**
	* Attach a new portal capture component
	*/
	virtual void Attach();

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class USceneCaptureReflectComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCaptureReflectComponent
    class UTextureRenderTarget2D* TextureTarget;
    FLOAT ScaleFOV;
    //## END PROPS SceneCaptureReflectComponent

    DECLARE_CLASS(USceneCaptureReflectComponent,USceneCaptureComponent,0,Engine)
public:

	// UActorComponent interface

	/**
	* Attach a new reflect capture component
	*/
	virtual void Attach();

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class UWindDirectionalSourceComponent : public UActorComponent
{
public:
    //## BEGIN PROPS WindDirectionalSourceComponent
    FWindSourceSceneProxy* SceneProxy;
    FLOAT Strength;
    FLOAT Phase;
    FLOAT Frequency;
    FLOAT Speed;
    //## END PROPS WindDirectionalSourceComponent

    DECLARE_CLASS(UWindDirectionalSourceComponent,UActorComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void Detach( UBOOL bWillReattach = FALSE );
public:
	
	/**
	 * Creates a proxy to represent the wind source to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	 virtual class FWindSourceSceneProxy* CreateSceneProxy() const;
};

class UDistributionFloatConstant : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatConstant
    FLOAT Constant;
    //## END PROPS DistributionFloatConstant

    DECLARE_CLASS(UDistributionFloatConstant,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};

class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
public:
    //## BEGIN PROPS DistributionFloatParameterBase
    FName ParameterName;
    FLOAT MinInput;
    FLOAT MaxInput;
    FLOAT MinOutput;
    FLOAT MaxOutput;
    BYTE ParamMode;
    //## END PROPS DistributionFloatParameterBase

    DECLARE_ABSTRACT_CLASS(UDistributionFloatParameterBase,UDistributionFloatConstant,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL );
	
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FLOAT& OutFloat) { return false; }

	/**
	 * Return whether or not this distribution can be baked into a FRawDistribution lookup table
	 */
	virtual UBOOL CanBeBaked() const { return FALSE; }
};

class UDistributionFloatConstantCurve : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatConstantCurve
    FInterpCurveFloat ConstantCurve;
    //## END PROPS DistributionFloatConstantCurve

    DECLARE_CLASS(UDistributionFloatConstantCurve,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UDistributionFloatUniform : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatUniform
    FLOAT Min;
    FLOAT Max;
    //## END PROPS DistributionFloatUniform

    DECLARE_CLASS(UDistributionFloatUniform,UDistributionFloat,0,Engine)
	virtual void PostLoad();

	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL );
#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Fill out an array of floats and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 4 floats
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FLOAT* Values);
#endif

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};

class UDistributionFloatUniformCurve : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatUniformCurve
    FInterpCurveVector2D ConstantCurve;
    //## END PROPS DistributionFloatUniformCurve

    DECLARE_CLASS(UDistributionFloatUniformCurve,UDistributionFloat,0,Engine)
	virtual void PostLoad();

	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL );
#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Fill out an array of floats and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 4 floats
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FLOAT* Values);
#endif

	virtual FVector2D GetMinMaxValue(FLOAT F = 0.f, UObject* Data = NULL);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UDistributionVectorConstant : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorConstant
    FVector Constant;
    BITFIELD bLockAxes:1;
    BYTE LockedAxes GCC_BITFIELD_MAGIC;
    //## END PROPS DistributionVectorConstant

    DECLARE_CLASS(UDistributionVectorConstant,UDistributionVector,0,Engine)
	virtual FVector GetValue(FLOAT F = 0.f, UObject* Data = NULL, INT Extreme = 0);

	// UObject interface
	virtual void Serialize(FArchive& Ar);
	
	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
public:
    //## BEGIN PROPS DistributionVectorParameterBase
    FName ParameterName;
    FVector MinInput;
    FVector MaxInput;
    FVector MinOutput;
    FVector MaxOutput;
    BYTE ParamModes[3];
    //## END PROPS DistributionVectorParameterBase

    DECLARE_ABSTRACT_CLASS(UDistributionVectorParameterBase,UDistributionVectorConstant,0,Engine)
	virtual FVector GetValue(FLOAT F = 0.f, UObject* Data = NULL, INT Extreme = 0);
	
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FVector& OutVector) { return false; }

	/**
	 * Return whether or not this distribution can be baked into a FRawDistribution lookup table
	 */
	virtual UBOOL CanBeBaked() const { return FALSE; }
};

class UDistributionVectorConstantCurve : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorConstantCurve
    FInterpCurveVector ConstantCurve;
    BITFIELD bLockAxes:1;
    BYTE LockedAxes GCC_BITFIELD_MAGIC;
    //## END PROPS DistributionVectorConstantCurve

    DECLARE_CLASS(UDistributionVectorConstantCurve,UDistributionVector,0,Engine)
	virtual FVector GetValue(FLOAT F = 0.f, UObject* Data = NULL, INT Extreme = 0);

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorUniform : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorUniform
    FVector Max;
    FVector Min;
    BITFIELD bLockAxes:1;
    BITFIELD bUseExtremes:1;
    BYTE LockedAxes GCC_BITFIELD_MAGIC;
    BYTE MirrorFlags[3];
    //## END PROPS DistributionVectorUniform

    DECLARE_CLASS(UDistributionVectorUniform,UDistributionVector,0,Engine)
	virtual void PostLoad();

	virtual FVector GetValue(FLOAT F = 0.f, UObject* Data = NULL, INT Extreme = 0);
#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Return the lock flags used at runtime to calculate the final value
	 */
	virtual ERawDistributionLockFlags GetLockFlags(INT InIndex) 
	{
		if (InIndex != 0)
		{
			return RDL_None;
		}

		switch (LockedAxes)
		{
		case EDVLF_XY:		return RDL_XY;
		case EDVLF_XZ:		return RDL_XZ;
		case EDVLF_YZ:		return RDL_YZ;
		case EDVLF_XYZ:		return RDL_XYZ;
		}
		return RDL_None;
	}

	/**
	 * Fill out an array of vectors and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 2 vectors
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FVector* Values);
#endif
	
	/** These two functions will retrieve the Min/Max values respecting the Locked and Mirror flags. */
	virtual FVector GetMinValue();
	virtual FVector GetMaxValue();

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorUniformCurve : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorUniformCurve
    FInterpCurveTwoVectors ConstantCurve;
    BITFIELD bLockAxes1:1;
    BITFIELD bLockAxes2:1;
    BITFIELD bUseExtremes:1;
    BYTE LockedAxes[2] GCC_BITFIELD_MAGIC;
    BYTE MirrorFlags[3];
    //## END PROPS DistributionVectorUniformCurve

    DECLARE_CLASS(UDistributionVectorUniformCurve,UDistributionVector,0,Engine)
	virtual void PostLoad();

	virtual FVector		GetValue(FLOAT F = 0.f, UObject* Data = NULL, INT Extreme = 0);
#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Return the lock flags used at runtime to calculate the final value
	 */
	virtual ERawDistributionLockFlags GetLockFlags(INT InIndex) 
	{
		if ((InIndex >= 0) && (InIndex <= 1))
		{
			switch (LockedAxes[InIndex])
			{
			case EDVLF_XY:		return RDL_XY;
			case EDVLF_XZ:		return RDL_XZ;
			case EDVLF_YZ:		return RDL_YZ;
			case EDVLF_XYZ:		return RDL_XYZ;
			}
		}
		return RDL_None;
	}

	/**
	 * Return true if the distribution is a uniform curve
	 */
	virtual UBOOL IsUniformCurve() { return TRUE; }

	/**
	 * Fill out an array of vectors and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 2 vectors
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FVector* Values);
#endif
	virtual FTwoVectors GetMinMaxValue(FLOAT F = 0.f, UObject* Data = NULL);
	
	/** These two functions will retrieve the Min/Max values respecting the Locked and Mirror flags. */
	virtual FVector GetMinValue();
	virtual FVector GetMaxValue();

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
	
	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();

	virtual void	LockAndMirror(FTwoVectors& Val);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

struct FPresetGeneratedPoint
{
    FLOAT KeyIn;
    FLOAT KeyOut;
    BITFIELD TangentsValid:1;
    FLOAT TangentIn;
    FLOAT TangentOut;
    BYTE IntepMode;

    /** Constructors */
    FPresetGeneratedPoint() {}
    FPresetGeneratedPoint(EEventParm)
    {
        appMemzero(this, sizeof(FPresetGeneratedPoint));
    }
};

class UCurveEdPresetCurve : public UObject
{
public:
    //## BEGIN PROPS CurveEdPresetCurve
    FStringNoInit CurveName;
    TArrayNoInit<struct FPresetGeneratedPoint> Points;
    //## END PROPS CurveEdPresetCurve

    DECLARE_CLASS(UCurveEdPresetCurve,UObject,0,Engine)
	UBOOL	StoreCurvePoints(INT CurveIndex, FCurveEdInterface* Distribution);
};

class UDamageType : public UObject
{
public:
    //## BEGIN PROPS DamageType
    FStringNoInit DeathString;
    FStringNoInit FemaleSuicide;
    FStringNoInit MaleSuicide;
    BITFIELD bArmorStops:1;
    BITFIELD bAlwaysGibs:1;
    BITFIELD bNeverGibs:1;
    BITFIELD bLocationalHit:1;
    BITFIELD bCausesBlood:1;
    BITFIELD bCausesBloodSplatterDecals:1;
    BITFIELD bKUseOwnDeathVel:1;
    BITFIELD bCausedByWorld:1;
    BITFIELD bExtraMomentumZ:1;
    BITFIELD bCausesFracture:1;
    BITFIELD bIgnoreDriverDamageMult:1;
    BITFIELD bDontHurtInstigator:1;
    BITFIELD bKRadialImpulse:1;
    BITFIELD bRadialDamageVelChange:1;
    FLOAT GibModifier;
    FLOAT KDamageImpulse;
    FLOAT KDeathVel;
    FLOAT KDeathUpKick;
    FLOAT KImpulseRadius;
    FLOAT RadialDamageImpulse;
    FLOAT VehicleDamageScaling;
    FLOAT VehicleMomentumScaling;
    class UForceFeedbackWaveform* DamagedFFWaveform;
    class UForceFeedbackWaveform* KilledFFWaveform;
    //## END PROPS DamageType

    DECLARE_ABSTRACT_CLASS(UDamageType,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDamageType)
};

class UKillZDamageType : public UDamageType
{
public:
    //## BEGIN PROPS KillZDamageType
    //## END PROPS KillZDamageType

    DECLARE_ABSTRACT_CLASS(UKillZDamageType,UDamageType,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UKillZDamageType)
};

class UDebugManager : public UObject
{
public:
    //## BEGIN PROPS DebugManager
    INT FirstColoredMip;
    //## END PROPS DebugManager

    DECLARE_CLASS(UDebugManager,UObject,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDebugManager)
};

class UEdCoordSystem : public UObject
{
public:
    //## BEGIN PROPS EdCoordSystem
    FMatrix M;
    FStringNoInit Desc;
    //## END PROPS EdCoordSystem

    DECLARE_CLASS(UEdCoordSystem,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UEdCoordSystem)
};

class UFaceFXAnimSet : public UObject
{
public:
    //## BEGIN PROPS FaceFXAnimSet
    class UFaceFXAsset* DefaultFaceFXAsset;
    FPointer InternalFaceFXAnimSet;
    TArrayNoInit<BYTE> RawFaceFXAnimSetBytes;
    TArrayNoInit<BYTE> RawFaceFXMiniSessionBytes;
    TArrayNoInit<class USoundCue*> ReferencedSoundCues;
    INT NumLoadErrors;
    //## END PROPS FaceFXAnimSet

    DECLARE_CLASS(UFaceFXAnimSet,UObject,0,Engine)
	/** Creates a new FaceFX AnimSet for the given FaceFX Asset.  This is only called from within the editor. */
	void CreateFxAnimSet( class UFaceFXAsset* FaceFXAsset );

	/** Get list of FaceFX animations in this AnimSet. Names are in the form GroupName.AnimName.*/
	void GetSequenceNames(TArray<FString>& OutNames);

#if WITH_FACEFX
	/** Returns the internal FaceFX representation of this FaceFX AnimSet. */
	class OC3Ent::Face::FxAnimSet* GetFxAnimSet( void );
#endif

	/** Fixes up the ReferencedSoundCue stuff. */
	void FixupReferencedSoundCues();

	// UObject interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();
	virtual void PostLoad();
	virtual void FinishDestroy();
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();

	/**
	 * Used by various commandlets to purge Editor only data from the object.
	 * 
	 * @param TargetPlatform Platform the object will be saved for (ie PC vs console cooking, etc)
	 */
	virtual void StripData(UE3::EPlatformType TargetPlatform);
};

class UFaceFXAsset : public UObject
{
public:
    //## BEGIN PROPS FaceFXAsset
    class USkeletalMesh* DefaultSkelMesh;
    FPointer FaceFXActor;
    TArrayNoInit<BYTE> RawFaceFXActorBytes;
    TArrayNoInit<BYTE> RawFaceFXSessionBytes;
    TArrayNoInit<class UMorphTargetSet*> PreviewMorphSets;
    TArrayNoInit<class UFaceFXAnimSet*> MountedFaceFXAnimSets;
    TArrayNoInit<class USoundCue*> ReferencedSoundCues;
    INT NumLoadErrors;
    //## END PROPS FaceFXAsset

    void MountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet);
    void UnmountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet);
    DECLARE_FUNCTION(execMountFaceFXAnimSet)
    {
        P_GET_OBJECT(UFaceFXAnimSet,AnimSet);
        P_FINISH;
        MountFaceFXAnimSet(AnimSet);
    }
    DECLARE_FUNCTION(execUnmountFaceFXAnimSet)
    {
        P_GET_OBJECT(UFaceFXAnimSet,AnimSet);
        P_FINISH;
        UnmountFaceFXAnimSet(AnimSet);
    }
    DECLARE_CLASS(UFaceFXAsset,UObject,0,Engine)
	/** Creates a new FaceFX Actor for this FaceFX Asset.  This is only called from within the editor. */
	void CreateFxActor( class USkeletalMesh* SkelMesh );

	/** 
	 *	Get list of FaceFX animations in this Asset. Names are in the form GroupName.AnimName.
	 *	@param bExcludeMountedGroups	If true, do not show animations that are in separate FaceFXAnimSets currently mounted to the Asset.
	 */
	void GetSequenceNames(UBOOL bExcludeMountedGroups, TArray<FString>& OutNames);

#if WITH_FACEFX
	/** Returns the internal FaceFX representation of this FaceFX Asset. */
	class OC3Ent::Face::FxActor* GetFxActor( void );
#endif

	/** Fixes up the ReferencedSoundCue stuff. */
	void FixupReferencedSoundCues();

	// UObject interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();
	virtual void PostLoad();
	virtual void FinishDestroy();
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();

	/**
	 * Used by various commandlets to purge Editor only data from the object.
	 * 
	 * @param TargetPlatform Platform the object will be saved for (ie PC vs console cooking, etc)
	 */
	virtual void StripData(UE3::EPlatformType TargetPlatform);
};

struct FFontImportOptionsData
{
    FStringNoInit FontName;
    FLOAT Height;
    BITFIELD bEnableAntialiasing:1;
    BITFIELD bEnableBold:1;
    BITFIELD bEnableItalic:1;
    BITFIELD bEnableUnderline:1;
    BYTE CharacterSet GCC_BITFIELD_MAGIC;
    FStringNoInit Chars;
    FStringNoInit UnicodeRange;
    FStringNoInit CharsFilePath;
    FStringNoInit CharsFileWildcard;
    BITFIELD bCreatePrintableOnly:1;
    BITFIELD bIncludeASCIIRange:1;
    FLinearColor ForegroundColor;
    BITFIELD bEnableDropShadow:1;
    INT TexturePageWidth;
    INT TexturePageMaxHeight;
    INT XPadding;
    INT YPadding;
    INT ExtendBoxTop;
    INT ExtendBoxBottom;
    INT ExtendBoxRight;
    INT ExtendBoxLeft;
    BITFIELD bEnableLegacyMode:1;
    INT Kerning;

    /** Constructors */
    FFontImportOptionsData() {}
    FFontImportOptionsData(EEventParm)
    {
        appMemzero(this, sizeof(FFontImportOptionsData));
    }
};

class UFontImportOptions : public UObject
{
public:
    //## BEGIN PROPS FontImportOptions
    struct FFontImportOptionsData Data;
    //## END PROPS FontImportOptions

    DECLARE_CLASS(UFontImportOptions,UObject,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UFontImportOptions)
};

struct FFontCharacter
{
    INT StartU;
    INT StartV;
    INT USize;
    INT VSize;
    BYTE TextureIndex;
    INT VerticalOffset;

		// Serializer.
		friend FArchive& operator<<( FArchive& Ar, FFontCharacter& Ch )
		{
			Ar << Ch.StartU << Ch.StartV << Ch.USize << Ch.VSize << Ch.TextureIndex;

			if( Ar.Ver() < VER_FONT_FORMAT_AND_UV_TILING_CHANGES )
			{
				Ch.VerticalOffset = 0;
			}
			else
			{
				Ar << Ch.VerticalOffset;
			}

			return Ar;
		}
	
};

#define UCONST_NULLCHARACTER 127

class UFont : public UObject
{
public:
    //## BEGIN PROPS Font
    TArrayNoInit<struct FFontCharacter> Characters;
    TArrayNoInit<class UTexture2D*> Textures;
    TMap< WORD,WORD > CharRemap;
    INT IsRemapped;
    INT Kerning;
    struct FFontImportOptionsData ImportOptions;
    INT NumCharacters;
    TArrayNoInit<INT> MaxCharHeight;
    //## END PROPS Font

    virtual INT GetResolutionPageIndex(FLOAT HeightTest) const;
    virtual FLOAT GetScalingFactor(FLOAT HeightTest) const;
    virtual FLOAT GetAuthoredViewportHeight(FLOAT ViewportHeight) const;
    virtual FLOAT GetMaxCharHeight() const;
    DECLARE_FUNCTION(execGetResolutionPageIndex)
    {
        P_GET_FLOAT(HeightTest);
        P_FINISH;
        *(INT*)Result=GetResolutionPageIndex(HeightTest);
    }
    DECLARE_FUNCTION(execGetScalingFactor)
    {
        P_GET_FLOAT(HeightTest);
        P_FINISH;
        *(FLOAT*)Result=GetScalingFactor(HeightTest);
    }
    DECLARE_FUNCTION(execGetAuthoredViewportHeight)
    {
        P_GET_FLOAT(ViewportHeight);
        P_FINISH;
        *(FLOAT*)Result=GetAuthoredViewportHeight(ViewportHeight);
    }
    DECLARE_FUNCTION(execGetMaxCharHeight)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMaxCharHeight();
    }
    DECLARE_CLASS(UFont,UObject,0,Engine)
	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return		Size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	// UFont interface
	FORCEINLINE TCHAR RemapChar(TCHAR CharCode) const
	{
		const WORD UCode = ToUnicode(CharCode);
		if ( IsRemapped )
		{
			// currently, fonts are only remapped if they contain Unicode characters.
			// For remapped fonts, all characters in the CharRemap map are valid, so
			// if the characters exists in the map, it's safe to use - otherwise, return
			// the null character (an empty square on windows)
			const WORD* FontChar = CharRemap.Find(UCode);
			if ( FontChar == NULL )
				return UCONST_NULLCHARACTER;

			return (TCHAR)*FontChar;
		}

		// Otherwise, our Characters array will contains 256 members, and is
		// a one-to-one mapping of character codes to array indexes, though
		// not every character is a valid character.
		if ( UCode >= NumCharacters )
		{
			return UCONST_NULLCHARACTER;
		}

		// If the character's size is 0, it's non-printable or otherwise unsupported by
		// the font.  Return the default null character (an empty square on windows).
		if ( Characters(UCode).VSize == 0 && UCode >= TEXT(' ') )
		{
			return UCONST_NULLCHARACTER;
		}

		return CharCode;
	}

	FORCEINLINE void GetCharSize(TCHAR InCh, FLOAT& Width, FLOAT& Height, INT ResolutionPageIndex=0) const
	{
		Width = Height = 0.f;

		const INT Ch = (INT)RemapChar(InCh) + ResolutionPageIndex;
		if( Ch < Characters.Num() )
		{
			const FFontCharacter& Char = Characters(Ch);
			if( Char.TextureIndex < Textures.Num() && Textures(Char.TextureIndex) != NULL )
			{
				Width = Char.USize;
				
				// The height of the character will always be the maximum height of any character in this
				// font.  This ensures consistent vertical alignment of text.  For example, we don't want
				// vertically centered text to visually shift up and down as characters are added to a string.
				// NOTE: This also gives us consistent alignment with fonts generated by the legacy importer.
				const INT MultiFontIndex = Ch / NumCharacters;
				Height = MaxCharHeight( MultiFontIndex );
			}
		}
	}

	/**
	 * Calculate the width of the string using this font's default size and scale.
	 *
	 * @param	Text					the string to size
	 * @param	ResolutionPageIndex		the index for the multi-font page to use; get by calling GetResolutionPageIndex()
	 *
	 * @return	the width (in pixels) of the specified text, or 0 if Text was NULL.
	 */
	FORCEINLINE INT GetStringSize( const TCHAR *Text, INT ResolutionPageIndex=0 ) const
	{
		FLOAT	Width, Height, Total;

		Total = 0.0f;
		while( *Text )
		{
			GetCharSize( *Text++, Width, Height, ResolutionPageIndex );
			Total += Width;
		}

		return( appCeil( Total ) );
	}

	// UObject interface

	/**
	* Serialize the object struct with the given archive
	*
	* @param Ar - archive to serialize with
	*/
	virtual void Serialize( FArchive& Ar );

	/**
	* Called after object and all its dependencies have been serialized.
	*/
	virtual void PostLoad();

    /**
     * Caches the character count and maximum character height for this font (as well as sub-fonts, in the multi-font case)
     */
    virtual void CacheCharacterCountAndMaxCharHeight();
    
	virtual UBOOL IsLocalizedResource();
};

class UMultiFont : public UFont
{
public:
    //## BEGIN PROPS MultiFont
    TArrayNoInit<FLOAT> ResolutionTestTable;
    //## END PROPS MultiFont

    virtual INT GetResolutionTestTableIndex(FLOAT HeightTest) const;
    DECLARE_FUNCTION(execGetResolutionTestTableIndex)
    {
        P_GET_FLOAT(HeightTest);
        P_FINISH;
        *(INT*)Result=GetResolutionTestTableIndex(HeightTest);
    }
    DECLARE_CLASS(UMultiFont,UFont,0,Engine)
	void Serialize( FArchive& Ar );

	/**
	* Called after object and all its dependencies have been serialized.
	*/
	virtual void PostLoad();

    /**
     * Caches the character count and maximum character height for this font (as well as sub-fonts, in the multi-font case)
     */
    virtual void CacheCharacterCountAndMaxCharHeight();
    
	/**
	 * Calulate the index for the texture page containing the multi-font character set to use, based on the specified screen resolution.
	 *
	 * @param	HeightTest	the height (in pixels) of the viewport being rendered to.
	 *
	 * @return	the index of the multi-font "subfont" that most closely matches the specified resolution.  this value is used
	 *			as the value for "ResolutionPageIndex" when calling other font-related methods.
	 */
	virtual INT GetResolutionPageIndex(FLOAT HeightTest) const;

	/**
	 * Determine the height of the mutli-font resolution page which will be used for the specified resolution.
	 *
	 * @param	ViewportHeight	the height (in pixels) of the viewport being rendered to.
	 */
	virtual FLOAT GetAuthoredViewportHeight( float ViewportHeight ) const;

	/**
	 * Calculate the amount of scaling necessary to match the authored resolution for the multi-font level which most closely matches
	 * the specified resolution.
	 *
	 * @param	HeightTest	the height (in pixels) of the viewport being rendered to.
	 *
	 * @return	the percentage scale required to match the size of the multi-font's closest matching subfont.
	 */
	virtual FLOAT GetScalingFactor(FLOAT HeightTest) const;
};

class UForceFeedbackManager : public UObject
{
public:
    //## BEGIN PROPS ForceFeedbackManager
    BITFIELD bAllowsForceFeedback:1;
    BITFIELD bIsPaused:1;
    class UForceFeedbackWaveform* FFWaveform;
    INT CurrentSample;
    FLOAT ElapsedTime;
    FLOAT ScaleAllWaveformsBy;
    //## END PROPS ForceFeedbackManager

    DECLARE_ABSTRACT_CLASS(UForceFeedbackManager,UObject,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(APlayerController)
protected:
	/**
	 * Update the currently playing waveform sample
	 *
	 * @param DeltaTime The amount of elapsed time since the last update
	 */
	virtual void UpdateWaveformData(FLOAT DeltaTime);

public:
	/**
	 * Applies the current waveform data to the gamepad/mouse/etc
	 * This function is platform specific
	 *
	 * @param DeviceID The device that needs updating
	 * @param DeltaTime The amount of elapsed time since the last update
	 */
	virtual void ApplyForceFeedback(INT DeviceID,FLOAT DeltaTime) {}

	/** Clear any vibration going on this device right away. */
	virtual void ForceClearWaveformData(INT DeviceID) {}
};

struct FTitleSafeZoneArea
{
    FLOAT MaxPercentX;
    FLOAT MaxPercentY;
    FLOAT RecommendedPercentX;
    FLOAT RecommendedPercentY;

    /** Constructors */
    FTitleSafeZoneArea() {}
    FTitleSafeZoneArea(EEventParm)
    {
        appMemzero(this, sizeof(FTitleSafeZoneArea));
    }
};

struct FPerPlayerSplitscreenData
{
    FLOAT SizeX;
    FLOAT SizeY;
    FLOAT OriginX;
    FLOAT OriginY;

    /** Constructors */
    FPerPlayerSplitscreenData() {}
    FPerPlayerSplitscreenData(EEventParm)
    {
        appMemzero(this, sizeof(FPerPlayerSplitscreenData));
    }
};

struct FSplitscreenData
{
    TArrayNoInit<struct FPerPlayerSplitscreenData> PlayerData;

    /** Constructors */
    FSplitscreenData() {}
    FSplitscreenData(EEventParm)
    {
        appMemzero(this, sizeof(FSplitscreenData));
    }
};

struct FDebugDisplayProperty
{
    class UObject* Obj;
    FName PropertyName;
    BITFIELD bSpecialProperty:1;

    /** Constructors */
    FDebugDisplayProperty() {}
    FDebugDisplayProperty(EEventParm)
    {
        appMemzero(this, sizeof(FDebugDisplayProperty));
    }
};

struct GameViewportClient_eventPostRender_Parms
{
    class UCanvas* Canvas;
    GameViewportClient_eventPostRender_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventTick_Parms
{
    FLOAT DeltaTime;
    GameViewportClient_eventTick_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventGetSubtitleRegion_Parms
{
    FVector2D MinPos;
    FVector2D MaxPos;
    GameViewportClient_eventGetSubtitleRegion_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventLayoutPlayers_Parms
{
    GameViewportClient_eventLayoutPlayers_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventGameSessionEnded_Parms
{
    GameViewportClient_eventGameSessionEnded_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventInsertInteraction_Parms
{
    class UInteraction* NewInteraction;
    INT InIndex;
    INT ReturnValue;
    GameViewportClient_eventInsertInteraction_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventInit_Parms
{
    FString OutError;
    UBOOL ReturnValue;
    GameViewportClient_eventInit_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventFindPlayerByControllerId_Parms
{
    INT ControllerId;
    class ULocalPlayer* ReturnValue;
    GameViewportClient_eventFindPlayerByControllerId_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventRemovePlayer_Parms
{
    class ULocalPlayer* ExPlayer;
    UBOOL ReturnValue;
    GameViewportClient_eventRemovePlayer_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventCreatePlayer_Parms
{
    INT ControllerId;
    FString OutError;
    UBOOL bSpawnActor;
    class ULocalPlayer* ReturnValue;
    GameViewportClient_eventCreatePlayer_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventHandleInputChar_Parms
{
    INT ControllerId;
    FString Unicode;
    UBOOL ReturnValue;
    GameViewportClient_eventHandleInputChar_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventHandleInputAxis_Parms
{
    INT ControllerId;
    FName Key;
    FLOAT Delta;
    FLOAT DeltaTime;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    GameViewportClient_eventHandleInputAxis_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventHandleInputKey_Parms
{
    INT ControllerId;
    FName Key;
    BYTE EventType;
    FLOAT AmountDepressed;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    GameViewportClient_eventHandleInputKey_Parms(EEventParm)
    {
    }
};
class UGameViewportClient : public UObject, public FViewportClient, public FExec
{
public:
    //## BEGIN PROPS GameViewportClient
    FViewport* Viewport;
    FViewportFrame* ViewportFrame;
    TArray<class UInteraction*> GlobalInteractions;
    class UClass* UIControllerClass;
    class UUIInteraction* UIController;
    class UConsole* ViewportConsole;
    QWORD ShowFlags;
    FStringNoInit LoadingMessage;
    FStringNoInit SavingMessage;
    FStringNoInit ConnectingMessage;
    FStringNoInit PausedMessage;
    FStringNoInit PrecachingMessage;
    BITFIELD bShowTitleSafeZone:1;
    BITFIELD bDisplayingUIMouseCursor:1;
    BITFIELD bUIMouseCaptureOverride:1;
    BITFIELD bDisableWorldRendering:1;
    struct FTitleSafeZoneArea TitleSafeZone;
    TArrayNoInit<struct FSplitscreenData> SplitscreenInfo;
protected:
    BYTE DesiredSplitscreenType;
    BYTE ActiveSplitscreenType;
public:
    BYTE Default2PSplitType;
    BYTE Default3PSplitType;
    TArrayNoInit<struct FDebugDisplayProperty> DebugProperties;
    FScriptDelegate __HandleInputKey__Delegate;
    FScriptDelegate __HandleInputAxis__Delegate;
    FScriptDelegate __HandleInputChar__Delegate;
    //## END PROPS GameViewportClient

    virtual FString ConsoleCommand(const FString& Command);
    void GetViewportSize(FVector2D& out_ViewportSize);
    UBOOL IsFullScreenViewport();
    UBOOL ShouldForceFullscreenViewport() const;
    DECLARE_FUNCTION(execConsoleCommand)
    {
        P_GET_STR(Command);
        P_FINISH;
        *(FString*)Result=ConsoleCommand(Command);
    }
    DECLARE_FUNCTION(execGetViewportSize)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportSize);
        P_FINISH;
        GetViewportSize(out_ViewportSize);
    }
    DECLARE_FUNCTION(execIsFullScreenViewport)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFullScreenViewport();
    }
    DECLARE_FUNCTION(execShouldForceFullscreenViewport)
    {
        P_FINISH;
        *(UBOOL*)Result=ShouldForceFullscreenViewport();
    }
    void eventPostRender(class UCanvas* Canvas)
    {
        GameViewportClient_eventPostRender_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),&Parms);
    }
    void eventTick(FLOAT DeltaTime)
    {
        GameViewportClient_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    void eventGetSubtitleRegion(FVector2D& MinPos,FVector2D& MaxPos)
    {
        GameViewportClient_eventGetSubtitleRegion_Parms Parms(EC_EventParm);
        Parms.MinPos=MinPos;
        Parms.MaxPos=MaxPos;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSubtitleRegion),&Parms);
        MinPos=Parms.MinPos;
        MaxPos=Parms.MaxPos;
    }
    void eventLayoutPlayers()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LayoutPlayers),NULL);
    }
    void eventGameSessionEnded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_GameSessionEnded),NULL);
    }
    INT eventInsertInteraction(class UInteraction* NewInteraction,INT InIndex=-1)
    {
        GameViewportClient_eventInsertInteraction_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.NewInteraction=NewInteraction;
        Parms.InIndex=InIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertInteraction),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInit(FString& OutError)
    {
        GameViewportClient_eventInit_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.OutError=OutError;
        ProcessEvent(FindFunctionChecked(ENGINE_Init),&Parms);
        OutError=Parms.OutError;
        return Parms.ReturnValue;
    }
    class ULocalPlayer* eventFindPlayerByControllerId(INT ControllerId)
    {
        GameViewportClient_eventFindPlayerByControllerId_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_FindPlayerByControllerId),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemovePlayer(class ULocalPlayer* ExPlayer)
    {
        GameViewportClient_eventRemovePlayer_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ExPlayer=ExPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovePlayer),&Parms);
        return Parms.ReturnValue;
    }
    class ULocalPlayer* eventCreatePlayer(INT ControllerId,FString& OutError,UBOOL bSpawnActor)
    {
        GameViewportClient_eventCreatePlayer_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        Parms.OutError=OutError;
        Parms.bSpawnActor=bSpawnActor ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CreatePlayer),&Parms);
        OutError=Parms.OutError;
        return Parms.ReturnValue;
    }
    UBOOL delegateHandleInputChar(INT ControllerId,const FString& Unicode)
    {
        GameViewportClient_eventHandleInputChar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Unicode=Unicode;
        ProcessDelegate(ENGINE_HandleInputChar,&__HandleInputChar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateHandleInputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad)
    {
        GameViewportClient_eventHandleInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.Delta=Delta;
        Parms.DeltaTime=DeltaTime;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_HandleInputAxis,&__HandleInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateHandleInputKey(INT ControllerId,FName Key,BYTE EventType,FLOAT AmountDepressed,UBOOL bGamepad=FALSE)
    {
        GameViewportClient_eventHandleInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.EventType=EventType;
        Parms.AmountDepressed=AmountDepressed;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_HandleInputKey,&__HandleInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UGameViewportClient,UObject,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UEngine)
	// Constructor.
	UGameViewportClient();

	/**
	 * Cleans up all rooted or referenced objects created or managed by the GameViewportClient.  This method is called
	 * when this GameViewportClient has been disassociated with the game engine (i.e. is no longer the engine's GameViewport).
	 */
	virtual void DetachViewportClient();

	/**
	 * Called every frame to allow the game viewport to update time based state.
	 * @param	DeltaTime	The time since the last call to Tick.
	 */
	void Tick( FLOAT DeltaTime );

	// FViewportClient interface.
	virtual void RedrawRequested(FViewport* InViewport) {}

	/**
	 * Routes an input key event received from the viewport to the Interactions array for processing.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	EventType		the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(FViewport* Viewport,INT ControllerId,FName Key,EInputEvent EventType,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Routes an input axis (joystick, thumbstick, or mouse) event received from the viewport to the Interactions array for processing.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this input axis event
	 * @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
	 * @param	Delta			the movement delta for the axis
	 * @param	DeltaTime		the time (in seconds) since the last axis update.
	 *
	 * @return	TRUE to consume the axis event, FALSE to pass it on.
	 */
	virtual UBOOL InputAxis(FViewport* Viewport,INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Routes a character input event (typing) received from the viewport to the Interactions array for processing.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this character input event
	 * @param	Character		the character that was typed
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputChar(FViewport* Viewport,INT ControllerId,TCHAR Character);

	/** Returns the platform specific forcefeedback manager associated with this viewport */
	virtual class UForceFeedbackManager* GetForceFeedbackManager(INT ControllerId);

	/**
	 * @return	the splitscreen type that is currently being used
	 */
	FORCEINLINE ESplitScreenType GetCurrentSplitscreenType() const
	{
		return static_cast<ESplitScreenType>(ActiveSplitscreenType);
	}

	/**
	* Callback to allow game viewport to override the splitscreen settings
	* @param NewSettings - settings to modify
	* @param SplitScreenType - current splitscreen type being used
	*/
	virtual void OverrideSplitscreenSettings(FSystemSettingsData& SplitscreenSettings,ESplitScreenType SplitScreenType) const {}

	/**
 	 * @return whether or not this Controller has Tilt Turned on
	 **/
	virtual UBOOL IsControllerTiltActive( INT ControllerID ) const;

	/**
	 * sets whether or not the the player wants to utilize the Tilt functionality
	 **/
	virtual void SetControllerTiltDesiredIfAvailable( INT ControllerID, UBOOL bActive );

	/**
	 * sets whether or not the Tilt functionality is turned on
	 **/
	virtual void SetControllerTiltActive( INT ControllerID, UBOOL bActive );

	/**
	 * sets whether or not to ONLY use the tilt input controls
	 **/
	virtual void SetOnlyUseControllerTiltInput( INT ControllerID, UBOOL bActive );

	/**
	 * sets whether or not to use the tilt forward and back input controls
	 **/
	virtual void SetUseTiltForwardAndBack( INT ControllerID, UBOOL bActive );

	/**
	 * @return whether or not this Controller has a keyboard available to be used
	 **/
	virtual UBOOL IsKeyboardAvailable( INT ControllerID ) const;

	/**
	 * @return whether or not this Controller has a mouse available to be used
	 **/
	virtual UBOOL IsMouseAvailable( INT ControllerID ) const;


	/**
	 * Changes the value of bUIMouseCaptureOverride.
	 */
	FORCEINLINE void SetMouseCaptureOverride( UBOOL bOverride )
	{
		bUIMouseCaptureOverride = bOverride;
	}

	/**
	 * Retrieves the cursor that should be displayed by the OS
	 *
	 * @param	Viewport	the viewport that contains the cursor
	 * @param	X			the x position of the cursor
	 * @param	Y			the Y position of the cursor
	 *
	 * @return	the cursor that the OS should display
	 */
	virtual EMouseCursor GetCursor( FViewport* Viewport, INT X, INT Y );

	/**
	 * Callback to let the game engine know the UI software mouse cursor is being rendered.
	 *
	 * @param	bVisible	Whether the UI software mouse cursor is visible or not
	 */
	void OnShowUIMouseCursor( UBOOL bVisible );

	virtual void Precache();
	virtual void Draw(FViewport* Viewport,FCanvas* Canvas);
	virtual void LostFocus(FViewport* Viewport);
	virtual void ReceivedFocus(FViewport* Viewport);
	virtual UBOOL IsFocused(FViewport* Viewport);
	virtual void CloseRequested(FViewport* Viewport);
	virtual UBOOL RequiresHitProxyStorage() { return 0; }

	/**
	 * Determines whether this viewport client should receive calls to InputAxis() if the game's window is not currently capturing the mouse.
	 * Used by the UI system to easily receive calls to InputAxis while the viewport's mouse capture is disabled.
	 */
	virtual UBOOL RequiresUncapturedAxisInput() const;

	// FExec interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/**
	 * Set this GameViewportClient's viewport and viewport frame to the viewport specified
	 */
	virtual void SetViewportFrame( FViewportFrame* InViewportFrame );

	/**
	 * Set this GameViewportClient's viewport to the viewport specified
	 */
	virtual void SetViewport( FViewport* InViewportFrame );

	/** sets bDropDetail and other per-frame detail level flags on the current WorldInfo
	 * @param DeltaSeconds - amount of time passed since last tick
	 */
	virtual void SetDropDetail(FLOAT DeltaSeconds);
};

struct FIniLocFileEntry
{
    FStringNoInit Filename;
    BYTE ReadState;

    /** Constructors */
    FIniLocFileEntry() {}
    FIniLocFileEntry(EEventParm)
    {
        appMemzero(this, sizeof(FIniLocFileEntry));
    }
};

struct IniLocPatcher_eventOnReadTitleFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString Filename;
    IniLocPatcher_eventOnReadTitleFileComplete_Parms(EEventParm)
    {
    }
};
class UIniLocPatcher : public UObject
{
public:
    //## BEGIN PROPS IniLocPatcher
    TArrayNoInit<struct FIniLocFileEntry> Files;
    TScriptInterface<class IInterface> SystemInterface;
    FScriptDelegate __OnReadTitleFileComplete__Delegate;
    //## END PROPS IniLocPatcher

    virtual void ProcessIniLocFile(const FString& Filename,TArray<BYTE>& FileData);
    DECLARE_FUNCTION(execProcessIniLocFile)
    {
        P_GET_STR(Filename);
        P_GET_TARRAY_REF(BYTE,FileData);
        P_FINISH;
        ProcessIniLocFile(Filename,FileData);
    }
    void delegateOnReadTitleFileComplete(UBOOL bWasSuccessful,const FString& Filename)
    {
        IniLocPatcher_eventOnReadTitleFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Filename=Filename;
        ProcessDelegate(ENGINE_OnReadTitleFileComplete,&__OnReadTitleFileComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UIniLocPatcher,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UIniLocPatcher)
};

class UCustomPropertyItemHandler : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UCustomPropertyItemHandler,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCustomPropertyItemHandler)
};

class ICustomPropertyItemHandler
{
protected:
	virtual ~ICustomPropertyItemHandler() {}
public:
	typedef UCustomPropertyItemHandler UClassType;
	virtual UObject* GetUObjectInterfaceCustomPropertyItemHandler()=0;
	/**
	 * Determines whether the specified property value matches the current value of the property.  Called after the user
	 * has changed the value of a property handled by a custom property window item.  Is used to determine whether Pre/PostEditChange
	 * should be called for the selected objects.
	 *
	 * @param	InProperty			the property whose value is being checked.
	 * @param	NewPropertyValue	the value to compare against the current value of the property.
	 * @param	ArrayIndex			the array index for the element being compared; only relevant for array properties
	 *
	 * @return	TRUE if NewPropertyValue matches the current value of the property specified, indicating that no effective changes
	 *			were actually made.
	 */
	virtual UBOOL IsCustomPropertyValueIdentical( UProperty* InProperty, const union UPropertyValue& NewPropertyValue, INT ArrayIndex=INDEX_NONE )=0;

	/**
	 * Method for overriding the default behavior of applying property values received from a custom editor property window item.
	 *
	 * @param	InProperty		the property that is being edited
	 * @param	PropertyValue	the value to assign to the property
	 * @param	ArrayIndex		the array index for the element being changed; only relevant for array properties
	 *
	 * @return	TRUE if the property was handled by this object and the property value was successfully applied to the
	 *			object's data.
	 */
	virtual UBOOL EditorSetPropertyValue( UProperty* InProperty, const union UPropertyValue& PropertyValue, INT ArrayIndex=INDEX_NONE )=0;
};

class UOnlineStats : public UObject
{
public:
    //## BEGIN PROPS OnlineStats
    TArrayNoInit<struct FStringIdToStringMapping> ViewIdMappings;
    //## END PROPS OnlineStats

    virtual UBOOL GetViewId(FName ViewName,INT& ViewId);
    virtual FName GetViewName(INT ViewId);
    DECLARE_FUNCTION(execGetViewId)
    {
        P_GET_NAME(ViewName);
        P_GET_INT_REF(ViewId);
        P_FINISH;
        *(UBOOL*)Result=GetViewId(ViewName,ViewId);
    }
    DECLARE_FUNCTION(execGetViewName)
    {
        P_GET_INT(ViewId);
        P_FINISH;
        *(FName*)Result=GetViewName(ViewId);
    }
    DECLARE_ABSTRACT_CLASS(UOnlineStats,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineStats)
};

struct FOnlineStatsColumn
{
    INT ColumnNo;
    struct FSettingsData StatValue;

    /** Constructors */
    FOnlineStatsColumn() {}
    FOnlineStatsColumn(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineStatsColumn));
    }
};

struct FOnlineStatsRow
{
    struct FUniqueNetId PlayerID;
    struct FSettingsData Rank;
    FStringNoInit NickName;
    TArrayNoInit<struct FOnlineStatsColumn> Columns;

    /** Constructors */
    FOnlineStatsRow() {}
    FOnlineStatsRow(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineStatsRow));
    }
};

struct FColumnMetaData
{
    INT Id;
    FName Name;
    FStringNoInit ColumnName;

    /** Constructors */
    FColumnMetaData() {}
    FColumnMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FColumnMetaData));
    }
};

struct OnlineStatsRead_eventOnReadComplete_Parms
{
    OnlineStatsRead_eventOnReadComplete_Parms(EEventParm)
    {
    }
};
class UOnlineStatsRead : public UOnlineStats
{
public:
    //## BEGIN PROPS OnlineStatsRead
    INT ViewId;
    INT SortColumnId;
    TArrayNoInit<INT> ColumnIds;
    INT TotalRowsInView;
    TArrayNoInit<struct FOnlineStatsRow> Rows;
    TArrayNoInit<struct FColumnMetaData> ColumnMappings;
    FStringNoInit ViewName;
    INT TitleId;
    //## END PROPS OnlineStatsRead

    virtual UBOOL GetIntStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,INT& StatValue);
    virtual UBOOL SetIntStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,INT StatValue);
    virtual UBOOL GetFloatStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,FLOAT& StatValue);
    virtual UBOOL SetFloatStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,FLOAT StatValue);
    virtual void AddPlayer(const FString& PlayerName,struct FUniqueNetId PlayerID);
    virtual INT GetRankForPlayer(struct FUniqueNetId PlayerID);
    DECLARE_FUNCTION(execGetIntStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_INT_REF(StatValue);
        P_FINISH;
        *(UBOOL*)Result=GetIntStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execSetIntStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_INT(StatValue);
        P_FINISH;
        *(UBOOL*)Result=SetIntStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execGetFloatStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_FLOAT_REF(StatValue);
        P_FINISH;
        *(UBOOL*)Result=GetFloatStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execSetFloatStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_FLOAT(StatValue);
        P_FINISH;
        *(UBOOL*)Result=SetFloatStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execAddPlayer)
    {
        P_GET_STR(PlayerName);
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_FINISH;
        AddPlayer(PlayerName,PlayerID);
    }
    DECLARE_FUNCTION(execGetRankForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_FINISH;
        *(INT*)Result=GetRankForPlayer(PlayerID);
    }
    void eventOnReadComplete()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnReadComplete),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UOnlineStatsRead,UOnlineStats,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineStatsRead)
};

struct OnlineStatsWrite_eventOnStatsWriteComplete_Parms
{
    OnlineStatsWrite_eventOnStatsWriteComplete_Parms(EEventParm)
    {
    }
};
class UOnlineStatsWrite : public UOnlineStats
{
public:
    //## BEGIN PROPS OnlineStatsWrite
    TArrayNoInit<struct FStringIdToStringMapping> StatMappings;
    TArrayNoInit<struct FSettingsProperty> Properties;
    TArrayNoInit<INT> ViewIds;
    TArrayNoInit<INT> ArbitratedViewIds;
    INT RatingId;
    FScriptDelegate __OnStatsWriteComplete__Delegate;
    //## END PROPS OnlineStatsWrite

    virtual UBOOL GetStatId(FName StatName,INT& StatId);
    virtual FName GetStatName(INT StatId);
    virtual void SetFloatStat(INT StatId,FLOAT Value);
    virtual void SetIntStat(INT StatId,INT Value);
    virtual void IncrementFloatStat(INT StatId,FLOAT IncBy=1.000000);
    virtual void IncrementIntStat(INT StatId,INT IncBy=1);
    virtual void DecrementFloatStat(INT StatId,FLOAT DecBy=1.000000);
    virtual void DecrementIntStat(INT StatId,INT DecBy=1);
    DECLARE_FUNCTION(execGetStatId)
    {
        P_GET_NAME(StatName);
        P_GET_INT_REF(StatId);
        P_FINISH;
        *(UBOOL*)Result=GetStatId(StatName,StatId);
    }
    DECLARE_FUNCTION(execGetStatName)
    {
        P_GET_INT(StatId);
        P_FINISH;
        *(FName*)Result=GetStatName(StatId);
    }
    DECLARE_FUNCTION(execSetFloatStat)
    {
        P_GET_INT(StatId);
        P_GET_FLOAT(Value);
        P_FINISH;
        SetFloatStat(StatId,Value);
    }
    DECLARE_FUNCTION(execSetIntStat)
    {
        P_GET_INT(StatId);
        P_GET_INT(Value);
        P_FINISH;
        SetIntStat(StatId,Value);
    }
    DECLARE_FUNCTION(execIncrementFloatStat)
    {
        P_GET_INT(StatId);
        P_GET_FLOAT_OPTX(IncBy,1.000000);
        P_FINISH;
        IncrementFloatStat(StatId,IncBy);
    }
    DECLARE_FUNCTION(execIncrementIntStat)
    {
        P_GET_INT(StatId);
        P_GET_INT_OPTX(IncBy,1);
        P_FINISH;
        IncrementIntStat(StatId,IncBy);
    }
    DECLARE_FUNCTION(execDecrementFloatStat)
    {
        P_GET_INT(StatId);
        P_GET_FLOAT_OPTX(DecBy,1.000000);
        P_FINISH;
        DecrementFloatStat(StatId,DecBy);
    }
    DECLARE_FUNCTION(execDecrementIntStat)
    {
        P_GET_INT(StatId);
        P_GET_INT_OPTX(DecBy,1);
        P_FINISH;
        DecrementIntStat(StatId,DecBy);
    }
    void delegateOnStatsWriteComplete()
    {
        ProcessDelegate(ENGINE_OnStatsWriteComplete,&__OnStatsWriteComplete__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UOnlineStatsWrite,UOnlineStats,0,Engine)
	/**
	 * Finds the specified stat in the property list
	 *
	 * @param StatId the stat to search for
	 *
	 * @return pointer to the stat or NULL if not found
	 */
	FORCEINLINE FSettingsData* FindStat(INT StatId)
	{
		// Search for the individual stat
		for (INT PropertyIndex = 0; PropertyIndex < Properties.Num(); ++PropertyIndex)
		{
			FSettingsProperty& Stat = Properties(PropertyIndex);
			if (Stat.PropertyId == StatId)
			{
				return &Stat.Data;
			}
		}
		return NULL;
	}
};

struct FCurveEdEntry
{
    class UObject* CurveObject;
    FColor CurveColor;
    FStringNoInit CurveName;
    INT bHideCurve;
    INT bColorCurve;
    INT bFloatingPointColorCurve;
    INT bClamp;
    FLOAT ClampLow;
    FLOAT ClampHigh;

    /** Constructors */
    FCurveEdEntry() {}
    FCurveEdEntry(EEventParm)
    {
        appMemzero(this, sizeof(FCurveEdEntry));
    }
};

struct FCurveEdTab
{
    FStringNoInit TabName;
    TArrayNoInit<struct FCurveEdEntry> Curves;
    FLOAT ViewStartInput;
    FLOAT ViewEndInput;
    FLOAT ViewStartOutput;
    FLOAT ViewEndOutput;

    /** Constructors */
    FCurveEdTab() {}
    FCurveEdTab(EEventParm)
    {
        appMemzero(this, sizeof(FCurveEdTab));
    }
};

class UInterpCurveEdSetup : public UObject
{
public:
    //## BEGIN PROPS InterpCurveEdSetup
    TArrayNoInit<struct FCurveEdTab> Tabs;
    INT ActiveTab;
    //## END PROPS InterpCurveEdSetup

    DECLARE_CLASS(UInterpCurveEdSetup,UObject,0,Engine)
	// UObject interface
	void PostLoad();
	void Serialize(FArchive& Ar);
	
	// InterpCurveEdSetup interface
	static FCurveEdInterface* GetCurveEdInterfacePointer(const FCurveEdEntry& Entry);
	void AddCurveToCurrentTab(UObject* InCurve, const FString& CurveName, const FColor& CurveColor, 
			UBOOL bInColorCurve=false, UBOOL bInFloatingPointColor=false, UBOOL bInClamp=false,
			FLOAT InClampLow=0.f, FLOAT InClampHigh=0.f);
	void RemoveCurve(UObject* InCurve);
	void ReplaceCurve(UObject* RemoveCurve, UObject* AddCurve);
	void CreateNewTab(const FString& InTabName);
	void RemoveTab(const FString& InTabName);
	UBOOL ShowingCurve(UObject* InCurve);

	void ChangeCurveColor(UObject* InCurve, const FColor& CurveColor);
	void ChangeCurveName(UObject* InCurve, const FString& NewCurveName);

	void ResetTabs();
};

class ULevelStreaming : public UObject
{
public:
    //## BEGIN PROPS LevelStreaming
    FName PackageName;
    class ULevel* LoadedLevel;
    FVector Offset;
    FVector OldOffset;
    BITFIELD bIsVisible:1;
    BITFIELD bHasLoadRequestPending:1;
    BITFIELD bHasUnloadRequestPending:1;
    BITFIELD bShouldBeVisibleInEditor:1;
    BITFIELD bBoundingBoxVisible:1;
    BITFIELD bLocked:1;
    BITFIELD bIsFullyStatic:1;
    BITFIELD bShouldBeLoaded:1;
    BITFIELD bShouldBeVisible:1;
    BITFIELD bShouldBlockOnLoad:1;
    BITFIELD bIsRequestingUnloadAndRemoval:1;
    FColor DrawColor;
    TArrayNoInit<class ALevelStreamingVolume*> EditorStreamingVolumes;
    FLOAT MinTimeBetweenVolumeUnloadRequests;
    FLOAT LastVolumeUnloadRequestTime;
    //## END PROPS LevelStreaming

    DECLARE_ABSTRACT_CLASS(ULevelStreaming,UObject,0,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if level should be loaded/ streamed in, FALSE otherwise
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );

	/**
	 * Returns whether this level should be visible/ associated with the world if it is
	 * loaded.
	 * 
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if the level should be visible, FALSE otherwise
	 */
	virtual UBOOL ShouldBeVisible( const FVector& ViewLocation );
	
	// UObject interface.
	virtual void PostEditChange(FEditPropertyChain& PropertyThatChanged);
};

class ULevelStreamingDistance : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingDistance
    FVector Origin;
    FLOAT MaxDistance;
    //## END PROPS LevelStreamingDistance

    DECLARE_CLASS(ULevelStreamingDistance,ULevelStreaming,0,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if level should be loaded/ streamed in, FALSE otherwise
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );
};

class ULevelStreamingKismet : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingKismet
    //## END PROPS LevelStreamingKismet

    DECLARE_CLASS(ULevelStreamingKismet,ULevelStreaming,0,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if level should be loaded/ streamed in, FALSE otherwise
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );

	/**
	 * Returns whether this level should be visible/ associated with the world if it is
	 * loaded.
	 * 
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if the level should be visible, FALSE otherwise
	 */
	virtual UBOOL ShouldBeVisible( const FVector& ViewLocation );
};

class ULevelStreamingPersistent : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingPersistent
    //## END PROPS LevelStreamingPersistent

    DECLARE_CLASS(ULevelStreamingPersistent,ULevelStreaming,0|CLASS_Transient,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation )
	{
		return TRUE;
	}

	/**
	 * Returns whether this level should be visible/ associated with the world if it is
	 * loaded.
	 * 
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE
	 */
	virtual UBOOL ShouldBeVisible( const FVector& ViewLocation )
	{
		return TRUE;
	}
};

class ULightFunction : public UObject
{
public:
    //## BEGIN PROPS LightFunction
    class UMaterialInterface* SourceMaterial;
    FVector Scale;
    //## END PROPS LightFunction

    DECLARE_CLASS(ULightFunction,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ULightFunction)
};

class UMapInfo : public UObject
{
public:
    //## BEGIN PROPS MapInfo
    //## END PROPS MapInfo

    DECLARE_ABSTRACT_CLASS(UMapInfo,UObject,0,Engine)
	virtual void CheckForErrors()
	{
	}
};

class UMaterialExpression : public UObject
{
public:
    //## BEGIN PROPS MaterialExpression
    INT EditorX;
    INT EditorY;
    BITFIELD bRealtimePreview:1;
    BITFIELD bIsParameterExpression:1;
    BITFIELD bShowOutputNameOnPin:1;
    BITFIELD bHidePreviewWindow:1;
    class UMaterialExpressionCompound* Compound;
    FStringNoInit Desc;
    TArrayNoInit<FName> MenuCategories;
    //## END PROPS MaterialExpression

    DECLARE_ABSTRACT_CLASS(UMaterialExpression,UObject,0,Engine)
    DECLARE_WITHIN(UMaterial)
	// UObject interface.

	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// UMaterialExpression interface.

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL) {}

	virtual INT Compile(FMaterialCompiler* Compiler) { return INDEX_NONE; }
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual INT GetHeight() const;
	virtual UBOOL UsesLeftGutter() const;
	virtual UBOOL UsesRightGutter() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 0; }
	
	virtual INT CompilerError(FMaterialCompiler* Compiler, const TCHAR* pcMessage);
};

class UObjectReferencer : public UObject
{
public:
    //## BEGIN PROPS ObjectReferencer
    TArrayNoInit<class UObject*> ReferencedObjects;
    //## END PROPS ObjectReferencer

    DECLARE_CLASS(UObjectReferencer,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UObjectReferencer)
};

struct FPlayerInformation
{
    FStringNoInit ControllerName;
    FStringNoInit PlayerName;
    struct FUniqueNetId UniqueId;
    BITFIELD bIsBot:1;
    INT LastPlayerEventIdx;

    /** Constructors */
    FPlayerInformation() {}
    FPlayerInformation(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerInformation));
    }
};

struct FGameplayEvent
{
    INT PlayerEventAndTarget;
    INT EventNameAndDesc;

    /** Constructors */
    FGameplayEvent() {}
    FGameplayEvent(EEventParm)
    {
        appMemzero(this, sizeof(FGameplayEvent));
    }
};

struct FPlayerEvent
{
    FLOAT EventTime;
    FVector EventLocation;
    INT PlayerIndexAndYaw;
    INT PlayerPitchAndRoll;

    /** Constructors */
    FPlayerEvent() {}
    FPlayerEvent(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerEvent));
    }
};

class UOnlineGameplayEvents : public UObject
{
public:
    //## BEGIN PROPS OnlineGameplayEvents
    TArrayNoInit<struct FPlayerInformation> PlayerList;
    TArrayNoInit<FString> EventDescList;
    TArrayNoInit<FName> EventNames;
    TArrayNoInit<struct FGameplayEvent> GameplayEvents;
    TArrayNoInit<struct FPlayerEvent> PlayerEvents;
    FStringNoInit GameplaySessionStartTime;
    BITFIELD bGameplaySessionInProgress:1;
    FGuid GameplaySessionID;
    //## END PROPS OnlineGameplayEvents

    DECLARE_CLASS(UOnlineGameplayEvents,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineGameplayEvents)
};

struct FConfiguredGameSetting
{
    INT GameSettingId;
    FStringNoInit GameSettingsClassName;
    FStringNoInit URL;
    class UOnlineGameSettings* GameSettings;

    /** Constructors */
    FConfiguredGameSetting() {}
    FConfiguredGameSetting(EEventParm)
    {
        appMemzero(this, sizeof(FConfiguredGameSetting));
    }
};

struct FPlaylist
{
    TArrayNoInit<struct FConfiguredGameSetting> ConfiguredGames;
    INT PlaylistId;
    FStringNoInit LocalizationString;
    TArrayNoInit<INT> ContentIds;
    INT TeamSize;
    INT TeamCount;
    FStringNoInit Name;

    /** Constructors */
    FPlaylist() {}
    FPlaylist(EEventParm)
    {
        appMemzero(this, sizeof(FPlaylist));
    }
};

struct OnlinePlaylistManager_eventOnReadPlaylistComplete_Parms
{
    OnlinePlaylistManager_eventOnReadPlaylistComplete_Parms(EEventParm)
    {
    }
};
class UOnlinePlaylistManager : public UObject
{
public:
    //## BEGIN PROPS OnlinePlaylistManager
    TArrayNoInit<struct FPlaylist> Playlists;
    TArrayNoInit<FString> PlaylistFileNames;
    TArrayNoInit<FName> DatastoresToRefresh;
    INT DownloadCount;
    INT SuccessfulCount;
    FScriptDelegate __OnReadPlaylistComplete__Delegate;
    //## END PROPS OnlinePlaylistManager

    virtual void DetermineFilesToDownload();
    virtual void FinalizePlaylistObjects();
    DECLARE_FUNCTION(execDetermineFilesToDownload)
    {
        P_FINISH;
        DetermineFilesToDownload();
    }
    DECLARE_FUNCTION(execFinalizePlaylistObjects)
    {
        P_FINISH;
        FinalizePlaylistObjects();
    }
    void delegateOnReadPlaylistComplete()
    {
        ProcessDelegate(ENGINE_OnReadPlaylistComplete,&__OnReadPlaylistComplete__Delegate,NULL);
    }
    DECLARE_CLASS(UOnlinePlaylistManager,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Playlist");}

    NO_DEFAULT_CONSTRUCTOR(UOnlinePlaylistManager)
};

struct FOnlineProfileSetting
{
    BYTE Owner;
    struct FSettingsProperty ProfileSetting;

		/** Does nothing (no init version) */
		FOnlineProfileSetting(void)
		{
		}

		/**
		 * Zeroes members
		 */
		FOnlineProfileSetting(EEventParm) :
			Owner(0),
			ProfileSetting(EC_EventParm)
		{
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineProfileSetting(const FOnlineProfileSetting& Other) :
			Owner(0),
			ProfileSetting(EC_EventParm)
		{
			Owner = Other.Owner;
			ProfileSetting = Other.ProfileSetting;
		}

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineProfileSetting& operator=(const FOnlineProfileSetting& Other)
		{
			if (&Other != this)
			{
				Owner = Other.Owner;
				ProfileSetting = Other.ProfileSetting;
			}
			return *this;
		}
	
};

struct OnlineProfileSettings_eventModifyAvailableProfileSettings_Parms
{
    OnlineProfileSettings_eventModifyAvailableProfileSettings_Parms(EEventParm)
    {
    }
};
struct OnlineProfileSettings_eventSetToDefaults_Parms
{
    OnlineProfileSettings_eventSetToDefaults_Parms(EEventParm)
    {
    }
};
struct OnlineProfileSettings_eventNotifySettingValueUpdated_Parms
{
    FName SettingName;
    OnlineProfileSettings_eventNotifySettingValueUpdated_Parms(EEventParm)
    {
    }
};
class UOnlineProfileSettings : public UObject
{
public:
    //## BEGIN PROPS OnlineProfileSettings
    INT VersionNumber;
    TArrayNoInit<INT> ProfileSettingIds;
    TArrayNoInit<struct FOnlineProfileSetting> ProfileSettings;
    TArrayNoInit<struct FOnlineProfileSetting> DefaultSettings;
    TArrayNoInit<struct FIdToStringMapping> OwnerMappings;
    TArrayNoInit<struct FSettingsPropertyPropertyMetaData> ProfileMappings;
    BYTE AsyncState;
    FScriptDelegate __NotifySettingValueUpdated__Delegate;
    //## END PROPS OnlineProfileSettings

    virtual UBOOL GetProfileSettingId(FName ProfileSettingName,INT& ProfileSettingId);
    virtual FName GetProfileSettingName(INT ProfileSettingId);
    virtual FString GetProfileSettingColumnHeader(INT ProfileSettingId);
    INT FindProfileSettingIndex(INT ProfileSettingId) const;
    INT FindProfileMappingIndex(INT ProfileSettingId) const;
    INT FindProfileMappingIndexByName(FName ProfileSettingName) const;
    virtual UBOOL IsProfileSettingIdMapped(INT ProfileSettingId);
    virtual UBOOL GetProfileSettingValue(INT ProfileSettingId,FString& Value,INT ValueMapID=-1);
    virtual FName GetProfileSettingValueName(INT ProfileSettingId);
    virtual UBOOL GetProfileSettingValues(INT ProfileSettingId,TArray<FName>& Values);
    virtual UBOOL GetProfileSettingValueByName(FName ProfileSettingName,FString& Value);
    virtual UBOOL SetProfileSettingValueByName(FName ProfileSettingName,const FString& NewValue);
    virtual UBOOL SetProfileSettingValue(INT ProfileSettingId,const FString& NewValue);
    virtual UBOOL GetProfileSettingValueId(INT ProfileSettingId,INT& ValueId,INT* ListIndex=NULL);
    virtual UBOOL GetProfileSettingValueInt(INT ProfileSettingId,INT& Value);
    virtual UBOOL GetProfileSettingValueFloat(INT ProfileSettingId,FLOAT& Value);
    virtual UBOOL SetProfileSettingValueId(INT ProfileSettingId,INT Value);
    virtual UBOOL SetProfileSettingValueInt(INT ProfileSettingId,INT Value);
    virtual UBOOL SetProfileSettingValueFloat(INT ProfileSettingId,FLOAT Value);
    virtual UBOOL GetProfileSettingDefaultId(INT ProfileSettingId,INT& DefaultId,INT& ListIndex);
    virtual UBOOL GetProfileSettingDefaultInt(INT ProfileSettingId,INT& DefaultInt);
    virtual UBOOL GetProfileSettingDefaultFloat(INT ProfileSettingId,FLOAT& DefaultFloat);
    virtual void AppendVersionToReadIds();
    virtual void AppendVersionToSettings();
    virtual INT GetVersionNumber();
    virtual void SetDefaultVersionNumber();
    virtual UBOOL GetProfileSettingMappingType(INT ProfileId,BYTE& OutType);
    virtual UBOOL GetProfileSettingRange(INT ProfileId,FLOAT& OutMinValue,FLOAT& OutMaxValue,FLOAT& RangeIncrement,BYTE& bFormatAsInt);
    virtual UBOOL SetRangedProfileSettingValue(INT ProfileId,FLOAT NewValue);
    virtual UBOOL GetRangedProfileSettingValue(INT ProfileId,FLOAT& OutValue);
    DECLARE_FUNCTION(execGetProfileSettingId)
    {
        P_GET_NAME(ProfileSettingName);
        P_GET_INT_REF(ProfileSettingId);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingId(ProfileSettingName,ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingName)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(FName*)Result=GetProfileSettingName(ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingColumnHeader)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(FString*)Result=GetProfileSettingColumnHeader(ProfileSettingId);
    }
    DECLARE_FUNCTION(execFindProfileSettingIndex)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(INT*)Result=FindProfileSettingIndex(ProfileSettingId);
    }
    DECLARE_FUNCTION(execFindProfileMappingIndex)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(INT*)Result=FindProfileMappingIndex(ProfileSettingId);
    }
    DECLARE_FUNCTION(execFindProfileMappingIndexByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_FINISH;
        *(INT*)Result=FindProfileMappingIndexByName(ProfileSettingName);
    }
    DECLARE_FUNCTION(execIsProfileSettingIdMapped)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(UBOOL*)Result=IsProfileSettingIdMapped(ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingValue)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_STR_REF(Value);
        P_GET_INT_OPTX(ValueMapID,-1);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValue(ProfileSettingId,Value,ValueMapID);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueName)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(FName*)Result=GetProfileSettingValueName(ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingValues)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_TARRAY_REF(FName,Values);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValues(ProfileSettingId,Values);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_GET_STR_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValueByName(ProfileSettingName,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetProfileSettingValueByName(ProfileSettingName,NewValue);
    }
    DECLARE_FUNCTION(execSetProfileSettingValue)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetProfileSettingValue(ProfileSettingId,NewValue);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueId)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(ValueId);
        P_GET_INT_OPTX_REF(ListIndex,0);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValueId(ProfileSettingId,ValueId,pListIndex ? &ListIndex : NULL);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueInt)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValueInt(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueFloat)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_FLOAT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingValueFloat(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueId)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT(Value);
        P_FINISH;
        *(UBOOL*)Result=SetProfileSettingValueId(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueInt)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT(Value);
        P_FINISH;
        *(UBOOL*)Result=SetProfileSettingValueInt(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueFloat)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_FLOAT(Value);
        P_FINISH;
        *(UBOOL*)Result=SetProfileSettingValueFloat(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execGetProfileSettingDefaultId)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(DefaultId);
        P_GET_INT_REF(ListIndex);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingDefaultId(ProfileSettingId,DefaultId,ListIndex);
    }
    DECLARE_FUNCTION(execGetProfileSettingDefaultInt)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(DefaultInt);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingDefaultInt(ProfileSettingId,DefaultInt);
    }
    DECLARE_FUNCTION(execGetProfileSettingDefaultFloat)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_FLOAT_REF(DefaultFloat);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingDefaultFloat(ProfileSettingId,DefaultFloat);
    }
    DECLARE_FUNCTION(execSetToDefaults)
    {
        P_FINISH;
        SetToDefaults();
    }
    DECLARE_FUNCTION(execAppendVersionToReadIds)
    {
        P_FINISH;
        AppendVersionToReadIds();
    }
    DECLARE_FUNCTION(execAppendVersionToSettings)
    {
        P_FINISH;
        AppendVersionToSettings();
    }
    DECLARE_FUNCTION(execGetVersionNumber)
    {
        P_FINISH;
        *(INT*)Result=GetVersionNumber();
    }
    DECLARE_FUNCTION(execSetDefaultVersionNumber)
    {
        P_FINISH;
        SetDefaultVersionNumber();
    }
    DECLARE_FUNCTION(execGetProfileSettingMappingType)
    {
        P_GET_INT(ProfileId);
        P_GET_BYTE_REF(OutType);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingMappingType(ProfileId,OutType);
    }
    DECLARE_FUNCTION(execGetProfileSettingRange)
    {
        P_GET_INT(ProfileId);
        P_GET_FLOAT_REF(OutMinValue);
        P_GET_FLOAT_REF(OutMaxValue);
        P_GET_FLOAT_REF(RangeIncrement);
        P_GET_BYTE_REF(bFormatAsInt);
        P_FINISH;
        *(UBOOL*)Result=GetProfileSettingRange(ProfileId,OutMinValue,OutMaxValue,RangeIncrement,bFormatAsInt);
    }
    DECLARE_FUNCTION(execSetRangedProfileSettingValue)
    {
        P_GET_INT(ProfileId);
        P_GET_FLOAT(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetRangedProfileSettingValue(ProfileId,NewValue);
    }
    DECLARE_FUNCTION(execGetRangedProfileSettingValue)
    {
        P_GET_INT(ProfileId);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetRangedProfileSettingValue(ProfileId,OutValue);
    }
    void eventModifyAvailableProfileSettings()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ModifyAvailableProfileSettings),NULL);
    }
    void eventSetToDefaults()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetToDefaults),NULL);
    }
    void delegateNotifySettingValueUpdated(FName SettingName)
    {
        OnlineProfileSettings_eventNotifySettingValueUpdated_Parms Parms(EC_EventParm);
        Parms.SettingName=SettingName;
        ProcessDelegate(ENGINE_NotifySettingValueUpdated,&__NotifySettingValueUpdated__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineProfileSettings,UObject,0,Engine)
protected:
	/**
	 * Sets all of the profile settings to their default values
	 */
    virtual void SetToDefaults();

public:
	/**
	 * Finds the specified profile setting
	 *
	 * @param SettingId to search for
	 *
	 * @return pointer to the setting or NULL if not found
	 */
	FORCEINLINE FOnlineProfileSetting* FindSetting(INT SettingId)
	{
		for (INT ProfileIndex = 0; ProfileIndex < ProfileSettings.Num(); ++ProfileIndex)
		{
			FOnlineProfileSetting& Setting = ProfileSettings(ProfileIndex);
			if (Setting.ProfileSetting.PropertyId == SettingId)
			{
				return &Setting;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified property's meta data
	 *
	 * @param PropertyId id of the property to search the meta data for
	 *
	 * @return pointer to the property meta data or NULL if not found
	 */
	FORCEINLINE FSettingsPropertyPropertyMetaData* FindProfileSettingMetaData(INT ProfileId)
	{
		for (INT MetaDataIndex = 0; MetaDataIndex < ProfileMappings.Num(); MetaDataIndex++)
		{
			FSettingsPropertyPropertyMetaData& MetaData = ProfileMappings(MetaDataIndex);
			if (MetaData.Id == ProfileId)
			{
				return &MetaData;
			}
		}
		return NULL;
	}

	/**
	 * Searches for the profile setting by id and sets the value
	 *
	 * @param ProfileSettingId the id of the profile setting to return
	 * @param Value the new value of the setting
	 *
	 * @return true if the profile setting was found and not id mapped, false otherwise
	 */
	template<typename TYPE>
	FORCEINLINE UBOOL SetProfileSettingTypedValue(INT ProfileSettingId,TYPE Value)
	{
		// Search for the profile setting id in the mappings
		for (INT Index = 0; Index < ProfileMappings.Num(); Index++)
		{
			const FSettingsPropertyPropertyMetaData& MetaData = ProfileMappings(Index);
			if (MetaData.Id == ProfileSettingId)
			{
				// Find the profile setting that matches this id
				for (INT Index2 = 0; Index2 < ProfileSettings.Num(); Index2++)
				{
					FOnlineProfileSetting& Setting = ProfileSettings(Index2);
					if (Setting.ProfileSetting.PropertyId == ProfileSettingId)
					{
						// If this is a raw value, then read it
						if (MetaData.MappingType == PVMT_RawValue)
						{
							Setting.ProfileSetting.Data.SetData(Value);
							if ( DELEGATE_IS_SET(NotifySettingValueUpdated) )
							{
								delegateNotifySettingValueUpdated(GetProfileSettingName(ProfileSettingId));
							}
							return TRUE;
						}
						else
						{
							warnf(TEXT("SetProfileSettingValue(%d) did not find a valid MappingType" ),
								ProfileSettingId);
							return FALSE;
						}
					}
				}
			}
		}
		return FALSE;
	}

	/** Finalize the clean up process */
	virtual void FinishDestroy(void);
};

class UPlayer : public UObject, public FExec
{
public:
    //## BEGIN PROPS Player
    class APlayerController* Actor;
    INT CurrentNetSpeed;
    INT ConfiguredInternetSpeed;
    INT ConfiguredLanSpeed;
    FLOAT PP_DesaturationMultiplier;
    FLOAT PP_HighlightsMultiplier;
    FLOAT PP_MidTonesMultiplier;
    FLOAT PP_ShadowsMultiplier;
    //## END PROPS Player

    virtual void SwitchController(class APlayerController* PC);
    DECLARE_FUNCTION(execSwitchController)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_FINISH;
        SwitchController(PC);
    }
    DECLARE_CLASS(UPlayer,UObject,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// FExec interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);
};

struct FCurrentPostProcessVolumeInfo
{
    struct FPostProcessSettings LastSettings;
    class APostProcessVolume* LastVolumeUsed;
    FLOAT BlendStartTime;
    FLOAT LastBlendTime;

    /** Constructors */
    FCurrentPostProcessVolumeInfo() {}
    FCurrentPostProcessVolumeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCurrentPostProcessVolumeInfo));
    }
};

class ULocalPlayer : public UPlayer
{
public:
    //## BEGIN PROPS LocalPlayer
    INT ControllerId;
    class UGameViewportClient* ViewportClient;
    FVector2D Origin;
    FVector2D Size;
    class UPostProcessChain* PlayerPostProcess;
    TArrayNoInit<class UPostProcessChain*> PlayerPostProcessChains;
    FSceneViewStateInterface* ViewState;
    FSynchronizedActorVisibilityHistory ActorVisibilityHistory;
    FVector LastViewLocation;
    struct FCurrentPostProcessVolumeInfo CurrentPPInfo;
    BITFIELD bOverridePostProcessSettings:1;
    BITFIELD bSentSplitJoin:1;
    struct FPostProcessSettings PostProcessSettingsOverride;
    FLOAT PPSettingsOverrideStartBlend;
    //## END PROPS LocalPlayer

    UBOOL SpawnPlayActor(const FString& URL,FString& OutError);
    void SendSplitJoin();
    UBOOL GetActorVisibility(class AActor* TestActor) const;
    virtual UBOOL InsertPostProcessingChain(class UPostProcessChain* InChain,INT InIndex,UBOOL bInClone);
    virtual UBOOL RemovePostProcessingChain(INT InIndex);
    virtual UBOOL RemoveAllPostProcessingChains();
    virtual class UPostProcessChain* GetPostProcessChain(INT InIndex);
    virtual void TouchPlayerPostProcessChain();
    DECLARE_FUNCTION(execSpawnPlayActor)
    {
        P_GET_STR(URL);
        P_GET_STR_REF(OutError);
        P_FINISH;
        *(UBOOL*)Result=SpawnPlayActor(URL,OutError);
    }
    DECLARE_FUNCTION(execSendSplitJoin)
    {
        P_FINISH;
        SendSplitJoin();
    }
    DECLARE_FUNCTION(execGetActorVisibility)
    {
        P_GET_OBJECT(AActor,TestActor);
        P_FINISH;
        *(UBOOL*)Result=GetActorVisibility(TestActor);
    }
    DECLARE_FUNCTION(execInsertPostProcessingChain)
    {
        P_GET_OBJECT(UPostProcessChain,InChain);
        P_GET_INT(InIndex);
        P_GET_UBOOL(bInClone);
        P_FINISH;
        *(UBOOL*)Result=InsertPostProcessingChain(InChain,InIndex,bInClone);
    }
    DECLARE_FUNCTION(execRemovePostProcessingChain)
    {
        P_GET_INT(InIndex);
        P_FINISH;
        *(UBOOL*)Result=RemovePostProcessingChain(InIndex);
    }
    DECLARE_FUNCTION(execRemoveAllPostProcessingChains)
    {
        P_FINISH;
        *(UBOOL*)Result=RemoveAllPostProcessingChains();
    }
    DECLARE_FUNCTION(execGetPostProcessChain)
    {
        P_GET_INT(InIndex);
        P_FINISH;
        *(class UPostProcessChain**)Result=GetPostProcessChain(InIndex);
    }
    DECLARE_FUNCTION(execTouchPlayerPostProcessChain)
    {
        P_FINISH;
        TouchPlayerPostProcessChain();
    }
    DECLARE_CLASS(ULocalPlayer,UPlayer,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UEngine)
	/** Is object propagation currently overriding our view? */
	static UBOOL bOverrideView;
	static FVector OverrideLocation;
	static FRotator OverrideRotation;

	// Constructor.
	ULocalPlayer();

	/**
	 *	Rebuilds the PlayerPostProcessChain.
	 *	This should be called whenever the chain array has items inserted/removed.
	 */
	void RebuildPlayerPostProcessChain();

	/**
	 * Updates the post-process settings for the player's view.
	 * @param ViewLocation - The player's current view location.
	 */
	void UpdatePostProcessSettings(const FVector& ViewLocation);

	/**
	 * Calculate the view settings for drawing from this view actor
	 *
	 * @param	View - output view struct
	 * @param	ViewLocation - output actor location
	 * @param	ViewRotation - output actor rotation
	 * @param	Viewport - current client viewport
	 */
	FSceneView* CalcSceneView( FSceneViewFamily* ViewFamily, FVector& ViewLocation, FRotator& ViewRotation, FViewport* Viewport );

	// UObject interface.
	virtual void FinishDestroy();

	// FExec interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	void ExecMacro( const TCHAR* Filename, FOutputDevice& Ar );

};

class UPostProcessChain : public UObject
{
public:
    //## BEGIN PROPS PostProcessChain
    TArrayNoInit<class UPostProcessEffect*> Effects;
    //## END PROPS PostProcessChain

    DECLARE_CLASS(UPostProcessChain,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPostProcessChain)
};

class UPrimitiveComponentFactory : public UObject
{
public:
    //## BEGIN PROPS PrimitiveComponentFactory
    BITFIELD CollideActors:1;
    BITFIELD BlockActors:1;
    BITFIELD BlockZeroExtent:1;
    BITFIELD BlockNonZeroExtent:1;
    BITFIELD BlockRigidBody:1;
    BITFIELD HiddenGame:1;
    BITFIELD HiddenEditor:1;
    BITFIELD CastShadow:1;
    //## END PROPS PrimitiveComponentFactory

    DECLARE_ABSTRACT_CLASS(UPrimitiveComponentFactory,UObject,0,Engine)
	virtual UBOOL FactoryIsValid() { return 1; }
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter) { return NULL; }
};

class UMeshComponentFactory : public UPrimitiveComponentFactory
{
public:
    //## BEGIN PROPS MeshComponentFactory
    TArrayNoInit<class UMaterialInterface*> Materials;
    //## END PROPS MeshComponentFactory

    DECLARE_ABSTRACT_CLASS(UMeshComponentFactory,UPrimitiveComponentFactory,0,Engine)
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter) { return NULL; }
};

class UStaticMeshComponentFactory : public UMeshComponentFactory
{
public:
    //## BEGIN PROPS StaticMeshComponentFactory
    class UStaticMesh* StaticMesh;
    //## END PROPS StaticMeshComponentFactory

    DECLARE_CLASS(UStaticMeshComponentFactory,UMeshComponentFactory,0,Engine)
	virtual UBOOL FactoryIsValid() { return StaticMesh != NULL && Super::FactoryIsValid(); }
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter);
};

class USavedMove : public UObject
{
public:
    //## BEGIN PROPS SavedMove
    class USavedMove* NextMove;
    FLOAT TimeStamp;
    FLOAT Delta;
    BITFIELD bRun:1;
    BITFIELD bDuck:1;
    BITFIELD bPressedJump:1;
    BITFIELD bDoubleJump:1;
    BITFIELD bPreciseDestination:1;
    BITFIELD bForceRMVelocity:1;
    BYTE DoubleClickMove GCC_BITFIELD_MAGIC;
    BYTE SavedPhysics;
    FVector StartLocation;
    FVector StartRelativeLocation;
    FVector StartVelocity;
    FVector StartFloor;
    FVector SavedLocation;
    FVector SavedVelocity;
    FVector SavedRelativeLocation;
    FVector RMVelocity;
    FVector Acceleration;
    FRotator Rotation;
    class AActor* StartBase;
    class AActor* EndBase;
    FLOAT CustomTimeDilation;
    FLOAT AccelDotThreshold;
    //## END PROPS SavedMove

    DECLARE_CLASS(USavedMove,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USavedMove)
};

class USaveGameSummary : public UObject
{
public:
    //## BEGIN PROPS SaveGameSummary
    FName BaseLevel;
    FStringNoInit Description;
    //## END PROPS SaveGameSummary

    DECLARE_CLASS(USaveGameSummary,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USaveGameSummary)
};

class USkeletalMeshSocket : public UObject
{
public:
    //## BEGIN PROPS SkeletalMeshSocket
    FName SocketName;
    FName BoneName;
    FVector RelativeLocation;
    FRotator RelativeRotation;
    FVector RelativeScale;
    class USkeletalMesh* PreviewSkelMesh;
    class USkeletalMeshComponent* PreviewSkelComp;
    class UStaticMesh* PreviewStaticMesh;
    //## END PROPS SkeletalMeshSocket

    DECLARE_CLASS(USkeletalMeshSocket,UObject,0,Engine)
	/** Utility that returns the current matrix for this socket. Returns false if socket was not valid (bone not found etc) */
	UBOOL GetSocketMatrix(FMatrix& OutMatrix, class USkeletalMeshComponent* SkelComp) const;
};

struct FSoundNodeEditorData
{
    INT NodePosX;
    INT NodePosY;
    friend FArchive& operator<<(FArchive& Ar,FSoundNodeEditorData& MySoundNodeEditorData)
    {
        return Ar << MySoundNodeEditorData.NodePosX << MySoundNodeEditorData.NodePosY;
    }

    /** Constructors */
    FSoundNodeEditorData() {}
    FSoundNodeEditorData(EEventParm)
    {
        appMemzero(this, sizeof(FSoundNodeEditorData));
    }
};

class USoundCue : public UObject
{
public:
    //## BEGIN PROPS SoundCue
    FName SoundGroup;
    class USoundNode* FirstNode;
    TMap< USoundNode*,FSoundNodeEditorData > EditorData;
    FLOAT MaxAudibleDistance;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    FLOAT Duration;
    class UFaceFXAnimSet* FaceFXAnimSetRef;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXAnimName;
    INT MaxConcurrentPlayCount;
    INT CurrentPlayCount;
    //## END PROPS SoundCue

    virtual FLOAT GetCueDuration();
    DECLARE_FUNCTION(execGetCueDuration)
    {
        P_FINISH;
        *(FLOAT*)Result=GetCueDuration();
    }
    DECLARE_CLASS(USoundCue,UObject,0,Engine)
	// UObject interface.
	virtual void Serialize( FArchive& Ar );

	/**
	 * Strip Editor-only data when cooking for console platforms.
	 */
	virtual void StripData( UE3::EPlatformType TargetPlatform );

	/**
	 * Returns a description of this object that can be used as extra information in list views.
	 */
	virtual FString GetDesc( void );

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * @return		Sum of the size of waves referenced by this cue.
	 */
	virtual INT GetResourceSize( void );

	/**
	 *	@param		Platform		EPlatformType indicating the platform of interest...
	 *
	 *	@return		Sum of the size of waves referenced by this cue for the given platform.
	 */
	virtual INT GetResourceSize( UE3::EPlatformType Platform );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );
	
	/** 
	 * Remap sound locations through portals
	 */
	FVector RemapLocationThroughPortals( const FVector& SourceLocation, const FVector& ListenerLocation );
	
	/** 
	 * Calculate the maximum audible distance accounting for every node
	 */
	void CalculateMaxAudibleDistance( void );
	
	/**
	 * Checks to see if a location is audible
	 */
	UBOOL IsAudible( const FVector& SourceLocation, const FVector& ListenerLocation, AActor* SourceActor, INT& bIsOccluded, UBOOL bCheckOcclusion );
	
	/** 
	 * Does a simple range check to all listeners to test hearability
	 */
	UBOOL IsAudibleSimple( FVector* Location );

	/** 
	 * Draw debug information relating to a sound cue
	 */
	void DrawCue( FCanvas* Canvas, TArray<USoundNode *>& SelectedNodes );
	
	/**
	 * Recursively finds all attenuation nodes in a sound node tree
	 */
	void RecursiveFindAttenuation( USoundNode* Node, TArray<class USoundNodeAttenuation*> &OutAttens );

	/**
	 * Recursively finds all waves in a sound node tree.
	 */
	void RecursiveFindWaves( USoundNode* Node, TArray<USoundNodeWave *> &OutWaves );
	
	/** 
	 * Makes sure ogg vorbis data is available for all sound nodes in this cue by converting on demand
	 */
	UBOOL ValidateData( void );
};

struct FRecognisableWord
{
    INT Id;
    FStringNoInit ReferenceWord;
    FStringNoInit PhoneticWord;

    /** Constructors */
    FRecognisableWord() {}
    FRecognisableWord(EEventParm)
    {
        appMemzero(this, sizeof(FRecognisableWord));
    }
};

struct FRecogVocabulary
{
    TArrayNoInit<struct FRecognisableWord> WhoDictionary;
    TArrayNoInit<struct FRecognisableWord> WhatDictionary;
    TArrayNoInit<struct FRecognisableWord> WhereDictionary;
    FStringNoInit VocabName;
    TArrayNoInit<BYTE> VocabData;
    TArrayNoInit<BYTE> WorkingVocabData;

		/**
		 * Creates the work data required for speech recognition
		 */
		UBOOL CreateSpeechRecognitionData( class USpeechRecognition* Owner, FString Folder, INT Index );

		/** 
		 * Loads the created vocabulary after it has been modified by BuildVoice
		 */
		UBOOL LoadSpeechRecognitionData( void );

		/** 
		 * Clear out all the created vocab data
		 */
		void Clear( void );

		/** 
		 * Returns name of created vocab file
		 */
		FString GetVocabName( void );
	
		/** 
		 * Returns address of converted vocab data
		 */
		void* GetVocabData( void );
		
		/** 
		 * Return the number of items in this vocabulary
		 */
		INT GetNumItems( void );
	
		/** 
		 * Return the number of bytes allocated by this resource
		 */
		INT GetResourceSize( void );
	
		/**
		 * Write dictionary to a text file
		 */
		void OutputDictionary( TArrayNoInit<struct FRecognisableWord>& Dictionary, FString& Line );
		UBOOL SaveDictionary( FString& TextFile );
		
		/** 
		 * Looks up the word in the dictionary
		 */		
		FString GetStringFromWordId( DWORD WordId );
		
		/** 
		 * Initialise the recogniser
		 */
		UBOOL InitSpeechRecognition( class USpeechRecognition* Owner );
	
};

struct FRecogUserData
{
    INT ActiveVocabularies;
    TArrayNoInit<BYTE> UserData;

    /** Constructors */
    FRecogUserData() {}
    FRecogUserData(EEventParm)
    {
        appMemzero(this, sizeof(FRecogUserData));
    }
};

class USpeechRecognition : public UObject
{
public:
    //## BEGIN PROPS SpeechRecognition
    FStringNoInit Language;
    FLOAT ConfidenceThreshhold;
    TArrayNoInit<struct FRecogVocabulary> Vocabularies;
    TArrayNoInit<BYTE> VoiceData;
    TArrayNoInit<BYTE> WorkingVoiceData;
    TArrayNoInit<BYTE> UserData;
    struct FRecogUserData InstanceData[4];
    BITFIELD bDirty:1;
    BITFIELD bInitialised:1;
    FPointer FnxVoiceData;
    //## END PROPS SpeechRecognition

    DECLARE_CLASS(USpeechRecognition,UObject,0,Engine)
	/**
	 * Initialise the recogniser
	 */
	UBOOL InitSpeechRecognition( INT MaxLocalTalkers );
	
	/**
	 * Validates a word from a dictionary
	 */
	UBOOL ValidateRecognitionItem( BYTE* UniqueIDs, FRecognisableWord& Word );
	
	/**
	 * Validates the source speech recognition data
	 */
	UBOOL ValidateRecognitionData( void );

	/**
	 * Creates the work data required for speech recognition
	 */
	UBOOL CreateSpeechRecognitionData( void );

	/**
	 * Process input samples
	 */
	DWORD RecogniseSpeech( DWORD UserIndex, SWORD* Samples, INT NumSamples );

	/** 
	 * Select vocabularies
	 */
	UBOOL SelectVocabularies( DWORD LocalTalker, DWORD VocabBitField );

	/**
	 * Returns an array of recognised words based on the grammer rules $who $what [$where]
	 */
	UBOOL GetResult( DWORD UserIndex, TArray<struct FSpeechRecognizedWord>& Words );

	/**
	 * Looks up the word in the dictionary
	 */
	FString GetStringFromWordId( DWORD WordID );

	/**
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc( void );

	/**
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * @return		The size of the asset.
	 */
	virtual INT GetResourceSize( void );

	/**
	 * Callback after any property has changed
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called before the package is saved
	 */
	virtual void PreSave( void );

	/**
	 * Manages any error codes that may have occurred
	 */
	FString HandleError( INT Error );

	/**
	 * Convert the language code to Fonix folder
	 */
	FString GetLanguageFolder( void );
};

class USurface : public UObject
{
public:
    //## BEGIN PROPS Surface
    //## END PROPS Surface

    DECLARE_FUNCTION(execGetSurfaceWidth);
    DECLARE_FUNCTION(execGetSurfaceHeight);
    DECLARE_ABSTRACT_CLASS(USurface,UObject,0,Engine)
	virtual FLOAT GetSurfaceWidth() const PURE_VIRTUAL(USurface::GetSurfaceWidth,return 0;);
	virtual FLOAT GetSurfaceHeight() const PURE_VIRTUAL(USurface::GetSurfaceHeight,return 0;);
};

class UMaterialInterface : public USurface
{
public:
    //## BEGIN PROPS MaterialInterface
    FRenderCommandFence ParentRefFence;
    FStringNoInit PreviewMesh;
    //## END PROPS MaterialInterface

    virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue,INT& OutFontPage);
    virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat& OutValue);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
    virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetVectorCurveParameterValue(FName ParameterName,FInterpCurveVector& OutValue);
    virtual void SetForceMipLevelsToBeResident(FLOAT ForceDuration);
    DECLARE_FUNCTION(execGetMaterial);
    DECLARE_FUNCTION(execGetPhysicalMaterial);
    DECLARE_FUNCTION(execGetFontParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UFont,OutFontValue);
        P_GET_INT_REF(OutFontPage);
        P_FINISH;
        *(UBOOL*)Result=GetFontParameterValue(ParameterName,OutFontValue,OutFontPage);
    }
    DECLARE_FUNCTION(execGetScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetScalarParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetScalarCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveFloat,OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetScalarCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UTexture,OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetTextureParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetVectorParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetVectorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveVector,OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetVectorCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execSetForceMipLevelsToBeResident)
    {
        P_GET_FLOAT(ForceDuration);
        P_FINISH;
        SetForceMipLevelsToBeResident(ForceDuration);
    }
    DECLARE_ABSTRACT_CLASS(UMaterialInterface,USurface,0,Engine)
	/**
	 * Get the material which this is an instance of.
	 * Warning - This is platform dependent!  Do not call GetMaterial(GCurrentMaterialPlatform) and save that reference,
	 * as it will be different depending on the current platform.  Instead call GetMaterial(MSP_BASE) to get the base material and save that.
	 * When getting the material for rendering/checking usage, GetMaterial(GCurrentMaterialPlatform) is fine.
	 *
	 * @param Platform - The platform to get material for.
	 */
	virtual class UMaterial* GetMaterial(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform) PURE_VIRTUAL(UMaterialInterface::GetMaterial,return NULL;);

	/**
	* Tests this material instance for dependency on a given material instance.
	* @param	TestDependency - The material instance to test this instance for dependency upon.
	* @return	True if the material instance is dependent on TestDependency.
	*/
	virtual UBOOL IsDependent(UMaterialInterface* TestDependency) { return FALSE; }

	/**
	* Returns a pointer to the FMaterialRenderProxy used for rendering.
	*
	* @param	Selected	specify TRUE to return an alternate material used for rendering this material when part of a selection
	*						@note: only valid in the editor!
	*
	* @return	The resource to use for rendering this material instance.
	*/
	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected) const PURE_VIRTUAL(UMaterialInterface::GetRenderProxy,return NULL;);

	/**
	* Returns a pointer to the physical material used by this material instance.
	* @return The physical material.
	*/
	virtual UPhysicalMaterial* GetPhysicalMaterial() const PURE_VIRTUAL(UMaterialInterface::GetPhysicalMaterial,return NULL;);

	/**
	 * Gathers the textures used to render the material instance.
	 * @param OutTextures	Upon return contains the textures used to render the material instance.
	 * @param bOnlyAddOnce	Whether to add textures that are sampled multiple times uniquely or not
	 */
	virtual void GetTextures(TArray<UTexture*>& OutTextures,UBOOL bOnlyAddOnce = TRUE) PURE_VIRTUAL(UMaterial::GetTextures,return;);

	/**
	 * Checks if the material can be used with the given usage flag.  
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(EMaterialUsage Usage) PURE_VIRTUAL(UMaterialInterface::CheckMaterialUsage,return FALSE;);

	/**
	* Allocates a new material resource
	* @return	The allocated resource
	*/
	virtual FMaterialResource* AllocateResource() PURE_VIRTUAL(UMaterialInterface::AllocateResource,return NULL;);

	/**
	 * Gets the static permutation resource if the instance has one
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource * GetMaterialResource(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform) { return NULL; }

	/**
	 * Compiles a FMaterialResource on the given platform with the given static parameters
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param MaterialPlatform - The material platform to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	virtual UBOOL CompileStaticPermutation(
		FStaticParameterSet* StaticParameters, 
		FMaterialResource* StaticPermutation, 
		EShaderPlatform Platform, 
		EMaterialShaderPlatform MaterialPlatform,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump)
		PURE_VIRTUAL(UMaterialInterface::CompileStaticPermutation,return FALSE;);

	/**
	* Gets the value of the given static switch parameter
	*
	* @param	ParameterName	The name of the static switch parameter
	* @param	OutValue		Will contain the value of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid) 
		PURE_VIRTUAL(UMaterialInterface::GetStaticSwitchParameterValue,return FALSE;);

	/**
	* Gets the value of the given static component mask parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	R, G, B, A		Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A, FGuid &OutExpressionGuid) 
		PURE_VIRTUAL(UMaterialInterface::GetStaticComponentMaskParameterValue,return FALSE;);

	virtual UBOOL IsFallbackMaterial() { return FALSE; }

	/** @return The material's view relevance. */
	FMaterialViewRelevance GetViewRelevance();

	INT GetWidth() const;
	INT GetHeight() const;

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return GetWidth(); }
	virtual FLOAT GetSurfaceHeight() const { return GetHeight(); }

	// UObject interface
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
};

class UMaterial : public UMaterialInterface
{
public:
    //## BEGIN PROPS Material
    class UPhysicalMaterial* PhysMaterial;
    class UClass* PhysicalMaterial;
    FColorMaterialInput DiffuseColor;
    FScalarMaterialInput DiffusePower;
    FColorMaterialInput SpecularColor;
    FScalarMaterialInput SpecularPower;
    FVectorMaterialInput Normal;
    FColorMaterialInput EmissiveColor;
    FScalarMaterialInput Opacity;
    FScalarMaterialInput OpacityMask;
    FLOAT OpacityMaskClipValue;
    FVector2MaterialInput Distortion;
    BYTE BlendMode;
    BYTE LightingModel;
    FColorMaterialInput CustomLighting;
    FScalarMaterialInput TwoSidedLightingMask;
    FColorMaterialInput TwoSidedLightingColor;
    BITFIELD TwoSided:1;
    BITFIELD bDisableDepthTest:1;
    BITFIELD bAllowFog:1;
    BITFIELD bUseOneLayerDistortion:1;
    BITFIELD bUsedAsLightFunction:1;
    BITFIELD bUsedWithFogVolumes:1;
    BITFIELD bUsedAsSpecialEngineMaterial:1;
    BITFIELD bUsedWithSkeletalMesh:1;
    BITFIELD bUsedWithFracturedMeshes:1;
    BITFIELD bUsedWithParticleSystem:1;
    BITFIELD bUsedWithParticleSprites:1;
    BITFIELD bUsedWithBeamTrails:1;
    BITFIELD bUsedWithParticleSubUV:1;
    BITFIELD bUsedWithFoliage:1;
    BITFIELD bUsedWithSpeedTree:1;
    BITFIELD bUsedWithStaticLighting:1;
    BITFIELD bUsedWithLensFlare:1;
    BITFIELD bUsedWithGammaCorrection:1;
    BITFIELD bUsedWithInstancedMeshParticles:1;
    BITFIELD bUsedWithFluidSurfaces:1;
    BITFIELD bUsedWithDecals:1;
    BITFIELD bUsedWithMaterialEffect:1;
    BITFIELD Wireframe:1;
    BITFIELD bIsFallbackMaterial:1;
    BITFIELD bUsesDistortion:1;
    BITFIELD bIsMasked:1;
    BITFIELD bSupportsSinglePassSHLight:1;
    BITFIELD bIsPreviewMaterial:1;
    class UMaterial* FallbackMaterial;
    FMaterialResource* MaterialResources[2];
    class FDefaultMaterialInstance* DefaultMaterialInstances[2];
    INT EditorX;
    INT EditorY;
    INT EditorPitch;
    INT EditorYaw;
    TArrayNoInit<class UMaterialExpression*> Expressions;
    TArrayNoInit<class UMaterialExpressionComment*> EditorComments;
    TArrayNoInit<class UMaterialExpressionCompound*> EditorCompounds;
    TMap< FName, TArray<UMaterialExpression*> > EditorParameters;
    TArrayNoInit<class UTexture*> ReferencedTextures;
    TArrayNoInit<FName> ContentTags;
    //## END PROPS Material

    DECLARE_CLASS(UMaterial,UMaterialInterface,0,Engine)
	// Constructor.
	UMaterial();

	/** @return TRUE if the material uses distortion */
	UBOOL HasDistortion() const;
	/** @return TRUE if the material uses the scene color texture */
	UBOOL UsesSceneColor() const;

	/**
	 * Allocates a material resource off the heap to be stored in MaterialResource.
	 */
	virtual FMaterialResource* AllocateResource();

	/**
	 * Gathers the textures used to render the material instance.
	 * @param OutTextures	Upon return contains the textures used to render the material instance.
	 * @param bOnlyAddOnce	Whether to add textures that are sampled multiple times uniquely or not
	 */
	virtual void GetTextures(TArray<UTexture*>& OutTextures,UBOOL bOnlyAddOnce = TRUE);

private:

	/** Sets the value associated with the given usage flag. */
	void SetUsageByFlag(EMaterialUsage Usage, UBOOL NewValue);

public:

	/** Gets the name of the given usage flag. */
	FString GetUsageName(EMaterialUsage Usage);

	/** Gets the value associated with the given usage flag. */
	UBOOL GetUsageByFlag(EMaterialUsage Usage);

	/**
	 * Checks if the material can be used with the given usage flag.
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(EMaterialUsage Usage);

	/**
	 * Sets the given usage flag.
	 * @param bNeedsRecompile - TRUE if the material was recompiled for the usage change
	 * @param Usage - The usage flag to set
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	UBOOL SetMaterialUsage(UBOOL &bNeedsRecompile, EMaterialUsage Usage);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of vector parameter names used in this material.
	 */
	virtual void GetAllVectorParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of scalar parameter names used in this material.
	 */
	virtual void GetAllScalarParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of texture parameter names used in this material.
	 */
	virtual void GetAllTextureParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of font parameter names used in this material.
	 */
	virtual void GetAllFontParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of static switch parameter names used in this material.
	 */
	virtual void GetAllStaticSwitchParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of static component mask parameter names used in this material.
	 */
	virtual void GetAllStaticComponentMaskParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * Attempts to find a expression by its GUID.
	 *
	 * @param InGUID GUID to search for.
	 *
	 * @return Returns a expression object pointer if one is found, otherwise NULL if nothing is found.
	 */
	template<typename ExpressionType>
	ExpressionType* FindExpressionByGUID(const FGuid &InGUID)
	{
		ExpressionType* Result = NULL;

		for(INT ExpressionIndex = 0;ExpressionIndex < Expressions.Num();ExpressionIndex++)
		{
			ExpressionType* ExpressionPtr =
				Cast<ExpressionType>(Expressions(ExpressionIndex));

			if(ExpressionPtr && ExpressionPtr->ExpressionGUID.IsValid() && ExpressionPtr->ExpressionGUID==InGUID)
			{
				Result = ExpressionPtr;
				break;
			}
		}

		return Result;
	}

	/**
	 * Builds a string of parameters in the fallback material that do not exist in the base material.
	 * These parameters won't be set by material instances, which get their parameter list from the base material.
	 *
	 * @param ParameterMismatches - string of unmatches material names to populate
	 */
	virtual void GetFallbackParameterInconsistencies(FString &ParameterMismatches);

	// UMaterialInterface interface.

	/**
	 * Get the material which this is an instance of.
	 * Warning - This is platform dependent!  Do not call GetMaterial(GCurrentMaterialPlatform) and save that reference,
	 * as it will be different depending on the current platform.  Instead call GetMaterial(MSP_BASE) to get the base material and save that.
	 * When getting the material for rendering/checking usage, GetMaterial(GCurrentMaterialPlatform) is fine.
	 *
	 * @param Platform - The platform to get material for.
	 */
	virtual UMaterial* GetMaterial(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform);
    virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue,INT& OutFontPage);

	/**
	 * Gets the value of the given static switch parameter
	 *
	 * @param	ParameterName	The name of the static switch parameter
	 * @param	OutValue		Will contain the value of the parameter if successful
	 * @return					True if successful
	 */
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid);

	/**
	 * Gets the value of the given static component mask parameter
	 *
	 * @param	ParameterName	The name of the parameter
	 * @param	R, G, B, A		Will contain the values of the parameter if successful
	 * @return					True if successful
	 */
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A, FGuid &OutExpressionGuid);

	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected) const;
	virtual UPhysicalMaterial* GetPhysicalMaterial() const;

	/**
	 * Compiles a FMaterialResource on the given platform with the given static parameters
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param MaterialPlatform - The material platform to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	UBOOL CompileStaticPermutation(
		FStaticParameterSet* StaticParameters,
		FMaterialResource* StaticPermutation,
		EShaderPlatform Platform,
		EMaterialShaderPlatform MaterialPlatform,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump);

	/**
	 * Compiles material resources for the current platform if the shader map for that resource didn't already exist.
	 *
	 * @param ShaderPlatform - platform to compile for
	 * @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	 * @param bForceAllPlatforms - compile for all platforms, not just the current.
	 */
	void CacheResourceShaders(EShaderPlatform Platform, UBOOL bFlushExistingShaderMaps=FALSE, UBOOL bForceAllPlatforms=FALSE);

	/**
	 * Flushes existing resource shader maps and resets the material resource's Ids.
	 */
	virtual void FlushResourceShaderMaps();

	/**
	 * Gets the material resource based on the input platform
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource * GetMaterialResource(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform);

	/** === USurface interface === */
	/**
	 * Method for retrieving the width of this surface.
	 *
	 * This implementation returns the maximum width of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the width of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceWidth() const;
	/**
	 * Method for retrieving the height of this surface.
	 *
	 * This implementation returns the maximum height of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the height of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	/**
	 * Called before serialization on save to propagate referenced textures. This is not done
	 * during content cooking as the material expressions used to retrieve this information will
	 * already have been dissociated via RemoveExpressions
	 */
	void PreSave();

	virtual void AddReferencedObjects(TArray<UObject*>& ObjectArray);
	virtual void Serialize(FArchive& Ar);
	virtual void PostDuplicate();
	virtual void PostLoad();
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	 * @return		Sum of the size of textures referenced by this material.
	 */
	virtual INT GetResourceSize();

	/**
	 * Used by various commandlets to purge Editor only data from the object.
	 *
	 * @param TargetPlatform Platform the object will be saved for (ie PC vs console cooking, etc)
	 */
	virtual void StripData(UE3::EPlatformType TargetPlatform);

	/**
	* Null any material expression references for this material
	*/
	void RemoveExpressions();

	UBOOL IsFallbackMaterial() { return bIsFallbackMaterial; }

	/**
	 * Goes through every material, flushes the specified types and re-initializes the material's shader maps.
	 */
	static void UpdateMaterialShaders(TArray<FShaderType*>& ShaderTypesToFlush, TArray<FVertexFactoryType*>& VFTypesToFlush);

	/**
	 * Adds an expression node that represents a parameter to the list of material parameters.
	 *
	 * @param	Expression	Pointer to the node that is going to be inserted if it's a parameter type.
	 */
	virtual UBOOL AddExpressionParameter(UMaterialExpression* Expression);

	/**
	 * Removes an expression node that represents a parameter from the list of material parameters.
	 *
	 * @param	Expression	Pointer to the node that is going to be removed if it's a parameter type.
	 */
	virtual UBOOL RemoveExpressionParameter(UMaterialExpression* Expression);

	/**
	 * A parameter with duplicates has to update its peers so that they all have the same value. If this step isn't performed then
	 * the expression nodes will not accurately display the final compiled material.
	 *
	 * @param	Parameter	Pointer to the expression node whose state needs to be propagated.
	 */
	virtual void PropagateExpressionParameterChanges(UMaterialExpression* Parameter);

	/**
	 * This function removes the expression from the editor parameters list (if it exists) and then re-adds it.
	 *
	 * @param	Expression	The expression node that represents a parameter that needs updating.
	 */
	virtual void UpdateExpressionParameterName(UMaterialExpression* Expression);

	/**
	 * Iterates through all of the expression nodes in the material and finds any parameters to put in EditorParameters.
	 */
	virtual void BuildEditorParameterList();

	/**
	 * Returns TRUE if the provided expression parameter has duplicates.
	 *
	 * @param	Expression	The expression parameter to check for duplicates.
	 */
	virtual UBOOL HasDuplicateParameters(UMaterialExpression* Expression);

	/**
	 * Returns TRUE if the provided expression dynamic parameter has duplicates.
	 *
	 * @param	Expression	The expression dynamic parameter to check for duplicates.
	 */
	virtual UBOOL HasDuplicateDynamicParameters(UMaterialExpression* Expression);

	/**
	 * Iterates through all of the expression nodes and fixes up changed names on
	 * matching dynamic parameters when a name change occurs.
	 *
	 * @param	Expression	The expression dynamic parameter.
	 */
	virtual void UpdateExpressionDynamicParameterNames(UMaterialExpression* Expression);

	/**
	 * Gets the name of a parameter.
	 *
	 * @param	Expression	The expression to retrieve the name from.
	 * @param	OutName		The variable that will hold the parameter name.
	 * @return	TRUE if the expression is a parameter with a name.
	 */
	static UBOOL GetExpressionParameterName(UMaterialExpression* Expression, FName& OutName);

	/**
	 * Copies the values of an expression parameter to another expression parameter of the same class.
	 *
	 * @param	Source			The source parameter.
	 * @param	Destination		The destination parameter that will receive Source's values.
	 */
	static UBOOL CopyExpressionParameters(UMaterialExpression* Source, UMaterialExpression* Destination);

	/**
	 * Returns TRUE if the provided expression node is a parameter.
	 *
	 * @param	Expression	The expression node to inspect.
	 */
	static UBOOL IsParameter(UMaterialExpression* Expression);

	/**
	 * Returns TRUE if the provided expression node is a dynamic parameter.
	 *
	 * @param	Expression	The expression node to inspect.
	 */
	static UBOOL IsDynamicParameter(UMaterialExpression* Expression);

	/**
	 * Returns the number of parameter groups. NOTE: The number returned can be innaccurate if you have parameters of different types with the same name.
	 */
	inline INT GetNumEditorParameters() const
	{
		return EditorParameters.Num();
	}

	/**
	 * Empties the editor parameters for the material.
	 */
	inline void EmptyEditorParameters()
	{
		EditorParameters.Empty();
	}

private:
	/**
	 * Sets overrides in the material's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values
	 */
	void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	void ClearStaticParameterOverrides();

public:
	/** Helper functions for text output of properties... */
	static const TCHAR* GetMaterialLightingModelString(EMaterialLightingModel InMaterialLightingModel);
	static EMaterialLightingModel GetMaterialLightingModelFromString(const TCHAR* InMaterialLightingModelStr);
	static const TCHAR* GetBlendModeString(EBlendMode InBlendMode);
	static EBlendMode GetBlendModeFromString(const TCHAR* InBlendModeStr);
};

class UTexture : public USurface
{
public:
    //## BEGIN PROPS Texture
    BITFIELD SRGB:1;
    BITFIELD RGBE:1;
    BITFIELD CompressionNoAlpha:1;
    BITFIELD CompressionNone:1;
    BITFIELD CompressionNoMipmaps:1;
    BITFIELD CompressionFullDynamicRange:1;
    BITFIELD DeferCompression:1;
    BITFIELD NeverStream:1;
    BITFIELD bDitherMipMapAlpha:1;
    BITFIELD bPreserveBorderR:1;
    BITFIELD bPreserveBorderG:1;
    BITFIELD bPreserveBorderB:1;
    BITFIELD bPreserveBorderA:1;
    BITFIELD bNoTiling:1;
    BITFIELD bAsyncResourceReleaseHasBeenStarted:1;
    FLOAT UnpackMin[4];
    FLOAT UnpackMax[4];
    FByteBulkData SourceArt;
    BYTE CompressionSettings;
    BYTE Filter;
    BYTE LODGroup;
    INT LODBias;
    INT CachedCombinedLODBias;
    FStringNoInit SourceFilePath;
    FStringNoInit SourceFileTimestamp;
    FTextureResource* Resource;
    //## END PROPS Texture

    DECLARE_ABSTRACT_CLASS(UTexture,USurface,0,Engine)
	/**
	 * Resets the resource for the texture.
	 */
	void ReleaseResource();

	/**
	 * Creates a new resource for the texture, and updates any cached references to the resource.
	 */
	virtual void UpdateResource();

	/**
	 * Implemented by subclasses to create a new resource for the texture.
	 */
	virtual FTextureResource* CreateResource() PURE_VIRTUAL(UTexture::CreateResource,return NULL;);

	/**
	 * Returns the cached combined LOD bias based on texture LOD group and LOD bias.
	 *
	 * @return	LOD bias
	 */
	FORCEINLINE INT GetCachedLODBias()
	{
		return CachedCombinedLODBias;
	}

	/**
	 * Compresses the texture based on the compression settings. Make sure to update UTexture::PostEditChange
	 * if you add any variables that might require recompression.
	 */
	virtual void Compress();

	/**
	 * @return The material value type of this texture.
	 */
	virtual EMaterialValueType GetMaterialType() PURE_VIRTUAL(UTexture::GetMaterialType,return MCT_Texture;);

	/**
	 * Updates the streaming status of the texture and performs finalization when appropriate. The function returns
	 * TRUE while there are pending requests in flight and updating needs to continue.
	 *
	 * @return	TRUE if there are requests in flight, FALSE otherwise
	 */
	virtual UBOOL UpdateStreamingStatus()
	{
		return FALSE;
	}

	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PreSave();
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	 * Used by various commandlets to purge Editor only data from the object.
	 * 
	 * @param TargetPlatform Platform the object will be saved for (ie PC vs console cooking, etc)
	 */
	virtual void StripData(UE3::EPlatformType TargetPlatform);

	/** Helper functions for text output of texture properties... */
	static const TCHAR* GetCompressionSettingsString(TextureCompressionSettings InCompressionSettings);
	static TextureCompressionSettings GetCompressionSettingsFromString(const TCHAR* InCompressionSettingsStr);
	static const TCHAR* GetPixelFormatString(EPixelFormat InPixelFormat);
	static EPixelFormat GetPixelFormatFromString(const TCHAR* InPixelFormatStr);
	static const TCHAR* GetTextureFilterString(TextureFilter InFilter);
	static TextureFilter GetTextureFilterFromString(const TCHAR* InFilterStr);
	static const TCHAR* GetTextureAddressString(TextureAddress InAddress);
	static TextureAddress GetTextureAddressFromString(const TCHAR* InAddressStr);
	static const TCHAR* GetTextureGroupString(TextureGroup InGroup);
	static TextureGroup GetTextureGroupFromString(const TCHAR* InGroupStr);
};

struct FTexture2DMipMap
{
    FTextureMipBulkData Data;
    INT SizeX;
    INT SizeY;

		/**
		 * Special serialize function passing the owning UObject along as required by FUnytpedBulkData
		 * serialization.
		 *
		 * @param	Ar		Archive to serialize with
		 * @param	Owner	UObject this structure is serialized within
		 * @param	MipIdx	Current mip being serialized
		 */
		void Serialize( FArchive& Ar, UObject* Owner, INT MipIdx );
	
};

class UTexture2D : public UTexture
{
public:
    //## BEGIN PROPS Texture2D
    TIndirectArray<FTexture2DMipMap> Mips;
    INT SizeX;
    INT SizeY;
    BYTE Format;
    BYTE AddressX;
    BYTE AddressY;
    BITFIELD bIsStreamable:1 GCC_BITFIELD_MAGIC;
    BITFIELD bHasCancelationPending:1;
    BITFIELD bHasBeenLoadedFromPersistentArchive:1;
    BITFIELD bForceMiplevelsToBeResident:1;
    BITFIELD bGlobalForceMipLevelsToBeResident:1;
    FLOAT ForceMipLevelsToBeResidentTimestamp;
    FName TextureFileCacheName;
    FGuid TextureFileCacheGuid;
    INT RequestedMips;
    INT ResidentMips;
    mutable FThreadSafeCounter PendingMipChangeRequestStatus;
private:
    TLinkedList<UTexture2D*> StreamableTexturesLink;
public:
    INT MipTailBaseIdx;
    FTexture2DResourceMem* ResourceMem;
    INT FirstResourceMemMip;
    //## END PROPS Texture2D

    void SetForceMipLevelsToBeResident(FLOAT Seconds);
    DECLARE_FUNCTION(execSetForceMipLevelsToBeResident)
    {
        P_GET_FLOAT(Seconds);
        P_FINISH;
        SetForceMipLevelsToBeResident(Seconds);
    }
    DECLARE_FUNCTION(execCreate);
    DECLARE_CLASS(UTexture2D,UTexture,0,Engine)
	// Static prviate variables.
private:
	/** First streamable texture link. Not handled by GC as BeginDestroy automatically unlinks.	*/
	static TLinkedList<UTexture2D*>* FirstStreamableLink;
	/** Current streamable texture link for iteration over textures. Not handled by GC as BeginDestroy automatically unlinks. */
	static TLinkedList<UTexture2D*>* CurrentStreamableLink;
	/** Number of streamable textures. */
	static INT NumStreamableTextures;

public:

	// UObject interface.
	virtual void InitializeIntrinsicPropertyValues();
	virtual void Serialize(FArchive& Ar);
#if !CONSOLE
	// SetLinker is only virtual on consoles.
	virtual void SetLinker( ULinkerLoad* L, INT I );
#endif
	/**
	 * Called after the garbage collection mark phase on unreachable objects.
	 */
	virtual void BeginDestroy();
	/**
 	 * Called after object and all its dependencies have been serialized.
	 */
	virtual void PostLoad();
	/**
 	 * Called after object has been duplicated.
	 */
	virtual void PostDuplicate();

	/** 
	 * Generates a GUID for the texture if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void GenerateTextureFileCacheGUID(UBOOL bForceGeneration=FALSE);

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface.
	virtual FTextureResource* CreateResource();
	virtual void Compress();
	virtual EMaterialValueType GetMaterialType() { return MCT_Texture2D; }
	/**
	 * Creates a new resource for the texture, and updates any cached references to the resource.
	 */
	virtual void UpdateResource();

	// UTexture2D interface.
	void Init(UINT InSizeX,UINT InSizeY,EPixelFormat InFormat);
	void LegacySerialize(FArchive& Ar);

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Returns the size of this texture in bytes if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Number of toplevel mips to calculate size for
	 * @return	size of top mipcount mips in bytes
	 */
	INT GetSize( INT MipCount ) const;

	/**
	 * Returns the size of this texture in bytes on 360 if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Number of toplevel mips to calculate size for
	 * @return	size of top mipcount mips in bytes
	 */
	INT Get360Size( INT MipCount ) const;

	/**
	 * Returns whether the texture is ready for streaming aka whether it has had InitRHI called on it.
	 *
	 * @return TRUE if initialized and ready for streaming, FALSE otherwise
	 */
	UBOOL IsReadyForStreaming();

	/**
	 * Updates the streaming status of the texture and performs finalization when appropriate. The function returns
	 * TRUE while there are pending requests in flight and updating needs to continue.
	 *
	 * @return	TRUE if there are requests in flight, FALSE otherwise
	 */
	virtual UBOOL UpdateStreamingStatus();

	/**
	 * Tries to cancel a pending mip change request. Requests cannot be canceled if they are in the
	 * finalization phase.
	 *
	 * @param	TRUE if cancelation was successful, FALSE otherwise
	 */
	UBOOL CancelPendingMipChangeRequest();

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	/**
	 * Returns whether miplevels should be forced resident.
	 *
	 * @return TRUE if either transient or serialized override requests miplevels to be resident, FALSE otherwise
	 */
	UBOOL ShouldMipLevelsBeForcedResident() const
	{
		return bGlobalForceMipLevelsToBeResident || bForceMiplevelsToBeResident;
	}

	/**
	 * Whether all miplevels of this texture have been fully streamed in, LOD settings permitting.
	 */
	UBOOL IsFullyStreamedIn();

	/**
	 * Returns a reference to the global list of streamable textures.
	 *
	 * @return reference to global list of streamable textures.
	 */
	static TLinkedList<UTexture2D*>*& GetStreamableList();

	/**
	 * Returns a reference to the current streamable link.
	 *
	 * @return reference to current streamable link
	 */
	static TLinkedList<UTexture2D*>*& GetCurrentStreamableLink();

	/**
	 * Links texture to streamable list and updates streamable texture count.
	 */
	void LinkStreaming();

	/**
	 * Unlinks texture from streamable list, resets CurrentStreamableLink if it matches
	 * StreamableTexturesLink and also updates the streamable texture count.
	 */
	void UnlinkStreaming();
	
	/**
	 * Returns the number of streamable textures, maintained by link/ unlink code
	 *
	 * @return	Number of streamable textures
	 */
	static INT GetNumStreamableTextures();

	/**
	 * Cancels any pending texture streaming actions if possible.
	 * Returns when no more async loading requests are in flight.
	 */
	static void CancelPendingTextureStreaming();

	/**
	* Initialize the GPU resource memory that will be used for the bulk mip data
	* This memory is allocated based on the SizeX,SizeY of the texture and the first mip used
	*
	* @param FirstMipIdx first mip that will be resident	
	* @return FTexture2DResourceMem container for the allocated GPU resource mem
	*/
	class FTexture2DResourceMem* InitResourceMem(INT FirstMipIdx);
};

class UTextureFlipBook : public UTexture2D, public FTickableObject
{
public:
    //## BEGIN PROPS TextureFlipBook
    FLOAT TimeIntoMovie;
    FLOAT TimeSinceLastFrame;
    FLOAT HorizontalScale;
    FLOAT VerticalScale;
    BITFIELD bPaused:1;
    BITFIELD bStopped:1;
    BITFIELD bLooping:1;
    BITFIELD bAutoPlay:1;
    INT HorizontalImages;
    INT VerticalImages;
    BYTE FBMethod;
    FLOAT FrameRate;
    FLOAT FrameTime;
    INT CurrentRow;
    INT CurrentColumn;
    FLOAT RenderOffsetU;
    FLOAT RenderOffsetV;
    FRenderCommandFence* ReleaseResourcesFence;
    //## END PROPS TextureFlipBook

    virtual void Play();
    virtual void Pause();
    virtual void Stop();
    virtual void SetCurrentFrame(INT Row,INT Col);
    DECLARE_FUNCTION(execPlay)
    {
        P_FINISH;
        Play();
    }
    DECLARE_FUNCTION(execPause)
    {
        P_FINISH;
        Pause();
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        Stop();
    }
    DECLARE_FUNCTION(execSetCurrentFrame)
    {
        P_GET_INT(Row);
        P_GET_INT(Col);
        P_FINISH;
        SetCurrentFrame(Row,Col);
    }
    DECLARE_CLASS(UTextureFlipBook,UTexture2D,0,Engine)
	// FTickableObject interface

	/**
	 * Updates the movie texture if necessary by requesting a new frame from the decoder taking into account both
	 * game and movie framerate.
	 *
	 * @param DeltaTime		Time (in seconds) that has passed since the last time this function has been called.
	 */
	virtual void Tick( FLOAT DeltaTime );

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}
	
	// UObject interface.
	/**
	 * Initializes property values for intrinsic classes.  It is called immediately after the class default object
	 * is initialized against its archetype, but before any objects of this class are created.
	 */
	void InitializeIntrinsicPropertyValues();
	/**
	 * Serializes the compressed movie data.
	 *
	 * @param Ar	FArchive to serialize RawData with.
	 */
	virtual void Serialize(FArchive& Ar);
	
	/**
	 * Postload initialization of movie texture. Creates decoder object and retriever first frame.
	 */
	virtual void PostLoad();
	/**
	 * PostEditChange - gets called whenever a property is either edited via the Editor or the "set" console command.
	 *
	 * @param PropertyThatChanged	Property that changed
	 */
	virtual void PostEditChange(UProperty* /*PropertyThatChanged*/);

	/**
	 * Called after the garbage collection mark phase on unreachable objects.
	 */
	virtual void BeginDestroy();
	/**
	 * Called to check if the object is ready for FinishDestroy.  This is called after BeginDestroy to check the completion of the
	 * potentially asynchronous object cleanup.
	 * @return True if the object's asynchronous cleanup has completed and it is ready for FinishDestroy to be called.
	 */
	virtual UBOOL IsReadyForFinishDestroy();
	/**
	 * Destroy - gets called by ConditionalDestroy from within destructor. We need to ensure that the decoder 
	 * doesn't have any references to RawData before destructing it.
	 */
	virtual void FinishDestroy();

	// Thumbnail interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// FlipBook texture interface...
	void			SetStartFrame();
	virtual UBOOL	IsAFlipBook()	{ return true;	}
	virtual void	GetFlipBookOffset(FVector& Offset)
	{
		Offset.X = CurrentColumn	* HorizontalScale;
		Offset.Y = CurrentRow		* VerticalScale;
	}
	virtual void	GetFlipBookScale(FVector& Scale)
	{
		Scale.X	= HorizontalScale;
		Scale.Y = VerticalScale;
	}

	/**
	 *	Retrieve the UV offset
	 *
	 *	@param	UVOffset	FVector2D to fill in with the offset
	 */
	void GetTextureOffset(FVector2D& UVOffset);
	/**
	 *	Retrieve the UV offset
	 *
	 *	@param	UVOffset	FLinearColor to fill in with the offset
	 */
	void GetTextureOffset_RenderThread(FLinearColor& UVOffset);

	/**	
	 *	Set the texture offset (pass it to the render thread)
	 */
	void SetTextureOffset();
	/**
	 *	Set the texture offset in the render thread
	 *
	 *	@param	UOffset		The value to set for the U offset
	 *	@param	VOffset		The value to set for the V offset
	 */
	void SetTextureOffset_RenderThread(FLOAT UOffset, FLOAT VOffset);
};

struct FSourceTexture2DRegion
{
    INT OffsetX;
    INT OffsetY;
    INT SizeX;
    INT SizeY;
    class UTexture2D* Texture2D;

    /** Constructors */
    FSourceTexture2DRegion() {}
    FSourceTexture2DRegion(EEventParm)
    {
        appMemzero(this, sizeof(FSourceTexture2DRegion));
    }
};

class UTexture2DComposite : public UTexture
{
public:
    //## BEGIN PROPS Texture2DComposite
    TArrayNoInit<struct FSourceTexture2DRegion> SourceRegions;
    INT MaxTextureSize;
    //## END PROPS Texture2DComposite

    UBOOL SourceTexturesFullyStreamedIn();
    void UpdateCompositeTexture(INT NumMipsToGenerate);
    void ResetSourceRegions();
    DECLARE_FUNCTION(execSourceTexturesFullyStreamedIn)
    {
        P_FINISH;
        *(UBOOL*)Result=SourceTexturesFullyStreamedIn();
    }
    DECLARE_FUNCTION(execUpdateCompositeTexture)
    {
        P_GET_INT(NumMipsToGenerate);
        P_FINISH;
        UpdateCompositeTexture(NumMipsToGenerate);
    }
    DECLARE_FUNCTION(execResetSourceRegions)
    {
        P_FINISH;
        ResetSourceRegions();
    }
    DECLARE_CLASS(UTexture2DComposite,UTexture,0,Engine)
private:
	/**
	 * Calculate the first available mip from a set of textures based on the LOD bias for each
	 * texture.
	 *
	 * @return first available mip index from the source regions
	 */
	INT GetFirstAvailableMipIndex(const TArray<FSourceTexture2DRegion>& ValidRegions);

	/**
	* Locks each region of the source RHI texture 2d resources and copies the block of data
	* for that region to the destination mip buffer. This is done for all mip levels.
	*
	* (Only called by the rendering thread)
	*/
	void RenderThread_CopyRectRegions(const TArray<FSourceTexture2DRegion>& ValidRegions);

	// UTexture interface.
	virtual FTextureResource* CreateResource();
	virtual EMaterialValueType GetMaterialType()  { return MCT_Texture2D; }

	// USurface interface.
	virtual FLOAT GetSurfaceWidth() const;
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	virtual void Serialize(FArchive& Ar);
};

class UTexture2DDynamic : public UTexture
{
public:
    //## BEGIN PROPS Texture2DDynamic
    INT SizeX;
    INT SizeY;
    BYTE Format;
    INT NumMips;
    BITFIELD bIsResolveTarget:1;
    //## END PROPS Texture2DDynamic

    void Init(INT InSizeX,INT InSizeY,BYTE InFormat=2,UBOOL InIsResolveTarget=FALSE);
    DECLARE_FUNCTION(execInit)
    {
        P_GET_INT(InSizeX);
        P_GET_INT(InSizeY);
        P_GET_BYTE_OPTX(InFormat,2);
        P_GET_UBOOL_OPTX(InIsResolveTarget,FALSE);
        P_FINISH;
        Init(InSizeX,InSizeY,InFormat,InIsResolveTarget);
    }
    DECLARE_FUNCTION(execCreate);
    DECLARE_CLASS(UTexture2DDynamic,UTexture,0,Engine)
public:
	// UTexture interface.
	virtual FTextureResource* CreateResource();
	virtual EMaterialValueType GetMaterialType()  { return MCT_Texture2D; }

	// USurface interface.
	virtual FLOAT GetSurfaceWidth() const;
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	virtual void Serialize(FArchive& Ar);
};

class UTextureCube : public UTexture
{
public:
    //## BEGIN PROPS TextureCube
    INT SizeX;
    INT SizeY;
    BYTE Format;
    INT NumMips;
    BITFIELD bIsCubemapValid:1;
    class UTexture2D* FacePosX;
    class UTexture2D* FaceNegX;
    class UTexture2D* FacePosY;
    class UTexture2D* FaceNegY;
    class UTexture2D* FacePosZ;
    class UTexture2D* FaceNegZ;
    //## END PROPS TextureCube

    DECLARE_CLASS(UTextureCube,UTexture,0,Engine)
	// UObject interface.
	void InitializeIntrinsicPropertyValues();
	virtual void Serialize(FArchive& Ar);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostLoad();

	// Thumbnail interface.
	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface
	virtual FTextureResource* CreateResource();
	virtual EMaterialValueType GetMaterialType() { return MCT_TextureCube; }

	// UTextureCube interface

	/**
	 * Validates cubemap which entails verifying that all faces are non-NULL and share the same format, width, height and number of
	 * miplevels. The results are cached in the respective mirrored properties and bIsCubemapValid is set accordingly.
	 */
	void Validate();

	/**
	 * Returns the face associated with the passed in index.
	 *
	 * @param	FaceIndex	index of face to return
	 * @return	texture object associated with passed in face index
	 */
	UTexture2D* GetFace( INT FaceIndex ) const;

	/**
	 * Sets the face associated with the passed in index.
	 *
	 * @param	FaceIndex	index of face to return
	 * @param	FaceTexture	texture object to associate with passed in face index
	 */
	void SetFace(INT FaceIndex,UTexture2D* FaceTexture);

	/**
	 * Returns the size of this texture in bytes on 360 if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Number of toplevel mips to calculate size for
	 * @return	size of top mipcount mips in bytes
	 */
	INT Get360Size( INT MipCount ) const;
};

class UTextureMovie : public UTexture
{
public:
    //## BEGIN PROPS TextureMovie
    INT SizeX;
    INT SizeY;
    BYTE Format;
    BYTE AddressX;
    BYTE AddressY;
    BYTE MovieStreamSource;
    class UClass* DecoderClass;
    class UCodecMovie* Decoder;
    BITFIELD Paused:1;
    BITFIELD Stopped:1;
    BITFIELD Looping:1;
    BITFIELD AutoPlay:1;
    FByteBulkData Data;
    FRenderCommandFence* ReleaseCodecFence;
    //## END PROPS TextureMovie

    virtual void Play();
    virtual void Pause();
    virtual void Stop();
    DECLARE_FUNCTION(execPlay)
    {
        P_FINISH;
        Play();
    }
    DECLARE_FUNCTION(execPause)
    {
        P_FINISH;
        Pause();
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        Stop();
    }
    DECLARE_CLASS(UTextureMovie,UTexture,0,Engine)
	// USurface interface
	
	/**
	* @return width of surface
	*/
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }

	/**
	* @return height of surface
	*/
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface

	/**
	* Create a new movie texture resource
	*
	* @return newly created FTextureMovieResource
	*/
	virtual FTextureResource* CreateResource();

	/**
	* Materials should treat a movie texture like a regular 2D texture resource.
	*
	* @return EMaterialValueType for this resource
	*/
	virtual EMaterialValueType GetMaterialType();

	// UObject interface.
	
	/**
	 * Serializes the compressed movie data.
	 *
	 * @param Ar	FArchive to serialize RawData with.
	 */
	virtual void Serialize(FArchive& Ar);	
	
	/**
	 * Postload initialization of movie texture. Creates decoder object and retriever first frame.
	 */
	virtual void PostLoad();
	
	/**
	* Called before destroying the object.  This is called immediately upon deciding to destroy the object, to allow the object to begin an
	* asynchronous cleanup process.
	*
	* We need to ensure that the decoder doesn't have any references to the movie texture resource before destructing it.
	*/
	virtual void BeginDestroy();
	
	/**
	* Called when a property on this object has been modified externally
	*
	* @param PropertyThatChanged the property that will be modified
	*/
	virtual void PreEditChange(UProperty* PropertyAboutToChange);

	/**
	* Called when a property on this object has been modified externally
	*
	* @param PropertyThatChanged the property that was modified
	*/
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/**
	* Called to check if the object is ready for FinishDestroy.  This is called after BeginDestroy to check the completion of the
	* potentially asynchronous object cleanup.
	* @return True if the object's asynchronous cleanup has completed and it is ready for FinishDestroy to be called.
	*/
	virtual UBOOL IsReadyForFinishDestroy();

	/**
	 * Called to finish destroying the object.  After UObject::FinishDestroy is called, the object's memory should no longer be accessed.
	 *
	 * note: because ExitProperties() is called here, Super::FinishDestroy() should always be called at the end of your child class's
	 * FinishDestroy() method, rather than at the beginning.
	 */
	virtual void FinishDestroy();

	// Thumbnail interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	// UTextureMovie

	/**
	 * Access the movie target resource for this movie texture object
	 * @return pointer to resource or NULL if not initialized
	 */
	class FTextureMovieResource* GetTextureMovieResource();
	
	/** 
	 * Creates a new codec and checks to see if it has a valid stream
	 */
	void InitDecoder();
};

class UTextureRenderTarget : public UTexture
{
public:
    //## BEGIN PROPS TextureRenderTarget
    BITFIELD bUpdateImmediate:1;
    BITFIELD bNeedsTwoCopies:1;
    BITFIELD bRenderOnce:1;
    //## END PROPS TextureRenderTarget

    DECLARE_ABSTRACT_CLASS(UTextureRenderTarget,UTexture,0,Engine)
	/**
	 * Access the render target resource for this texture target object
	 * @return pointer to resource or NULL if not initialized
	 */
	FTextureRenderTargetResource* GetRenderTargetResource();

	// UTexture interface.

	/**
	 * No mip data used so compression is not needed
	 */
	virtual void Compress();

	/**
	 * Create a new 2D render target texture resource
	 * @return newly created FTextureRenderTarget2DResource
	 */
	virtual FTextureResource* CreateResource();
	
	/**
	 * Materials should treat a render target 2D texture like a regular 2D texture resource.
	 * @return EMaterialValueType for this resource
	 */
	virtual EMaterialValueType GetMaterialType();
};

class UTextureRenderTarget2D : public UTextureRenderTarget
{
public:
    //## BEGIN PROPS TextureRenderTarget2D
    INT SizeX;
    INT SizeY;
    BYTE Format;
    BYTE AddressX;
    BYTE AddressY;
    FLinearColor ClearColor;
    //## END PROPS TextureRenderTarget2D

    DECLARE_FUNCTION(execCreate);
    DECLARE_CLASS(UTextureRenderTarget2D,UTextureRenderTarget,0,Engine)
	/**
	* Initialize the settings needed to create a render target texture
	* and create its resource
	* @param	InSizeX - width of the texture
	* @param	InSizeY - height of the texture
	* @param	InFormat - format of the texture
	*/
	void Init(UINT InSizeX, UINT InSizeY, EPixelFormat InFormat);

	/**
	* Utility for creating a new UTexture2D from a TextureRenderTarget2D
	* TextureRenderTarget2D must be square and a power of two size.
	* @param	Outer - Outer to use when constructing the new Texture2D.
	* @param	NewTexName - Name of new UTexture2D object.
	* @param	bCompress - Whether to compress the constructed texture.
	* @param	bSRGB - Whether to create the new texture as SRGB.
	* @return	New UTexture2D object.
	*/
	UTexture2D* ConstructTexture2D(UObject* Outer, const FString& NewTexName, EObjectFlags InFlags, UBOOL bCompress=TRUE, UBOOL bSRGB=TRUE);

	// USurface interface

	/**
	* @return width of surface
	*/
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }

	/**
	* @return height of surface
	*/
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface.

	/**
	* Create a new 2D render target texture resource
	* @return newly created FTextureRenderTarget2DResource
	*/
	virtual FTextureResource* CreateResource();

	/**
	* Materials should treat a render target 2D texture like a regular 2D texture resource.
	* @return EMaterialValueType for this resource
	*/
	virtual EMaterialValueType GetMaterialType();

	// UObject interface

	/**
	* Called when any property in this object is modified in UnrealEd
	* @param	PropertyThatChanged - changed property
	*/
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/**
	* Called after the object has been loaded
	*/
	virtual void PostLoad();

	// Editor thumbnail interface.

	/**
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/**
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Serialize properties (used for backwards compatibility with main branch)
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();
};

struct ScriptedTexture_eventRender_Parms
{
    class UCanvas* C;
    ScriptedTexture_eventRender_Parms(EEventParm)
    {
    }
};
class UScriptedTexture : public UTextureRenderTarget2D
{
public:
    //## BEGIN PROPS ScriptedTexture
    BITFIELD bNeedsUpdate:1;
    BITFIELD bSkipNextClear:1;
    FScriptDelegate __Render__Delegate;
    //## END PROPS ScriptedTexture

    void delegateRender(class UCanvas* C)
    {
        ScriptedTexture_eventRender_Parms Parms(EC_EventParm);
        Parms.C=C;
        ProcessDelegate(ENGINE_Render,&__Render__Delegate,&Parms);
    }
    DECLARE_CLASS(UScriptedTexture,UTextureRenderTarget2D,0,Engine)
	/** global list of scripted textures that should be updated */
	static TArray<UScriptedTexture*> GScriptedTextures;

	UScriptedTexture();
	virtual void BeginDestroy();

	virtual void UpdateResource();
	/** calls Render() (after setting up Canvas, etc) if the scripted texture needs an update */
	void CheckUpdate();

protected:
	/** native rendering hook. Default implementation just calls script delegate. */
	virtual void Render(UCanvas* C);
};

class UTextureRenderTargetCube : public UTextureRenderTarget
{
public:
    //## BEGIN PROPS TextureRenderTargetCube
    INT SizeX;
    BYTE Format;
    //## END PROPS TextureRenderTargetCube

    DECLARE_CLASS(UTextureRenderTargetCube,UTextureRenderTarget,0,Engine)
	/** 
	* Initialize the settings needed to create a render target texture
	* and create its resource
	* @param	InSizeX - width of the texture
	* @param	InFormat - format of the texture
	*/
	void Init(UINT InSizeX, EPixelFormat InFormat);

	/**
	*	Utility for creating a new UTextureCube from a TextureRenderTargetCube.
	*	TextureRenderTargetCube must be square and a power of two size.
	*	@param	Outer			Outer to use when constructing the new TextureCube.
	*	@param	NewTexName		Name of new UTextureCube object.
	*	@return					New UTextureCube object.
	*/
	class UTextureCube* ConstructTextureCube(UObject* Outer, const FString& NewTexName, EObjectFlags InFlags);

	// USurface interface

	/**
	* @return width of surface
	*/
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }
	
	/**
	* @return height of surface
	*/
	virtual FLOAT GetSurfaceHeight() const { return SizeX; }	

	// UTexture interface.

	/**
	* Create a new 2D render target texture resource
	* @return newly created FTextureRenderTarget2DResource
	*/
	virtual FTextureResource* CreateResource();
	
	/**
	* Materials should treat a render target 2D texture like a regular 2D texture resource.
	* @return EMaterialValueType for this resource
	*/
	virtual EMaterialValueType GetMaterialType();

	// UObject interface

	/** 
	* Called when any property in this object is modified in UnrealEd
	* @param	PropertyThatChanged - changed property
	*/
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** 
	 * Called after the object has been loaded
 	 */
	virtual void PostLoad();

	// Editor thumbnail interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Serialize properties (used for backwards compatibility with main branch)
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();
};

class UWaveFormBase : public UObject
{
public:
    //## BEGIN PROPS WaveFormBase
    class UForceFeedbackWaveform* TheWaveForm;
    //## END PROPS WaveFormBase

    DECLARE_ABSTRACT_CLASS(UWaveFormBase,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UWaveFormBase)
};

#endif // !INCLUDED_ENGINE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AActor,-1,execSupportsKismetModification);
AUTOGENERATE_FUNCTION(AActor,-1,execIsInPersistentLevel);
AUTOGENERATE_FUNCTION(AActor,-1,execGetPackageGuid);
AUTOGENERATE_FUNCTION(AActor,-1,execNativePostRenderFor);
AUTOGENERATE_FUNCTION(AActor,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTargetLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AActor,-1,execIsPlayerOwned);
AUTOGENERATE_FUNCTION(AActor,-1,execPrestreamTextures);
AUTOGENERATE_FUNCTION(AActor,-1,execSetNetUpdateTime);
AUTOGENERATE_FUNCTION(AActor,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(AActor,-1,execLocalPlayerControllers);
AUTOGENERATE_FUNCTION(AActor,-1,execAllOwnedComponents);
AUTOGENERATE_FUNCTION(AActor,-1,execComponentList);
AUTOGENERATE_FUNCTION(AActor,-1,execOverlappingActors);
AUTOGENERATE_FUNCTION(AActor,321,execCollidingActors);
AUTOGENERATE_FUNCTION(AActor,312,execVisibleCollidingActors);
AUTOGENERATE_FUNCTION(AActor,311,execVisibleActors);
AUTOGENERATE_FUNCTION(AActor,309,execTraceActors);
AUTOGENERATE_FUNCTION(AActor,307,execTouchingActors);
AUTOGENERATE_FUNCTION(AActor,306,execBasedActors);
AUTOGENERATE_FUNCTION(AActor,305,execChildActors);
AUTOGENERATE_FUNCTION(AActor,313,execDynamicActors);
AUTOGENERATE_FUNCTION(AActor,304,execAllActors);
AUTOGENERATE_FUNCTION(AActor,547,execGetURLMap);
AUTOGENERATE_FUNCTION(AActor,-1,execGetDestination);
AUTOGENERATE_FUNCTION(AActor,-1,execSuggestTossVelocity);
AUTOGENERATE_FUNCTION(AActor,532,execPlayerCanSeeMe);
AUTOGENERATE_FUNCTION(AActor,512,execMakeNoise);
AUTOGENERATE_FUNCTION(AActor,-1,execPlaySound);
AUTOGENERATE_FUNCTION(AActor,-1,execCreateAudioComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTimerRate);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTimerCount);
AUTOGENERATE_FUNCTION(AActor,-1,execIsTimerActive);
AUTOGENERATE_FUNCTION(AActor,-1,execPauseTimer);
AUTOGENERATE_FUNCTION(AActor,-1,execClearTimer);
AUTOGENERATE_FUNCTION(AActor,280,execSetTimer);
AUTOGENERATE_FUNCTION(AActor,279,execDestroy);
AUTOGENERATE_FUNCTION(AActor,-1,execSpawn);
AUTOGENERATE_FUNCTION(AActor,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(AActor,-1,execGetComponentsBoundingBox);
AUTOGENERATE_FUNCTION(AActor,-1,execIsOverlapping);
AUTOGENERATE_FUNCTION(AActor,-1,execContainsPoint);
AUTOGENERATE_FUNCTION(AActor,-1,execFindSpot);
AUTOGENERATE_FUNCTION(AActor,-1,execTraceAllPhysicsAssetInteractions);
AUTOGENERATE_FUNCTION(AActor,548,execFastTrace);
AUTOGENERATE_FUNCTION(AActor,-1,execPointCheckComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execTraceComponent);
AUTOGENERATE_FUNCTION(AActor,277,execTrace);
AUTOGENERATE_FUNCTION(AActor,-1,execClampRotation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetTickGroup);
AUTOGENERATE_FUNCTION(AActor,-1,execReattachComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execDetachComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execAttachComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execUnClock);
AUTOGENERATE_FUNCTION(AActor,-1,execClock);
AUTOGENERATE_FUNCTION(AActor,3970,execSetPhysics);
AUTOGENERATE_FUNCTION(AActor,-1,execSetOnlyOwnerSee);
AUTOGENERATE_FUNCTION(AActor,-1,execSetHidden);
AUTOGENERATE_FUNCTION(AActor,-1,execChartData);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugCone);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugCylinder);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugSphere);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugCoordinateSystem);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugBox);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugLine);
AUTOGENERATE_FUNCTION(AActor,-1,execFlushPersistentDebugLines);
AUTOGENERATE_FUNCTION(AActor,-1,execSetForcedInitialReplicatedProperty);
AUTOGENERATE_FUNCTION(AActor,-1,execIsOwnedBy);
AUTOGENERATE_FUNCTION(AActor,-1,execGetBaseMost);
AUTOGENERATE_FUNCTION(AActor,-1,execIsBasedOn);
AUTOGENERATE_FUNCTION(AActor,-1,execFindBase);
AUTOGENERATE_FUNCTION(AActor,272,execSetOwner);
AUTOGENERATE_FUNCTION(AActor,298,execSetBase);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTerminalVelocity);
AUTOGENERATE_FUNCTION(AActor,3971,execAutonomousPhysics);
AUTOGENERATE_FUNCTION(AActor,3969,execMoveSmooth);
AUTOGENERATE_FUNCTION(AActor,-1,execfixedTurn);
AUTOGENERATE_FUNCTION(AActor,-1,execSetHardAttach);
AUTOGENERATE_FUNCTION(AActor,-1,execSetRelativeLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetRelativeRotation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetZone);
AUTOGENERATE_FUNCTION(AActor,-1,execMovingWhichWay);
AUTOGENERATE_FUNCTION(AActor,299,execSetRotation);
AUTOGENERATE_FUNCTION(AActor,267,execSetLocation);
AUTOGENERATE_FUNCTION(AActor,266,execMove);
AUTOGENERATE_FUNCTION(AActor,-1,execSetDrawScale3D);
AUTOGENERATE_FUNCTION(AActor,-1,execSetDrawScale);
AUTOGENERATE_FUNCTION(AActor,-1,execSetCollisionType);
AUTOGENERATE_FUNCTION(AActor,283,execSetCollisionSize);
AUTOGENERATE_FUNCTION(AActor,262,execSetCollision);
AUTOGENERATE_FUNCTION(AActor,261,execFinishAnim);
AUTOGENERATE_FUNCTION(AActor,256,execSleep);
AUTOGENERATE_FUNCTION(AActor,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(AActor,-1,execForceUpdateComponents);
AUTOGENERATE_FUNCTION(AAnimatedCamera,-1,execStopCameraAnim);
AUTOGENERATE_FUNCTION(AAnimatedCamera,-1,execStopAllCameraAnimsByType);
AUTOGENERATE_FUNCTION(AAnimatedCamera,-1,execStopAllCameraAnims);
AUTOGENERATE_FUNCTION(AAnimatedCamera,-1,execPlayCameraAnim);
AUTOGENERATE_FUNCTION(AAnimatedCamera,-1,execApplyCameraModifiersNative);
AUTOGENERATE_FUNCTION(AAnimatedCamera,-1,execApplyCameraModifiers);
AUTOGENERATE_FUNCTION(ACamera,-1,execSetViewTarget);
AUTOGENERATE_FUNCTION(ACamera,-1,execCheckViewTarget);
AUTOGENERATE_FUNCTION(ACamera,-1,execApplyCameraModifiers);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execApplyTransientScaling);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execStop);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execAdvanceAnim);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execUpdate);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execPlay);
AUTOGENERATE_FUNCTION(UCameraModifier,-1,execIsDisabled);
AUTOGENERATE_FUNCTION(UCameraModifier,-1,execModifyCamera);
AUTOGENERATE_FUNCTION(AController,-1,execStopLatentExecution);
AUTOGENERATE_FUNCTION(AController,-1,execInLatentExecution);
AUTOGENERATE_FUNCTION(AController,-1,execEndClimbLadder);
AUTOGENERATE_FUNCTION(AController,527,execWaitForLanding);
AUTOGENERATE_FUNCTION(AController,526,execPickWallAdjust);
AUTOGENERATE_FUNCTION(AController,520,execActorReachable);
AUTOGENERATE_FUNCTION(AController,521,execPointReachable);
AUTOGENERATE_FUNCTION(AController,-1,execFindPathToIntercept);
AUTOGENERATE_FUNCTION(AController,525,execFindRandomDest);
AUTOGENERATE_FUNCTION(AController,-1,execFindPathTowardNearest);
AUTOGENERATE_FUNCTION(AController,517,execFindPathToward);
AUTOGENERATE_FUNCTION(AController,518,execFindPathTo);
AUTOGENERATE_FUNCTION(AController,508,execFinishRotation);
AUTOGENERATE_FUNCTION(AController,502,execMoveToward);
AUTOGENERATE_FUNCTION(AController,500,execMoveTo);
AUTOGENERATE_FUNCTION(AController,531,execPickTarget);
AUTOGENERATE_FUNCTION(AController,537,execCanSeeByPoints);
AUTOGENERATE_FUNCTION(AController,533,execCanSee);
AUTOGENERATE_FUNCTION(AController,514,execLineOfSightTo);
AUTOGENERATE_FUNCTION(AController,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AController,-1,execBeyondFogDistance);
AUTOGENERATE_FUNCTION(AController,-1,execGetAdjustLocation);
AUTOGENERATE_FUNCTION(AController,-1,execSetAdjustLocation);
AUTOGENERATE_FUNCTION(AController,-1,execGetDestinationPosition);
AUTOGENERATE_FUNCTION(AController,-1,execSetDestinationPosition);
AUTOGENERATE_FUNCTION(AController,-1,execGetFocalPoint);
AUTOGENERATE_FUNCTION(AController,-1,execSetFocalPoint);
AUTOGENERATE_FUNCTION(AController,-1,execGetBasedPosition);
AUTOGENERATE_FUNCTION(AController,-1,execSetBasedPosition);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_RemoveIndex);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_RemoveItem);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_InsertItem);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_AddItem);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_Empty);
AUTOGENERATE_FUNCTION(AController,-1,execIsLocalPlayerController);
AUTOGENERATE_FUNCTION(ACoverGroup,-1,execToggleGroup);
AUTOGENERATE_FUNCTION(ACoverGroup,-1,execDisableGroup);
AUTOGENERATE_FUNCTION(ACoverGroup,-1,execEnableGroup);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetLocationDescription);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execAddCoverSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsEnabled);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execAutoAdjustSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotActions);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execHasFireLinkTo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetFireLinkTo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotIdxToRight);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotIdxToLeft);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsRightEdgeSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsLeftEdgeSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsEdgeSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execFindSlots);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsValidClaim);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsExposedTo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotMarker);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotViewPoint);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotRotation);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotLocation);
AUTOGENERATE_FUNCTION(ACoverSlotMarker,-1,execIsValidClaim);
AUTOGENERATE_FUNCTION(ACoverSlotMarker,-1,execSetSlotEnabled);
AUTOGENERATE_FUNCTION(ACoverSlotMarker,-1,execGetSlotRotation);
AUTOGENERATE_FUNCTION(ACoverSlotMarker,-1,execGetSlotLocation);
AUTOGENERATE_FUNCTION(ADroppedPickup,-1,execRemoveFromNavigation);
AUTOGENERATE_FUNCTION(ADroppedPickup,-1,execAddToNavigation);
AUTOGENERATE_FUNCTION(AEmitter,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execGetPooledComponent);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execGetFreeMatInstConsts);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execFreeMaterialInstanceConstants);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execGetFreeStaticMeshComponent);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execFreeStaticMeshComponents);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execReturnToPool);
AUTOGENERATE_FUNCTION(UFaceFXAsset,-1,execUnmountFaceFXAnimSet);
AUTOGENERATE_FUNCTION(UFaceFXAsset,-1,execMountFaceFXAnimSet);
AUTOGENERATE_FUNCTION(AFileWriter,-1,execLogf);
AUTOGENERATE_FUNCTION(AFileWriter,-1,execCloseFile);
AUTOGENERATE_FUNCTION(AFileWriter,-1,execOpenFile);
AUTOGENERATE_FUNCTION(UFont,-1,execGetMaxCharHeight);
AUTOGENERATE_FUNCTION(UFont,-1,execGetAuthoredViewportHeight);
AUTOGENERATE_FUNCTION(UFont,-1,execGetScalingFactor);
AUTOGENERATE_FUNCTION(UFont,-1,execGetResolutionPageIndex);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execDoSentinel_PerfAtSpecificLocation);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execDoSentinel_MemoryAtSpecificLocation);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetTravelLocations);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execHandlePerLoadedMapAudioStats);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execDoSentinelActionPerLoadedMap);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execEndSentinelRun);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execAddSentinelPerTimePeriodStats);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execBeginSentinelRun);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execSwapPlayerControllers);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execForceClearUnpauseDelegates);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetNetworkNumber);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execDoNavFearCostFallOff);
AUTOGENERATE_FUNCTION(AGameReplicationInfo,-1,execOnSameTeam);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execShouldForceFullscreenViewport);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execIsFullScreenViewport);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execGetViewportSize);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(UHeightFogComponent,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(AHUD,-1,execDraw2DLine);
AUTOGENERATE_FUNCTION(AHUD,-1,execDraw3DLine);
AUTOGENERATE_FUNCTION(UIniLocPatcher,-1,execProcessIniLocFile);
AUTOGENERATE_FUNCTION(AInterpActor,-1,execSetShadowParentOnAllAttachedComponents);
AUTOGENERATE_FUNCTION(AInventoryManager,-1,execInventoryActors);
AUTOGENERATE_FUNCTION(ULightEnvironmentComponent,-1,execIsEnabled);
AUTOGENERATE_FUNCTION(ULightEnvironmentComponent,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execTouchPlayerPostProcessChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execGetPostProcessChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execRemoveAllPostProcessingChains);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execRemovePostProcessingChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execInsertPostProcessingChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execGetActorVisibility);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execSendSplitJoin);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execSpawnPlayActor);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execSetForceMipLevelsToBeResident);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetVectorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetPhysicalMaterial);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetMaterial);
AUTOGENERATE_FUNCTION(UMultiFont,-1,execGetResolutionTestTableIndex);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execIsOnDifferentNetwork);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execGetAllNavInRadius);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execCanTeleport);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execIsUsableAnchorFor);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execGetReachSpecTo);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execFinalizePlaylistObjects);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execDetermineFilesToDownload);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetRangedProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetRangedProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingRange);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingMappingType);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetDefaultVersionNumber);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetVersionNumber);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execAppendVersionToSettings);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execAppendVersionToReadIds);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetToDefaults);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingDefaultFloat);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingDefaultInt);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingDefaultId);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetProfileSettingValueFloat);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetProfileSettingValueInt);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetProfileSettingValueId);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValueFloat);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValueInt);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValueId);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetProfileSettingValueByName);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValueByName);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValues);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValueName);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execIsProfileSettingIdMapped);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execFindProfileMappingIndexByName);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execFindProfileMappingIndex);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execFindProfileSettingIndex);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingColumnHeader);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingName);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingId);
AUTOGENERATE_FUNCTION(UOnlineStats,-1,execGetViewName);
AUTOGENERATE_FUNCTION(UOnlineStats,-1,execGetViewId);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetRankForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execAddPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execSetFloatStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetFloatStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execSetIntStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetIntStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execDecrementIntStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execDecrementFloatStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execIncrementIntStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execIncrementFloatStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execSetIntStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execSetFloatStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execGetStatName);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execGetStatId);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execGetBuildUniqueId);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execAreUniqueNetIdsEqual);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execStringToUniqueNetId);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execUniqueNetIdToString);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execInit);
AUTOGENERATE_FUNCTION(APawn,-1,execClearPathStep);
AUTOGENERATE_FUNCTION(APawn,-1,execDrawPathStep);
AUTOGENERATE_FUNCTION(APawn,-1,execIncrementPathChild);
AUTOGENERATE_FUNCTION(APawn,-1,execIncrementPathStep);
AUTOGENERATE_FUNCTION(APawn,-1,execAddGoalEvaluator);
AUTOGENERATE_FUNCTION(APawn,-1,execAddPathConstraint);
AUTOGENERATE_FUNCTION(APawn,-1,execClearConstraints);
AUTOGENERATE_FUNCTION(APawn,-1,execGetVehicleBase);
AUTOGENERATE_FUNCTION(APawn,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(APawn,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(APawn,-1,execGetViewRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execIsPlayerPawn);
AUTOGENERATE_FUNCTION(APawn,-1,execIsLocallyControlled);
AUTOGENERATE_FUNCTION(APawn,-1,execIsHumanControlled);
AUTOGENERATE_FUNCTION(APawn,-1,execTermRagdoll);
AUTOGENERATE_FUNCTION(APawn,-1,execInitRagdoll);
AUTOGENERATE_FUNCTION(APawn,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedDesiredRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execSetPushesRigidBodies);
AUTOGENERATE_FUNCTION(APawn,-1,execForceCrouch);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedPoint);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedDestination);
AUTOGENERATE_FUNCTION(APawn,-1,execGetBestAnchor);
AUTOGENERATE_FUNCTION(APawn,-1,execSetAnchor);
AUTOGENERATE_FUNCTION(APawn,-1,execSetRemoteViewPitch);
AUTOGENERATE_FUNCTION(APawn,-1,execIsInvisible);
AUTOGENERATE_FUNCTION(APawn,-1,execIsValidEnemyTargetFor);
AUTOGENERATE_FUNCTION(APawn,-1,execIsValidTargetFor);
AUTOGENERATE_FUNCTION(APawn,-1,execSuggestJumpVelocity);
AUTOGENERATE_FUNCTION(APawn,-1,execValidAnchor);
AUTOGENERATE_FUNCTION(APawn,-1,execAdjustDestination);
AUTOGENERATE_FUNCTION(APawn,-1,execIsAliveAndWell);
AUTOGENERATE_FUNCTION(APawn,-1,execGetBasedPosition);
AUTOGENERATE_FUNCTION(APawn,-1,execSetBasedPosition);
AUTOGENERATE_FUNCTION(APhysicsVolume,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(UPlayer,-1,execSwitchController);
AUTOGENERATE_FUNCTION(APlayerController,-1,execLogOutBugItAIGoToLogFile);
AUTOGENERATE_FUNCTION(APlayerController,-1,execLogOutBugItGoToLogFile);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetFRotatorFromString);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetFVectorFromString);
AUTOGENERATE_FUNCTION(APlayerController,-1,execShowSurvey);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsShowingSubtitles);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetShowSubtitles);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPlayerControllerFromNetId);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsPlayerMuted);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientFlushLevelStreaming);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerUpdateLevelVisibility);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientUpdateLevelStreamingStatus);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetViewTarget);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetViewTarget);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsLocalPlayerController);
AUTOGENERATE_FUNCTION(APlayerController,-1,execHasClientLoadedCurrentWorld);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerNotifyLoadedWorld);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCreateTTSSoundCue);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPooledAudioComponent);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsMouseAvailable);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsKeyboardAvailable);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetUseTiltForwardAndBack);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetOnlyUseControllerTiltInput);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetControllerTiltActive);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetControllerTiltDesiredIfAvailable);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsControllerTiltActive);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCleanUpAudioComponents);
AUTOGENERATE_FUNCTION(APlayerController,524,execFindStairRotation);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCheckSpeedHack);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerProcessConvolve);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientConvolve);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetAudioGroupVolume);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetAllowMatureLanguage);
AUTOGENERATE_FUNCTION(APlayerController,-1,execPasteFromClipboard);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCopyToClipboard);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetDefaultURL);
AUTOGENERATE_FUNCTION(APlayerController,546,execUpdateURL);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientTravel);
AUTOGENERATE_FUNCTION(APlayerController,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetServerNetworkAddress);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPlayerNetworkAddress);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetNetSpeed);
AUTOGENERATE_FUNCTION(APlayerReplicationInfo,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(APlayerReplicationInfo,-1,execUpdatePing);
AUTOGENERATE_FUNCTION(APlayerReplicationInfo,-1,execGetPlayerAlias);
AUTOGENERATE_FUNCTION(APlayerReplicationInfo,-1,execAreUniqueNetIdsEqual);
AUTOGENERATE_FUNCTION(UPointLightComponent,-1,execSetTranslation);
AUTOGENERATE_FUNCTION(APortalMarker,-1,execCanTeleport);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execCreatePortalTexture);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execTransformHitLocation);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execTransformVectorDir);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execTransformActor);
AUTOGENERATE_FUNCTION(AProjectile,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(UReachSpec,-1,execGetDirection);
AUTOGENERATE_FUNCTION(UReachSpec,-1,execGetEnd);
AUTOGENERATE_FUNCTION(UReachSpec,-1,execCostFor);
AUTOGENERATE_FUNCTION(ARoute,-1,execMoveOntoRoutePath);
AUTOGENERATE_FUNCTION(ARoute,-1,execResolveRouteIndex);
AUTOGENERATE_FUNCTION(USceneCapture2DComponent,-1,execSetView);
AUTOGENERATE_FUNCTION(USceneCapture2DComponent,-1,execSetCaptureParameters);
AUTOGENERATE_FUNCTION(USceneCaptureComponent,-1,execSetFrameRate);
AUTOGENERATE_FUNCTION(USceneCapturePortalComponent,-1,execSetCaptureParameters);
AUTOGENERATE_FUNCTION(USettings,-1,execUpdateFromURL);
AUTOGENERATE_FUNCTION(USettings,-1,execBuildURL);
AUTOGENERATE_FUNCTION(USettings,-1,execAppendContextsToURL);
AUTOGENERATE_FUNCTION(USettings,-1,execAppendPropertiesToURL);
AUTOGENERATE_FUNCTION(USettings,-1,execAppendDataBindingsToURL);
AUTOGENERATE_FUNCTION(USettings,-1,execGetQoSAdvertisedStringSettings);
AUTOGENERATE_FUNCTION(USettings,-1,execGetQoSAdvertisedProperties);
AUTOGENERATE_FUNCTION(USettings,-1,execGetRangedPropertyValue);
AUTOGENERATE_FUNCTION(USettings,-1,execSetRangedPropertyValue);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyRange);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyMappingType);
AUTOGENERATE_FUNCTION(USettings,-1,execHasStringSetting);
AUTOGENERATE_FUNCTION(USettings,-1,execHasProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execUpdateProperties);
AUTOGENERATE_FUNCTION(USettings,-1,execUpdateStringSettings);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyType);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyValueId);
AUTOGENERATE_FUNCTION(USettings,-1,execSetPropertyValueId);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execGetIntProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetIntProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execGetFloatProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetFloatProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetPropertyFromStringByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyAsStringByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyAsString);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyColumnHeader);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyId);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringSettingValueFromStringByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueNameByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueName);
AUTOGENERATE_FUNCTION(USettings,-1,execIsWildcardStringSetting);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingColumnHeader);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingId);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueByName);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringSettingValueByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueNames);
AUTOGENERATE_FUNCTION(USettings,-1,execIncrementStringSettingValue);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValue);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringSettingValue);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataDateTime);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataBlob);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataInt);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataFloat);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataString);
AUTOGENERATE_FUNCTION(USettings,-1,execEmptySettingsData);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsData);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataBlob);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataDateTime);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataInt);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataFloat);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataString);
AUTOGENERATE_FUNCTION(USoundCue,-1,execGetCueDuration);
AUTOGENERATE_FUNCTION(USurface,-1,execGetSurfaceHeight);
AUTOGENERATE_FUNCTION(USurface,-1,execGetSurfaceWidth);
AUTOGENERATE_FUNCTION(ATeamInfo,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(ATeleporter,-1,execCanTeleport);
AUTOGENERATE_FUNCTION(UTexture2D,-1,execCreate);
AUTOGENERATE_FUNCTION(UTexture2D,-1,execSetForceMipLevelsToBeResident);
AUTOGENERATE_FUNCTION(UTexture2DComposite,-1,execResetSourceRegions);
AUTOGENERATE_FUNCTION(UTexture2DComposite,-1,execUpdateCompositeTexture);
AUTOGENERATE_FUNCTION(UTexture2DComposite,-1,execSourceTexturesFullyStreamedIn);
AUTOGENERATE_FUNCTION(UTexture2DDynamic,-1,execCreate);
AUTOGENERATE_FUNCTION(UTexture2DDynamic,-1,execInit);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execSetCurrentFrame);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execStop);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execPause);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execPlay);
AUTOGENERATE_FUNCTION(UTextureMovie,-1,execStop);
AUTOGENERATE_FUNCTION(UTextureMovie,-1,execPause);
AUTOGENERATE_FUNCTION(UTextureMovie,-1,execPlay);
AUTOGENERATE_FUNCTION(UTextureRenderTarget2D,-1,execCreate);
AUTOGENERATE_FUNCTION(AVehicle,-1,execGetTargetLocation);
AUTOGENERATE_FUNCTION(AVolume,-1,execEncompasses);
AUTOGENERATE_FUNCTION(AWeapon,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetWorldFractureSettings);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execOnScreenDebugMessageExists);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAddOnScreenDebugMessage);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execDoMemoryTracking);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPlayingDemo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsRecordingDemo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetDetailMode);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetMapName);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetMapInfo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetMapInfo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetSeamlessTravelMidpointPause);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsInSeamlessTravel);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSeamlessTravel);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execCommitMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execCancelPendingMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsMapChangeReady);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPreparingMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execPrepareMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execNotifyMatchStarted);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllPawns);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllControllers);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execNavigationPointCheck);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execRadiusNavigationPoints);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllNavigationPoints);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetAddressURL);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execVerifyNavList);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execForceGarbageCollection);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPlayInEditor);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsConsoleBuild);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsDemoBuild);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetLocalURL);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetLevelRBGravity);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetGameSequence);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execUpdateMusicTrack);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsMenuLevel);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_NATIVE_DEFS
#define ENGINE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,AActor);
DECLARE_NATIVE_TYPE(Engine,UActorComponent);
DECLARE_NATIVE_TYPE(Engine,UActorFactory);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryAI);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryAmbientSound);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryAmbientSoundMovable);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryAmbientSoundSimple);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryArchetype);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryCoverLink);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryDynamicSM);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryEmitter);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryFracturedStaticMesh);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryLensFlare);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryLight);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryMover);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryPathNode);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryPhysicsAsset);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryPhysXDestructible);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryPlayerStart);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryRigidBody);
DECLARE_NATIVE_TYPE(Engine,UActorFactorySkeletalMesh);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryStaticMesh);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryTrigger);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryVehicle);
DECLARE_NATIVE_TYPE(Engine,UAdvancedReachSpec);
DECLARE_NATIVE_TYPE(Engine,UAmbientOcclusionEffect);
DECLARE_NATIVE_TYPE(Engine,AAnimatedCamera);
DECLARE_NATIVE_TYPE(Engine,UAudioComponent);
DECLARE_NATIVE_TYPE(Engine,AAutoLadder);
DECLARE_NATIVE_TYPE(Engine,ABlockingVolume);
DECLARE_NATIVE_TYPE(Engine,UBloomEffect);
DECLARE_NATIVE_TYPE(Engine,UBookMark);
DECLARE_NATIVE_TYPE(Engine,ABrush);
DECLARE_NATIVE_TYPE(Engine,ACamera);
DECLARE_NATIVE_TYPE(Engine,ACameraActor);
DECLARE_NATIVE_TYPE(Engine,UCameraAnim);
DECLARE_NATIVE_TYPE(Engine,UCameraAnimInst);
DECLARE_NATIVE_TYPE(Engine,UCameraMode);
DECLARE_NATIVE_TYPE(Engine,UCameraModifier);
DECLARE_NATIVE_TYPE(Engine,UCanvas);
DECLARE_NATIVE_TYPE(Engine,UCeilingReachSpec);
DECLARE_NATIVE_TYPE(Engine,UCheatManager);
DECLARE_NATIVE_TYPE(Engine,AClipMarker);
DECLARE_NATIVE_TYPE(Engine,UClipPadEntry);
DECLARE_NATIVE_TYPE(Engine,UCodecMovie);
DECLARE_NATIVE_TYPE(Engine,UCodecMovieFallback);
DECLARE_NATIVE_TYPE(Engine,AController);
DECLARE_NATIVE_TYPE(Engine,ACoverGroup);
DECLARE_NATIVE_TYPE(Engine,ACoverLink);
DECLARE_NATIVE_TYPE(Engine,UCoverSlipReachSpec);
DECLARE_NATIVE_TYPE(Engine,ACoverSlotMarker);
DECLARE_NATIVE_TYPE(Engine,ACrowdReplicationActor);
DECLARE_NATIVE_TYPE(Engine,ACullDistanceVolume);
DECLARE_NATIVE_TYPE(Engine,UCurveEdPresetCurve);
DECLARE_NATIVE_TYPE(Engine,UCustomPropertyItemHandler);
DECLARE_NATIVE_TYPE(Engine,UCylinderComponent);
DECLARE_NATIVE_TYPE(Engine,UDamageType);
DECLARE_NATIVE_TYPE(Engine,UDebugManager);
DECLARE_NATIVE_TYPE(Engine,ADefaultPhysicsVolume);
DECLARE_NATIVE_TYPE(Engine,ADirectionalLight);
DECLARE_NATIVE_TYPE(Engine,UDirectionalLightComponent);
DECLARE_NATIVE_TYPE(Engine,ADirectionalLightToggleable);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatConstant);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatConstantCurve);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatParameterBase);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatUniform);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatUniformCurve);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorConstant);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorConstantCurve);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorParameterBase);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorUniform);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorUniformCurve);
DECLARE_NATIVE_TYPE(Engine,UDOFAndBloomEffect);
DECLARE_NATIVE_TYPE(Engine,UDOFBloomMotionBlurEffect);
DECLARE_NATIVE_TYPE(Engine,UDOFEffect);
DECLARE_NATIVE_TYPE(Engine,ADoorMarker);
DECLARE_NATIVE_TYPE(Engine,UDrawConeComponent);
DECLARE_NATIVE_TYPE(Engine,UDrawLightConeComponent);
DECLARE_NATIVE_TYPE(Engine,ADroppedPickup);
DECLARE_NATIVE_TYPE(Engine,ADynamicAnchor);
DECLARE_NATIVE_TYPE(Engine,ADynamicBlockingVolume);
DECLARE_NATIVE_TYPE(Engine,ADynamicCameraActor);
DECLARE_NATIVE_TYPE(Engine,UDynamicLightEnvironmentComponent);
DECLARE_NATIVE_TYPE(Engine,ADynamicSMActor);
DECLARE_NATIVE_TYPE(Engine,UEdCoordSystem);
DECLARE_NATIVE_TYPE(Engine,AEmitter);
DECLARE_NATIVE_TYPE(Engine,AEmitterPool);
DECLARE_NATIVE_TYPE(Engine,UFaceFXAnimSet);
DECLARE_NATIVE_TYPE(Engine,UFaceFXAsset);
DECLARE_NATIVE_TYPE(Engine,AFileLog);
DECLARE_NATIVE_TYPE(Engine,AFileWriter);
DECLARE_NATIVE_TYPE(Engine,UFloorToCeilingReachSpec);
DECLARE_NATIVE_TYPE(Engine,UFont);
DECLARE_NATIVE_TYPE(Engine,UFontImportOptions);
DECLARE_NATIVE_TYPE(Engine,UForcedReachSpec);
DECLARE_NATIVE_TYPE(Engine,UForceFeedbackManager);
DECLARE_NATIVE_TYPE(Engine,AGameInfo);
DECLARE_NATIVE_TYPE(Engine,AGameReplicationInfo);
DECLARE_NATIVE_TYPE(Engine,UGameViewportClient);
DECLARE_NATIVE_TYPE(Engine,AGravityVolume);
DECLARE_NATIVE_TYPE(Engine,UHeightFogComponent);
DECLARE_NATIVE_TYPE(Engine,AHUD);
DECLARE_NATIVE_TYPE(Engine,AInfo);
DECLARE_NATIVE_TYPE(Engine,UIniLocPatcher);
DECLARE_NATIVE_TYPE(Engine,AInternetInfo);
DECLARE_NATIVE_TYPE(Engine,AInterpActor);
DECLARE_NATIVE_TYPE(Engine,UInterpCurveEdSetup);
DECLARE_NATIVE_TYPE(Engine,AInventory);
DECLARE_NATIVE_TYPE(Engine,AInventoryManager);
DECLARE_NATIVE_TYPE(Engine,AKeypoint);
DECLARE_NATIVE_TYPE(Engine,UKillZDamageType);
DECLARE_NATIVE_TYPE(Engine,ALadder);
DECLARE_NATIVE_TYPE(Engine,ULadderReachSpec);
DECLARE_NATIVE_TYPE(Engine,ALadderVolume);
DECLARE_NATIVE_TYPE(Engine,ULevelStreaming);
DECLARE_NATIVE_TYPE(Engine,ULevelStreamingDistance);
DECLARE_NATIVE_TYPE(Engine,ULevelStreamingKismet);
DECLARE_NATIVE_TYPE(Engine,ULevelStreamingPersistent);
DECLARE_NATIVE_TYPE(Engine,ALevelStreamingVolume);
DECLARE_NATIVE_TYPE(Engine,ALiftCenter);
DECLARE_NATIVE_TYPE(Engine,ALiftExit);
DECLARE_NATIVE_TYPE(Engine,ALight);
DECLARE_NATIVE_TYPE(Engine,ULightComponent);
DECLARE_NATIVE_TYPE(Engine,ULightEnvironmentComponent);
DECLARE_NATIVE_TYPE(Engine,ULightFunction);
DECLARE_NATIVE_TYPE(Engine,ALightVolume);
DECLARE_NATIVE_TYPE(Engine,ULocalPlayer);
DECLARE_NATIVE_TYPE(Engine,AMantleMarker);
DECLARE_NATIVE_TYPE(Engine,UMantleReachSpec);
DECLARE_NATIVE_TYPE(Engine,UMapInfo);
DECLARE_NATIVE_TYPE(Engine,UMaterial);
DECLARE_NATIVE_TYPE(Engine,UMaterialEffect);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpression);
DECLARE_NATIVE_TYPE(Engine,AMaterialInstanceActor);
DECLARE_NATIVE_TYPE(Engine,UMaterialInterface);
DECLARE_NATIVE_TYPE(Engine,AMatineeActor);
DECLARE_NATIVE_TYPE(Engine,UMeshComponent);
DECLARE_NATIVE_TYPE(Engine,UMeshComponentFactory);
DECLARE_NATIVE_TYPE(Engine,UMotionBlurEffect);
DECLARE_NATIVE_TYPE(Engine,UMultiFont);
DECLARE_NATIVE_TYPE(Engine,UMusicTrackDataStructures);
DECLARE_NATIVE_TYPE(Engine,AMutator);
DECLARE_NATIVE_TYPE(Engine,ANavigationPoint);
DECLARE_NATIVE_TYPE(Engine,ANote);
DECLARE_NATIVE_TYPE(Engine,AObjective);
DECLARE_NATIVE_TYPE(Engine,UObjectReferencer);
DECLARE_NATIVE_TYPE(Engine,UOnlineGameplayEvents);
DECLARE_NATIVE_TYPE(Engine,UOnlineGameSearch);
DECLARE_NATIVE_TYPE(Engine,UOnlineGameSettings);
DECLARE_NATIVE_TYPE(Engine,UOnlinePlaylistManager);
DECLARE_NATIVE_TYPE(Engine,UOnlineProfileSettings);
DECLARE_NATIVE_TYPE(Engine,UOnlineStats);
DECLARE_NATIVE_TYPE(Engine,UOnlineStatsRead);
DECLARE_NATIVE_TYPE(Engine,UOnlineStatsWrite);
DECLARE_NATIVE_TYPE(Engine,UOnlineSubsystem);
DECLARE_NATIVE_TYPE(Engine,APathBlockingVolume);
DECLARE_NATIVE_TYPE(Engine,APathNode);
DECLARE_NATIVE_TYPE(Engine,APawn);
DECLARE_NATIVE_TYPE(Engine,APhysicsVolume);
DECLARE_NATIVE_TYPE(Engine,APickupFactory);
DECLARE_NATIVE_TYPE(Engine,UPlayer);
DECLARE_NATIVE_TYPE(Engine,APlayerController);
DECLARE_NATIVE_TYPE(Engine,APlayerReplicationInfo);
DECLARE_NATIVE_TYPE(Engine,APlayerStart);
DECLARE_NATIVE_TYPE(Engine,APointLight);
DECLARE_NATIVE_TYPE(Engine,UPointLightComponent);
DECLARE_NATIVE_TYPE(Engine,APointLightMovable);
DECLARE_NATIVE_TYPE(Engine,APointLightToggleable);
DECLARE_NATIVE_TYPE(Engine,APolyMarker);
DECLARE_NATIVE_TYPE(Engine,APortalMarker);
DECLARE_NATIVE_TYPE(Engine,APortalTeleporter);
DECLARE_NATIVE_TYPE(Engine,APortalVolume);
DECLARE_NATIVE_TYPE(Engine,UPostProcessChain);
DECLARE_NATIVE_TYPE(Engine,UPostProcessEffect);
DECLARE_NATIVE_TYPE(Engine,APostProcessVolume);
DECLARE_NATIVE_TYPE(Engine,APotentialClimbWatcher);
DECLARE_NATIVE_TYPE(Engine,UPrimitiveComponent);
DECLARE_NATIVE_TYPE(Engine,UPrimitiveComponentFactory);
DECLARE_NATIVE_TYPE(Engine,AProjectile);
DECLARE_NATIVE_TYPE(Engine,UProscribedReachSpec);
DECLARE_NATIVE_TYPE(Engine,UReachSpec);
DECLARE_NATIVE_TYPE(Engine,AReplicationInfo);
DECLARE_NATIVE_TYPE(Engine,AReverbVolume);
DECLARE_NATIVE_TYPE(Engine,ARoute);
DECLARE_NATIVE_TYPE(Engine,USavedMove);
DECLARE_NATIVE_TYPE(Engine,USaveGameSummary);
DECLARE_NATIVE_TYPE(Engine,ASceneCapture2DActor);
DECLARE_NATIVE_TYPE(Engine,USceneCapture2DComponent);
DECLARE_NATIVE_TYPE(Engine,ASceneCaptureActor);
DECLARE_NATIVE_TYPE(Engine,USceneCaptureComponent);
DECLARE_NATIVE_TYPE(Engine,ASceneCaptureCubeMapActor);
DECLARE_NATIVE_TYPE(Engine,USceneCaptureCubeMapComponent);
DECLARE_NATIVE_TYPE(Engine,ASceneCapturePortalActor);
DECLARE_NATIVE_TYPE(Engine,USceneCapturePortalComponent);
DECLARE_NATIVE_TYPE(Engine,ASceneCaptureReflectActor);
DECLARE_NATIVE_TYPE(Engine,USceneCaptureReflectComponent);
DECLARE_NATIVE_TYPE(Engine,AScout);
DECLARE_NATIVE_TYPE(Engine,UScriptedTexture);
DECLARE_NATIVE_TYPE(Engine,USettings);
DECLARE_NATIVE_TYPE(Engine,USkeletalMeshComponent);
DECLARE_NATIVE_TYPE(Engine,USkeletalMeshSocket);
DECLARE_NATIVE_TYPE(Engine,ASkyLight);
DECLARE_NATIVE_TYPE(Engine,USkyLightComponent);
DECLARE_NATIVE_TYPE(Engine,ASkyLightToggleable);
DECLARE_NATIVE_TYPE(Engine,USlotToSlotReachSpec);
DECLARE_NATIVE_TYPE(Engine,USoundCue);
DECLARE_NATIVE_TYPE(Engine,USpeechRecognition);
DECLARE_NATIVE_TYPE(Engine,USphericalHarmonicLightComponent);
DECLARE_NATIVE_TYPE(Engine,ASpotLight);
DECLARE_NATIVE_TYPE(Engine,USpotLightComponent);
DECLARE_NATIVE_TYPE(Engine,ASpotLightMovable);
DECLARE_NATIVE_TYPE(Engine,ASpotLightToggleable);
DECLARE_NATIVE_TYPE(Engine,AStaticLightCollectionActor);
DECLARE_NATIVE_TYPE(Engine,AStaticMeshActor);
DECLARE_NATIVE_TYPE(Engine,AStaticMeshActorBase);
DECLARE_NATIVE_TYPE(Engine,AStaticMeshActorBasedOnExtremeContent);
DECLARE_NATIVE_TYPE(Engine,AStaticMeshCollectionActor);
DECLARE_NATIVE_TYPE(Engine,UStaticMeshComponent);
DECLARE_NATIVE_TYPE(Engine,UStaticMeshComponentFactory);
DECLARE_NATIVE_TYPE(Engine,USurface);
DECLARE_NATIVE_TYPE(Engine,USwatTurnReachSpec);
DECLARE_NATIVE_TYPE(Engine,ATeamInfo);
DECLARE_NATIVE_TYPE(Engine,ATeleporter);
DECLARE_NATIVE_TYPE(Engine,UTeleportReachSpec);
DECLARE_NATIVE_TYPE(Engine,UTexture);
DECLARE_NATIVE_TYPE(Engine,UTexture2D);
DECLARE_NATIVE_TYPE(Engine,UTexture2DComposite);
DECLARE_NATIVE_TYPE(Engine,UTexture2DDynamic);
DECLARE_NATIVE_TYPE(Engine,UTextureCube);
DECLARE_NATIVE_TYPE(Engine,UTextureFlipBook);
DECLARE_NATIVE_TYPE(Engine,UTextureMovie);
DECLARE_NATIVE_TYPE(Engine,UTextureRenderTarget);
DECLARE_NATIVE_TYPE(Engine,UTextureRenderTarget2D);
DECLARE_NATIVE_TYPE(Engine,UTextureRenderTargetCube);
DECLARE_NATIVE_TYPE(Engine,ATrigger);
DECLARE_NATIVE_TYPE(Engine,ATriggerVolume);
DECLARE_NATIVE_TYPE(Engine,UUberPostProcessEffect);
DECLARE_NATIVE_TYPE(Engine,AVehicle);
DECLARE_NATIVE_TYPE(Engine,AVolume);
DECLARE_NATIVE_TYPE(Engine,AVolumePathNode);
DECLARE_NATIVE_TYPE(Engine,UWallTransReachSpec);
DECLARE_NATIVE_TYPE(Engine,UWaveFormBase);
DECLARE_NATIVE_TYPE(Engine,AWeapon);
DECLARE_NATIVE_TYPE(Engine,UWindDirectionalSourceComponent);
DECLARE_NATIVE_TYPE(Engine,AWorldInfo);
DECLARE_NATIVE_TYPE(Engine,AZoneInfo);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE \
	AActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAActorNative; \
	UActorChannel::StaticClass(); \
	UActorComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUActorComponentNative; \
	UActorFactory::StaticClass(); \
	UActorFactoryAI::StaticClass(); \
	UActorFactoryAmbientSound::StaticClass(); \
	UActorFactoryAmbientSoundMovable::StaticClass(); \
	UActorFactoryAmbientSoundSimple::StaticClass(); \
	UActorFactoryArchetype::StaticClass(); \
	UActorFactoryCoverLink::StaticClass(); \
	UActorFactoryDynamicSM::StaticClass(); \
	UActorFactoryEmitter::StaticClass(); \
	UActorFactoryFracturedStaticMesh::StaticClass(); \
	UActorFactoryLensFlare::StaticClass(); \
	UActorFactoryLight::StaticClass(); \
	UActorFactoryMover::StaticClass(); \
	UActorFactoryPathNode::StaticClass(); \
	UActorFactoryPhysicsAsset::StaticClass(); \
	UActorFactoryPhysXDestructible::StaticClass(); \
	UActorFactoryPlayerStart::StaticClass(); \
	UActorFactoryRigidBody::StaticClass(); \
	UActorFactorySkeletalMesh::StaticClass(); \
	UActorFactoryStaticMesh::StaticClass(); \
	UActorFactoryTrigger::StaticClass(); \
	UActorFactoryVehicle::StaticClass(); \
	UAdvancedReachSpec::StaticClass(); \
	UAmbientOcclusionEffect::StaticClass(); \
	AAnimatedCamera::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAAnimatedCameraNative; \
	UArrowComponent::StaticClass(); \
	UAudioComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAudioComponentNative; \
	AAutoLadder::StaticClass(); \
	ABlockingVolume::StaticClass(); \
	UBloomEffect::StaticClass(); \
	UBookMark::StaticClass(); \
	ABrush::StaticClass(); \
	UBrushComponent::StaticClass(); \
	ACamera::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineACameraNative; \
	ACameraActor::StaticClass(); \
	UCameraAnim::StaticClass(); \
	UCameraAnimInst::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUCameraAnimInstNative; \
	UCameraConeComponent::StaticClass(); \
	UCameraMode::StaticClass(); \
	UCameraModifier::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUCameraModifierNative; \
	UCanvas::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUCanvasNative; \
	UCeilingReachSpec::StaticClass(); \
	UChannel::StaticClass(); \
	UChannelDownload::StaticClass(); \
	UCheatManager::StaticClass(); \
	UChildConnection::StaticClass(); \
	UClient::StaticClass(); \
	AClipMarker::StaticClass(); \
	UClipPadEntry::StaticClass(); \
	UCodecMovie::StaticClass(); \
	UCodecMovieBink::StaticClass(); \
	UCodecMovieFallback::StaticClass(); \
	UControlChannel::StaticClass(); \
	AController::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAControllerNative; \
	ACoverGroup::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineACoverGroupNative; \
	ACoverLink::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineACoverLinkNative; \
	UCoverSlipReachSpec::StaticClass(); \
	ACoverSlotMarker::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineACoverSlotMarkerNative; \
	ACrowdReplicationActor::StaticClass(); \
	ACullDistanceVolume::StaticClass(); \
	UCurveEdPresetCurve::StaticClass(); \
	UCustomPropertyItemHandler::StaticClass(); \
	UCylinderComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUCylinderComponentNative; \
	UDamageType::StaticClass(); \
	UDebugManager::StaticClass(); \
	ADefaultPhysicsVolume::StaticClass(); \
	UDemoPlayPendingLevel::StaticClass(); \
	UDemoRecConnection::StaticClass(); \
	UDemoRecDriver::StaticClass(); \
	ADirectionalLight::StaticClass(); \
	UDirectionalLightComponent::StaticClass(); \
	ADirectionalLightToggleable::StaticClass(); \
	UDistributionFloatConstant::StaticClass(); \
	UDistributionFloatConstantCurve::StaticClass(); \
	UDistributionFloatParameterBase::StaticClass(); \
	UDistributionFloatUniform::StaticClass(); \
	UDistributionFloatUniformCurve::StaticClass(); \
	UDistributionVectorConstant::StaticClass(); \
	UDistributionVectorConstantCurve::StaticClass(); \
	UDistributionVectorParameterBase::StaticClass(); \
	UDistributionVectorUniform::StaticClass(); \
	UDistributionVectorUniformCurve::StaticClass(); \
	UDOFAndBloomEffect::StaticClass(); \
	UDOFBloomMotionBlurEffect::StaticClass(); \
	UDOFEffect::StaticClass(); \
	ADoorMarker::StaticClass(); \
	UDownload::StaticClass(); \
	UDrawBoxComponent::StaticClass(); \
	UDrawCapsuleComponent::StaticClass(); \
	UDrawConeComponent::StaticClass(); \
	UDrawCylinderComponent::StaticClass(); \
	UDrawFrustumComponent::StaticClass(); \
	UDrawLightConeComponent::StaticClass(); \
	UDrawLightRadiusComponent::StaticClass(); \
	UDrawQuadComponent::StaticClass(); \
	UDrawSoundRadiusComponent::StaticClass(); \
	UDrawSphereComponent::StaticClass(); \
	ADroppedPickup::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineADroppedPickupNative; \
	ADynamicAnchor::StaticClass(); \
	ADynamicBlockingVolume::StaticClass(); \
	ADynamicCameraActor::StaticClass(); \
	UDynamicLightEnvironmentComponent::StaticClass(); \
	ADynamicSMActor::StaticClass(); \
	UEdCoordSystem::StaticClass(); \
	AEmitter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAEmitterNative; \
	AEmitterPool::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAEmitterPoolNative; \
	UFaceFXAnimSet::StaticClass(); \
	UFaceFXAsset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUFaceFXAssetNative; \
	UFileChannel::StaticClass(); \
	AFileLog::StaticClass(); \
	AFileWriter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAFileWriterNative; \
	UFloorToCeilingReachSpec::StaticClass(); \
	UFont::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUFontNative; \
	UFontImportOptions::StaticClass(); \
	UForcedReachSpec::StaticClass(); \
	UForceFeedbackManager::StaticClass(); \
	UForceFeedbackWaveform::StaticClass(); \
	UFracturedStaticMesh::StaticClass(); \
	AGameInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAGameInfoNative; \
	AGameReplicationInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAGameReplicationInfoNative; \
	UGameViewportClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUGameViewportClientNative; \
	AGravityVolume::StaticClass(); \
	UGuidCache::StaticClass(); \
	UHeightFogComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUHeightFogComponentNative; \
	AHUD::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAHUDNative; \
	AInfo::StaticClass(); \
	UIniLocPatcher::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUIniLocPatcherNative; \
	AInternetInfo::StaticClass(); \
	AInterpActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAInterpActorNative; \
	UInterpCurveEdSetup::StaticClass(); \
	UInterpTrack::StaticClass(); \
	AInventory::StaticClass(); \
	AInventoryManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAInventoryManagerNative; \
	AKeypoint::StaticClass(); \
	UKillZDamageType::StaticClass(); \
	UKMeshProps::StaticClass(); \
	ALadder::StaticClass(); \
	ULadderReachSpec::StaticClass(); \
	ALadderVolume::StaticClass(); \
	ULevel::StaticClass(); \
	ULevelBase::StaticClass(); \
	ULevelStreaming::StaticClass(); \
	ULevelStreamingDistance::StaticClass(); \
	ULevelStreamingKismet::StaticClass(); \
	ULevelStreamingPersistent::StaticClass(); \
	ALevelStreamingVolume::StaticClass(); \
	ALiftCenter::StaticClass(); \
	ALiftExit::StaticClass(); \
	ALight::StaticClass(); \
	ULightComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineULightComponentNative; \
	ULightEnvironmentComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineULightEnvironmentComponentNative; \
	ULightFunction::StaticClass(); \
	ULightMapTexture2D::StaticClass(); \
	ALightVolume::StaticClass(); \
	ULineBatchComponent::StaticClass(); \
	ULocalPlayer::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineULocalPlayerNative; \
	AMantleMarker::StaticClass(); \
	UMantleReachSpec::StaticClass(); \
	UMapInfo::StaticClass(); \
	UMaterial::StaticClass(); \
	UMaterialEffect::StaticClass(); \
	UMaterialExpression::StaticClass(); \
	AMaterialInstanceActor::StaticClass(); \
	UMaterialInterface::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMaterialInterfaceNative; \
	AMatineeActor::StaticClass(); \
	UMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMeshComponentNative; \
	UMeshComponentFactory::StaticClass(); \
	UModel::StaticClass(); \
	UModelComponent::StaticClass(); \
	UMotionBlurEffect::StaticClass(); \
	UMultiFont::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMultiFontNative; \
	UMusicTrackDataStructures::StaticClass(); \
	AMutator::StaticClass(); \
	ANavigationPoint::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineANavigationPointNative; \
	UNetConnection::StaticClass(); \
	UNetDriver::StaticClass(); \
	UNetPendingLevel::StaticClass(); \
	ANote::StaticClass(); \
	AObjective::StaticClass(); \
	UObjectReferencer::StaticClass(); \
	UOnlineGameplayEvents::StaticClass(); \
	UOnlineGameSearch::StaticClass(); \
	UOnlineGameSettings::StaticClass(); \
	UOnlinePlaylistManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUOnlinePlaylistManagerNative; \
	UOnlineProfileSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUOnlineProfileSettingsNative; \
	UOnlineStats::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUOnlineStatsNative; \
	UOnlineStatsRead::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUOnlineStatsReadNative; \
	UOnlineStatsWrite::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUOnlineStatsWriteNative; \
	UOnlineSubsystem::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUOnlineSubsystemNative; \
	UPackageMapLevel::StaticClass(); \
	UPackageMapSeekFree::StaticClass(); \
	APathBlockingVolume::StaticClass(); \
	APathNode::StaticClass(); \
	APawn::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPawnNative; \
	UPendingLevel::StaticClass(); \
	APhysicsVolume::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPhysicsVolumeNative; \
	APickupFactory::StaticClass(); \
	UPlayer::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPlayerNative; \
	APlayerController::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPlayerControllerNative; \
	APlayerReplicationInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPlayerReplicationInfoNative; \
	APlayerStart::StaticClass(); \
	APointLight::StaticClass(); \
	UPointLightComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPointLightComponentNative; \
	APointLightMovable::StaticClass(); \
	APointLightToggleable::StaticClass(); \
	APolyMarker::StaticClass(); \
	UPolys::StaticClass(); \
	APortalMarker::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPortalMarkerNative; \
	APortalTeleporter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPortalTeleporterNative; \
	APortalVolume::StaticClass(); \
	UPostProcessChain::StaticClass(); \
	UPostProcessEffect::StaticClass(); \
	APostProcessVolume::StaticClass(); \
	APotentialClimbWatcher::StaticClass(); \
	UPrimitiveComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPrimitiveComponentNative; \
	UPrimitiveComponentFactory::StaticClass(); \
	AProjectile::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAProjectileNative; \
	UProscribedReachSpec::StaticClass(); \
	UReachSpec::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUReachSpecNative; \
	AReplicationInfo::StaticClass(); \
	AReverbVolume::StaticClass(); \
	ARoute::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARouteNative; \
	USavedMove::StaticClass(); \
	USaveGameSummary::StaticClass(); \
	ASceneCapture2DActor::StaticClass(); \
	USceneCapture2DComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSceneCapture2DComponentNative; \
	ASceneCaptureActor::StaticClass(); \
	USceneCaptureComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSceneCaptureComponentNative; \
	ASceneCaptureCubeMapActor::StaticClass(); \
	USceneCaptureCubeMapComponent::StaticClass(); \
	ASceneCapturePortalActor::StaticClass(); \
	USceneCapturePortalComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSceneCapturePortalComponentNative; \
	ASceneCaptureReflectActor::StaticClass(); \
	USceneCaptureReflectComponent::StaticClass(); \
	AScout::StaticClass(); \
	UScriptedTexture::StaticClass(); \
	UServerCommandlet::StaticClass(); \
	USettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSettingsNative; \
	UShaderCache::StaticClass(); \
	UShadowMap1D::StaticClass(); \
	UShadowMap2D::StaticClass(); \
	UShadowMapTexture2D::StaticClass(); \
	USkeletalMesh::StaticClass(); \
	USkeletalMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSkeletalMeshComponentNative; \
	USkeletalMeshSocket::StaticClass(); \
	ASkyLight::StaticClass(); \
	USkyLightComponent::StaticClass(); \
	ASkyLightToggleable::StaticClass(); \
	USlotToSlotReachSpec::StaticClass(); \
	USmokeTestCommandlet::StaticClass(); \
	USoundCue::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSoundCueNative; \
	USpeechRecognition::StaticClass(); \
	USphericalHarmonicLightComponent::StaticClass(); \
	ASpotLight::StaticClass(); \
	USpotLightComponent::StaticClass(); \
	ASpotLightMovable::StaticClass(); \
	ASpotLightToggleable::StaticClass(); \
	USpriteComponent::StaticClass(); \
	AStaticLightCollectionActor::StaticClass(); \
	UStaticMesh::StaticClass(); \
	AStaticMeshActor::StaticClass(); \
	AStaticMeshActorBase::StaticClass(); \
	AStaticMeshActorBasedOnExtremeContent::StaticClass(); \
	AStaticMeshCollectionActor::StaticClass(); \
	UStaticMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUStaticMeshComponentNative; \
	UStaticMeshComponentFactory::StaticClass(); \
	USurface::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSurfaceNative; \
	USwatTurnReachSpec::StaticClass(); \
	ATeamInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineATeamInfoNative; \
	ATeleporter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineATeleporterNative; \
	UTeleportReachSpec::StaticClass(); \
	UTexture::StaticClass(); \
	UTexture2D::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTexture2DNative; \
	UTexture2DComposite::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTexture2DCompositeNative; \
	UTexture2DDynamic::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTexture2DDynamicNative; \
	UTextureCube::StaticClass(); \
	UTextureFlipBook::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTextureFlipBookNative; \
	UTextureMovie::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTextureMovieNative; \
	UTextureRenderTarget::StaticClass(); \
	UTextureRenderTarget2D::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTextureRenderTarget2DNative; \
	UTextureRenderTargetCube::StaticClass(); \
	ATrigger::StaticClass(); \
	ATriggerVolume::StaticClass(); \
	UUberPostProcessEffect::StaticClass(); \
	AVehicle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAVehicleNative; \
	UVoiceChannel::StaticClass(); \
	AVolume::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAVolumeNative; \
	AVolumePathNode::StaticClass(); \
	UWallTransReachSpec::StaticClass(); \
	UWaveFormBase::StaticClass(); \
	AWeapon::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAWeaponNative; \
	UWindDirectionalSourceComponent::StaticClass(); \
	UWorld::StaticClass(); \
	AWorldInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAWorldInfoNative; \
	AZoneInfo::StaticClass(); \

#endif // ENGINE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AActor) GEngineAActorNatives[] = 
{ 
	MAP_NATIVE(AActor,execSupportsKismetModification)
	MAP_NATIVE(AActor,execIsInPersistentLevel)
	MAP_NATIVE(AActor,execGetPackageGuid)
	MAP_NATIVE(AActor,execNativePostRenderFor)
	MAP_NATIVE(AActor,execSetHUDLocation)
	MAP_NATIVE(AActor,execGetTargetLocation)
	MAP_NATIVE(AActor,execGetTeamNum)
	MAP_NATIVE(AActor,execIsPlayerOwned)
	MAP_NATIVE(AActor,execPrestreamTextures)
	MAP_NATIVE(AActor,execSetNetUpdateTime)
	MAP_NATIVE(AActor,execGetGravityZ)
	MAP_NATIVE(AActor,execLocalPlayerControllers)
	MAP_NATIVE(AActor,execAllOwnedComponents)
	MAP_NATIVE(AActor,execComponentList)
	MAP_NATIVE(AActor,execOverlappingActors)
	MAP_NATIVE(AActor,execCollidingActors)
	MAP_NATIVE(AActor,execVisibleCollidingActors)
	MAP_NATIVE(AActor,execVisibleActors)
	MAP_NATIVE(AActor,execTraceActors)
	MAP_NATIVE(AActor,execTouchingActors)
	MAP_NATIVE(AActor,execBasedActors)
	MAP_NATIVE(AActor,execChildActors)
	MAP_NATIVE(AActor,execDynamicActors)
	MAP_NATIVE(AActor,execAllActors)
	MAP_NATIVE(AActor,execGetURLMap)
	MAP_NATIVE(AActor,execGetDestination)
	MAP_NATIVE(AActor,execSuggestTossVelocity)
	MAP_NATIVE(AActor,execPlayerCanSeeMe)
	MAP_NATIVE(AActor,execMakeNoise)
	MAP_NATIVE(AActor,execPlaySound)
	MAP_NATIVE(AActor,execCreateAudioComponent)
	MAP_NATIVE(AActor,execGetTimerRate)
	MAP_NATIVE(AActor,execGetTimerCount)
	MAP_NATIVE(AActor,execIsTimerActive)
	MAP_NATIVE(AActor,execPauseTimer)
	MAP_NATIVE(AActor,execClearTimer)
	MAP_NATIVE(AActor,execSetTimer)
	MAP_NATIVE(AActor,execDestroy)
	MAP_NATIVE(AActor,execSpawn)
	MAP_NATIVE(AActor,execGetBoundingCylinder)
	MAP_NATIVE(AActor,execGetComponentsBoundingBox)
	MAP_NATIVE(AActor,execIsOverlapping)
	MAP_NATIVE(AActor,execContainsPoint)
	MAP_NATIVE(AActor,execFindSpot)
	MAP_NATIVE(AActor,execTraceAllPhysicsAssetInteractions)
	MAP_NATIVE(AActor,execFastTrace)
	MAP_NATIVE(AActor,execPointCheckComponent)
	MAP_NATIVE(AActor,execTraceComponent)
	MAP_NATIVE(AActor,execTrace)
	MAP_NATIVE(AActor,execClampRotation)
	MAP_NATIVE(AActor,execSetTickGroup)
	MAP_NATIVE(AActor,execReattachComponent)
	MAP_NATIVE(AActor,execDetachComponent)
	MAP_NATIVE(AActor,execAttachComponent)
	MAP_NATIVE(AActor,execUnClock)
	MAP_NATIVE(AActor,execClock)
	MAP_NATIVE(AActor,execSetPhysics)
	MAP_NATIVE(AActor,execSetOnlyOwnerSee)
	MAP_NATIVE(AActor,execSetHidden)
	MAP_NATIVE(AActor,execChartData)
	MAP_NATIVE(AActor,execDrawDebugCone)
	MAP_NATIVE(AActor,execDrawDebugCylinder)
	MAP_NATIVE(AActor,execDrawDebugSphere)
	MAP_NATIVE(AActor,execDrawDebugCoordinateSystem)
	MAP_NATIVE(AActor,execDrawDebugBox)
	MAP_NATIVE(AActor,execDrawDebugLine)
	MAP_NATIVE(AActor,execFlushPersistentDebugLines)
	MAP_NATIVE(AActor,execSetForcedInitialReplicatedProperty)
	MAP_NATIVE(AActor,execIsOwnedBy)
	MAP_NATIVE(AActor,execGetBaseMost)
	MAP_NATIVE(AActor,execIsBasedOn)
	MAP_NATIVE(AActor,execFindBase)
	MAP_NATIVE(AActor,execSetOwner)
	MAP_NATIVE(AActor,execSetBase)
	MAP_NATIVE(AActor,execGetTerminalVelocity)
	MAP_NATIVE(AActor,execAutonomousPhysics)
	MAP_NATIVE(AActor,execMoveSmooth)
	MAP_NATIVE(AActor,execfixedTurn)
	MAP_NATIVE(AActor,execSetHardAttach)
	MAP_NATIVE(AActor,execSetRelativeLocation)
	MAP_NATIVE(AActor,execSetRelativeRotation)
	MAP_NATIVE(AActor,execSetZone)
	MAP_NATIVE(AActor,execMovingWhichWay)
	MAP_NATIVE(AActor,execSetRotation)
	MAP_NATIVE(AActor,execSetLocation)
	MAP_NATIVE(AActor,execMove)
	MAP_NATIVE(AActor,execSetDrawScale3D)
	MAP_NATIVE(AActor,execSetDrawScale)
	MAP_NATIVE(AActor,execSetCollisionType)
	MAP_NATIVE(AActor,execSetCollisionSize)
	MAP_NATIVE(AActor,execSetCollision)
	MAP_NATIVE(AActor,execFinishAnim)
	MAP_NATIVE(AActor,execSleep)
	MAP_NATIVE(AActor,execConsoleCommand)
	MAP_NATIVE(AActor,execForceUpdateComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AActor);

NATIVE_INFO(UActorComponent) GEngineUActorComponentNatives[] = 
{ 
	MAP_NATIVE(UActorComponent,execDetachFromAny)
	MAP_NATIVE(UActorComponent,execForceUpdate)
	MAP_NATIVE(UActorComponent,execSetComponentRBFixed)
	MAP_NATIVE(UActorComponent,execSetTickGroup)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UActorComponent);

NATIVE_INFO(AAnimatedCamera) GEngineAAnimatedCameraNatives[] = 
{ 
	MAP_NATIVE(AAnimatedCamera,execStopCameraAnim)
	MAP_NATIVE(AAnimatedCamera,execStopAllCameraAnimsByType)
	MAP_NATIVE(AAnimatedCamera,execStopAllCameraAnims)
	MAP_NATIVE(AAnimatedCamera,execPlayCameraAnim)
	MAP_NATIVE(AAnimatedCamera,execApplyCameraModifiersNative)
	MAP_NATIVE(AAnimatedCamera,execApplyCameraModifiers)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AAnimatedCamera);

NATIVE_INFO(UAudioComponent) GEngineUAudioComponentNatives[] = 
{ 
	MAP_NATIVE(UAudioComponent,execResetToDefaults)
	MAP_NATIVE(UAudioComponent,execSetWaveParameter)
	MAP_NATIVE(UAudioComponent,execSetFloatParameter)
	MAP_NATIVE(UAudioComponent,execAdjustVolume)
	MAP_NATIVE(UAudioComponent,execFadeOut)
	MAP_NATIVE(UAudioComponent,execFadeIn)
	MAP_NATIVE(UAudioComponent,execIsPlaying)
	MAP_NATIVE(UAudioComponent,execStop)
	MAP_NATIVE(UAudioComponent,execPlay)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAudioComponent);

NATIVE_INFO(ACamera) GEngineACameraNatives[] = 
{ 
	MAP_NATIVE(ACamera,execSetViewTarget)
	MAP_NATIVE(ACamera,execCheckViewTarget)
	MAP_NATIVE(ACamera,execApplyCameraModifiers)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ACamera);

NATIVE_INFO(UCameraAnimInst) GEngineUCameraAnimInstNatives[] = 
{ 
	MAP_NATIVE(UCameraAnimInst,execApplyTransientScaling)
	MAP_NATIVE(UCameraAnimInst,execStop)
	MAP_NATIVE(UCameraAnimInst,execAdvanceAnim)
	MAP_NATIVE(UCameraAnimInst,execUpdate)
	MAP_NATIVE(UCameraAnimInst,execPlay)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UCameraAnimInst);

NATIVE_INFO(UCameraModifier) GEngineUCameraModifierNatives[] = 
{ 
	MAP_NATIVE(UCameraModifier,execIsDisabled)
	MAP_NATIVE(UCameraModifier,execModifyCamera)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UCameraModifier);

NATIVE_INFO(UCanvas) GEngineUCanvasNatives[] = 
{ 
	MAP_NATIVE(UCanvas,execDrawTextureDoubleLine)
	MAP_NATIVE(UCanvas,execDrawTextureLine)
	MAP_NATIVE(UCanvas,execDraw2DLine)
	MAP_NATIVE(UCanvas,execDrawRotatedMaterialTile)
	MAP_NATIVE(UCanvas,execDrawRotatedTile)
	MAP_NATIVE(UCanvas,execSetDrawColor)
	MAP_NATIVE(UCanvas,execSetPos)
	MAP_NATIVE(UCanvas,execDrawColorizedTile)
	MAP_NATIVE(UCanvas,execDrawTileStretched)
	MAP_NATIVE(UCanvas,execPopTransform)
	MAP_NATIVE(UCanvas,execPushTranslationMatrix)
	MAP_NATIVE(UCanvas,execProject)
	MAP_NATIVE(UCanvas,execDrawTileClipped)
	MAP_NATIVE(UCanvas,execDrawTextClipped)
	MAP_NATIVE(UCanvas,execDrawText)
	MAP_NATIVE(UCanvas,execTextSize)
	MAP_NATIVE(UCanvas,execStrLen)
	MAP_NATIVE(UCanvas,execDrawMaterialTileClipped)
	MAP_NATIVE(UCanvas,execDrawMaterialTile)
	MAP_NATIVE(UCanvas,execDrawTile)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UCanvas);

NATIVE_INFO(AController) GEngineAControllerNatives[] = 
{ 
	MAP_NATIVE(AController,execStopLatentExecution)
	MAP_NATIVE(AController,execInLatentExecution)
	MAP_NATIVE(AController,execEndClimbLadder)
	MAP_NATIVE(AController,execWaitForLanding)
	MAP_NATIVE(AController,execPickWallAdjust)
	MAP_NATIVE(AController,execActorReachable)
	MAP_NATIVE(AController,execPointReachable)
	MAP_NATIVE(AController,execFindPathToIntercept)
	MAP_NATIVE(AController,execFindRandomDest)
	MAP_NATIVE(AController,execFindPathTowardNearest)
	MAP_NATIVE(AController,execFindPathToward)
	MAP_NATIVE(AController,execFindPathTo)
	MAP_NATIVE(AController,execFinishRotation)
	MAP_NATIVE(AController,execMoveToward)
	MAP_NATIVE(AController,execMoveTo)
	MAP_NATIVE(AController,execPickTarget)
	MAP_NATIVE(AController,execCanSeeByPoints)
	MAP_NATIVE(AController,execCanSee)
	MAP_NATIVE(AController,execLineOfSightTo)
	MAP_NATIVE(AController,execGetTeamNum)
	MAP_NATIVE(AController,execBeyondFogDistance)
	MAP_NATIVE(AController,execGetAdjustLocation)
	MAP_NATIVE(AController,execSetAdjustLocation)
	MAP_NATIVE(AController,execGetDestinationPosition)
	MAP_NATIVE(AController,execSetDestinationPosition)
	MAP_NATIVE(AController,execGetFocalPoint)
	MAP_NATIVE(AController,execSetFocalPoint)
	MAP_NATIVE(AController,execGetBasedPosition)
	MAP_NATIVE(AController,execSetBasedPosition)
	MAP_NATIVE(AController,execRouteCache_RemoveIndex)
	MAP_NATIVE(AController,execRouteCache_RemoveItem)
	MAP_NATIVE(AController,execRouteCache_InsertItem)
	MAP_NATIVE(AController,execRouteCache_AddItem)
	MAP_NATIVE(AController,execRouteCache_Empty)
	MAP_NATIVE(AController,execIsLocalPlayerController)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AController);

NATIVE_INFO(ACoverGroup) GEngineACoverGroupNatives[] = 
{ 
	MAP_NATIVE(ACoverGroup,execToggleGroup)
	MAP_NATIVE(ACoverGroup,execDisableGroup)
	MAP_NATIVE(ACoverGroup,execEnableGroup)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ACoverGroup);

NATIVE_INFO(ACoverLink) GEngineACoverLinkNatives[] = 
{ 
	MAP_NATIVE(ACoverLink,execGetLocationDescription)
	MAP_NATIVE(ACoverLink,execAddCoverSlot)
	MAP_NATIVE(ACoverLink,execIsEnabled)
	MAP_NATIVE(ACoverLink,execAutoAdjustSlot)
	MAP_NATIVE(ACoverLink,execGetSlotActions)
	MAP_NATIVE(ACoverLink,execHasFireLinkTo)
	MAP_NATIVE(ACoverLink,execGetFireLinkTo)
	MAP_NATIVE(ACoverLink,execGetSlotIdxToRight)
	MAP_NATIVE(ACoverLink,execGetSlotIdxToLeft)
	MAP_NATIVE(ACoverLink,execIsRightEdgeSlot)
	MAP_NATIVE(ACoverLink,execIsLeftEdgeSlot)
	MAP_NATIVE(ACoverLink,execIsEdgeSlot)
	MAP_NATIVE(ACoverLink,execFindSlots)
	MAP_NATIVE(ACoverLink,execIsValidClaim)
	MAP_NATIVE(ACoverLink,execIsExposedTo)
	MAP_NATIVE(ACoverLink,execGetSlotMarker)
	MAP_NATIVE(ACoverLink,execGetSlotViewPoint)
	MAP_NATIVE(ACoverLink,execGetSlotRotation)
	MAP_NATIVE(ACoverLink,execGetSlotLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ACoverLink);

NATIVE_INFO(ACoverSlotMarker) GEngineACoverSlotMarkerNatives[] = 
{ 
	MAP_NATIVE(ACoverSlotMarker,execIsValidClaim)
	MAP_NATIVE(ACoverSlotMarker,execSetSlotEnabled)
	MAP_NATIVE(ACoverSlotMarker,execGetSlotRotation)
	MAP_NATIVE(ACoverSlotMarker,execGetSlotLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ACoverSlotMarker);

NATIVE_INFO(UCylinderComponent) GEngineUCylinderComponentNatives[] = 
{ 
	MAP_NATIVE(UCylinderComponent,execSetCylinderSize)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UCylinderComponent);

NATIVE_INFO(ADroppedPickup) GEngineADroppedPickupNatives[] = 
{ 
	MAP_NATIVE(ADroppedPickup,execRemoveFromNavigation)
	MAP_NATIVE(ADroppedPickup,execAddToNavigation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ADroppedPickup);

NATIVE_INFO(AEmitter) GEngineAEmitterNatives[] = 
{ 
	MAP_NATIVE(AEmitter,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AEmitter);

NATIVE_INFO(AEmitterPool) GEngineAEmitterPoolNatives[] = 
{ 
	MAP_NATIVE(AEmitterPool,execGetPooledComponent)
	MAP_NATIVE(AEmitterPool,execGetFreeMatInstConsts)
	MAP_NATIVE(AEmitterPool,execFreeMaterialInstanceConstants)
	MAP_NATIVE(AEmitterPool,execGetFreeStaticMeshComponent)
	MAP_NATIVE(AEmitterPool,execFreeStaticMeshComponents)
	MAP_NATIVE(AEmitterPool,execReturnToPool)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AEmitterPool);

NATIVE_INFO(UFaceFXAsset) GEngineUFaceFXAssetNatives[] = 
{ 
	MAP_NATIVE(UFaceFXAsset,execUnmountFaceFXAnimSet)
	MAP_NATIVE(UFaceFXAsset,execMountFaceFXAnimSet)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UFaceFXAsset);

NATIVE_INFO(AFileWriter) GEngineAFileWriterNatives[] = 
{ 
	MAP_NATIVE(AFileWriter,execLogf)
	MAP_NATIVE(AFileWriter,execCloseFile)
	MAP_NATIVE(AFileWriter,execOpenFile)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AFileWriter);

NATIVE_INFO(UFont) GEngineUFontNatives[] = 
{ 
	MAP_NATIVE(UFont,execGetMaxCharHeight)
	MAP_NATIVE(UFont,execGetAuthoredViewportHeight)
	MAP_NATIVE(UFont,execGetScalingFactor)
	MAP_NATIVE(UFont,execGetResolutionPageIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UFont);

NATIVE_INFO(AGameInfo) GEngineAGameInfoNatives[] = 
{ 
	MAP_NATIVE(AGameInfo,execDoSentinel_PerfAtSpecificLocation)
	MAP_NATIVE(AGameInfo,execDoSentinel_MemoryAtSpecificLocation)
	MAP_NATIVE(AGameInfo,execGetTravelLocations)
	MAP_NATIVE(AGameInfo,execHandlePerLoadedMapAudioStats)
	MAP_NATIVE(AGameInfo,execDoSentinelActionPerLoadedMap)
	MAP_NATIVE(AGameInfo,execEndSentinelRun)
	MAP_NATIVE(AGameInfo,execAddSentinelPerTimePeriodStats)
	MAP_NATIVE(AGameInfo,execBeginSentinelRun)
	MAP_NATIVE(AGameInfo,execSwapPlayerControllers)
	MAP_NATIVE(AGameInfo,execForceClearUnpauseDelegates)
	MAP_NATIVE(AGameInfo,execGetNetworkNumber)
	MAP_NATIVE(AGameInfo,execDoNavFearCostFallOff)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AGameInfo);

NATIVE_INFO(AGameReplicationInfo) GEngineAGameReplicationInfoNatives[] = 
{ 
	MAP_NATIVE(AGameReplicationInfo,execOnSameTeam)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AGameReplicationInfo);

NATIVE_INFO(UGameViewportClient) GEngineUGameViewportClientNatives[] = 
{ 
	MAP_NATIVE(UGameViewportClient,execShouldForceFullscreenViewport)
	MAP_NATIVE(UGameViewportClient,execIsFullScreenViewport)
	MAP_NATIVE(UGameViewportClient,execGetViewportSize)
	MAP_NATIVE(UGameViewportClient,execConsoleCommand)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UGameViewportClient);

NATIVE_INFO(UHeightFogComponent) GEngineUHeightFogComponentNatives[] = 
{ 
	MAP_NATIVE(UHeightFogComponent,execSetEnabled)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UHeightFogComponent);

NATIVE_INFO(AHUD) GEngineAHUDNatives[] = 
{ 
	MAP_NATIVE(AHUD,execDraw2DLine)
	MAP_NATIVE(AHUD,execDraw3DLine)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AHUD);

NATIVE_INFO(UIniLocPatcher) GEngineUIniLocPatcherNatives[] = 
{ 
	MAP_NATIVE(UIniLocPatcher,execProcessIniLocFile)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UIniLocPatcher);

NATIVE_INFO(AInterpActor) GEngineAInterpActorNatives[] = 
{ 
	MAP_NATIVE(AInterpActor,execSetShadowParentOnAllAttachedComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AInterpActor);

NATIVE_INFO(AInventoryManager) GEngineAInventoryManagerNatives[] = 
{ 
	MAP_NATIVE(AInventoryManager,execInventoryActors)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AInventoryManager);

NATIVE_INFO(ULightComponent) GEngineULightComponentNatives[] = 
{ 
	MAP_NATIVE(ULightComponent,execUpdateColorAndBrightness)
	MAP_NATIVE(ULightComponent,execGetDirection)
	MAP_NATIVE(ULightComponent,execGetOrigin)
	MAP_NATIVE(ULightComponent,execSetLightProperties)
	MAP_NATIVE(ULightComponent,execSetEnabled)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ULightComponent);

NATIVE_INFO(ULightEnvironmentComponent) GEngineULightEnvironmentComponentNatives[] = 
{ 
	MAP_NATIVE(ULightEnvironmentComponent,execIsEnabled)
	MAP_NATIVE(ULightEnvironmentComponent,execSetEnabled)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ULightEnvironmentComponent);

NATIVE_INFO(ULocalPlayer) GEngineULocalPlayerNatives[] = 
{ 
	MAP_NATIVE(ULocalPlayer,execTouchPlayerPostProcessChain)
	MAP_NATIVE(ULocalPlayer,execGetPostProcessChain)
	MAP_NATIVE(ULocalPlayer,execRemoveAllPostProcessingChains)
	MAP_NATIVE(ULocalPlayer,execRemovePostProcessingChain)
	MAP_NATIVE(ULocalPlayer,execInsertPostProcessingChain)
	MAP_NATIVE(ULocalPlayer,execGetActorVisibility)
	MAP_NATIVE(ULocalPlayer,execSendSplitJoin)
	MAP_NATIVE(ULocalPlayer,execSpawnPlayActor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ULocalPlayer);

NATIVE_INFO(UMaterialInterface) GEngineUMaterialInterfaceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInterface,execSetForceMipLevelsToBeResident)
	MAP_NATIVE(UMaterialInterface,execGetVectorCurveParameterValue)
	MAP_NATIVE(UMaterialInterface,execGetVectorParameterValue)
	MAP_NATIVE(UMaterialInterface,execGetTextureParameterValue)
	MAP_NATIVE(UMaterialInterface,execGetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInterface,execGetScalarParameterValue)
	MAP_NATIVE(UMaterialInterface,execGetFontParameterValue)
	MAP_NATIVE(UMaterialInterface,execGetPhysicalMaterial)
	MAP_NATIVE(UMaterialInterface,execGetMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMaterialInterface);

NATIVE_INFO(UMeshComponent) GEngineUMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UMeshComponent,execPrestreamTextures)
	MAP_NATIVE(UMeshComponent,execGetNumElements)
	MAP_NATIVE(UMeshComponent,execSetMaterial)
	MAP_NATIVE(UMeshComponent,execGetMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMeshComponent);

NATIVE_INFO(UMultiFont) GEngineUMultiFontNatives[] = 
{ 
	MAP_NATIVE(UMultiFont,execGetResolutionTestTableIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMultiFont);

NATIVE_INFO(ANavigationPoint) GEngineANavigationPointNatives[] = 
{ 
	MAP_NATIVE(ANavigationPoint,execIsOnDifferentNetwork)
	MAP_NATIVE(ANavigationPoint,execGetAllNavInRadius)
	MAP_NATIVE(ANavigationPoint,execCanTeleport)
	MAP_NATIVE(ANavigationPoint,execIsUsableAnchorFor)
	MAP_NATIVE(ANavigationPoint,execGetReachSpecTo)
	MAP_NATIVE(ANavigationPoint,execGetBoundingCylinder)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ANavigationPoint);

NATIVE_INFO(UOnlinePlaylistManager) GEngineUOnlinePlaylistManagerNatives[] = 
{ 
	MAP_NATIVE(UOnlinePlaylistManager,execFinalizePlaylistObjects)
	MAP_NATIVE(UOnlinePlaylistManager,execDetermineFilesToDownload)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UOnlinePlaylistManager);

NATIVE_INFO(UOnlineProfileSettings) GEngineUOnlineProfileSettingsNatives[] = 
{ 
	MAP_NATIVE(UOnlineProfileSettings,execGetRangedProfileSettingValue)
	MAP_NATIVE(UOnlineProfileSettings,execSetRangedProfileSettingValue)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingRange)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingMappingType)
	MAP_NATIVE(UOnlineProfileSettings,execSetDefaultVersionNumber)
	MAP_NATIVE(UOnlineProfileSettings,execGetVersionNumber)
	MAP_NATIVE(UOnlineProfileSettings,execAppendVersionToSettings)
	MAP_NATIVE(UOnlineProfileSettings,execAppendVersionToReadIds)
	MAP_NATIVE(UOnlineProfileSettings,execSetToDefaults)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingDefaultFloat)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingDefaultInt)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingDefaultId)
	MAP_NATIVE(UOnlineProfileSettings,execSetProfileSettingValueFloat)
	MAP_NATIVE(UOnlineProfileSettings,execSetProfileSettingValueInt)
	MAP_NATIVE(UOnlineProfileSettings,execSetProfileSettingValueId)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValueFloat)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValueInt)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValueId)
	MAP_NATIVE(UOnlineProfileSettings,execSetProfileSettingValue)
	MAP_NATIVE(UOnlineProfileSettings,execSetProfileSettingValueByName)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValueByName)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValues)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValueName)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingValue)
	MAP_NATIVE(UOnlineProfileSettings,execIsProfileSettingIdMapped)
	MAP_NATIVE(UOnlineProfileSettings,execFindProfileMappingIndexByName)
	MAP_NATIVE(UOnlineProfileSettings,execFindProfileMappingIndex)
	MAP_NATIVE(UOnlineProfileSettings,execFindProfileSettingIndex)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingColumnHeader)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingName)
	MAP_NATIVE(UOnlineProfileSettings,execGetProfileSettingId)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UOnlineProfileSettings);

NATIVE_INFO(UOnlineStats) GEngineUOnlineStatsNatives[] = 
{ 
	MAP_NATIVE(UOnlineStats,execGetViewName)
	MAP_NATIVE(UOnlineStats,execGetViewId)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UOnlineStats);

NATIVE_INFO(UOnlineStatsRead) GEngineUOnlineStatsReadNatives[] = 
{ 
	MAP_NATIVE(UOnlineStatsRead,execGetRankForPlayer)
	MAP_NATIVE(UOnlineStatsRead,execAddPlayer)
	MAP_NATIVE(UOnlineStatsRead,execSetFloatStatValueForPlayer)
	MAP_NATIVE(UOnlineStatsRead,execGetFloatStatValueForPlayer)
	MAP_NATIVE(UOnlineStatsRead,execSetIntStatValueForPlayer)
	MAP_NATIVE(UOnlineStatsRead,execGetIntStatValueForPlayer)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UOnlineStatsRead);

NATIVE_INFO(UOnlineStatsWrite) GEngineUOnlineStatsWriteNatives[] = 
{ 
	MAP_NATIVE(UOnlineStatsWrite,execDecrementIntStat)
	MAP_NATIVE(UOnlineStatsWrite,execDecrementFloatStat)
	MAP_NATIVE(UOnlineStatsWrite,execIncrementIntStat)
	MAP_NATIVE(UOnlineStatsWrite,execIncrementFloatStat)
	MAP_NATIVE(UOnlineStatsWrite,execSetIntStat)
	MAP_NATIVE(UOnlineStatsWrite,execSetFloatStat)
	MAP_NATIVE(UOnlineStatsWrite,execGetStatName)
	MAP_NATIVE(UOnlineStatsWrite,execGetStatId)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UOnlineStatsWrite);

NATIVE_INFO(UOnlineSubsystem) GEngineUOnlineSubsystemNatives[] = 
{ 
	MAP_NATIVE(UOnlineSubsystem,execGetBuildUniqueId)
	MAP_NATIVE(UOnlineSubsystem,execAreUniqueNetIdsEqual)
	MAP_NATIVE(UOnlineSubsystem,execStringToUniqueNetId)
	MAP_NATIVE(UOnlineSubsystem,execUniqueNetIdToString)
	MAP_NATIVE(UOnlineSubsystem,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UOnlineSubsystem);

NATIVE_INFO(APawn) GEngineAPawnNatives[] = 
{ 
	MAP_NATIVE(APawn,execClearPathStep)
	MAP_NATIVE(APawn,execDrawPathStep)
	MAP_NATIVE(APawn,execIncrementPathChild)
	MAP_NATIVE(APawn,execIncrementPathStep)
	MAP_NATIVE(APawn,execAddGoalEvaluator)
	MAP_NATIVE(APawn,execAddPathConstraint)
	MAP_NATIVE(APawn,execClearConstraints)
	MAP_NATIVE(APawn,execGetVehicleBase)
	MAP_NATIVE(APawn,execGetTeamNum)
	MAP_NATIVE(APawn,execGetPawnViewLocation)
	MAP_NATIVE(APawn,execGetViewRotation)
	MAP_NATIVE(APawn,execIsPlayerPawn)
	MAP_NATIVE(APawn,execIsLocallyControlled)
	MAP_NATIVE(APawn,execIsHumanControlled)
	MAP_NATIVE(APawn,execTermRagdoll)
	MAP_NATIVE(APawn,execInitRagdoll)
	MAP_NATIVE(APawn,execGetBoundingCylinder)
	MAP_NATIVE(APawn,execReachedDesiredRotation)
	MAP_NATIVE(APawn,execSetPushesRigidBodies)
	MAP_NATIVE(APawn,execForceCrouch)
	MAP_NATIVE(APawn,execReachedPoint)
	MAP_NATIVE(APawn,execReachedDestination)
	MAP_NATIVE(APawn,execGetBestAnchor)
	MAP_NATIVE(APawn,execSetAnchor)
	MAP_NATIVE(APawn,execSetRemoteViewPitch)
	MAP_NATIVE(APawn,execIsInvisible)
	MAP_NATIVE(APawn,execIsValidEnemyTargetFor)
	MAP_NATIVE(APawn,execIsValidTargetFor)
	MAP_NATIVE(APawn,execSuggestJumpVelocity)
	MAP_NATIVE(APawn,execValidAnchor)
	MAP_NATIVE(APawn,execAdjustDestination)
	MAP_NATIVE(APawn,execIsAliveAndWell)
	MAP_NATIVE(APawn,execGetBasedPosition)
	MAP_NATIVE(APawn,execSetBasedPosition)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APawn);

NATIVE_INFO(APhysicsVolume) GEngineAPhysicsVolumeNatives[] = 
{ 
	MAP_NATIVE(APhysicsVolume,execGetGravityZ)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APhysicsVolume);

NATIVE_INFO(UPlayer) GEngineUPlayerNatives[] = 
{ 
	MAP_NATIVE(UPlayer,execSwitchController)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPlayer);

NATIVE_INFO(APlayerController) GEngineAPlayerControllerNatives[] = 
{ 
	MAP_NATIVE(APlayerController,execLogOutBugItAIGoToLogFile)
	MAP_NATIVE(APlayerController,execLogOutBugItGoToLogFile)
	MAP_NATIVE(APlayerController,execGetFRotatorFromString)
	MAP_NATIVE(APlayerController,execGetFVectorFromString)
	MAP_NATIVE(APlayerController,execShowSurvey)
	MAP_NATIVE(APlayerController,execIsShowingSubtitles)
	MAP_NATIVE(APlayerController,execSetShowSubtitles)
	MAP_NATIVE(APlayerController,execGetPlayerControllerFromNetId)
	MAP_NATIVE(APlayerController,execIsPlayerMuted)
	MAP_NATIVE(APlayerController,execClientFlushLevelStreaming)
	MAP_NATIVE(APlayerController,execServerUpdateLevelVisibility)
	MAP_NATIVE(APlayerController,execClientUpdateLevelStreamingStatus)
	MAP_NATIVE(APlayerController,execGetViewTarget)
	MAP_NATIVE(APlayerController,execSetViewTarget)
	MAP_NATIVE(APlayerController,execIsLocalPlayerController)
	MAP_NATIVE(APlayerController,execHasClientLoadedCurrentWorld)
	MAP_NATIVE(APlayerController,execServerNotifyLoadedWorld)
	MAP_NATIVE(APlayerController,execCreateTTSSoundCue)
	MAP_NATIVE(APlayerController,execGetPooledAudioComponent)
	MAP_NATIVE(APlayerController,execIsMouseAvailable)
	MAP_NATIVE(APlayerController,execIsKeyboardAvailable)
	MAP_NATIVE(APlayerController,execSetUseTiltForwardAndBack)
	MAP_NATIVE(APlayerController,execSetOnlyUseControllerTiltInput)
	MAP_NATIVE(APlayerController,execSetControllerTiltActive)
	MAP_NATIVE(APlayerController,execSetControllerTiltDesiredIfAvailable)
	MAP_NATIVE(APlayerController,execIsControllerTiltActive)
	MAP_NATIVE(APlayerController,execCleanUpAudioComponents)
	MAP_NATIVE(APlayerController,execFindStairRotation)
	MAP_NATIVE(APlayerController,execCheckSpeedHack)
	MAP_NATIVE(APlayerController,execServerProcessConvolve)
	MAP_NATIVE(APlayerController,execClientConvolve)
	MAP_NATIVE(APlayerController,execSetAudioGroupVolume)
	MAP_NATIVE(APlayerController,execSetAllowMatureLanguage)
	MAP_NATIVE(APlayerController,execPasteFromClipboard)
	MAP_NATIVE(APlayerController,execCopyToClipboard)
	MAP_NATIVE(APlayerController,execGetDefaultURL)
	MAP_NATIVE(APlayerController,execUpdateURL)
	MAP_NATIVE(APlayerController,execClientTravel)
	MAP_NATIVE(APlayerController,execConsoleCommand)
	MAP_NATIVE(APlayerController,execGetServerNetworkAddress)
	MAP_NATIVE(APlayerController,execGetPlayerNetworkAddress)
	MAP_NATIVE(APlayerController,execSetNetSpeed)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APlayerController);

NATIVE_INFO(APlayerReplicationInfo) GEngineAPlayerReplicationInfoNatives[] = 
{ 
	MAP_NATIVE(APlayerReplicationInfo,execGetTeamNum)
	MAP_NATIVE(APlayerReplicationInfo,execUpdatePing)
	MAP_NATIVE(APlayerReplicationInfo,execGetPlayerAlias)
	MAP_NATIVE(APlayerReplicationInfo,execAreUniqueNetIdsEqual)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APlayerReplicationInfo);

NATIVE_INFO(UPointLightComponent) GEngineUPointLightComponentNatives[] = 
{ 
	MAP_NATIVE(UPointLightComponent,execSetTranslation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPointLightComponent);

NATIVE_INFO(APortalMarker) GEngineAPortalMarkerNatives[] = 
{ 
	MAP_NATIVE(APortalMarker,execCanTeleport)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APortalMarker);

NATIVE_INFO(APortalTeleporter) GEngineAPortalTeleporterNatives[] = 
{ 
	MAP_NATIVE(APortalTeleporter,execCreatePortalTexture)
	MAP_NATIVE(APortalTeleporter,execTransformHitLocation)
	MAP_NATIVE(APortalTeleporter,execTransformVectorDir)
	MAP_NATIVE(APortalTeleporter,execTransformActor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APortalTeleporter);

NATIVE_INFO(UPrimitiveComponent) GEngineUPrimitiveComponentNatives[] = 
{ 
	MAP_NATIVE(UPrimitiveComponent,execGetRotation)
	MAP_NATIVE(UPrimitiveComponent,execSetAbsolute)
	MAP_NATIVE(UPrimitiveComponent,execSetScale3D)
	MAP_NATIVE(UPrimitiveComponent,execSetScale)
	MAP_NATIVE(UPrimitiveComponent,execSetRotation)
	MAP_NATIVE(UPrimitiveComponent,execSetTranslation)
	MAP_NATIVE(UPrimitiveComponent,execSetActorCollision)
	MAP_NATIVE(UPrimitiveComponent,execSetTraceBlocking)
	MAP_NATIVE(UPrimitiveComponent,execSetViewOwnerDepthPriorityGroup)
	MAP_NATIVE(UPrimitiveComponent,execSetDepthPriorityGroup)
	MAP_NATIVE(UPrimitiveComponent,execSetLightingChannels)
	MAP_NATIVE(UPrimitiveComponent,execSetCullDistance)
	MAP_NATIVE(UPrimitiveComponent,execSetLightEnvironment)
	MAP_NATIVE(UPrimitiveComponent,execSetShadowParent)
	MAP_NATIVE(UPrimitiveComponent,execSetIgnoreOwnerHidden)
	MAP_NATIVE(UPrimitiveComponent,execSetOnlyOwnerSee)
	MAP_NATIVE(UPrimitiveComponent,execSetOwnerNoSee)
	MAP_NATIVE(UPrimitiveComponent,execSetHidden)
	MAP_NATIVE(UPrimitiveComponent,execSetRBDominanceGroup)
	MAP_NATIVE(UPrimitiveComponent,execGetRootBodyInstance)
	MAP_NATIVE(UPrimitiveComponent,execSetPhysMaterialOverride)
	MAP_NATIVE(UPrimitiveComponent,execInitRBPhys)
	MAP_NATIVE(UPrimitiveComponent,execSetNotifyRigidBodyCollision)
	MAP_NATIVE(UPrimitiveComponent,execSetRBChannel)
	MAP_NATIVE(UPrimitiveComponent,execSetRBCollidesWithChannel)
	MAP_NATIVE(UPrimitiveComponent,execSetBlockRigidBody)
	MAP_NATIVE(UPrimitiveComponent,execRigidBodyIsAwake)
	MAP_NATIVE(UPrimitiveComponent,execPutRigidBodyToSleep)
	MAP_NATIVE(UPrimitiveComponent,execWakeRigidBody)
	MAP_NATIVE(UPrimitiveComponent,execSetRBRotation)
	MAP_NATIVE(UPrimitiveComponent,execSetRBPosition)
	MAP_NATIVE(UPrimitiveComponent,execRetardRBLinearVelocity)
	MAP_NATIVE(UPrimitiveComponent,execSetRBAngularVelocity)
	MAP_NATIVE(UPrimitiveComponent,execSetRBLinearVelocity)
	MAP_NATIVE(UPrimitiveComponent,execAddTorque)
	MAP_NATIVE(UPrimitiveComponent,execAddRadialForce)
	MAP_NATIVE(UPrimitiveComponent,execAddForce)
	MAP_NATIVE(UPrimitiveComponent,execAddRadialImpulse)
	MAP_NATIVE(UPrimitiveComponent,execAddImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPrimitiveComponent);

NATIVE_INFO(AProjectile) GEngineAProjectileNatives[] = 
{ 
	MAP_NATIVE(AProjectile,execGetTeamNum)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AProjectile);

NATIVE_INFO(UReachSpec) GEngineUReachSpecNatives[] = 
{ 
	MAP_NATIVE(UReachSpec,execGetDirection)
	MAP_NATIVE(UReachSpec,execGetEnd)
	MAP_NATIVE(UReachSpec,execCostFor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UReachSpec);

NATIVE_INFO(ARoute) GEngineARouteNatives[] = 
{ 
	MAP_NATIVE(ARoute,execMoveOntoRoutePath)
	MAP_NATIVE(ARoute,execResolveRouteIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARoute);

NATIVE_INFO(USceneCapture2DComponent) GEngineUSceneCapture2DComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCapture2DComponent,execSetView)
	MAP_NATIVE(USceneCapture2DComponent,execSetCaptureParameters)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USceneCapture2DComponent);

NATIVE_INFO(USceneCaptureComponent) GEngineUSceneCaptureComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCaptureComponent,execSetFrameRate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USceneCaptureComponent);

NATIVE_INFO(USceneCapturePortalComponent) GEngineUSceneCapturePortalComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCapturePortalComponent,execSetCaptureParameters)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USceneCapturePortalComponent);

NATIVE_INFO(USettings) GEngineUSettingsNatives[] = 
{ 
	MAP_NATIVE(USettings,execUpdateFromURL)
	MAP_NATIVE(USettings,execBuildURL)
	MAP_NATIVE(USettings,execAppendContextsToURL)
	MAP_NATIVE(USettings,execAppendPropertiesToURL)
	MAP_NATIVE(USettings,execAppendDataBindingsToURL)
	MAP_NATIVE(USettings,execGetQoSAdvertisedStringSettings)
	MAP_NATIVE(USettings,execGetQoSAdvertisedProperties)
	MAP_NATIVE(USettings,execGetRangedPropertyValue)
	MAP_NATIVE(USettings,execSetRangedPropertyValue)
	MAP_NATIVE(USettings,execGetPropertyRange)
	MAP_NATIVE(USettings,execGetPropertyMappingType)
	MAP_NATIVE(USettings,execHasStringSetting)
	MAP_NATIVE(USettings,execHasProperty)
	MAP_NATIVE(USettings,execUpdateProperties)
	MAP_NATIVE(USettings,execUpdateStringSettings)
	MAP_NATIVE(USettings,execGetPropertyType)
	MAP_NATIVE(USettings,execGetPropertyValueId)
	MAP_NATIVE(USettings,execSetPropertyValueId)
	MAP_NATIVE(USettings,execGetStringProperty)
	MAP_NATIVE(USettings,execSetStringProperty)
	MAP_NATIVE(USettings,execGetIntProperty)
	MAP_NATIVE(USettings,execSetIntProperty)
	MAP_NATIVE(USettings,execGetFloatProperty)
	MAP_NATIVE(USettings,execSetFloatProperty)
	MAP_NATIVE(USettings,execSetPropertyFromStringByName)
	MAP_NATIVE(USettings,execGetPropertyAsStringByName)
	MAP_NATIVE(USettings,execGetPropertyAsString)
	MAP_NATIVE(USettings,execGetPropertyColumnHeader)
	MAP_NATIVE(USettings,execGetPropertyName)
	MAP_NATIVE(USettings,execGetPropertyId)
	MAP_NATIVE(USettings,execSetStringSettingValueFromStringByName)
	MAP_NATIVE(USettings,execGetStringSettingValueNameByName)
	MAP_NATIVE(USettings,execGetStringSettingValueName)
	MAP_NATIVE(USettings,execIsWildcardStringSetting)
	MAP_NATIVE(USettings,execGetStringSettingColumnHeader)
	MAP_NATIVE(USettings,execGetStringSettingName)
	MAP_NATIVE(USettings,execGetStringSettingId)
	MAP_NATIVE(USettings,execGetStringSettingValueByName)
	MAP_NATIVE(USettings,execSetStringSettingValueByName)
	MAP_NATIVE(USettings,execGetStringSettingValueNames)
	MAP_NATIVE(USettings,execIncrementStringSettingValue)
	MAP_NATIVE(USettings,execGetStringSettingValue)
	MAP_NATIVE(USettings,execSetStringSettingValue)
	MAP_NATIVE(USettings,execGetSettingsDataDateTime)
	MAP_NATIVE(USettings,execGetSettingsDataBlob)
	MAP_NATIVE(USettings,execGetSettingsDataInt)
	MAP_NATIVE(USettings,execGetSettingsDataFloat)
	MAP_NATIVE(USettings,execGetSettingsDataString)
	MAP_NATIVE(USettings,execEmptySettingsData)
	MAP_NATIVE(USettings,execSetSettingsData)
	MAP_NATIVE(USettings,execSetSettingsDataBlob)
	MAP_NATIVE(USettings,execSetSettingsDataDateTime)
	MAP_NATIVE(USettings,execSetSettingsDataInt)
	MAP_NATIVE(USettings,execSetSettingsDataFloat)
	MAP_NATIVE(USettings,execSetSettingsDataString)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USettings);

NATIVE_INFO(USkeletalMeshComponent) GEngineUSkeletalMeshComponentNatives[] = 
{ 
	MAP_NATIVE(USkeletalMeshComponent,execUpdateMeshForBrokenConstraints)
	MAP_NATIVE(USkeletalMeshComponent,execIsBoneHidden)
	MAP_NATIVE(USkeletalMeshComponent,execUnHideBone)
	MAP_NATIVE(USkeletalMeshComponent,execHideBone)
	MAP_NATIVE(USkeletalMeshComponent,execSetFaceFXRegisterEx)
	MAP_NATIVE(USkeletalMeshComponent,execSetFaceFXRegister)
	MAP_NATIVE(USkeletalMeshComponent,execGetFaceFXRegister)
	MAP_NATIVE(USkeletalMeshComponent,execDeclareFaceFXRegister)
	MAP_NATIVE(USkeletalMeshComponent,execIsPlayingFaceFXAnim)
	MAP_NATIVE(USkeletalMeshComponent,execStopFaceFXAnim)
	MAP_NATIVE(USkeletalMeshComponent,execPlayFaceFXAnim)
	MAP_NATIVE(USkeletalMeshComponent,execToggleInstanceVertexWeights)
	MAP_NATIVE(USkeletalMeshComponent,execUpdateInstanceVertexWeightBones)
	MAP_NATIVE(USkeletalMeshComponent,execFindInstanceVertexweightBonePair)
	MAP_NATIVE(USkeletalMeshComponent,execRemoveInstanceVertexWeightBoneParented)
	MAP_NATIVE(USkeletalMeshComponent,execAddInstanceVertexWeightBoneParented)
	MAP_NATIVE(USkeletalMeshComponent,execGetBonesWithinRadius)
	MAP_NATIVE(USkeletalMeshComponent,execUpdateAnimations)
	MAP_NATIVE(USkeletalMeshComponent,execForceSkelUpdate)
	MAP_NATIVE(USkeletalMeshComponent,execUpdateRBBonesFromSpaceBases)
	MAP_NATIVE(USkeletalMeshComponent,execSetHasPhysicsAssetInstance)
	MAP_NATIVE(USkeletalMeshComponent,execFindBodyInstanceNamed)
	MAP_NATIVE(USkeletalMeshComponent,execFindConstraintBoneName)
	MAP_NATIVE(USkeletalMeshComponent,execFindConstraintIndex)
	MAP_NATIVE(USkeletalMeshComponent,execInitSkelControls)
	MAP_NATIVE(USkeletalMeshComponent,execUpdateParentBoneMap)
	MAP_NATIVE(USkeletalMeshComponent,execSetParentAnimComponent)
	MAP_NATIVE(USkeletalMeshComponent,execSetAnimTreeTemplate)
	MAP_NATIVE(USkeletalMeshComponent,execGetClosestCollidingBoneLocation)
	MAP_NATIVE(USkeletalMeshComponent,execFindClosestBone)
	MAP_NATIVE(USkeletalMeshComponent,execTransformFromBoneSpace)
	MAP_NATIVE(USkeletalMeshComponent,execTransformToBoneSpace)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneAxis)
	MAP_NATIVE(USkeletalMeshComponent,execGetRefPosePosition)
	MAP_NATIVE(USkeletalMeshComponent,execBoneIsChildOf)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneNames)
	MAP_NATIVE(USkeletalMeshComponent,execGetParentBone)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneMatrix)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneName)
	MAP_NATIVE(USkeletalMeshComponent,execMatchRefBone)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneLocation)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneQuaternion)
	MAP_NATIVE(USkeletalMeshComponent,execFindMorphNode)
	MAP_NATIVE(USkeletalMeshComponent,execFindSkelControl)
	MAP_NATIVE(USkeletalMeshComponent,execAllAnimNodes)
	MAP_NATIVE(USkeletalMeshComponent,execFindAnimNode)
	MAP_NATIVE(USkeletalMeshComponent,execFindMorphTarget)
	MAP_NATIVE(USkeletalMeshComponent,execRestoreSavedAnimSets)
	MAP_NATIVE(USkeletalMeshComponent,execSaveAnimSets)
	MAP_NATIVE(USkeletalMeshComponent,execFindAnimSequence)
	MAP_NATIVE(USkeletalMeshComponent,execWakeSoftBody)
	MAP_NATIVE(USkeletalMeshComponent,execSetSoftBodyFrozen)
	MAP_NATIVE(USkeletalMeshComponent,execUpdateSoftBodyParams)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothValidBounds)
	MAP_NATIVE(USkeletalMeshComponent,execEnableClothValidBounds)
	MAP_NATIVE(USkeletalMeshComponent,execAttachClothToCollidingShapes)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothVelocity)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothPosition)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothSleep)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothThickness)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothTearFactor)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothStretchingStiffness)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothSolverIterations)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothSleepLinearVelocity)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothPressure)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothFriction)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothFlags)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothDampingCoefficient)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothCollisionResponseCoefficient)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothBendingStiffness)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothAttachmentTearFactor)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothAttachmentResponseCoefficient)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothThickness)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothTearFactor)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothStretchingStiffness)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothSolverIterations)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothSleepLinearVelocity)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothPressure)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothFriction)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothFlags)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothDampingCoefficient)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothCollisionResponseCoefficient)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothBendingStiffness)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothAttachmentTearFactor)
	MAP_NATIVE(USkeletalMeshComponent,execGetClothAttachmentResponseCoefficient)
	MAP_NATIVE(USkeletalMeshComponent,execResetClothVertsToRefPose)
	MAP_NATIVE(USkeletalMeshComponent,execSetAttachClothVertsToBaseBody)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothExternalForce)
	MAP_NATIVE(USkeletalMeshComponent,execUpdateClothParams)
	MAP_NATIVE(USkeletalMeshComponent,execSetClothFrozen)
	MAP_NATIVE(USkeletalMeshComponent,execSetEnableClothSimulation)
	MAP_NATIVE(USkeletalMeshComponent,execSetForceRefPose)
	MAP_NATIVE(USkeletalMeshComponent,execSetPhysicsAsset)
	MAP_NATIVE(USkeletalMeshComponent,execSetSkeletalMesh)
	MAP_NATIVE(USkeletalMeshComponent,execAttachedComponents)
	MAP_NATIVE(USkeletalMeshComponent,execIsComponentAttached)
	MAP_NATIVE(USkeletalMeshComponent,execFindComponentAttachedToBone)
	MAP_NATIVE(USkeletalMeshComponent,execGetSocketBoneName)
	MAP_NATIVE(USkeletalMeshComponent,execGetSocketByName)
	MAP_NATIVE(USkeletalMeshComponent,execGetSocketWorldLocationAndRotation)
	MAP_NATIVE(USkeletalMeshComponent,execAttachComponentToSocket)
	MAP_NATIVE(USkeletalMeshComponent,execDetachComponent)
	MAP_NATIVE(USkeletalMeshComponent,execAttachComponent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USkeletalMeshComponent);

NATIVE_INFO(USoundCue) GEngineUSoundCueNatives[] = 
{ 
	MAP_NATIVE(USoundCue,execGetCueDuration)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USoundCue);

NATIVE_INFO(UStaticMeshComponent) GEngineUStaticMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UStaticMeshComponent,execSetForceStaticDecals)
	MAP_NATIVE(UStaticMeshComponent,execDisableRBCollisionWithSMC)
	MAP_NATIVE(UStaticMeshComponent,execSetStaticMesh)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UStaticMeshComponent);

NATIVE_INFO(USurface) GEngineUSurfaceNatives[] = 
{ 
	MAP_NATIVE(USurface,execGetSurfaceHeight)
	MAP_NATIVE(USurface,execGetSurfaceWidth)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USurface);

NATIVE_INFO(ATeamInfo) GEngineATeamInfoNatives[] = 
{ 
	MAP_NATIVE(ATeamInfo,execGetTeamNum)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ATeamInfo);

NATIVE_INFO(ATeleporter) GEngineATeleporterNatives[] = 
{ 
	MAP_NATIVE(ATeleporter,execCanTeleport)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ATeleporter);

NATIVE_INFO(UTexture2D) GEngineUTexture2DNatives[] = 
{ 
	MAP_NATIVE(UTexture2D,execCreate)
	MAP_NATIVE(UTexture2D,execSetForceMipLevelsToBeResident)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTexture2D);

NATIVE_INFO(UTexture2DComposite) GEngineUTexture2DCompositeNatives[] = 
{ 
	MAP_NATIVE(UTexture2DComposite,execResetSourceRegions)
	MAP_NATIVE(UTexture2DComposite,execUpdateCompositeTexture)
	MAP_NATIVE(UTexture2DComposite,execSourceTexturesFullyStreamedIn)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTexture2DComposite);

NATIVE_INFO(UTexture2DDynamic) GEngineUTexture2DDynamicNatives[] = 
{ 
	MAP_NATIVE(UTexture2DDynamic,execCreate)
	MAP_NATIVE(UTexture2DDynamic,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTexture2DDynamic);

NATIVE_INFO(UTextureFlipBook) GEngineUTextureFlipBookNatives[] = 
{ 
	MAP_NATIVE(UTextureFlipBook,execSetCurrentFrame)
	MAP_NATIVE(UTextureFlipBook,execStop)
	MAP_NATIVE(UTextureFlipBook,execPause)
	MAP_NATIVE(UTextureFlipBook,execPlay)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTextureFlipBook);

NATIVE_INFO(UTextureMovie) GEngineUTextureMovieNatives[] = 
{ 
	MAP_NATIVE(UTextureMovie,execStop)
	MAP_NATIVE(UTextureMovie,execPause)
	MAP_NATIVE(UTextureMovie,execPlay)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTextureMovie);

NATIVE_INFO(UTextureRenderTarget2D) GEngineUTextureRenderTarget2DNatives[] = 
{ 
	MAP_NATIVE(UTextureRenderTarget2D,execCreate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTextureRenderTarget2D);

NATIVE_INFO(AVehicle) GEngineAVehicleNatives[] = 
{ 
	MAP_NATIVE(AVehicle,execGetTargetLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AVehicle);

NATIVE_INFO(AVolume) GEngineAVolumeNatives[] = 
{ 
	MAP_NATIVE(AVolume,execEncompasses)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AVolume);

NATIVE_INFO(AWeapon) GEngineAWeaponNatives[] = 
{ 
	MAP_NATIVE(AWeapon,execGetPhysicalFireStartLoc)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AWeapon);

NATIVE_INFO(AWorldInfo) GEngineAWorldInfoNatives[] = 
{ 
	MAP_NATIVE(AWorldInfo,execGetWorldFractureSettings)
	MAP_NATIVE(AWorldInfo,execOnScreenDebugMessageExists)
	MAP_NATIVE(AWorldInfo,execAddOnScreenDebugMessage)
	MAP_NATIVE(AWorldInfo,execDoMemoryTracking)
	MAP_NATIVE(AWorldInfo,execIsPlayingDemo)
	MAP_NATIVE(AWorldInfo,execIsRecordingDemo)
	MAP_NATIVE(AWorldInfo,execGetDetailMode)
	MAP_NATIVE(AWorldInfo,execGetMapName)
	MAP_NATIVE(AWorldInfo,execSetMapInfo)
	MAP_NATIVE(AWorldInfo,execGetMapInfo)
	MAP_NATIVE(AWorldInfo,execSetSeamlessTravelMidpointPause)
	MAP_NATIVE(AWorldInfo,execIsInSeamlessTravel)
	MAP_NATIVE(AWorldInfo,execSeamlessTravel)
	MAP_NATIVE(AWorldInfo,execCommitMapChange)
	MAP_NATIVE(AWorldInfo,execCancelPendingMapChange)
	MAP_NATIVE(AWorldInfo,execIsMapChangeReady)
	MAP_NATIVE(AWorldInfo,execIsPreparingMapChange)
	MAP_NATIVE(AWorldInfo,execPrepareMapChange)
	MAP_NATIVE(AWorldInfo,execNotifyMatchStarted)
	MAP_NATIVE(AWorldInfo,execAllPawns)
	MAP_NATIVE(AWorldInfo,execAllControllers)
	MAP_NATIVE(AWorldInfo,execNavigationPointCheck)
	MAP_NATIVE(AWorldInfo,execRadiusNavigationPoints)
	MAP_NATIVE(AWorldInfo,execAllNavigationPoints)
	MAP_NATIVE(AWorldInfo,execGetAddressURL)
	MAP_NATIVE(AWorldInfo,execVerifyNavList)
	MAP_NATIVE(AWorldInfo,execForceGarbageCollection)
	MAP_NATIVE(AWorldInfo,execIsPlayInEditor)
	MAP_NATIVE(AWorldInfo,execIsConsoleBuild)
	MAP_NATIVE(AWorldInfo,execIsDemoBuild)
	MAP_NATIVE(AWorldInfo,execGetLocalURL)
	MAP_NATIVE(AWorldInfo,execSetLevelRBGravity)
	MAP_NATIVE(AWorldInfo,execGetGameSequence)
	MAP_NATIVE(AWorldInfo,execGetGravityZ)
	MAP_NATIVE(AWorldInfo,execUpdateMusicTrack)
	MAP_NATIVE(AWorldInfo,execIsMenuLevel)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AWorldInfo);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,Actor,Components)
VERIFY_CLASS_OFFSET_NODIE(A,Actor,LatentActions)
VERIFY_CLASS_SIZE_NODIE(AActor)
VERIFY_CLASS_OFFSET_NODIE(U,ActorComponent,Scene)
VERIFY_CLASS_OFFSET_NODIE(U,ActorComponent,Owner)
VERIFY_CLASS_OFFSET_NODIE(U,ActorComponent,TickGroup)
VERIFY_CLASS_SIZE_NODIE(UActorComponent)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactory,GameplayActorClass)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactory,SpecificGameName)
VERIFY_CLASS_SIZE_NODIE(UActorFactory)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryAI,ControllerClass)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryAI,TeamIndex)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAI)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryAmbientSound,AmbientSoundCue)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSound)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryAmbientSoundMovable,AmbientSoundCue)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundMovable)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryAmbientSoundSimple,SoundNodeWave)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundSimple)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryArchetype,ArchetypeActor)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryArchetype)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryCoverLink)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryDynamicSM,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryDynamicSM,CollisionType)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryDynamicSM)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryEmitter,ParticleSystem)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryFracturedStaticMesh,FracturedStaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryFracturedStaticMesh,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryFracturedStaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryLensFlare,LensFlareObject)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryLensFlare)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryLight)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryMover)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPathNode)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryPhysicsAsset,PhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryPhysicsAsset,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryPhysXDestructible,PhysXDestructible)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryPhysXDestructible,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPhysXDestructible)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPlayerStart)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryRigidBody,InitialVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryRigidBody,StayUprightMaxTorque)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryRigidBody)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactorySkeletalMesh,SkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactorySkeletalMesh,AnimSequenceName)
VERIFY_CLASS_SIZE_NODIE(UActorFactorySkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryStaticMesh,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryStaticMesh,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryStaticMesh)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryTrigger)
VERIFY_CLASS_OFFSET_NODIE(U,ActorFactoryVehicle,VehicleClass)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryVehicle)
VERIFY_CLASS_SIZE_NODIE(UAdvancedReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,AmbientOcclusionEffect,OcclusionColor)
VERIFY_CLASS_OFFSET_NODIE(U,AmbientOcclusionEffect,HistoryWeightConvergenceTime)
VERIFY_CLASS_SIZE_NODIE(UAmbientOcclusionEffect)
VERIFY_CLASS_OFFSET_NODIE(A,AnimatedCamera,AnimInstPool)
VERIFY_CLASS_OFFSET_NODIE(A,AnimatedCamera,AccumulatorCameraActor)
VERIFY_CLASS_SIZE_NODIE(AAnimatedCamera)
VERIFY_CLASS_OFFSET_NODIE(U,ArrowComponent,ArrowColor)
VERIFY_CLASS_OFFSET_NODIE(U,ArrowComponent,ArrowSize)
VERIFY_CLASS_SIZE_NODIE(UArrowComponent)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundCue)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CueFirstNode)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,InstanceParameters)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,WaveInstances)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeData)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeOffsetMap)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeResetWaveMap)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,Listener)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,PlaybackTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,PortalVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,Location)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,ComponentLocation)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,LastOwner)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SubtitlePriority)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,FadeInStartTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,FadeInStopTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,FadeInTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,FadeOutStartTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,FadeOutStopTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,FadeOutTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,AdjustVolumeStartTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,AdjustVolumeStopTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,AdjustVolumeTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrAdjustVolumeTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentNotifyBufferFinishedHook)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentLocation)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentPitch)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentHighFrequencyGain)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentUseSpatialization)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentUseSeamlessLooping)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentVolumeMultiplier)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentPitchMultiplier)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentVoiceCenterChannelVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentVoiceRadioVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,VolumeMultiplier)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,PitchMultiplier)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,OcclusionCheckInterval)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,LastOcclusionCheckTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,PreviewSoundRadius)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,__OnAudioFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UAudioComponent)
VERIFY_CLASS_SIZE_NODIE(AAutoLadder)
VERIFY_CLASS_SIZE_NODIE(ABlockingVolume)
VERIFY_CLASS_SIZE_NODIE(UBloomEffect)
VERIFY_CLASS_OFFSET_NODIE(U,BookMark,Location)
VERIFY_CLASS_OFFSET_NODIE(U,BookMark,Rotation)
VERIFY_CLASS_SIZE_NODIE(UBookMark)
VERIFY_CLASS_OFFSET_NODIE(A,Brush,CsgOper)
VERIFY_CLASS_OFFSET_NODIE(A,Brush,SavedSelections)
VERIFY_CLASS_SIZE_NODIE(ABrush)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,Brush)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,BrushAggGeom)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,BrushPhysDesc)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,CachedPhysBrushData)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,CachedPhysBrushDataVersion)
VERIFY_CLASS_SIZE_NODIE(UBrushComponent)
VERIFY_CLASS_OFFSET_NODIE(A,Camera,PCOwner)
VERIFY_CLASS_OFFSET_NODIE(A,Camera,FadeTimeRemaining)
VERIFY_CLASS_SIZE_NODIE(ACamera)
VERIFY_CLASS_OFFSET_NODIE(A,CameraActor,AspectRatio)
VERIFY_CLASS_OFFSET_NODIE(A,CameraActor,MeshComp)
VERIFY_CLASS_SIZE_NODIE(ACameraActor)
VERIFY_CLASS_OFFSET_NODIE(U,CameraAnim,CameraInterpGroup)
VERIFY_CLASS_OFFSET_NODIE(U,CameraAnim,BoundingBox)
VERIFY_CLASS_SIZE_NODIE(UCameraAnim)
VERIFY_CLASS_OFFSET_NODIE(U,CameraAnimInst,CamAnim)
VERIFY_CLASS_OFFSET_NODIE(U,CameraAnimInst,SourceAnimNode)
VERIFY_CLASS_SIZE_NODIE(UCameraAnimInst)
VERIFY_CLASS_SIZE_NODIE(UCameraConeComponent)
VERIFY_CLASS_SIZE_NODIE(UCameraMode)
VERIFY_CLASS_OFFSET_NODIE(U,CameraModifier,CameraOwner)
VERIFY_CLASS_SIZE_NODIE(UCameraModifier)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,Font)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,OrgX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,OrgY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,ClipX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,ClipY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,CurX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,CurY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,CurYL)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,DrawColor)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,Canvas)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SceneView)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,ColorModulate)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,DefaultTexture)
VERIFY_CLASS_SIZE_NODIE(UCanvas)
VERIFY_CLASS_SIZE_NODIE(UCeilingReachSpec)
VERIFY_CLASS_SIZE_NODIE(UCheatManager)
VERIFY_CLASS_SIZE_NODIE(AClipMarker)
VERIFY_CLASS_OFFSET_NODIE(U,ClipPadEntry,Title)
VERIFY_CLASS_OFFSET_NODIE(U,ClipPadEntry,Text)
VERIFY_CLASS_SIZE_NODIE(UClipPadEntry)
VERIFY_CLASS_OFFSET_NODIE(U,CodecMovie,PlaybackDuration)
VERIFY_CLASS_SIZE_NODIE(UCodecMovie)
VERIFY_CLASS_OFFSET_NODIE(U,CodecMovieFallback,CurrentTime)
VERIFY_CLASS_SIZE_NODIE(UCodecMovieFallback)
VERIFY_CLASS_OFFSET_NODIE(A,Controller,Pawn)
VERIFY_CLASS_OFFSET_NODIE(A,Controller,OldBasedRotation)
VERIFY_CLASS_SIZE_NODIE(AController)
VERIFY_CLASS_OFFSET_NODIE(A,CoverGroup,CoverLinkRefs)
VERIFY_CLASS_OFFSET_NODIE(A,CoverGroup,AutoSelectHeight)
VERIFY_CLASS_SIZE_NODIE(ACoverGroup)
VERIFY_CLASS_OFFSET_NODIE(A,CoverLink,Slots)
VERIFY_CLASS_OFFSET_NODIE(A,CoverLink,LocationDescription)
VERIFY_CLASS_SIZE_NODIE(ACoverLink)
VERIFY_CLASS_OFFSET_NODIE(U,CoverSlipReachSpec,SpecDirection)
VERIFY_CLASS_SIZE_NODIE(UCoverSlipReachSpec)
VERIFY_CLASS_OFFSET_NODIE(A,CoverSlotMarker,OwningSlot)
VERIFY_CLASS_SIZE_NODIE(ACoverSlotMarker)
VERIFY_CLASS_OFFSET_NODIE(A,CrowdReplicationActor,Spawner)
VERIFY_CLASS_OFFSET_NODIE(A,CrowdReplicationActor,DestroyAllCount)
VERIFY_CLASS_SIZE_NODIE(ACrowdReplicationActor)
VERIFY_CLASS_OFFSET_NODIE(A,CullDistanceVolume,CullDistances)
VERIFY_CLASS_SIZE_NODIE(ACullDistanceVolume)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPresetCurve,CurveName)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPresetCurve,Points)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPresetCurve)
VERIFY_CLASS_SIZE_NODIE(UCustomPropertyItemHandler)
VERIFY_CLASS_OFFSET_NODIE(U,CylinderComponent,CollisionHeight)
VERIFY_CLASS_OFFSET_NODIE(U,CylinderComponent,CollisionRadius)
VERIFY_CLASS_OFFSET_NODIE(U,CylinderComponent,CylinderColor)
VERIFY_CLASS_SIZE_NODIE(UCylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DamageType,DeathString)
VERIFY_CLASS_OFFSET_NODIE(U,DamageType,KilledFFWaveform)
VERIFY_CLASS_SIZE_NODIE(UDamageType)
VERIFY_CLASS_OFFSET_NODIE(U,DebugManager,FirstColoredMip)
VERIFY_CLASS_SIZE_NODIE(UDebugManager)
VERIFY_CLASS_SIZE_NODIE(ADefaultPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(ADirectionalLight)
VERIFY_CLASS_OFFSET_NODIE(U,DirectionalLightComponent,TraceDistance)
VERIFY_CLASS_SIZE_NODIE(UDirectionalLightComponent)
VERIFY_CLASS_SIZE_NODIE(ADirectionalLightToggleable)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatConstant,Constant)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatConstant)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatConstantCurve,ConstantCurve)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatParameterBase,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatParameterBase,ParamMode)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatParameterBase)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatUniform,Min)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatUniform,Max)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatUniform)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionFloatUniformCurve,ConstantCurve)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatUniformCurve)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorConstant,Constant)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorConstant,LockedAxes)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorConstant)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorConstantCurve,ConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorConstantCurve,LockedAxes)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorParameterBase,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorParameterBase,ParamModes)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorParameterBase)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorUniform,Max)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorUniform,MirrorFlags)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorUniform)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorUniformCurve,ConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(U,DistributionVectorUniformCurve,MirrorFlags)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorUniformCurve)
VERIFY_CLASS_OFFSET_NODIE(U,DOFAndBloomEffect,BloomScale)
VERIFY_CLASS_OFFSET_NODIE(U,DOFAndBloomEffect,SceneMultiplier)
VERIFY_CLASS_SIZE_NODIE(UDOFAndBloomEffect)
VERIFY_CLASS_OFFSET_NODIE(U,DOFBloomMotionBlurEffect,MaxVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,DOFBloomMotionBlurEffect,CameraTranslationThreshold)
VERIFY_CLASS_SIZE_NODIE(UDOFBloomMotionBlurEffect)
VERIFY_CLASS_OFFSET_NODIE(U,DOFEffect,FalloffExponent)
VERIFY_CLASS_OFFSET_NODIE(U,DOFEffect,FocusPosition)
VERIFY_CLASS_SIZE_NODIE(UDOFEffect)
VERIFY_CLASS_OFFSET_NODIE(A,DoorMarker,MyDoor)
VERIFY_CLASS_OFFSET_NODIE(A,DoorMarker,DoorTrigger)
VERIFY_CLASS_SIZE_NODIE(ADoorMarker)
VERIFY_CLASS_OFFSET_NODIE(U,DrawBoxComponent,BoxColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawBoxComponent,BoxMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,DrawBoxComponent,BoxExtent)
VERIFY_CLASS_SIZE_NODIE(UDrawBoxComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCapsuleComponent,CapsuleColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCapsuleComponent,CapsuleMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCapsuleComponent,CapsuleHeight)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCapsuleComponent,CapsuleRadius)
VERIFY_CLASS_SIZE_NODIE(UDrawCapsuleComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawConeComponent,ConeColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawConeComponent,ConeSides)
VERIFY_CLASS_SIZE_NODIE(UDrawConeComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderRadius)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderTopRadius)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderHeight)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderHeightOffset)
VERIFY_CLASS_OFFSET_NODIE(U,DrawCylinderComponent,CylinderSides)
VERIFY_CLASS_SIZE_NODIE(UDrawCylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumAngle)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumAspectRatio)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumStartDist)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumEndDist)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,Texture)
VERIFY_CLASS_SIZE_NODIE(UDrawFrustumComponent)
VERIFY_CLASS_SIZE_NODIE(UDrawLightConeComponent)
VERIFY_CLASS_SIZE_NODIE(UDrawLightRadiusComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawQuadComponent,Texture)
VERIFY_CLASS_OFFSET_NODIE(U,DrawQuadComponent,Width)
VERIFY_CLASS_OFFSET_NODIE(U,DrawQuadComponent,Height)
VERIFY_CLASS_SIZE_NODIE(UDrawQuadComponent)
VERIFY_CLASS_SIZE_NODIE(UDrawSoundRadiusComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereRadius)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereSides)
VERIFY_CLASS_SIZE_NODIE(UDrawSphereComponent)
VERIFY_CLASS_OFFSET_NODIE(A,DroppedPickup,Inventory)
VERIFY_CLASS_OFFSET_NODIE(A,DroppedPickup,PickupCache)
VERIFY_CLASS_SIZE_NODIE(ADroppedPickup)
VERIFY_CLASS_OFFSET_NODIE(A,DynamicAnchor,CurrentUser)
VERIFY_CLASS_SIZE_NODIE(ADynamicAnchor)
VERIFY_CLASS_SIZE_NODIE(ADynamicBlockingVolume)
VERIFY_CLASS_SIZE_NODIE(ADynamicCameraActor)
VERIFY_CLASS_OFFSET_NODIE(U,DynamicLightEnvironmentComponent,State)
VERIFY_CLASS_OFFSET_NODIE(U,DynamicLightEnvironmentComponent,OverriddenLightingChannels)
VERIFY_CLASS_SIZE_NODIE(UDynamicLightEnvironmentComponent)
VERIFY_CLASS_OFFSET_NODIE(A,DynamicSMActor,StaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,DynamicSMActor,ReplicatedMeshScale3D)
VERIFY_CLASS_SIZE_NODIE(ADynamicSMActor)
VERIFY_CLASS_OFFSET_NODIE(U,EdCoordSystem,M)
VERIFY_CLASS_OFFSET_NODIE(U,EdCoordSystem,Desc)
VERIFY_CLASS_SIZE_NODIE(UEdCoordSystem)
VERIFY_CLASS_OFFSET_NODIE(A,Emitter,ParticleSystemComponent)
VERIFY_CLASS_SIZE_NODIE(AEmitter)
VERIFY_CLASS_OFFSET_NODIE(A,EmitterPool,PSCTemplate)
VERIFY_CLASS_OFFSET_NODIE(A,EmitterPool,FreeMatInstConsts)
VERIFY_CLASS_SIZE_NODIE(AEmitterPool)
VERIFY_CLASS_OFFSET_NODIE(U,FaceFXAnimSet,DefaultFaceFXAsset)
VERIFY_CLASS_OFFSET_NODIE(U,FaceFXAnimSet,NumLoadErrors)
VERIFY_CLASS_SIZE_NODIE(UFaceFXAnimSet)
VERIFY_CLASS_OFFSET_NODIE(U,FaceFXAsset,DefaultSkelMesh)
VERIFY_CLASS_OFFSET_NODIE(U,FaceFXAsset,NumLoadErrors)
VERIFY_CLASS_SIZE_NODIE(UFaceFXAsset)
VERIFY_CLASS_SIZE_NODIE(AFileLog)
VERIFY_CLASS_OFFSET_NODIE(A,FileWriter,ArchivePtr)
VERIFY_CLASS_OFFSET_NODIE(A,FileWriter,FileType)
VERIFY_CLASS_SIZE_NODIE(AFileWriter)
VERIFY_CLASS_SIZE_NODIE(UFloorToCeilingReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,Font,Characters)
VERIFY_CLASS_OFFSET_NODIE(U,Font,MaxCharHeight)
VERIFY_CLASS_SIZE_NODIE(UFont)
VERIFY_CLASS_OFFSET_NODIE(U,FontImportOptions,Data)
VERIFY_CLASS_SIZE_NODIE(UFontImportOptions)
VERIFY_CLASS_SIZE_NODIE(UForcedReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,ForceFeedbackManager,FFWaveform)
VERIFY_CLASS_OFFSET_NODIE(U,ForceFeedbackManager,ScaleAllWaveformsBy)
VERIFY_CLASS_SIZE_NODIE(UForceFeedbackManager)
VERIFY_CLASS_OFFSET_NODIE(U,ForceFeedbackWaveform,Samples)
VERIFY_CLASS_SIZE_NODIE(UForceFeedbackWaveform)
VERIFY_CLASS_OFFSET_NODIE(A,GameInfo,AutomatedPerfRemainingTime)
VERIFY_CLASS_OFFSET_NODIE(A,GameInfo,__CanUnpause__Delegate)
VERIFY_CLASS_SIZE_NODIE(AGameInfo)
VERIFY_CLASS_OFFSET_NODIE(A,GameReplicationInfo,GameClass)
VERIFY_CLASS_OFFSET_NODIE(A,GameReplicationInfo,MatchID)
VERIFY_CLASS_SIZE_NODIE(AGameReplicationInfo)
VERIFY_CLASS_OFFSET_NODIE(U,GameViewportClient,Viewport)
VERIFY_CLASS_OFFSET_NODIE(U,GameViewportClient,__HandleInputChar__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGameViewportClient)
VERIFY_CLASS_OFFSET_NODIE(A,GravityVolume,GravityZ)
VERIFY_CLASS_SIZE_NODIE(AGravityVolume)
VERIFY_CLASS_OFFSET_NODIE(U,HeightFogComponent,Height)
VERIFY_CLASS_OFFSET_NODIE(U,HeightFogComponent,StartDistance)
VERIFY_CLASS_SIZE_NODIE(UHeightFogComponent)
VERIFY_CLASS_OFFSET_NODIE(A,HUD,WhiteColor)
VERIFY_CLASS_OFFSET_NODIE(A,HUD,DebugDisplay)
VERIFY_CLASS_SIZE_NODIE(AHUD)
VERIFY_CLASS_SIZE_NODIE(AInfo)
VERIFY_CLASS_OFFSET_NODIE(U,IniLocPatcher,Files)
VERIFY_CLASS_OFFSET_NODIE(U,IniLocPatcher,__OnReadTitleFileComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UIniLocPatcher)
VERIFY_CLASS_SIZE_NODIE(AInternetInfo)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor,MyMarker)
VERIFY_CLASS_OFFSET_NODIE(A,InterpActor,AmbientSoundComponent)
VERIFY_CLASS_SIZE_NODIE(AInterpActor)
VERIFY_CLASS_OFFSET_NODIE(U,InterpCurveEdSetup,Tabs)
VERIFY_CLASS_OFFSET_NODIE(U,InterpCurveEdSetup,ActiveTab)
VERIFY_CLASS_SIZE_NODIE(UInterpCurveEdSetup)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrack,TrackInstClass)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrack,ActiveCondition)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrack,TrackTitle)
VERIFY_CLASS_SIZE_NODIE(UInterpTrack)
VERIFY_CLASS_OFFSET_NODIE(A,Inventory,Inventory)
VERIFY_CLASS_OFFSET_NODIE(A,Inventory,DroppedPickupParticles)
VERIFY_CLASS_SIZE_NODIE(AInventory)
VERIFY_CLASS_OFFSET_NODIE(A,InventoryManager,InventoryChain)
VERIFY_CLASS_OFFSET_NODIE(A,InventoryManager,PendingFire)
VERIFY_CLASS_SIZE_NODIE(AInventoryManager)
VERIFY_CLASS_SIZE_NODIE(AKeypoint)
VERIFY_CLASS_SIZE_NODIE(UKillZDamageType)
VERIFY_CLASS_OFFSET_NODIE(U,KMeshProps,COMNudge)
VERIFY_CLASS_OFFSET_NODIE(U,KMeshProps,AggGeom)
VERIFY_CLASS_SIZE_NODIE(UKMeshProps)
VERIFY_CLASS_OFFSET_NODIE(A,Ladder,MyLadder)
VERIFY_CLASS_OFFSET_NODIE(A,Ladder,LadderList)
VERIFY_CLASS_SIZE_NODIE(ALadder)
VERIFY_CLASS_SIZE_NODIE(ULadderReachSpec)
VERIFY_CLASS_OFFSET_NODIE(A,LadderVolume,WallDir)
VERIFY_CLASS_OFFSET_NODIE(A,LadderVolume,PendingClimber)
VERIFY_CLASS_SIZE_NODIE(ALadderVolume)
VERIFY_CLASS_OFFSET_NODIE(U,LevelStreaming,PackageName)
VERIFY_CLASS_OFFSET_NODIE(U,LevelStreaming,LastVolumeUnloadRequestTime)
VERIFY_CLASS_SIZE_NODIE(ULevelStreaming)
VERIFY_CLASS_OFFSET_NODIE(U,LevelStreamingDistance,Origin)
VERIFY_CLASS_OFFSET_NODIE(U,LevelStreamingDistance,MaxDistance)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingDistance)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingKismet)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingPersistent)
VERIFY_CLASS_OFFSET_NODIE(A,LevelStreamingVolume,StreamingLevels)
VERIFY_CLASS_OFFSET_NODIE(A,LevelStreamingVolume,Usage)
VERIFY_CLASS_SIZE_NODIE(ALevelStreamingVolume)
VERIFY_CLASS_OFFSET_NODIE(A,LiftCenter,MyLift)
VERIFY_CLASS_OFFSET_NODIE(A,LiftCenter,LiftTrigger)
VERIFY_CLASS_SIZE_NODIE(ALiftCenter)
VERIFY_CLASS_OFFSET_NODIE(A,LiftExit,MyLiftCenter)
VERIFY_CLASS_SIZE_NODIE(ALiftExit)
VERIFY_CLASS_OFFSET_NODIE(A,Light,LightComponent)
VERIFY_CLASS_SIZE_NODIE(ALight)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,SceneInfo)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,WorldToLight)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightToWorld)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightGuid)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightmapGuid)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,Brightness)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightColor)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,Function)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightEnv_BouncedLightBrightness)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightEnv_BouncedModulationColor)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,OtherLevelsToAffect)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightingChannels)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,InclusionVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ExclusionVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,InclusionConvexVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ExclusionConvexVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightAffectsClassification)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightShadowMode)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ModShadowColor)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ModShadowFadeoutTime)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ModShadowFadeoutExponent)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightListIndex)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ShadowProjectionTechnique)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ShadowFilterQuality)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,MinShadowResolution)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,MaxShadowResolution)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,ShadowFadeResolution)
VERIFY_CLASS_SIZE_NODIE(ULightComponent)
VERIFY_CLASS_OFFSET_NODIE(U,LightEnvironmentComponent,AffectedComponents)
VERIFY_CLASS_SIZE_NODIE(ULightEnvironmentComponent)
VERIFY_CLASS_OFFSET_NODIE(U,LightFunction,SourceMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,LightFunction,Scale)
VERIFY_CLASS_SIZE_NODIE(ULightFunction)
VERIFY_CLASS_SIZE_NODIE(ALightVolume)
VERIFY_CLASS_OFFSET_NODIE(U,LineBatchComponent,BatchedLines)
VERIFY_CLASS_OFFSET_NODIE(U,LineBatchComponent,DefaultLifeTime)
VERIFY_CLASS_SIZE_NODIE(ULineBatchComponent)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,ControllerId)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,PPSettingsOverrideStartBlend)
VERIFY_CLASS_SIZE_NODIE(ULocalPlayer)
VERIFY_CLASS_OFFSET_NODIE(A,MantleMarker,OwningSlot)
VERIFY_CLASS_SIZE_NODIE(AMantleMarker)
VERIFY_CLASS_SIZE_NODIE(UMantleReachSpec)
VERIFY_CLASS_SIZE_NODIE(UMapInfo)
VERIFY_CLASS_OFFSET_NODIE(U,Material,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Material,ContentTags)
VERIFY_CLASS_SIZE_NODIE(UMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEffect,Material)
VERIFY_CLASS_SIZE_NODIE(UMaterialEffect)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpression,EditorX)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpression,MenuCategories)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpression)
VERIFY_CLASS_OFFSET_NODIE(A,MaterialInstanceActor,MatInst)
VERIFY_CLASS_SIZE_NODIE(AMaterialInstanceActor)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInterface,ParentRefFence)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInterface,PreviewMesh)
VERIFY_CLASS_SIZE_NODIE(UMaterialInterface)
VERIFY_CLASS_OFFSET_NODIE(A,MatineeActor,InterpAction)
VERIFY_CLASS_OFFSET_NODIE(A,MatineeActor,Position)
VERIFY_CLASS_SIZE_NODIE(AMatineeActor)
VERIFY_CLASS_OFFSET_NODIE(U,MeshComponent,Materials)
VERIFY_CLASS_SIZE_NODIE(UMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(U,MeshComponentFactory,Materials)
VERIFY_CLASS_SIZE_NODIE(UMeshComponentFactory)
VERIFY_CLASS_SIZE_NODIE(UModelComponent)
VERIFY_CLASS_OFFSET_NODIE(U,MotionBlurEffect,MaxVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,MotionBlurEffect,CameraTranslationThreshold)
VERIFY_CLASS_SIZE_NODIE(UMotionBlurEffect)
VERIFY_CLASS_OFFSET_NODIE(U,MultiFont,ResolutionTestTable)
VERIFY_CLASS_SIZE_NODIE(UMultiFont)
VERIFY_CLASS_SIZE_NODIE(UMusicTrackDataStructures)
VERIFY_CLASS_OFFSET_NODIE(A,Mutator,NextMutator)
VERIFY_CLASS_OFFSET_NODIE(A,Mutator,GroupNames)
VERIFY_CLASS_SIZE_NODIE(AMutator)
VERIFY_CLASS_OFFSET_NODIE(A,NavigationPoint,NavOctreeObject)
VERIFY_CLASS_OFFSET_NODIE(A,NavigationPoint,LastAnchoredPawnTime)
VERIFY_CLASS_SIZE_NODIE(ANavigationPoint)
VERIFY_CLASS_OFFSET_NODIE(A,Note,Text)
VERIFY_CLASS_SIZE_NODIE(ANote)
VERIFY_CLASS_SIZE_NODIE(AObjective)
VERIFY_CLASS_OFFSET_NODIE(U,ObjectReferencer,ReferencedObjects)
VERIFY_CLASS_SIZE_NODIE(UObjectReferencer)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameplayEvents,PlayerList)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameplayEvents,GameplaySessionID)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameplayEvents)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameSearch,MaxSearchResults)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameSearch,AdditionalSearchCriteria)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameSearch)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameSettings,NumPublicConnections)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineGameSettings,BuildUniqueId)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameSettings)
VERIFY_CLASS_OFFSET_NODIE(U,OnlinePlaylistManager,Playlists)
VERIFY_CLASS_OFFSET_NODIE(U,OnlinePlaylistManager,__OnReadPlaylistComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlinePlaylistManager)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineProfileSettings,VersionNumber)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineProfileSettings,__NotifySettingValueUpdated__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineStats,ViewIdMappings)
VERIFY_CLASS_SIZE_NODIE(UOnlineStats)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineStatsRead,ViewId)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineStatsRead,TitleId)
VERIFY_CLASS_SIZE_NODIE(UOnlineStatsRead)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineStatsWrite,StatMappings)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineStatsWrite,__OnStatsWriteComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineStatsWrite)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineSubsystem,AccountInterface)
VERIFY_CLASS_OFFSET_NODIE(U,OnlineSubsystem,Patcher)
VERIFY_CLASS_SIZE_NODIE(UOnlineSubsystem)
VERIFY_CLASS_SIZE_NODIE(APathBlockingVolume)
VERIFY_CLASS_SIZE_NODIE(APathNode)
VERIFY_CLASS_OFFSET_NODIE(A,Pawn,MaxStepHeight)
VERIFY_CLASS_OFFSET_NODIE(A,Pawn,FailedLandingCount)
VERIFY_CLASS_SIZE_NODIE(APawn)
VERIFY_CLASS_OFFSET_NODIE(A,PhysicsVolume,ZoneVelocity)
VERIFY_CLASS_OFFSET_NODIE(A,PhysicsVolume,NextPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(APhysicsVolume)
VERIFY_CLASS_OFFSET_NODIE(A,PickupFactory,InventoryType)
VERIFY_CLASS_OFFSET_NODIE(A,PickupFactory,OriginalFactory)
VERIFY_CLASS_SIZE_NODIE(APickupFactory)
VERIFY_CLASS_OFFSET_NODIE(U,Player,Actor)
VERIFY_CLASS_OFFSET_NODIE(U,Player,PP_ShadowsMultiplier)
VERIFY_CLASS_SIZE_NODIE(UPlayer)
VERIFY_CLASS_OFFSET_NODIE(A,PlayerController,Player)
VERIFY_CLASS_OFFSET_NODIE(A,PlayerController,__CanUnpause__Delegate)
VERIFY_CLASS_SIZE_NODIE(APlayerController)
VERIFY_CLASS_OFFSET_NODIE(A,PlayerReplicationInfo,Score)
VERIFY_CLASS_OFFSET_NODIE(A,PlayerReplicationInfo,AutomatedTestingData)
VERIFY_CLASS_SIZE_NODIE(APlayerReplicationInfo)
VERIFY_CLASS_SIZE_NODIE(APlayerStart)
VERIFY_CLASS_SIZE_NODIE(APointLight)
VERIFY_CLASS_OFFSET_NODIE(U,PointLightComponent,ShadowRadiusMultiplier)
VERIFY_CLASS_OFFSET_NODIE(U,PointLightComponent,PreviewLightRadius)
VERIFY_CLASS_SIZE_NODIE(UPointLightComponent)
VERIFY_CLASS_SIZE_NODIE(APointLightMovable)
VERIFY_CLASS_SIZE_NODIE(APointLightToggleable)
VERIFY_CLASS_SIZE_NODIE(APolyMarker)
VERIFY_CLASS_OFFSET_NODIE(A,PortalMarker,MyPortal)
VERIFY_CLASS_SIZE_NODIE(APortalMarker)
VERIFY_CLASS_OFFSET_NODIE(A,PortalTeleporter,SisterPortal)
VERIFY_CLASS_OFFSET_NODIE(A,PortalTeleporter,MyMarker)
VERIFY_CLASS_SIZE_NODIE(APortalTeleporter)
VERIFY_CLASS_OFFSET_NODIE(A,PortalVolume,Portals)
VERIFY_CLASS_SIZE_NODIE(APortalVolume)
VERIFY_CLASS_OFFSET_NODIE(U,PostProcessChain,Effects)
VERIFY_CLASS_SIZE_NODIE(UPostProcessChain)
VERIFY_CLASS_OFFSET_NODIE(U,PostProcessEffect,EffectName)
VERIFY_CLASS_OFFSET_NODIE(U,PostProcessEffect,SceneDPG)
VERIFY_CLASS_SIZE_NODIE(UPostProcessEffect)
VERIFY_CLASS_OFFSET_NODIE(A,PostProcessVolume,Priority)
VERIFY_CLASS_OFFSET_NODIE(A,PostProcessVolume,NextLowerPriorityVolume)
VERIFY_CLASS_SIZE_NODIE(APostProcessVolume)
VERIFY_CLASS_SIZE_NODIE(APotentialClimbWatcher)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,SceneInfo)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,DetachFence)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LocalToWorldDeterminant)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LocalToWorld)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,MotionBlurInfoIndex)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,DecalList)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,DecalsToReattach)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Tag)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,ShadowParent)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,FogVolumeComponent)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Bounds)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,PreviousLightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,MinDrawDistance)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,CachedMaxDrawDistance)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,CachedCullDistance)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,DepthPriorityGroup)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,ViewOwnerDepthPriorityGroup)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,DetailMode)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,MotionBlurScale)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,TranslucencySortPriority)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LightingChannels)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,RBChannel)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,RBCollideWithChannels)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,OctreeNodes)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,PhysMaterialOverride)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,BodyInstance)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,RBDominanceGroup)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,CachedParentToWorld)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Translation)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Rotation)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Scale)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Scale3D)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LastSubmitTime)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LastRenderTime)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,ScriptRigidBodyCollisionThreshold)
VERIFY_CLASS_SIZE_NODIE(UPrimitiveComponent)
VERIFY_CLASS_SIZE_NODIE(UPrimitiveComponentFactory)
VERIFY_CLASS_OFFSET_NODIE(A,Projectile,Speed)
VERIFY_CLASS_OFFSET_NODIE(A,Projectile,CylinderComponent)
VERIFY_CLASS_SIZE_NODIE(AProjectile)
VERIFY_CLASS_SIZE_NODIE(UProscribedReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,ReachSpec,NavOctreeObject)
VERIFY_CLASS_OFFSET_NODIE(U,ReachSpec,BlockedBy)
VERIFY_CLASS_SIZE_NODIE(UReachSpec)
VERIFY_CLASS_SIZE_NODIE(AReplicationInfo)
VERIFY_CLASS_OFFSET_NODIE(A,ReverbVolume,Priority)
VERIFY_CLASS_OFFSET_NODIE(A,ReverbVolume,NextLowerPriorityVolume)
VERIFY_CLASS_SIZE_NODIE(AReverbVolume)
VERIFY_CLASS_OFFSET_NODIE(A,Route,RouteType)
VERIFY_CLASS_OFFSET_NODIE(A,Route,FudgeFactor)
VERIFY_CLASS_SIZE_NODIE(ARoute)
VERIFY_CLASS_OFFSET_NODIE(U,SavedMove,NextMove)
VERIFY_CLASS_OFFSET_NODIE(U,SavedMove,AccelDotThreshold)
VERIFY_CLASS_SIZE_NODIE(USavedMove)
VERIFY_CLASS_OFFSET_NODIE(U,SaveGameSummary,BaseLevel)
VERIFY_CLASS_OFFSET_NODIE(U,SaveGameSummary,Description)
VERIFY_CLASS_SIZE_NODIE(USaveGameSummary)
VERIFY_CLASS_OFFSET_NODIE(A,SceneCapture2DActor,DrawFrustum)
VERIFY_CLASS_SIZE_NODIE(ASceneCapture2DActor)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCapture2DComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCapture2DComponent,ProjMatrix)
VERIFY_CLASS_SIZE_NODIE(USceneCapture2DComponent)
VERIFY_CLASS_OFFSET_NODIE(A,SceneCaptureActor,SceneCapture)
VERIFY_CLASS_SIZE_NODIE(ASceneCaptureActor)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCaptureComponent,ClearColor)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCaptureComponent,ViewState)
VERIFY_CLASS_SIZE_NODIE(USceneCaptureComponent)
VERIFY_CLASS_OFFSET_NODIE(A,SceneCaptureCubeMapActor,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(A,SceneCaptureCubeMapActor,CubeMaterialInst)
VERIFY_CLASS_SIZE_NODIE(ASceneCaptureCubeMapActor)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCaptureCubeMapComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCaptureCubeMapComponent,WorldLocation)
VERIFY_CLASS_SIZE_NODIE(USceneCaptureCubeMapComponent)
VERIFY_CLASS_SIZE_NODIE(ASceneCapturePortalActor)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCapturePortalComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCapturePortalComponent,ViewDestination)
VERIFY_CLASS_SIZE_NODIE(USceneCapturePortalComponent)
VERIFY_CLASS_OFFSET_NODIE(A,SceneCaptureReflectActor,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(A,SceneCaptureReflectActor,ReflectMaterialInst)
VERIFY_CLASS_SIZE_NODIE(ASceneCaptureReflectActor)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCaptureReflectComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SceneCaptureReflectComponent,ScaleFOV)
VERIFY_CLASS_SIZE_NODIE(USceneCaptureReflectComponent)
VERIFY_CLASS_OFFSET_NODIE(A,Scout,PathSizes)
VERIFY_CLASS_OFFSET_NODIE(A,Scout,DefaultReachSpecClass)
VERIFY_CLASS_SIZE_NODIE(AScout)
VERIFY_CLASS_OFFSET_NODIE(U,ScriptedTexture,__Render__Delegate)
VERIFY_CLASS_SIZE_NODIE(UScriptedTexture)
VERIFY_CLASS_OFFSET_NODIE(U,Settings,LocalizedSettings)
VERIFY_CLASS_OFFSET_NODIE(U,Settings,__NotifyPropertyValueUpdated__Delegate)
VERIFY_CLASS_SIZE_NODIE(USettings)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap2D,Texture)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap2D,CoordinateScale)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap2D,CoordinateBias)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap2D,LightGuid)
VERIFY_CLASS_SIZE_NODIE(UShadowMap2D)
VERIFY_CLASS_SIZE_NODIE(UShadowMapTexture2D)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Bounds)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Materials)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Origin)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,RotOrigin)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,RefSkeleton)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SkeletalDepth)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,NameIndexMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,LODModels)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,RefBasesInvMatrix)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SkelMirrorTable)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SkelMirrorAxis)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SkelMirrorFlipAxis)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Sockets)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,LODInfo)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,PerPolyCollisionBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,AddToParentPerPolyCollisionBone)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,PerPolyBoneKDOPs)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,FaceFXAsset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,BoundsPreviewAsset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,LODBiasPC)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,LODBiasPS3)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,LODBiasXbox360)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothMesh)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothMeshScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothToGraphicsVertMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothWeldingMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothWeldingDomain)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothWeldedIndices)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,NumFreeClothVerts)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothIndexBuffer)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothStretchStiffness)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothBendStiffness)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothDensity)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothThickness)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothDamping)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothIterations)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothFriction)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothRelativeGridSpacing)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothPressure)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothCollisionResponseCoefficient)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothAttachmentResponseCoefficient)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothAttachmentTearFactor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothSleepLinearVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothSpecialBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothMetalImpulseThreshold)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothMetalPenetrationDepth)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothMetalMaxDeformationDistance)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothTearFactor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothTearReserve)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ClothTornTriMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodySurfaceToGraphicsVertMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodySurfaceIndices)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyTetraVertsUnscaled)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyTetraIndices)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyTetraLinks)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,CachedSoftBodyMeshes)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,CachedSoftBodyMeshScales)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodySpecialBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyVolumeStiffness)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyStretchingStiffness)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyDensity)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyParticleRadius)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyDamping)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodySolverIterations)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyFriction)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyRelativeGridSpacing)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodySleepLinearVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyAttachmentResponse)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyCollisionResponse)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyDetailLevel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodySubdivisionLevel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyAttachmentThreshold)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SoftBodyAttachmentTearFactor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,ReleaseResourcesFence)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SkelMeshGUID)
VERIFY_CLASS_SIZE_NODIE(USkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,AttachedToSkelComponent)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,AnimTreeTemplate)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,Animations)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,AnimTickArray)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsAssetInstance)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsWeight)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,GlobalAnimRateScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MeshObject)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,WireframeColor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SpaceBases)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,LocalAtoms)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RequiredBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ParentAnimComponent)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ParentBoneMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,AnimSets)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,TemporarySavedAnimSets)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MorphSets)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ActiveMorphs)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,Attachments)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SkelControlIndex)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ForcedLodModel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MinLodModel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PredictedLODLevel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,OldPredictedLODLevel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MaxDistanceFactor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bForceWireframe)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bForceRefpose)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bOldForceRefPose)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bDisplayBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bShowPrePhysBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bHideSkin)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bForceRawOffset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bIgnoreControllers)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bTransformFromAnimParent)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,TickTag)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,CachedAtomsTag)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bUseSingleBodyPhysics)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bRequiredBonesUpToDate)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MinDistFactorForKinematicUpdate)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsBlendZeroDriftBoneName)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,FramesPhysicsAsleep)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,LineCheckBoundsScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,InstanceVertexWeightBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothExternalForce)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothWind)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothBaseVelClampRange)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothBlendWeight)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothSim)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SceneIndex)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshPosData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshNormalData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshIndexData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,NumClothMeshVerts)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,NumClothMeshIndices)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshParentData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,NumClothMeshParentIndices)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshWeldedPosData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshWeldedNormalData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothMeshWeldedIndexData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothDirtyBufferFlag)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothRBChannel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothRBCollideWithChannels)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothForceScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothImpulseScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ClothAttachmentTearFactor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MinDistanceForClothReset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,LastClothLocation)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodySim)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodySceneIndex)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodyTetraPosData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodyTetraIndexData)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,NumSoftBodyTetraVerts)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,NumSoftBodyTetraIndices)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodyImpulseScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodyRBChannel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodyRBCollideWithChannels)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SoftBodyASVPlane)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,LimitMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootMotionDelta)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootMotionVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootBoneTranslation)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootMotionAccelScale)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootMotionMode)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PreviousRMM)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PendingRMM)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,OldPendingRMM)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bRMMOneFrameDelay)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootMotionRotationMode)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,FaceFXBlendMode)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,FaceFXActorInstance)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,CachedFaceFXAudioComp)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,BoneVisibility)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshSocket,SocketName)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshSocket,PreviewStaticMesh)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshSocket)
VERIFY_CLASS_SIZE_NODIE(ASkyLight)
VERIFY_CLASS_OFFSET_NODIE(U,SkyLightComponent,LowerBrightness)
VERIFY_CLASS_OFFSET_NODIE(U,SkyLightComponent,LowerColor)
VERIFY_CLASS_SIZE_NODIE(USkyLightComponent)
VERIFY_CLASS_SIZE_NODIE(ASkyLightToggleable)
VERIFY_CLASS_OFFSET_NODIE(U,SlotToSlotReachSpec,SpecDirection)
VERIFY_CLASS_SIZE_NODIE(USlotToSlotReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,SoundCue,SoundGroup)
VERIFY_CLASS_OFFSET_NODIE(U,SoundCue,CurrentPlayCount)
VERIFY_CLASS_SIZE_NODIE(USoundCue)
VERIFY_CLASS_OFFSET_NODIE(U,SpeechRecognition,Language)
VERIFY_CLASS_OFFSET_NODIE(U,SpeechRecognition,FnxVoiceData)
VERIFY_CLASS_SIZE_NODIE(USpeechRecognition)
VERIFY_CLASS_OFFSET_NODIE(U,SphericalHarmonicLightComponent,WorldSpaceIncidentLighting)
VERIFY_CLASS_SIZE_NODIE(USphericalHarmonicLightComponent)
VERIFY_CLASS_SIZE_NODIE(ASpotLight)
VERIFY_CLASS_OFFSET_NODIE(U,SpotLightComponent,InnerConeAngle)
VERIFY_CLASS_OFFSET_NODIE(U,SpotLightComponent,PreviewOuterCone)
VERIFY_CLASS_SIZE_NODIE(USpotLightComponent)
VERIFY_CLASS_SIZE_NODIE(ASpotLightMovable)
VERIFY_CLASS_SIZE_NODIE(ASpotLightToggleable)
VERIFY_CLASS_OFFSET_NODIE(U,SpriteComponent,Sprite)
VERIFY_CLASS_OFFSET_NODIE(U,SpriteComponent,ScreenSize)
VERIFY_CLASS_SIZE_NODIE(USpriteComponent)
VERIFY_CLASS_OFFSET_NODIE(A,StaticLightCollectionActor,LightComponents)
VERIFY_CLASS_OFFSET_NODIE(A,StaticLightCollectionActor,MaxLightComponents)
VERIFY_CLASS_SIZE_NODIE(AStaticLightCollectionActor)
VERIFY_CLASS_OFFSET_NODIE(A,StaticMeshActor,StaticMeshComponent)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActor)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActorBase)
VERIFY_CLASS_OFFSET_NODIE(A,StaticMeshActorBasedOnExtremeContent,StaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,StaticMeshActorBasedOnExtremeContent,NonExtremeContent)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActorBasedOnExtremeContent)
VERIFY_CLASS_OFFSET_NODIE(A,StaticMeshCollectionActor,StaticMeshComponents)
VERIFY_CLASS_OFFSET_NODIE(A,StaticMeshCollectionActor,MaxStaticMeshComponents)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshCollectionActor)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,ForcedLodModel)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,PreviousLODLevel)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,WireframeColor)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,OverriddenLightMapResolution)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,SubDivisionStepSize)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,MinSubDivisions)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,MaxSubDivisions)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,IrrelevantLights)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,LODData)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponentFactory,StaticMesh)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshComponentFactory)
VERIFY_CLASS_SIZE_NODIE(USurface)
VERIFY_CLASS_OFFSET_NODIE(U,SwatTurnReachSpec,SpecDirection)
VERIFY_CLASS_SIZE_NODIE(USwatTurnReachSpec)
VERIFY_CLASS_OFFSET_NODIE(A,TeamInfo,TeamName)
VERIFY_CLASS_OFFSET_NODIE(A,TeamInfo,TeamColor)
VERIFY_CLASS_SIZE_NODIE(ATeamInfo)
VERIFY_CLASS_OFFSET_NODIE(A,Teleporter,URL)
VERIFY_CLASS_OFFSET_NODIE(A,Teleporter,LastFired)
VERIFY_CLASS_SIZE_NODIE(ATeleporter)
VERIFY_CLASS_SIZE_NODIE(UTeleportReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,Texture,UnpackMin)
VERIFY_CLASS_OFFSET_NODIE(U,Texture,Resource)
VERIFY_CLASS_SIZE_NODIE(UTexture)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,Mips)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,FirstResourceMemMip)
VERIFY_CLASS_SIZE_NODIE(UTexture2D)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2DComposite,SourceRegions)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2DComposite,MaxTextureSize)
VERIFY_CLASS_SIZE_NODIE(UTexture2DComposite)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2DDynamic,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2DDynamic,NumMips)
VERIFY_CLASS_SIZE_NODIE(UTexture2DDynamic)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,FaceNegZ)
VERIFY_CLASS_SIZE_NODIE(UTextureCube)
VERIFY_CLASS_OFFSET_NODIE(U,TextureFlipBook,TimeIntoMovie)
VERIFY_CLASS_OFFSET_NODIE(U,TextureFlipBook,ReleaseResourcesFence)
VERIFY_CLASS_SIZE_NODIE(UTextureFlipBook)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,ReleaseCodecFence)
VERIFY_CLASS_SIZE_NODIE(UTextureMovie)
VERIFY_CLASS_SIZE_NODIE(UTextureRenderTarget)
VERIFY_CLASS_OFFSET_NODIE(U,TextureRenderTarget2D,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TextureRenderTarget2D,ClearColor)
VERIFY_CLASS_SIZE_NODIE(UTextureRenderTarget2D)
VERIFY_CLASS_OFFSET_NODIE(U,TextureRenderTargetCube,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TextureRenderTargetCube,Format)
VERIFY_CLASS_SIZE_NODIE(UTextureRenderTargetCube)
VERIFY_CLASS_OFFSET_NODIE(A,Trigger,CylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(A,Trigger,AITriggerDelay)
VERIFY_CLASS_SIZE_NODIE(ATrigger)
VERIFY_CLASS_SIZE_NODIE(ATriggerVolume)
VERIFY_CLASS_OFFSET_NODIE(U,UberPostProcessEffect,SceneShadows)
VERIFY_CLASS_OFFSET_NODIE(U,UberPostProcessEffect,SceneDesaturation)
VERIFY_CLASS_SIZE_NODIE(UUberPostProcessEffect)
VERIFY_CLASS_OFFSET_NODIE(A,Vehicle,Driver)
VERIFY_CLASS_OFFSET_NODIE(A,Vehicle,TurnTime)
VERIFY_CLASS_SIZE_NODIE(AVehicle)
VERIFY_CLASS_OFFSET_NODIE(A,Volume,AssociatedActor)
VERIFY_CLASS_OFFSET_NODIE(A,Volume,LocationName)
VERIFY_CLASS_SIZE_NODIE(AVolume)
VERIFY_CLASS_OFFSET_NODIE(A,VolumePathNode,StartingRadius)
VERIFY_CLASS_OFFSET_NODIE(A,VolumePathNode,StartingHeight)
VERIFY_CLASS_SIZE_NODIE(AVolumePathNode)
VERIFY_CLASS_SIZE_NODIE(UWallTransReachSpec)
VERIFY_CLASS_OFFSET_NODIE(U,WaveFormBase,TheWaveForm)
VERIFY_CLASS_SIZE_NODIE(UWaveFormBase)
VERIFY_CLASS_OFFSET_NODIE(A,Weapon,CurrentFireMode)
VERIFY_CLASS_OFFSET_NODIE(A,Weapon,CachedMaxRange)
VERIFY_CLASS_SIZE_NODIE(AWeapon)
VERIFY_CLASS_OFFSET_NODIE(U,WindDirectionalSourceComponent,SceneProxy)
VERIFY_CLASS_OFFSET_NODIE(U,WindDirectionalSourceComponent,Speed)
VERIFY_CLASS_SIZE_NODIE(UWindDirectionalSourceComponent)
VERIFY_CLASS_OFFSET_NODIE(A,WorldInfo,DefaultPostProcessSettings)
VERIFY_CLASS_OFFSET_NODIE(A,WorldInfo,PriorityScreenMessages)
VERIFY_CLASS_SIZE_NODIE(AWorldInfo)
VERIFY_CLASS_OFFSET_NODIE(A,ZoneInfo,KillZ)
VERIFY_CLASS_OFFSET_NODIE(A,ZoneInfo,KillZDamageType)
VERIFY_CLASS_SIZE_NODIE(AZoneInfo)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
